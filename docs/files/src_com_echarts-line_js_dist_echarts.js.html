<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/com/echarts-line/js/dist/echarts.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/: Animation.html">: Animation</a></li>
            
                <li><a href="../classes/Captcha.html">Captcha</a></li>
            
                <li><a href="../classes/Checkin.html">Checkin</a></li>
            
                <li><a href="../classes/Cookie.html">Cookie</a></li>
            
                <li><a href="../classes/countDown.html">countDown</a></li>
            
                <li><a href="../classes/GoTop.html">GoTop</a></li>
            
                <li><a href="../classes/limitText.html">limitText</a></li>
            
                <li><a href="../classes/loading.html">loading</a></li>
            
                <li><a href="../classes/Log.html">Log</a></li>
            
                <li><a href="../classes/numberstep.html">numberstep</a></li>
            
                <li><a href="../classes/NumFormat.html">NumFormat</a></li>
            
                <li><a href="../classes/NumSeparate.html">NumSeparate</a></li>
            
                <li><a href="../classes/pageCount.html">pageCount</a></li>
            
                <li><a href="../classes/popup.html">popup</a></li>
            
                <li><a href="../classes/Tabset.html">Tabset</a></li>
            
                <li><a href="../classes/templateMerge.html">templateMerge</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/com.html">com</a></li>
            
                <li><a href="../modules/lufax.html">lufax</a></li>
            
                <li><a href="../modules/lufax
author: fangxiao.html">lufax
author: fangxiao</a></li>
            
                <li><a href="../modules/ui.html">ui</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/com/echarts-line/js/dist/echarts.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * ESL (Enterprise Standard Loader)
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @file Browser端标准加载器，符合AMD规范
 * @author errorrik(errorrik@gmail.com)
 *         Firede(firede@firede.us)
 */

/* jshint ignore:start */
var define;
var require;
var esl;
/* jshint ignore:end */

(function (global) {
    // &quot;mod&quot;开头的变量或函数为内部模块管理函数
    // 为提高压缩率，不使用function或object包装

    /**
     * 模块容器
     *
     * @inner
     * @type {Object}
     */
    var modModules = {};

    /**
     * 自动定义的模块表
     *
     * 模块define factory是用到时才执行，但是以下几种情况需要自动马上执行：
     * 1. require( [moduleId], callback )
     * 2. plugin module: require( &#x27;plugin!resource&#x27; )
     *
     * @inner
     * @type {Object}
     */
    var autoDefineModules = {};


    // 模块状态枚举量
    var MODULE_PRE_DEFINED = 1;
    var MODULE_ANALYZED = 2;
    var MODULE_PREPARED = 3;
    var MODULE_DEFINED = 4;

    /**
     * 全局require函数
     *
     * @inner
     * @type {Function}
     */
    var actualGlobalRequire = createLocalRequire();

    // #begin-ignore
    /**
     * 超时提醒定时器
     *
     * @inner
     * @type {number}
     */
    var waitTimeout;
    // #end-ignore

    /**
     * 加载模块
     *
     * @param {string|Array} requireId 模块id或模块id数组，
     * @param {Function=} callback 加载完成的回调函数
     * @return {*}
     */
    function require(requireId, callback) {
        // #begin-ignore
        // #begin assertNotContainRelativeId
        // 确定require的模块id不包含相对id。用于global require，提前预防难以跟踪的错误出现
        var invalidIds = [];

        /**
         * 监测模块id是否relative id
         *
         * @inner
         * @param {string} id 模块id
         */
        function monitor(id) {
            if (id.indexOf(&#x27;.&#x27;) === 0) {
                invalidIds.push(id);
            }
        }

        if (typeof requireId === &#x27;string&#x27;) {
            monitor(requireId);
        }
        else {
            each(
                requireId,
                function (id) {
                    monitor(id);
                }
            );
        }

        // 包含相对id时，直接抛出错误
        if (invalidIds.length &gt; 0) {
            throw new Error(
                &#x27;[REQUIRE_FATAL]Relative ID is not allowed in global require: &#x27;
                + invalidIds.join(&#x27;, &#x27;)
            );
        }
        // #end assertNotContainRelativeId

        // 超时提醒
        var timeout = requireConf.waitSeconds;
        if (timeout &amp;&amp; (requireId instanceof Array)) {
            if (waitTimeout) {
                clearTimeout(waitTimeout);
            }
            waitTimeout = setTimeout(waitTimeoutNotice, timeout * 1000);
        }
        // #end-ignore

        return actualGlobalRequire(requireId, callback);
    }

    /**
     * 版本号
     *
     * @type {string}
     */
    require.version = &#x27;1.8.6&#x27;;

    /**
     * loader名称
     *
     * @type {string}
     */
    require.loader = &#x27;esl&#x27;;

    /**
     * 将模块标识转换成相对的url
     *
     * @param {string} id 模块标识
     * @return {string}
     */
    require.toUrl = actualGlobalRequire.toUrl;

    // #begin-ignore
    /**
     * 超时提醒函数
     *
     * @inner
     */
    function waitTimeoutNotice() {
        var hangModules = [];
        var missModules = [];
        var hangModulesMap = {};
        var missModulesMap = {};
        var visited = {};

        /**
         * 检查模块的加载错误
         *
         * @inner
         * @param {string} id 模块id
         */
        function checkError(id, hard) {
            if (visited[id] || modIs(id, MODULE_DEFINED)) {
                return;
            }

            visited[id] = 1;

            if (!modIs(id, MODULE_PREPARED)) {
                // HACK: 为gzip后体积优化，不做抽取
                if (!hangModulesMap[id]) {
                    hangModulesMap[id] = 1;
                    hangModules.push(id);
                }
            }

            var mod = modModules[id];
            if (!mod) {
                if (!missModulesMap[id]) {
                    missModulesMap[id] = 1;
                    missModules.push(id);
                }
            }
            else if (hard) {
                if (!hangModulesMap[id]) {
                    hangModulesMap[id] = 1;
                    hangModules.push(id);
                }

                each(
                    mod.depMs,
                    function (dep) {
                        checkError(dep.absId, dep.hard);
                    }
                );
            }
        }

        for (var id in autoDefineModules) {
            checkError(id, 1);
        }

        if (hangModules.length || missModules.length) {
            throw new Error(
                &#x27;[MODULE_TIMEOUT]Hang( &#x27;
                + (hangModules.join(&#x27;, &#x27;) || &#x27;none&#x27;)
                + &#x27; ) Miss( &#x27;
                + (missModules.join(&#x27;, &#x27;) || &#x27;none&#x27;)
                + &#x27; )&#x27;
            );
        }
    }
    // #end-ignore

    /**
     * 尝试完成模块定义的定时器
     *
     * @inner
     * @type {number}
     */
    var tryDefineTimeout;

    /**
     * 定义模块
     *
     * @param {string=} id 模块标识
     * @param {Array=} dependencies 依赖模块列表
     * @param {Function=} factory 创建模块的工厂方法
     */
    function define(id, dependencies, factory) {
        // define(factory)
        // define(dependencies, factory)
        // define(id, factory)
        // define(id, dependencies, factory)
        if (factory == null) {
            if (dependencies == null) {
                factory = id;
                id = null;
            }
            else {
                factory = dependencies;
                dependencies = null;
                if (id instanceof Array) {
                    dependencies = id;
                    id = null;
                }
            }
        }

        if (factory == null) {
            return;
        }

        // 出现window不是疏忽
        // esl设计是做为browser端的loader
        // 闭包的global更多意义在于：
        //     define和require方法可以被挂到用户自定义对象中
        var opera = window.opera;

        // IE下通过current script的data-require-id获取当前id
        if (
            !id
            &amp;&amp; document.attachEvent
            &amp;&amp; (!(opera &amp;&amp; opera.toString() === &#x27;[object Opera]&#x27;))
        ) {
            var currentScript = getCurrentScript();
            id = currentScript &amp;&amp; currentScript.getAttribute(&#x27;data-require-id&#x27;);
        }

        if (id) {
            modPreDefine(id, dependencies, factory);

            // 在不远的未来尝试完成define
            // define可能是在页面中某个地方调用，不一定是在独立的文件被require装载
            if (tryDefineTimeout) {
                clearTimeout(tryDefineTimeout);
            }
        }
        else {
            // 纪录到共享变量中，在load或readystatechange中处理
            // 标准浏览器下，使用匿名define时，将进入这个分支
            wait4PreDefine[0] = {
                deps    : dependencies,
                factory : factory
            };
        }
    }

    define.amd = {};

    /**
     * 模块配置获取函数
     *
     * @inner
     * @return {Object} 模块配置对象
     */
    function moduleConfigGetter() {
        var conf = requireConf.config[this.id];
        if (conf &amp;&amp; typeof conf === &#x27;object&#x27;) {
            return conf;
        }

        return {};
    }

    /**
     * 预定义模块
     *
     * @inner
     * @param {string} id 模块标识
     * @param {Array.&lt;string&gt;} dependencies 显式声明的依赖模块列表
     * @param {*} factory 模块定义函数或模块对象
     */
    function modPreDefine(id, dependencies, factory) {
        // 将模块存入容器
        //
        // 模块内部信息包括
        // -----------------------------------
        // id: module id
        // depsDec: 模块定义时声明的依赖
        // deps: 模块依赖，默认为[&#x27;require&#x27;, &#x27;exports&#x27;, &#x27;module&#x27;]
        // factory: 初始化函数或对象
        // factoryDeps: 初始化函数的参数依赖
        // exports: 模块的实际暴露对象（AMD定义）
        // config: 用于获取模块配置信息的函数（AMD定义）
        // state: 模块当前状态
        // require: local require函数
        // depMs: 实际依赖的模块集合，数组形式
        // depMkv: 实际依赖的模块集合，表形式，便于查找
        // depRs: 实际依赖的资源集合
        // depPMs: 用于加载资源的模块集合，key是模块名，value是1，仅用于快捷查找
        // ------------------------------------
        if (!modModules[id]) {
            modModules[id] = {
                id          : id,
                depsDec     : dependencies,
                deps        : dependencies || [&#x27;require&#x27;, &#x27;exports&#x27;, &#x27;module&#x27;],
                factoryDeps : [],
                factory     : factory,
                exports     : {},
                config      : moduleConfigGetter,
                state       : MODULE_PRE_DEFINED,
                require     : createLocalRequire(id),
                depMs       : [],
                depMkv      : {},
                depRs       : [],
                depPMs      : []
            };
        }
    }

    /**
     * 预分析模块
     *
     * 首先，完成对factory中声明依赖的分析提取
     * 然后，尝试加载&quot;资源加载所需模块&quot;
     *
     * 需要先加载模块的原因是：如果模块不存在，无法进行resourceId normalize化
     * modAnalyse完成后续的依赖分析处理，并进行依赖模块的加载
     *
     * @inner
     * @param {string} id 模块id
     */
    function modAnalyse(id) {
        var mod = modModules[id];
        if (!mod || modIs(id, MODULE_ANALYZED)) {
            return;
        }

        var deps = mod.deps;
        var factory = mod.factory;
        var hardDependsCount = 0;

        // 分析function body中的require
        // 如果包含显式依赖声明，根据AMD规定和性能考虑，可以不分析factoryBody
        if (typeof factory === &#x27;function&#x27;) {
            hardDependsCount = Math.min(factory.length, deps.length);

            // If the dependencies argument is present, the module loader
            // SHOULD NOT scan for dependencies within the factory function.
            !mod.depsDec &amp;&amp; factory.toString()
                .replace(/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg, &#x27;&#x27;)
                .replace(/require\(\s*([&#x27;&quot;&#x27;])([^&#x27;&quot;]+)\1\s*\)/g,
                    function ($0, $1, depId) {
                        deps.push(depId);
                    }
                );
        }

        var requireModules = [];
        each(deps, function (depId, index) {
            var idInfo = parseId(depId);
            var absId = normalize(idInfo.mod, id);
            var moduleInfo;
            var resInfo;

            if (absId &amp;&amp; !BUILDIN_MODULE[absId]) {
                // 如果依赖是一个资源，将其信息添加到module.depRs
                //
                // module.depRs中的项有可能是重复的。
                // 在这个阶段，加载resource的module可能还未defined，
                // 导致此时resource id无法被normalize。
                //
                // 比如对a/b/c而言，下面几个resource可能指的是同一个资源：
                // - js!../name.js
                // - js!a/name.js
                // - ../../js!../name.js
                //
                // 所以加载资源的module ready时，需要遍历module.depRs进行处理
                if (idInfo.res) {
                    resInfo = {
                        id: depId,
                        mod: absId,
                        res: idInfo.res
                    };
                    autoDefineModules[absId] = 1;
                    mod.depPMs.push(absId);
                    mod.depRs.push(resInfo);
                }

                // 对依赖模块的id normalize能保证正确性，在此处进行去重
                moduleInfo = mod.depMkv[absId];
                if (!moduleInfo) {
                    moduleInfo = {
                        id      : idInfo.mod,
                        absId   : absId,
                        hard    : index &lt; hardDependsCount
                    };
                    mod.depMs.push(moduleInfo);
                    mod.depMkv[absId] = moduleInfo;
                    requireModules.push(absId);
                }
            }
            else {
                moduleInfo = {absId: absId};
            }

            // 如果当前正在分析的依赖项是define中声明的，
            // 则记录到module.factoryDeps中
            // 在factory invoke前将用于生成invoke arguments
            if (index &lt; hardDependsCount) {
                mod.factoryDeps.push(resInfo || moduleInfo);
            }
        });

        mod.state = MODULE_ANALYZED;
        modInitFactoryInvoker(id);
        nativeRequire(requireModules);
    }

    /**
     * 对一些需要自动定义的模块进行自动定义
     *
     * @inner
     */
    function modAutoInvoke() {
        for (var id in autoDefineModules) {
            modUpdatePreparedState(id);
            modTryInvokeFactory(id);
        }
    }

    /**
     * 更新模块的准备状态
     *
     * @inner
     * @param {string} id 模块id
     */
    function modUpdatePreparedState(id) {
        var visited = {};
        update(id);

        function update(id) {
            if (!modIs(id, MODULE_ANALYZED)) {
                return false;
            }
            if (modIs(id, MODULE_PREPARED) || visited[id]) {
                return true;
            }

            visited[id] = 1;
            var mod = modModules[id];
            var prepared = true;

            each(
                mod.depMs,
                function (dep) {
                    return (prepared = update(dep.absId));
                }
            );

            // 判断resource是否加载完成。如果resource未加载完成，则认为未准备好
            /* jshint ignore:start */
            prepared &amp;&amp; each(
                mod.depRs,
                function (dep) {
                    prepared = !!(dep.absId &amp;&amp; modIs(dep.absId, MODULE_DEFINED));
                    return prepared;
                }
            );
            /* jshint ignore:end */

            if (prepared) {
                mod.state = MODULE_PREPARED;
            }

            return prepared;
        }
    }

    /**
     * 初始化模块定义时所需的factory执行器
     *
     * @inner
     * @param {string} id 模块id
     */
    function modInitFactoryInvoker(id) {
        var mod = modModules[id];
        var invoking;

        mod.invokeFactory = invokeFactory;
        each(
            mod.depPMs,
            function (pluginModuleId) {

                modAddDefinedListener(
                    pluginModuleId,
                    function () {
                        each(mod.depRs, function (res) {
                            if (!res.absId &amp;&amp; res.mod === pluginModuleId) {
                                res.absId = normalize(res.id, id);
                                nativeRequire([res.absId], modAutoInvoke);
                            }
                        });
                    }
                );

            }
        );

        /**
         * 初始化模块
         *
         * @inner
         */
        function invokeFactory() {
            if (invoking || mod.state !== MODULE_PREPARED) {
                return;
            }

            invoking = 1;

            // 拼接factory invoke所需的arguments
            var factoryReady = 1;
            var factoryDeps = [];
            each(
                mod.factoryDeps,
                function (dep) {
                    var depId = dep.absId;

                    if (!BUILDIN_MODULE[depId]) {
                        modTryInvokeFactory(depId);
                        if (!modIs(depId, MODULE_DEFINED)) {
                            factoryReady = 0;
                            return false;
                        }
                    }

                    factoryDeps.push(depId);
                }
            );

            if (factoryReady) {
                try {
                    var args = modGetModulesExports(
                        factoryDeps,
                        {
                            require : mod.require,
                            exports : mod.exports,
                            module  : mod
                        }
                    );

                    // 调用factory函数初始化module
                    var factory = mod.factory;
                    var exports = typeof factory === &#x27;function&#x27;
                        ? factory.apply(global, args)
                        : factory;

                    if (exports != null) {
                        mod.exports = exports;
                    }

                    mod.invokeFactory = null;
                    delete autoDefineModules[id];
                }
                catch (ex) {
                    invoking = 0;
                    if (/^\[MODULE_MISS\]&quot;([^&quot;]+)/.test(ex.message)) {
                        // 出错，则说明在factory的运行中，该require的模块是需要的
                        // 所以把它加入强依赖中
                        var hardCirclurDep = mod.depMkv[RegExp.$1];
                        hardCirclurDep &amp;&amp; (hardCirclurDep.hard = 1);
                        return;
                    }

                    throw ex;
                }

                // 完成define
                // 不放在try里，避免后续的运行错误被这里吞掉
                modDefined(id);
            }
        }
    }

    /**
     * 判断模块是否完成相应的状态
     *
     * @inner
     * @param {string} id 模块标识
     * @param {number} state 状态码，使用时传入相应的枚举变量，比如&#x60;MODULE_DEFINED&#x60;
     * @return {boolean}
     */
    function modIs(id, state) {
        return modModules[id] &amp;&amp; modModules[id].state &gt;= state;
    }

    /**
     * 尝试执行模块factory函数，进行模块初始化
     *
     * @inner
     * @param {string} id 模块id
     */
    function modTryInvokeFactory(id) {
        var mod = modModules[id];

        if (mod &amp;&amp; mod.invokeFactory) {
            mod.invokeFactory();
        }
    }

    /**
     * 根据模块id数组，获取其的exports数组
     * 用于模块初始化的factory参数或require的callback参数生成
     *
     * @inner
     * @param {Array} modules 模块id数组
     * @param {Object} buildinModules 内建模块对象
     * @return {Array}
     */
    function modGetModulesExports(modules, buildinModules) {
        var args = [];
        each(
            modules,
            function (id, index) {
                args[index] = buildinModules[id] || modGetModuleExports(id);
            }
        );

        return args;
    }

    /**
     * 模块定义完成事件监听器容器
     *
     * @inner
     * @type {Object}
     */
    var modDefinedListeners = {};

    /**
     * 添加模块定义完成时间的监听器
     *
     * @inner
     * @param {string} id 模块标识
     * @param {Function} listener 监听函数
     */
    function modAddDefinedListener(id, listener) {
        if (modIs(id, MODULE_DEFINED)) {
            listener();
            return;
        }

        var listeners = modDefinedListeners[id];
        if (!listeners) {
            listeners = modDefinedListeners[id] = [];
        }

        listeners.push(listener);
    }

    /**
     * 模块状态切换为定义完成
     * 因为需要触发事件，MODULE_DEFINED状态切换通过该函数
     *
     * @inner
     * @param {string} id 模块标识
     * @param {number} state 目标状态
     */
    function modDefined(id) {
        var listeners = modDefinedListeners[id] || [];
        var mod = modModules[id];
        mod.state = MODULE_DEFINED;

        var len = listeners.length;
        while (len--) {
            // 这里不做function类型的检测
            // 因为listener都是通过modOn传入的，modOn为内部调用
            listeners[len]();
        }

        // 清理listeners
        listeners.length = 0;
        delete modDefinedListeners[id];
    }

    /**
     * 获取模块的exports
     *
     * @inner
     * @param {string} id 模块标识
     * @return {*}
     */
    function modGetModuleExports(id) {
        if (modIs(id, MODULE_DEFINED)) {
            return modModules[id].exports;
        }

        return null;
    }

    /**
     * 内建module名称集合
     *
     * @inner
     * @type {Object}
     */
    var BUILDIN_MODULE = {
        require : require,
        exports : 1,
        module  : 1
    };

    /**
     * 未预定义的模块集合
     * 主要存储匿名方式define的模块
     *
     * @inner
     * @type {Array}
     */
    var wait4PreDefine = [];

    /**
     * 完成模块预定义，此时处理的模块是匿名define的模块
     *
     * @inner
     */
    function completePreDefine(currentId) {
        // HACK: 这里在IE下有个性能陷阱，不能使用任何变量。
        //       否则貌似会形成变量引用和修改的读写锁，导致wait4PreDefine释放困难
        each(wait4PreDefine, function (mod) {
            modPreDefine(
                currentId,
                mod.deps,
                mod.factory
            );
        });

        wait4PreDefine.length = 0;
        modAnalyse(currentId);
    }

    /**
     * 获取模块
     *
     * @param {string|Array} ids 模块名称或模块名称列表
     * @param {Function=} callback 获取模块完成时的回调函数
     * @return {Object}
     */
    function nativeRequire(ids, callback, baseId, noRequests) {
        // 根据 https://github.com/amdjs/amdjs-api/wiki/require
        // It MUST throw an error if the module has not
        // already been loaded and evaluated.
        if (typeof ids === &#x27;string&#x27;) {
            modTryInvokeFactory(ids);
            if (!modIs(ids, MODULE_DEFINED)) {
                throw new Error(&#x27;[MODULE_MISS]&quot;&#x27; + ids + &#x27;&quot; is not exists!&#x27;);
            }

            return modGetModuleExports(ids);
        }

        noRequests = noRequests || {};
        var isCallbackCalled = 0;
        if (ids instanceof Array) {
            tryFinishRequire();

            if (!isCallbackCalled) {
                each(ids, function (id) {
                    if (!(BUILDIN_MODULE[id] || modIs(id, MODULE_DEFINED))) {
                        modAddDefinedListener(id, tryFinishRequire);

                        if (!noRequests[id]) {
                            (id.indexOf(&#x27;!&#x27;) &gt; 0
                                ? loadResource
                                : loadModule
                            )(id, baseId);
                        }

                        modAnalyse(id);
                    }
                });

                modAutoInvoke();
            }
        }

        /**
         * 尝试完成require，调用callback
         * 在模块与其依赖模块都加载完时调用
         *
         * @inner
         */
        function tryFinishRequire() {
            if (!isCallbackCalled) {
                var isAllCompleted = 1;
                each(ids, function (id) {
                    if (!BUILDIN_MODULE[id]) {
                        return (isAllCompleted = !!modIs(id, MODULE_DEFINED));
                    }
                });

                // 检测并调用callback
                if (isAllCompleted) {
                    isCallbackCalled = 1;

                    (typeof callback === &#x27;function&#x27;) &amp;&amp; callback.apply(
                        global,
                        modGetModulesExports(ids, BUILDIN_MODULE)
                    );
                }
            }
        }
    }

    /**
     * 正在加载的模块列表
     *
     * @inner
     * @type {Object}
     */
    var loadingModules = {};

    /**
     * 加载模块
     *
     * @inner
     * @param {string} moduleId 模块标识
     */
    function loadModule(moduleId) {
        if (loadingModules[moduleId] || modModules[moduleId]) {
            return;
        }

        loadingModules[moduleId] = 1;

        // 创建script标签
        //
        // 这里不挂接onerror的错误处理
        // 因为高级浏览器在devtool的console面板会报错
        // 再throw一个Error多此一举了
        var script = document.createElement(&#x27;script&#x27;);
        script.setAttribute(&#x27;data-require-id&#x27;, moduleId);
        script.src = toUrl(moduleId + &#x27;.js&#x27;) ;
        script.async = true;
        if (script.readyState) {
            script.onreadystatechange = loadedListener;
        }
        else {
            script.onload = loadedListener;
        }
        appendScript(script);

        /**
         * script标签加载完成的事件处理函数
         *
         * @inner
         */
        function loadedListener() {
            var readyState = script.readyState;
            if (
                typeof readyState === &#x27;undefined&#x27;
                || /^(loaded|complete)$/.test(readyState)
            ) {
                script.onload = script.onreadystatechange = null;
                script = null;

                completePreDefine(moduleId);
                for (var key in autoDefineModules) {
                    modAnalyse(key);
                }
                modAutoInvoke();
            }
        }
    }

    /**
     * 加载资源
     *
     * @inner
     * @param {string} pluginAndResource 插件与资源标识
     * @param {string} baseId 当前环境的模块标识
     */
    function loadResource(pluginAndResource, baseId) {
        if (modModules[pluginAndResource]) {
            return;
        }

        var idInfo = parseId(pluginAndResource);
        var resource = {
            id: pluginAndResource,
            state: MODULE_ANALYZED
        };
        modModules[pluginAndResource] = resource;

        /**
         * plugin加载完成的回调函数
         *
         * @inner
         * @param {*} value resource的值
         */
        function pluginOnload(value) {
            resource.exports = value || true;
            modDefined(pluginAndResource);
        }

        /* jshint ignore:start */
        /**
         * 该方法允许plugin使用加载的资源声明模块
         *
         * @param {string} id 模块id
         * @param {string} text 模块声明字符串
         */
        pluginOnload.fromText = function (id, text) {
            autoDefineModules[id] = 1;
            new Function(text)();
            completePreDefine(id);
        };
        /* jshint ignore:end */

        /**
         * 加载资源
         *
         * @inner
         * @param {Object} plugin 用于加载资源的插件模块
         */
        function load(plugin) {
            var pluginRequire = baseId
                ? modModules[baseId].require
                : actualGlobalRequire;

            plugin.load(
                idInfo.res,
                pluginRequire,
                pluginOnload,
                moduleConfigGetter.call({id: pluginAndResource})
            );
        }

        load(modGetModuleExports(idInfo.mod));
    }

    /**
     * require配置
     *
     * @inner
     * @type {Object}
     */
    var requireConf = {
        baseUrl     : &#x27;./&#x27;,
        paths       : {},
        config      : {},
        map         : {},
        packages    : [],
        // #begin-ignore
        waitSeconds : 0,
        // #end-ignore
        noRequests  : {},
        urlArgs     : {}
    };

    /**
     * 配置require
     *
     * @param {Object} conf 配置对象
     */
    require.config = function (conf) {
        function mergeArrayItem(item) {
            oldValue.push(item);
        }

        if (conf) {
            for (var key in requireConf) {
                var newValue = conf[key];
                var oldValue = requireConf[key];

                if (newValue) {
                    if (key === &#x27;urlArgs&#x27; &amp;&amp; typeof newValue === &#x27;string&#x27;) {
                        requireConf.urlArgs[&#x27;*&#x27;] = newValue;
                    }
                    else {
                        // 简单的多处配置还是需要支持，所以配置实现为支持二级mix
                        if (oldValue instanceof Array) {
                            each(newValue, mergeArrayItem);
                        }
                        else if (typeof oldValue === &#x27;object&#x27;) {
                            for (var key in newValue) {
                                oldValue[key] = newValue[key];
                            }
                        }
                        else {
                            requireConf[key] = newValue;
                        }
                    }
                }
            }

            createConfIndex();
        }

        // 配置信息对象clone返回，避免返回结果对象被用户程序修改可能导致的问题
        // return clone(requireConf);
    };

    /**
     * 对象克隆，支持raw type, Array, raw Object
     *
     * @inner
     * @param {*} source 要克隆的对象
     * @return {*}
     */
    // function clone(source) {
    //     var result = source;

    //     if (source instanceof Array) {
    //         result = [];
    //         each(source, function (item, i) {
    //             result[i] = clone(item);
    //         });
    //     }
    //     else if (typeof source === &#x27;object&#x27;) {
    //         result = {};
    //         for (var key in source) {
    //             if (source.hasOwnProperty(key)) {
    //                 result[key] = clone(source[key]);
    //             }
    //         }
    //     }

    //     return result;
    // }

    // 初始化时需要创建配置索引
    createConfIndex();

    /**
     * paths内部索引
     *
     * @inner
     * @type {Array}
     */
    var pathsIndex;

    /**
     * packages内部索引
     *
     * @inner
     * @type {Array}
     */
    var packagesIndex;

    /**
     * mapping内部索引
     *
     * @inner
     * @type {Array}
     */
    var mappingIdIndex;

    /**
     * urlArgs内部索引
     *
     * @inner
     * @type {Array}
     */
    var urlArgsIndex;

    /**
     * noRequests内部索引
     *
     * @inner
     * @type {Array}
     */
    var noRequestsIndex;

    /**
     * 将key为module id prefix的Object，生成数组形式的索引，并按照长度和字面排序
     *
     * @inner
     * @param {Object} value 源值
     * @param {boolean} allowAsterisk 是否允许*号表示匹配所有
     * @return {Array}
     */
    function createKVSortedIndex(value, allowAsterisk) {
        var index = kv2List(value, 1, allowAsterisk);
        index.sort(descSorterByKOrName);
        return index;
    }

    /**
     * 创建配置信息内部索引
     *
     * @inner
     */
    function createConfIndex() {
        requireConf.baseUrl = requireConf.baseUrl.replace(/\/$/, &#x27;&#x27;) + &#x27;/&#x27;;

        // create paths index
        pathsIndex = createKVSortedIndex(requireConf.paths);

        // create mappingId index
        mappingIdIndex = createKVSortedIndex(requireConf.map, 1);
        each(
            mappingIdIndex,
            function (item) {
                item.v = createKVSortedIndex(item.v);
            }
        );

        // create packages index
        packagesIndex = [];
        each(
            requireConf.packages,
            function (packageConf) {
                var pkg = packageConf;
                if (typeof packageConf === &#x27;string&#x27;) {
                    pkg = {
                        name: packageConf.split(&#x27;/&#x27;)[0],
                        location: packageConf,
                        main: &#x27;main&#x27;
                    };
                }

                pkg.location = pkg.location || pkg.name;
                pkg.main = (pkg.main || &#x27;main&#x27;).replace(/\.js$/i, &#x27;&#x27;);
                pkg.reg = createPrefixRegexp(pkg.name);
                packagesIndex.push(pkg);
            }
        );
        packagesIndex.sort(descSorterByKOrName);

        // create urlArgs index
        urlArgsIndex = createKVSortedIndex(requireConf.urlArgs, 1);

        // create noRequests index
        noRequestsIndex = createKVSortedIndex(requireConf.noRequests);
        each(noRequestsIndex, function (item) {
            var value = item.v;
            var mapIndex = {};
            item.v = mapIndex;

            if (!(value instanceof Array)) {
                value = [value];
            }

            each(value, function (meetId) {
                mapIndex[meetId] = 1;
            });
        });
    }

    /**
     * 对配置信息的索引进行检索
     *
     * @inner
     * @param {string} value 要检索的值
     * @param {Array} index 索引对象
     * @param {Function} hitBehavior 索引命中的行为函数
     */
    function indexRetrieve(value, index, hitBehavior) {
        each(index, function (item) {
            if (item.reg.test(value)) {
                hitBehavior(item.v, item.k, item);
                return false;
            }
        });
    }

    /**
     * 将&#x60;模块标识+&#x27;.extension&#x27;&#x60;形式的字符串转换成相对的url
     *
     * @inner
     * @param {string} source 源字符串
     * @return {string}
     */
    function toUrl(source) {
        // 分离 模块标识 和 .extension
        var extReg = /(\.[a-z0-9]+)$/i;
        var queryReg = /(\?[^#]*)$/;
        var extname = &#x27;&#x27;;
        var id = source;
        var query = &#x27;&#x27;;

        if (queryReg.test(source)) {
            query = RegExp.$1;
            source = source.replace(queryReg, &#x27;&#x27;);
        }

        if (extReg.test(source)) {
            extname = RegExp.$1;
            id = source.replace(extReg, &#x27;&#x27;);
        }

        var url = id;

        // paths处理和匹配
        var isPathMap;
        indexRetrieve(id, pathsIndex, function (value, key) {
            url = url.replace(key, value);
            isPathMap = 1;
        });

        // packages处理和匹配
        if (!isPathMap) {
            indexRetrieve(id, packagesIndex, function (value, key, item) {
                url = url.replace(item.name, item.location);
            });
        }

        // 相对路径时，附加baseUrl
        if (!/^([a-z]{2,10}:\/)?\//i.test(url)) {
            url = requireConf.baseUrl + url;
        }

        // 附加 .extension 和 query
        url += extname + query;

        // urlArgs处理和匹配
        indexRetrieve(id, urlArgsIndex, function (value) {
            url += (url.indexOf(&#x27;?&#x27;) &gt; 0 ? &#x27;&amp;&#x27; : &#x27;?&#x27;) + value;
        });

        return url;
    }

    /**
     * 创建local require函数
     *
     * @inner
     * @param {number} baseId 当前module id
     * @return {Function}
     */
    function createLocalRequire(baseId) {
        var requiredCache = {};
        function req(requireId, callback) {
            if (typeof requireId === &#x27;string&#x27;) {
                if (!requiredCache[requireId]) {
                    requiredCache[requireId] =
                        nativeRequire(normalize(requireId, baseId));
                }

                return requiredCache[requireId];
            }
            else if (requireId instanceof Array) {
                // 分析是否有resource，取出pluginModule先
                var pluginModules = [];
                var pureModules = [];
                var normalizedIds = [];

                each(
                    requireId,
                    function (id, i) {
                        var idInfo = parseId(id);
                        var absId = normalize(idInfo.mod, baseId);
                        pureModules.push(absId);
                        autoDefineModules[absId] = 1;

                        if (idInfo.res) {
                            pluginModules.push(absId);
                            normalizedIds[i] = null;
                        }
                        else {
                            normalizedIds[i] = absId;
                        }
                    }
                );

                var noRequestModules = {};
                each(
                    pureModules,
                    function (id) {
                        var meet;
                        indexRetrieve(
                            id,
                            noRequestsIndex,
                            function (value) {
                                meet = value;
                            }
                        );

                        if (meet) {
                            if (meet[&#x27;*&#x27;]) {
                                noRequestModules[id] = 1;
                            }
                            else {
                                each(pureModules, function (meetId) {
                                    if (meet[meetId]) {
                                        noRequestModules[id] = 1;
                                        return false;
                                    }
                                });
                            }
                        }
                    }
                );

                // 加载模块
                nativeRequire(
                    pureModules,
                    function () {
                        /* jshint ignore:start */
                        each(normalizedIds, function (id, i) {
                            if (id == null) {
                                normalizedIds[i] = normalize(requireId[i], baseId);
                            }
                        });
                        /* jshint ignore:end */

                        nativeRequire(normalizedIds, callback, baseId);
                    },
                    baseId,
                    noRequestModules
                );
            }
        }

        /**
         * 将[module ID] + &#x27;.extension&#x27;格式的字符串转换成url
         *
         * @inner
         * @param {string} id 符合描述格式的源字符串
         * @return {string}
         */
        req.toUrl = function (id) {
            return toUrl(normalize(id, baseId));
        };

        return req;
    }

    /**
     * id normalize化
     *
     * @inner
     * @param {string} id 需要normalize的模块标识
     * @param {string} baseId 当前环境的模块标识
     * @return {string}
     */
    function normalize(id, baseId) {
        if (!id) {
            return &#x27;&#x27;;
        }

        baseId = baseId || &#x27;&#x27;;
        var idInfo = parseId(id);
        if (!idInfo) {
            return id;
        }

        var resourceId = idInfo.res;
        var moduleId = relative2absolute(idInfo.mod, baseId);

        each(
            packagesIndex,
            function (packageConf) {
                var name = packageConf.name;
                if (name === moduleId) {
                    moduleId = name + &#x27;/&#x27; + packageConf.main;
                    return false;
                }
            }
        );

        // 根据config中的map配置进行module id mapping
        indexRetrieve(
            baseId,
            mappingIdIndex,
            function (value) {

                indexRetrieve(
                    moduleId,
                    value,
                    function (mdValue, mdKey) {
                        moduleId = moduleId.replace(mdKey, mdValue);
                    }
                );

            }
        );

        if (resourceId) {
            var mod = modGetModuleExports(moduleId);
            resourceId = mod.normalize
                ? mod.normalize(
                    resourceId,
                    function (resId) {
                        return normalize(resId, baseId);
                    }
                  )
                : normalize(resourceId, baseId);

            moduleId += &#x27;!&#x27; + resourceId;
        }

        return moduleId;
    }

    /**
     * 相对id转换成绝对id
     *
     * @inner
     * @param {string} id 要转换的id
     * @param {string} baseId 当前所在环境id
     * @return {string}
     */
    function relative2absolute(id, baseId) {
        if (id.indexOf(&#x27;.&#x27;) === 0) {
            var basePath = baseId.split(&#x27;/&#x27;);
            var namePath = id.split(&#x27;/&#x27;);
            var baseLen = basePath.length - 1;
            var nameLen = namePath.length;
            var cutBaseTerms = 0;
            var cutNameTerms = 0;

            pathLoop: for (var i = 0; i &lt; nameLen; i++) {
                var term = namePath[i];
                switch (term) {
                    case &#x27;..&#x27;:
                        if (cutBaseTerms &lt; baseLen) {
                            cutBaseTerms++;
                            cutNameTerms++;
                        }
                        else {
                            break pathLoop;
                        }
                        break;
                    case &#x27;.&#x27;:
                        cutNameTerms++;
                        break;
                    default:
                        break pathLoop;
                }
            }

            basePath.length = baseLen - cutBaseTerms;
            namePath = namePath.slice(cutNameTerms);

            return basePath.concat(namePath).join(&#x27;/&#x27;);
        }

        return id;
    }

    /**
     * 解析id，返回带有module和resource属性的Object
     *
     * @inner
     * @param {string} id 标识
     * @return {Object}
     */
    function parseId(id) {
        var segs = id.split(&#x27;!&#x27;);

        if (segs[0]) {
            return {
                mod: segs[0],
                res: segs[1]
            };
        }

        return null;
    }

    /**
     * 将对象数据转换成数组，数组每项是带有k和v的Object
     *
     * @inner
     * @param {Object} source 对象数据
     * @return {Array.&lt;Object&gt;}
     */
    function kv2List(source, keyMatchable, allowAsterisk) {
        var list = [];
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                var item = {
                    k: key,
                    v: source[key]
                };
                list.push(item);

                if (keyMatchable) {
                    item.reg = key === &#x27;*&#x27; &amp;&amp; allowAsterisk
                        ? /^/
                        : createPrefixRegexp(key);
                }
            }
        }

        return list;
    }

    // 感谢requirejs，通过currentlyAddingScript兼容老旧ie
    //
    // For some cache cases in IE 6-8, the script executes before the end
    // of the appendChild execution, so to tie an anonymous define
    // call to the module name (which is stored on the node), hold on
    // to a reference to this node, but clear after the DOM insertion.
    var currentlyAddingScript;
    var interactiveScript;

    /**
     * 获取当前script标签
     * 用于ie下define未指定module id时获取id
     *
     * @inner
     * @return {HTMLDocument}
     */
    function getCurrentScript() {
        if (currentlyAddingScript) {
            return currentlyAddingScript;
        }
        else if (
            interactiveScript
            &amp;&amp; interactiveScript.readyState === &#x27;interactive&#x27;
        ) {
            return interactiveScript;
        }
        else {
            var scripts = document.getElementsByTagName(&#x27;script&#x27;);
            var scriptLen = scripts.length;
            while (scriptLen--) {
                var script = scripts[scriptLen];
                if (script.readyState === &#x27;interactive&#x27;) {
                    interactiveScript = script;
                    return script;
                }
            }
        }
    }

    var headElement = document.getElementsByTagName(&#x27;head&#x27;)[0];
    var baseElement = document.getElementsByTagName(&#x27;base&#x27;)[0];
    if (baseElement) {
        headElement = baseElement.parentNode;
    }

    /**
     * 向页面中插入script标签
     *
     * @inner
     * @param {HTMLScriptElement} script script标签
     */
    function appendScript(script) {
        currentlyAddingScript = script;

        // If BASE tag is in play, using appendChild is a problem for IE6.
        // See: http://dev.jquery.com/ticket/2709
        baseElement
            ? headElement.insertBefore(script, baseElement)
            : headElement.appendChild(script);

        currentlyAddingScript = null;
    }

    /**
     * 创建id前缀匹配的正则对象
     *
     * @inner
     * @param {string} prefix id前缀
     * @return {RegExp}
     */
    function createPrefixRegexp(prefix) {
        return new RegExp(&#x27;^&#x27; + prefix + &#x27;(/|$)&#x27;);
    }

    /**
     * 循环遍历数组集合
     *
     * @inner
     * @param {Array} source 数组源
     * @param {function(Array,Number):boolean} iterator 遍历函数
     */
    function each(source, iterator) {
        if (source instanceof Array) {
            for (var i = 0, len = source.length; i &lt; len; i++) {
                if (iterator(source[i], i) === false) {
                    break;
                }
            }
        }
    }

    /**
     * 根据元素的k或name项进行数组字符数逆序的排序函数
     *
     * @inner
     */
    function descSorterByKOrName(a, b) {
        var aValue = a.k || a.name;
        var bValue = b.k || b.name;

        if (bValue === &#x27;*&#x27;) {
            return -1;
        }

        if (aValue === &#x27;*&#x27;) {
            return 1;
        }

        return bValue.length - aValue.length;
    }

    // 暴露全局对象
    //
    // 如果define已经存在，说明已经有一个amd loader了，避免覆盖
    // 这里有一个假设，只有amd loader会用define，但是，任何形式的loader可能会用require
    //
    // 使用 &#x60;global.&#x60; 的原因是，让被运行在第三方页面的代码，也能方便的用loader
    // 第三方页面很可能存在一个loader，就算不存在，可能未来也会有。所以不能在全局用loader
    // 这时，把esl的代码拿过去，只改全局IIFE最后的 &#x60;this&#x60;，就能获得namespace上的loader
    //
    //  // 声明自己的namespace
    //  var selfnamespace = {};
    //
    //  // 这里是esl的代码
    //  (function (global){
    //      // esl的实现
    //  })(selfnamespace); // 改这里的this
    //
    if (!global.define) {
        global.define = define;

        // 可能碰到其他形式的loader，所以，不要覆盖人家
        if (!global.require) {
            global.require = require;
        }

        // 如果存在其他版本的esl，在define那里就判断过了，不会进入这个分支
        // 所以这里就不判断了，直接写
        global.esl = require;
    }
})(this);
define(&#x27;echarts&#x27;, [&#x27;echarts/echarts&#x27;], function (main) {return main;});
define(&#x27;echarts/echarts&#x27;, [
    &#x27;require&#x27;,
    &#x27;./config&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;zrender/tool/event&#x27;,
    &#x27;zrender/tool/env&#x27;,
    &#x27;zrender&#x27;,
    &#x27;zrender/config&#x27;,
    &#x27;./chart/island&#x27;,
    &#x27;./component/toolbox&#x27;,
    &#x27;./component&#x27;,
    &#x27;./component/title&#x27;,
    &#x27;./component/tooltip&#x27;,
    &#x27;./component/legend&#x27;,
    &#x27;./util/ecData&#x27;,
    &#x27;./chart&#x27;,
    &#x27;zrender/tool/color&#x27;,
    &#x27;./component/timeline&#x27;,
    &#x27;zrender/shape/Image&#x27;,
    &#x27;zrender/loadingEffect/Bar&#x27;,
    &#x27;zrender/loadingEffect/Bubble&#x27;,
    &#x27;zrender/loadingEffect/DynamicLine&#x27;,
    &#x27;zrender/loadingEffect/Ring&#x27;,
    &#x27;zrender/loadingEffect/Spin&#x27;,
    &#x27;zrender/loadingEffect/Whirling&#x27;,
    &#x27;./theme/default&#x27;
], function (require) {
    var ecConfig = require(&#x27;./config&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    var zrEvent = require(&#x27;zrender/tool/event&#x27;);
    var self = {};
    var _canvasSupported = require(&#x27;zrender/tool/env&#x27;).canvasSupported;
    var _idBase = new Date() - 0;
    var _instances = {};
    var DOM_ATTRIBUTE_KEY = &#x27;_echarts_instance_&#x27;;
    self.version = &#x27;2.1.10&#x27;;
    self.dependencies = { zrender: &#x27;2.0.6&#x27; };
    self.init = function (dom, theme) {
        var zrender = require(&#x27;zrender&#x27;);
        if ((zrender.version || &#x27;1.0.3&#x27;).replace(&#x27;.&#x27;, &#x27;&#x27;) - 0 &lt; self.dependencies.zrender.replace(&#x27;.&#x27;, &#x27;&#x27;) - 0) {
            console.error(&#x27;ZRender &#x27; + (zrender.version || &#x27;1.0.3-&#x27;) + &#x27; is too old for ECharts &#x27; + self.version + &#x27;. Current version need ZRender &#x27; + self.dependencies.zrender + &#x27;+&#x27;);
        }
        dom = dom instanceof Array ? dom[0] : dom;
        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
        if (!key) {
            key = _idBase++;
            dom.setAttribute(DOM_ATTRIBUTE_KEY, key);
        }
        if (_instances[key]) {
            _instances[key].dispose();
        }
        _instances[key] = new Echarts(dom);
        _instances[key].id = key;
        _instances[key].canvasSupported = _canvasSupported;
        _instances[key].setTheme(theme);
        return _instances[key];
    };
    self.getInstanceById = function (key) {
        return _instances[key];
    };
    function MessageCenter() {
        zrEvent.Dispatcher.call(this);
    }
    zrUtil.merge(MessageCenter.prototype, zrEvent.Dispatcher.prototype, true);
    function Echarts(dom) {
        this._themeConfig = zrUtil.clone(ecConfig);
        this.dom = dom;
        this._connected = false;
        this._status = {
            dragIn: false,
            dragOut: false,
            needRefresh: false
        };
        this._curEventType = false;
        this._chartList = [];
        this._messageCenter = new MessageCenter();
        this._messageCenterOutSide = new MessageCenter();
        this.resize = this.resize();
        this._init();
    }
    var ZR_EVENT = require(&#x27;zrender/config&#x27;).EVENT;
    var ZR_EVENT_LISTENS = [
        &#x27;CLICK&#x27;,
        &#x27;DBLCLICK&#x27;,
        &#x27;MOUSEOVER&#x27;,
        &#x27;MOUSEOUT&#x27;,
        &#x27;DRAGSTART&#x27;,
        &#x27;DRAGEND&#x27;,
        &#x27;DRAGENTER&#x27;,
        &#x27;DRAGOVER&#x27;,
        &#x27;DRAGLEAVE&#x27;,
        &#x27;DROP&#x27;
    ];
    function callChartListMethodReverse(ecInstance, methodName, arg0, arg1, arg2) {
        var chartList = ecInstance._chartList;
        var len = chartList.length;
        while (len--) {
            var chart = chartList[len];
            if (typeof chart[methodName] === &#x27;function&#x27;) {
                chart[methodName](arg0, arg1, arg2);
            }
        }
    }
    Echarts.prototype = {
        _init: function () {
            var self = this;
            var _zr = require(&#x27;zrender&#x27;).init(this.dom);
            this._zr = _zr;
            this._messageCenter.dispatch = function (type, event, eventPackage, that) {
                eventPackage = eventPackage || {};
                eventPackage.type = type;
                eventPackage.event = event;
                self._messageCenter.dispatchWithContext(type, eventPackage, that);
                if (type != &#x27;HOVER&#x27; &amp;&amp; type != &#x27;MOUSEOUT&#x27;) {
                    setTimeout(function () {
                        self._messageCenterOutSide.dispatchWithContext(type, eventPackage, that);
                    }, 50);
                } else {
                    self._messageCenterOutSide.dispatchWithContext(type, eventPackage, that);
                }
            };
            this._onevent = function (param) {
                return self.__onevent(param);
            };
            for (var e in ecConfig.EVENT) {
                if (e != &#x27;CLICK&#x27; &amp;&amp; e != &#x27;DBLCLICK&#x27; &amp;&amp; e != &#x27;HOVER&#x27; &amp;&amp; e != &#x27;MOUSEOUT&#x27; &amp;&amp; e != &#x27;MAP_ROAM&#x27;) {
                    this._messageCenter.bind(ecConfig.EVENT[e], this._onevent, this);
                }
            }
            var eventBehaviors = {};
            this._onzrevent = function (param) {
                return self[eventBehaviors[param.type]](param);
            };
            for (var i = 0, len = ZR_EVENT_LISTENS.length; i &lt; len; i++) {
                var eventName = ZR_EVENT_LISTENS[i];
                var eventValue = ZR_EVENT[eventName];
                eventBehaviors[eventValue] = &#x27;_on&#x27; + eventName.toLowerCase();
                _zr.on(eventValue, this._onzrevent);
            }
            this.chart = {};
            this.component = {};
            var Island = require(&#x27;./chart/island&#x27;);
            this._island = new Island(this._themeConfig, this._messageCenter, _zr, {}, this);
            this.chart.island = this._island;
            var Toolbox = require(&#x27;./component/toolbox&#x27;);
            this._toolbox = new Toolbox(this._themeConfig, this._messageCenter, _zr, {}, this);
            this.component.toolbox = this._toolbox;
            var componentLibrary = require(&#x27;./component&#x27;);
            componentLibrary.define(&#x27;title&#x27;, require(&#x27;./component/title&#x27;));
            componentLibrary.define(&#x27;tooltip&#x27;, require(&#x27;./component/tooltip&#x27;));
            componentLibrary.define(&#x27;legend&#x27;, require(&#x27;./component/legend&#x27;));
            if (_zr.getWidth() === 0 || _zr.getHeight() === 0) {
                console.error(&#x27;Dom’s width &amp; height should be ready before init.&#x27;);
            }
        },
        __onevent: function (param) {
            param.__echartsId = param.__echartsId || this.id;
            var fromMyself = param.__echartsId === this.id;
            if (!this._curEventType) {
                this._curEventType = param.type;
            }
            switch (param.type) {
            case ecConfig.EVENT.LEGEND_SELECTED:
                this._onlegendSelected(param);
                break;
            case ecConfig.EVENT.DATA_ZOOM:
                if (!fromMyself) {
                    var dz = this.component.dataZoom;
                    if (dz) {
                        dz.silence(true);
                        dz.absoluteZoom(param.zoom);
                        dz.silence(false);
                    }
                }
                this._ondataZoom(param);
                break;
            case ecConfig.EVENT.DATA_RANGE:
                fromMyself &amp;&amp; this._ondataRange(param);
                break;
            case ecConfig.EVENT.MAGIC_TYPE_CHANGED:
                if (!fromMyself) {
                    var tb = this.component.toolbox;
                    if (tb) {
                        tb.silence(true);
                        tb.setMagicType(param.magicType);
                        tb.silence(false);
                    }
                }
                this._onmagicTypeChanged(param);
                break;
            case ecConfig.EVENT.DATA_VIEW_CHANGED:
                fromMyself &amp;&amp; this._ondataViewChanged(param);
                break;
            case ecConfig.EVENT.TOOLTIP_HOVER:
                fromMyself &amp;&amp; this._tooltipHover(param);
                break;
            case ecConfig.EVENT.RESTORE:
                this._onrestore();
                break;
            case ecConfig.EVENT.REFRESH:
                fromMyself &amp;&amp; this._onrefresh(param);
                break;
            case ecConfig.EVENT.TOOLTIP_IN_GRID:
            case ecConfig.EVENT.TOOLTIP_OUT_GRID:
                if (!fromMyself) {
                    var grid = this.component.grid;
                    if (grid) {
                        this._zr.trigger(&#x27;mousemove&#x27;, {
                            connectTrigger: true,
                            zrenderX: grid.getX() + param.x * grid.getWidth(),
                            zrenderY: grid.getY() + param.y * grid.getHeight()
                        });
                    }
                } else if (this._connected) {
                    var grid = this.component.grid;
                    if (grid) {
                        param.x = (param.event.zrenderX - grid.getX()) / grid.getWidth();
                        param.y = (param.event.zrenderY - grid.getY()) / grid.getHeight();
                    }
                }
                break;
            }
            if (this._connected &amp;&amp; fromMyself &amp;&amp; this._curEventType === param.type) {
                for (var c in this._connected) {
                    this._connected[c].connectedEventHandler(param);
                }
                this._curEventType = null;
            }
            if (!fromMyself || !this._connected &amp;&amp; fromMyself) {
                this._curEventType = null;
            }
        },
        _onclick: function (param) {
            callChartListMethodReverse(this, &#x27;onclick&#x27;, param);
            if (param.target) {
                var ecData = this._eventPackage(param.target);
                if (ecData &amp;&amp; ecData.seriesIndex != null) {
                    this._messageCenter.dispatch(ecConfig.EVENT.CLICK, param.event, ecData, this);
                }
            }
        },
        _ondblclick: function (param) {
            callChartListMethodReverse(this, &#x27;ondblclick&#x27;, param);
            if (param.target) {
                var ecData = this._eventPackage(param.target);
                if (ecData &amp;&amp; ecData.seriesIndex != null) {
                    this._messageCenter.dispatch(ecConfig.EVENT.DBLCLICK, param.event, ecData, this);
                }
            }
        },
        _onmouseover: function (param) {
            if (param.target) {
                var ecData = this._eventPackage(param.target);
                if (ecData &amp;&amp; ecData.seriesIndex != null) {
                    this._messageCenter.dispatch(ecConfig.EVENT.HOVER, param.event, ecData, this);
                }
            }
        },
        _onmouseout: function (param) {
            if (param.target) {
                var ecData = this._eventPackage(param.target);
                if (ecData &amp;&amp; ecData.seriesIndex != null) {
                    this._messageCenter.dispatch(ecConfig.EVENT.MOUSEOUT, param.event, ecData, this);
                }
            }
        },
        _ondragstart: function (param) {
            this._status = {
                dragIn: false,
                dragOut: false,
                needRefresh: false
            };
            callChartListMethodReverse(this, &#x27;ondragstart&#x27;, param);
        },
        _ondragenter: function (param) {
            callChartListMethodReverse(this, &#x27;ondragenter&#x27;, param);
        },
        _ondragover: function (param) {
            callChartListMethodReverse(this, &#x27;ondragover&#x27;, param);
        },
        _ondragleave: function (param) {
            callChartListMethodReverse(this, &#x27;ondragleave&#x27;, param);
        },
        _ondrop: function (param) {
            callChartListMethodReverse(this, &#x27;ondrop&#x27;, param, this._status);
            this._island.ondrop(param, this._status);
        },
        _ondragend: function (param) {
            callChartListMethodReverse(this, &#x27;ondragend&#x27;, param, this._status);
            this._timeline &amp;&amp; this._timeline.ondragend(param, this._status);
            this._island.ondragend(param, this._status);
            if (this._status.needRefresh) {
                this._syncBackupData(this._option);
                var messageCenter = this._messageCenter;
                messageCenter.dispatch(ecConfig.EVENT.DATA_CHANGED, param.event, this._eventPackage(param.target), this);
                messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
            }
        },
        _onlegendSelected: function (param) {
            this._status.needRefresh = false;
            callChartListMethodReverse(this, &#x27;onlegendSelected&#x27;, param, this._status);
            if (this._status.needRefresh) {
                this._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
            }
        },
        _ondataZoom: function (param) {
            this._status.needRefresh = false;
            callChartListMethodReverse(this, &#x27;ondataZoom&#x27;, param, this._status);
            if (this._status.needRefresh) {
                this._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
            }
        },
        _ondataRange: function (param) {
            this._clearEffect();
            this._status.needRefresh = false;
            callChartListMethodReverse(this, &#x27;ondataRange&#x27;, param, this._status);
            if (this._status.needRefresh) {
                this._zr.refresh();
            }
        },
        _onmagicTypeChanged: function () {
            this._clearEffect();
            this._render(this._toolbox.getMagicOption());
        },
        _ondataViewChanged: function (param) {
            this._syncBackupData(param.option);
            this._messageCenter.dispatch(ecConfig.EVENT.DATA_CHANGED, null, param, this);
            this._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
        },
        _tooltipHover: function (param) {
            var tipShape = [];
            callChartListMethodReverse(this, &#x27;ontooltipHover&#x27;, param, tipShape);
        },
        _onrestore: function () {
            this.restore();
        },
        _onrefresh: function (param) {
            this._refreshInside = true;
            this.refresh(param);
            this._refreshInside = false;
        },
        _syncBackupData: function (curOption) {
            this.component.dataZoom &amp;&amp; this.component.dataZoom.syncBackupData(curOption);
        },
        _eventPackage: function (target) {
            if (target) {
                var ecData = require(&#x27;./util/ecData&#x27;);
                var seriesIndex = ecData.get(target, &#x27;seriesIndex&#x27;);
                var dataIndex = ecData.get(target, &#x27;dataIndex&#x27;);
                dataIndex = seriesIndex != -1 &amp;&amp; this.component.dataZoom ? this.component.dataZoom.getRealDataIndex(seriesIndex, dataIndex) : dataIndex;
                return {
                    seriesIndex: seriesIndex,
                    seriesName: (ecData.get(target, &#x27;series&#x27;) || {}).name,
                    dataIndex: dataIndex,
                    data: ecData.get(target, &#x27;data&#x27;),
                    name: ecData.get(target, &#x27;name&#x27;),
                    value: ecData.get(target, &#x27;value&#x27;),
                    special: ecData.get(target, &#x27;special&#x27;)
                };
            }
            return;
        },
        _render: function (magicOption) {
            this._mergeGlobalConifg(magicOption);
            var bgColor = magicOption.backgroundColor;
            if (bgColor) {
                if (!_canvasSupported &amp;&amp; bgColor.indexOf(&#x27;rgba&#x27;) != -1) {
                    var cList = bgColor.split(&#x27;,&#x27;);
                    this.dom.style.filter = &#x27;alpha(opacity=&#x27; + cList[3].substring(0, cList[3].lastIndexOf(&#x27;)&#x27;)) * 100 + &#x27;)&#x27;;
                    cList.length = 3;
                    cList[0] = cList[0].replace(&#x27;a&#x27;, &#x27;&#x27;);
                    this.dom.style.backgroundColor = cList.join(&#x27;,&#x27;) + &#x27;)&#x27;;
                } else {
                    this.dom.style.backgroundColor = bgColor;
                }
            }
            this._zr.clearAnimation();
            this._chartList = [];
            var chartLibrary = require(&#x27;./chart&#x27;);
            var componentLibrary = require(&#x27;./component&#x27;);
            if (magicOption.xAxis || magicOption.yAxis) {
                magicOption.grid = magicOption.grid || {};
                magicOption.dataZoom = magicOption.dataZoom || {};
            }
            var componentList = [
                &#x27;title&#x27;,
                &#x27;legend&#x27;,
                &#x27;tooltip&#x27;,
                &#x27;dataRange&#x27;,
                &#x27;roamController&#x27;,
                &#x27;grid&#x27;,
                &#x27;dataZoom&#x27;,
                &#x27;xAxis&#x27;,
                &#x27;yAxis&#x27;,
                &#x27;polar&#x27;
            ];
            var ComponentClass;
            var componentType;
            var component;
            for (var i = 0, l = componentList.length; i &lt; l; i++) {
                componentType = componentList[i];
                component = this.component[componentType];
                if (magicOption[componentType]) {
                    if (component) {
                        component.refresh &amp;&amp; component.refresh(magicOption);
                    } else {
                        ComponentClass = componentLibrary.get(/^[xy]Axis$/.test(componentType) ? &#x27;axis&#x27; : componentType);
                        component = new ComponentClass(this._themeConfig, this._messageCenter, this._zr, magicOption, this, componentType);
                        this.component[componentType] = component;
                    }
                    this._chartList.push(component);
                } else if (component) {
                    component.dispose();
                    this.component[componentType] = null;
                    delete this.component[componentType];
                }
            }
            var ChartClass;
            var chartType;
            var chart;
            var chartMap = {};
            for (var i = 0, l = magicOption.series.length; i &lt; l; i++) {
                chartType = magicOption.series[i].type;
                if (!chartType) {
                    console.error(&#x27;series[&#x27; + i + &#x27;] chart type has not been defined.&#x27;);
                    continue;
                }
                if (!chartMap[chartType]) {
                    chartMap[chartType] = true;
                    ChartClass = chartLibrary.get(chartType);
                    if (ChartClass) {
                        if (this.chart[chartType]) {
                            chart = this.chart[chartType];
                            chart.refresh(magicOption);
                        } else {
                            chart = new ChartClass(this._themeConfig, this._messageCenter, this._zr, magicOption, this);
                        }
                        this._chartList.push(chart);
                        this.chart[chartType] = chart;
                    } else {
                        console.error(chartType + &#x27; has not been required.&#x27;);
                    }
                }
            }
            for (chartType in this.chart) {
                if (chartType != ecConfig.CHART_TYPE_ISLAND &amp;&amp; !chartMap[chartType]) {
                    this.chart[chartType].dispose();
                    this.chart[chartType] = null;
                    delete this.chart[chartType];
                }
            }
            this.component.grid &amp;&amp; this.component.grid.refixAxisShape(this.component);
            this._island.refresh(magicOption);
            this._toolbox.refresh(magicOption);
            magicOption.animation &amp;&amp; !magicOption.renderAsImage ? this._zr.refresh() : this._zr.render();
            var imgId = &#x27;IMG&#x27; + this.id;
            var img = document.getElementById(imgId);
            if (magicOption.renderAsImage &amp;&amp; _canvasSupported) {
                if (img) {
                    img.src = this.getDataURL(magicOption.renderAsImage);
                } else {
                    img = this.getImage(magicOption.renderAsImage);
                    img.id = imgId;
                    img.style.position = &#x27;absolute&#x27;;
                    img.style.left = 0;
                    img.style.top = 0;
                    this.dom.firstChild.appendChild(img);
                }
                this.un();
                this._zr.un();
                this._disposeChartList();
                this._zr.clear();
            } else if (img) {
                img.parentNode.removeChild(img);
            }
            img = null;
            this._option = magicOption;
        },
        restore: function () {
            this._clearEffect();
            this._option = zrUtil.clone(this._optionRestore);
            this._disposeChartList();
            this._island.clear();
            this._toolbox.reset(this._option, true);
            this._render(this._option);
        },
        refresh: function (param) {
            this._clearEffect();
            param = param || {};
            var magicOption = param.option;
            if (!this._refreshInside &amp;&amp; magicOption) {
                magicOption = this.getOption();
                zrUtil.merge(magicOption, param.option, true);
                zrUtil.merge(this._optionRestore, param.option, true);
                this._toolbox.reset(magicOption);
            }
            this._island.refresh(magicOption);
            this._toolbox.refresh(magicOption);
            this._zr.clearAnimation();
            for (var i = 0, l = this._chartList.length; i &lt; l; i++) {
                this._chartList[i].refresh &amp;&amp; this._chartList[i].refresh(magicOption);
            }
            this.component.grid &amp;&amp; this.component.grid.refixAxisShape(this.component);
            this._zr.refresh();
        },
        _disposeChartList: function () {
            this._clearEffect();
            this._zr.clearAnimation();
            var len = this._chartList.length;
            while (len--) {
                var chart = this._chartList[len];
                if (chart) {
                    var chartType = chart.type;
                    this.chart[chartType] &amp;&amp; delete this.chart[chartType];
                    this.component[chartType] &amp;&amp; delete this.component[chartType];
                    chart.dispose &amp;&amp; chart.dispose();
                }
            }
            this._chartList = [];
        },
        _mergeGlobalConifg: function (magicOption) {
            var mergeList = [
                &#x27;backgroundColor&#x27;,
                &#x27;calculable&#x27;,
                &#x27;calculableColor&#x27;,
                &#x27;calculableHolderColor&#x27;,
                &#x27;nameConnector&#x27;,
                &#x27;valueConnector&#x27;,
                &#x27;animation&#x27;,
                &#x27;animationThreshold&#x27;,
                &#x27;animationDuration&#x27;,
                &#x27;animationEasing&#x27;,
                &#x27;addDataAnimation&#x27;,
                &#x27;symbolList&#x27;,
                &#x27;DRAG_ENABLE_TIME&#x27;
            ];
            var len = mergeList.length;
            while (len--) {
                var mergeItem = mergeList[len];
                if (magicOption[mergeItem] == null) {
                    magicOption[mergeItem] = this._themeConfig[mergeItem];
                }
            }
            var themeColor = magicOption.color;
            if (!(themeColor &amp;&amp; themeColor.length)) {
                themeColor = this._themeConfig.color;
            }
            if (!_canvasSupported) {
                magicOption.animation = false;
                magicOption.addDataAnimation = false;
            }
            this._zr.getColor = function (idx) {
                var zrColor = require(&#x27;zrender/tool/color&#x27;);
                return zrColor.getColor(idx, themeColor);
            };
        },
        setOption: function (option, notMerge) {
            if (!option.timeline) {
                return this._setOption(option, notMerge);
            } else {
                return this._setTimelineOption(option);
            }
        },
        _setOption: function (option, notMerge) {
            if (!notMerge &amp;&amp; this._option) {
                this._option = zrUtil.merge(this.getOption(), zrUtil.clone(option), true);
            } else {
                this._option = zrUtil.clone(option);
            }
            this._optionRestore = zrUtil.clone(this._option);
            if (!this._option.series || this._option.series.length === 0) {
                this._zr.clear();
                return;
            }
            if (this.component.dataZoom &amp;&amp; (this._option.dataZoom || this._option.toolbox &amp;&amp; this._option.toolbox.feature &amp;&amp; this._option.toolbox.feature.dataZoom &amp;&amp; this._option.toolbox.feature.dataZoom.show)) {
                this.component.dataZoom.syncOption(this._option);
            }
            this._toolbox.reset(this._option);
            this._render(this._option);
            return this;
        },
        getOption: function () {
            var magicOption = zrUtil.clone(this._option);
            var self = this;
            function restoreOption(prop) {
                var restoreSource = self._optionRestore[prop];
                if (restoreSource) {
                    if (restoreSource instanceof Array) {
                        var len = restoreSource.length;
                        while (len--) {
                            magicOption[prop][len].data = zrUtil.clone(restoreSource[len].data);
                        }
                    } else {
                        magicOption[prop].data = zrUtil.clone(restoreSource.data);
                    }
                }
            }
            restoreOption(&#x27;xAxis&#x27;);
            restoreOption(&#x27;yAxis&#x27;);
            restoreOption(&#x27;series&#x27;);
            return magicOption;
        },
        setSeries: function (series, notMerge) {
            if (!notMerge) {
                this.setOption({ series: series });
            } else {
                this._option.series = series;
                this.setOption(this._option, notMerge);
            }
            return this;
        },
        getSeries: function () {
            return this.getOption().series;
        },
        _setTimelineOption: function (option) {
            this._timeline &amp;&amp; this._timeline.dispose();
            var Timeline = require(&#x27;./component/timeline&#x27;);
            var timeline = new Timeline(this._themeConfig, this._messageCenter, this._zr, option, this);
            this._timeline = timeline;
            this.component.timeline = this._timeline;
            return this;
        },
        addData: function (seriesIdx, data, isHead, dataGrow, additionData) {
            var params = seriesIdx instanceof Array ? seriesIdx : [[
                    seriesIdx,
                    data,
                    isHead,
                    dataGrow,
                    additionData
                ]];
            var magicOption = this.getOption();
            var optionRestore = this._optionRestore;
            for (var i = 0, l = params.length; i &lt; l; i++) {
                seriesIdx = params[i][0];
                data = params[i][1];
                isHead = params[i][2];
                dataGrow = params[i][3];
                additionData = params[i][4];
                var seriesItem = optionRestore.series[seriesIdx];
                var inMethod = isHead ? &#x27;unshift&#x27; : &#x27;push&#x27;;
                var outMethod = isHead ? &#x27;pop&#x27; : &#x27;shift&#x27;;
                if (seriesItem) {
                    var seriesItemData = seriesItem.data;
                    var mSeriesItemData = magicOption.series[seriesIdx].data;
                    seriesItemData[inMethod](data);
                    mSeriesItemData[inMethod](data);
                    if (!dataGrow) {
                        seriesItemData[outMethod]();
                        data = mSeriesItemData[outMethod]();
                    }
                    if (additionData != null) {
                        var legend;
                        var legendData;
                        if (seriesItem.type === ecConfig.CHART_TYPE_PIE &amp;&amp; (legend = optionRestore.legend) &amp;&amp; (legendData = legend.data)) {
                            var mLegendData = magicOption.legend.data;
                            legendData[inMethod](additionData);
                            mLegendData[inMethod](additionData);
                            if (!dataGrow) {
                                var legendDataIdx = zrUtil.indexOf(legendData, data.name);
                                legendDataIdx != -1 &amp;&amp; legendData.splice(legendDataIdx, 1);
                                legendDataIdx = zrUtil.indexOf(mLegendData, data.name);
                                legendDataIdx != -1 &amp;&amp; mLegendData.splice(legendDataIdx, 1);
                            }
                        } else if (optionRestore.xAxis != null &amp;&amp; optionRestore.yAxis != null) {
                            var axisData;
                            var mAxisData;
                            var axisIdx = seriesItem.xAxisIndex || 0;
                            if (optionRestore.xAxis[axisIdx].type == null || optionRestore.xAxis[axisIdx].type === &#x27;category&#x27;) {
                                axisData = optionRestore.xAxis[axisIdx].data;
                                mAxisData = magicOption.xAxis[axisIdx].data;
                                axisData[inMethod](additionData);
                                mAxisData[inMethod](additionData);
                                if (!dataGrow) {
                                    axisData[outMethod]();
                                    mAxisData[outMethod]();
                                }
                            }
                            axisIdx = seriesItem.yAxisIndex || 0;
                            if (optionRestore.yAxis[axisIdx].type === &#x27;category&#x27;) {
                                axisData = optionRestore.yAxis[axisIdx].data;
                                mAxisData = magicOption.yAxis[axisIdx].data;
                                axisData[inMethod](additionData);
                                mAxisData[inMethod](additionData);
                                if (!dataGrow) {
                                    axisData[outMethod]();
                                    mAxisData[outMethod]();
                                }
                            }
                        }
                    }
                    this._option.series[seriesIdx].data = magicOption.series[seriesIdx].data;
                }
            }
            this._zr.clearAnimation();
            var chartList = this._chartList;
            for (var i = 0, l = chartList.length; i &lt; l; i++) {
                if (magicOption.addDataAnimation &amp;&amp; chartList[i].addDataAnimation) {
                    chartList[i].addDataAnimation(params);
                }
            }
            this.component.dataZoom &amp;&amp; this.component.dataZoom.syncOption(magicOption);
            this._option = magicOption;
            var self = this;
            setTimeout(function () {
                if (!self._zr) {
                    return;
                }
                self._zr.clearAnimation();
                for (var i = 0, l = chartList.length; i &lt; l; i++) {
                    chartList[i].motionlessOnce = magicOption.addDataAnimation &amp;&amp; chartList[i].addDataAnimation;
                }
                self._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, { option: magicOption }, self);
            }, magicOption.addDataAnimation ? 500 : 0);
            return this;
        },
        addMarkPoint: function (seriesIdx, markData) {
            return this._addMark(seriesIdx, markData, &#x27;markPoint&#x27;);
        },
        addMarkLine: function (seriesIdx, markData) {
            return this._addMark(seriesIdx, markData, &#x27;markLine&#x27;);
        },
        _addMark: function (seriesIdx, markData, markType) {
            var series = this._option.series;
            var seriesItem;
            if (series &amp;&amp; (seriesItem = series[seriesIdx])) {
                var seriesR = this._optionRestore.series;
                var seriesRItem = seriesR[seriesIdx];
                var markOpt = seriesItem[markType];
                var markOptR = seriesRItem[markType];
                markOpt = seriesItem[markType] = markOpt || { data: [] };
                markOptR = seriesRItem[markType] = markOptR || { data: [] };
                for (var key in markData) {
                    if (key === &#x27;data&#x27;) {
                        markOpt.data = markOpt.data.concat(markData.data);
                        markOptR.data = markOptR.data.concat(markData.data);
                    } else if (typeof markData[key] != &#x27;object&#x27; || markOpt[key] == null) {
                        markOpt[key] = markOptR[key] = markData[key];
                    } else {
                        zrUtil.merge(markOpt[key], markData[key], true);
                        zrUtil.merge(markOptR[key], markData[key], true);
                    }
                }
                var chart = this.chart[seriesItem.type];
                chart &amp;&amp; chart.addMark(seriesIdx, markData, markType);
            }
            return this;
        },
        delMarkPoint: function (seriesIdx, markName) {
            return this._delMark(seriesIdx, markName, &#x27;markPoint&#x27;);
        },
        delMarkLine: function (seriesIdx, markName) {
            return this._delMark(seriesIdx, markName, &#x27;markLine&#x27;);
        },
        _delMark: function (seriesIdx, markName, markType) {
            var series = this._option.series;
            var seriesItem;
            var mark;
            var dataArray;
            if (!(series &amp;&amp; (seriesItem = series[seriesIdx]) &amp;&amp; (mark = seriesItem[markType]) &amp;&amp; (dataArray = mark.data))) {
                return this;
            }
            markName = markName.split(&#x27; &gt; &#x27;);
            var targetIndex = -1;
            for (var i = 0, l = dataArray.length; i &lt; l; i++) {
                var dataItem = dataArray[i];
                if (dataItem instanceof Array) {
                    if (dataItem[0].name === markName[0] &amp;&amp; dataItem[1].name === markName[1]) {
                        targetIndex = i;
                        break;
                    }
                } else if (dataItem.name === markName[0]) {
                    targetIndex = i;
                    break;
                }
            }
            if (targetIndex &gt; -1) {
                dataArray.splice(targetIndex, 1);
                this._optionRestore.series[seriesIdx][markType].data.splice(targetIndex, 1);
                var chart = this.chart[seriesItem.type];
                chart &amp;&amp; chart.delMark(seriesIdx, markName.join(&#x27; &gt; &#x27;), markType);
            }
            return this;
        },
        getDom: function () {
            return this.dom;
        },
        getZrender: function () {
            return this._zr;
        },
        getDataURL: function (imgType) {
            if (!_canvasSupported) {
                return &#x27;&#x27;;
            }
            if (this._chartList.length === 0) {
                var imgId = &#x27;IMG&#x27; + this.id;
                var img = document.getElementById(imgId);
                if (img) {
                    return img.src;
                }
            }
            var tooltip = this.component.tooltip;
            tooltip &amp;&amp; tooltip.hideTip();
            switch (imgType) {
            case &#x27;jpeg&#x27;:
                break;
            default:
                imgType = &#x27;png&#x27;;
            }
            var bgColor = this._option.backgroundColor;
            if (bgColor &amp;&amp; bgColor.replace(&#x27; &#x27;, &#x27;&#x27;) === &#x27;rgba(0,0,0,0)&#x27;) {
                bgColor = &#x27;#fff&#x27;;
            }
            return this._zr.toDataURL(&#x27;image/&#x27; + imgType, bgColor);
        },
        getImage: function (imgType) {
            var title = this._optionRestore.title;
            var imgDom = document.createElement(&#x27;img&#x27;);
            imgDom.src = this.getDataURL(imgType);
            imgDom.title = title &amp;&amp; title.text || &#x27;ECharts&#x27;;
            return imgDom;
        },
        getConnectedDataURL: function (imgType) {
            if (!this.isConnected()) {
                return this.getDataURL(imgType);
            }
            var tempDom = this.dom;
            var imgList = {
                &#x27;self&#x27;: {
                    img: this.getDataURL(imgType),
                    left: tempDom.offsetLeft,
                    top: tempDom.offsetTop,
                    right: tempDom.offsetLeft + tempDom.offsetWidth,
                    bottom: tempDom.offsetTop + tempDom.offsetHeight
                }
            };
            var minLeft = imgList.self.left;
            var minTop = imgList.self.top;
            var maxRight = imgList.self.right;
            var maxBottom = imgList.self.bottom;
            for (var c in this._connected) {
                tempDom = this._connected[c].getDom();
                imgList[c] = {
                    img: this._connected[c].getDataURL(imgType),
                    left: tempDom.offsetLeft,
                    top: tempDom.offsetTop,
                    right: tempDom.offsetLeft + tempDom.offsetWidth,
                    bottom: tempDom.offsetTop + tempDom.offsetHeight
                };
                minLeft = Math.min(minLeft, imgList[c].left);
                minTop = Math.min(minTop, imgList[c].top);
                maxRight = Math.max(maxRight, imgList[c].right);
                maxBottom = Math.max(maxBottom, imgList[c].bottom);
            }
            var zrDom = document.createElement(&#x27;div&#x27;);
            zrDom.style.position = &#x27;absolute&#x27;;
            zrDom.style.left = &#x27;-4000px&#x27;;
            zrDom.style.width = maxRight - minLeft + &#x27;px&#x27;;
            zrDom.style.height = maxBottom - minTop + &#x27;px&#x27;;
            document.body.appendChild(zrDom);
            var zrImg = require(&#x27;zrender&#x27;).init(zrDom);
            var ImageShape = require(&#x27;zrender/shape/Image&#x27;);
            for (var c in imgList) {
                zrImg.addShape(new ImageShape({
                    style: {
                        x: imgList[c].left - minLeft,
                        y: imgList[c].top - minTop,
                        image: imgList[c].img
                    }
                }));
            }
            zrImg.render();
            var bgColor = this._option.backgroundColor;
            if (bgColor &amp;&amp; bgColor.replace(/ /g, &#x27;&#x27;) === &#x27;rgba(0,0,0,0)&#x27;) {
                bgColor = &#x27;#fff&#x27;;
            }
            var image = zrImg.toDataURL(&#x27;image/png&#x27;, bgColor);
            setTimeout(function () {
                zrImg.dispose();
                zrDom.parentNode.removeChild(zrDom);
                zrDom = null;
            }, 100);
            return image;
        },
        getConnectedImage: function (imgType) {
            var title = this._optionRestore.title;
            var imgDom = document.createElement(&#x27;img&#x27;);
            imgDom.src = this.getConnectedDataURL(imgType);
            imgDom.title = title &amp;&amp; title.text || &#x27;ECharts&#x27;;
            return imgDom;
        },
        on: function (eventName, eventListener) {
            this._messageCenterOutSide.bind(eventName, eventListener, this);
            return this;
        },
        un: function (eventName, eventListener) {
            this._messageCenterOutSide.unbind(eventName, eventListener);
            return this;
        },
        connect: function (connectTarget) {
            if (!connectTarget) {
                return this;
            }
            if (!this._connected) {
                this._connected = {};
            }
            if (connectTarget instanceof Array) {
                for (var i = 0, l = connectTarget.length; i &lt; l; i++) {
                    this._connected[connectTarget[i].id] = connectTarget[i];
                }
            } else {
                this._connected[connectTarget.id] = connectTarget;
            }
            return this;
        },
        disConnect: function (connectTarget) {
            if (!connectTarget || !this._connected) {
                return this;
            }
            if (connectTarget instanceof Array) {
                for (var i = 0, l = connectTarget.length; i &lt; l; i++) {
                    delete this._connected[connectTarget[i].id];
                }
            } else {
                delete this._connected[connectTarget.id];
            }
            for (var k in this._connected) {
                return k, this;
            }
            this._connected = false;
            return this;
        },
        connectedEventHandler: function (param) {
            if (param.__echartsId != this.id) {
                this._onevent(param);
            }
        },
        isConnected: function () {
            return !!this._connected;
        },
        showLoading: function (loadingOption) {
            var effectList = {
                bar: require(&#x27;zrender/loadingEffect/Bar&#x27;),
                bubble: require(&#x27;zrender/loadingEffect/Bubble&#x27;),
                dynamicLine: require(&#x27;zrender/loadingEffect/DynamicLine&#x27;),
                ring: require(&#x27;zrender/loadingEffect/Ring&#x27;),
                spin: require(&#x27;zrender/loadingEffect/Spin&#x27;),
                whirling: require(&#x27;zrender/loadingEffect/Whirling&#x27;)
            };
            this._toolbox.hideDataView();
            loadingOption = loadingOption || {};
            var textStyle = loadingOption.textStyle || {};
            loadingOption.textStyle = textStyle;
            var finalTextStyle = zrUtil.merge(zrUtil.clone(textStyle), this._themeConfig.textStyle);
            textStyle.textFont = finalTextStyle.fontStyle + &#x27; &#x27; + finalTextStyle.fontWeight + &#x27; &#x27; + finalTextStyle.fontSize + &#x27;px &#x27; + finalTextStyle.fontFamily;
            textStyle.text = loadingOption.text || this._themeConfig.loadingText;
            if (loadingOption.x != null) {
                textStyle.x = loadingOption.x;
            }
            if (loadingOption.y != null) {
                textStyle.y = loadingOption.y;
            }
            loadingOption.effectOption = loadingOption.effectOption || {};
            loadingOption.effectOption.textStyle = textStyle;
            var Effect = loadingOption.effect;
            if (typeof Effect === &#x27;string&#x27; || Effect == null) {
                Effect = effectList[loadingOption.effect || &#x27;spin&#x27;];
            }
            this._zr.showLoading(new Effect(loadingOption.effectOption));
            return this;
        },
        hideLoading: function () {
            this._zr.hideLoading();
            return this;
        },
        setTheme: function (theme) {
            if (theme) {
                if (typeof theme === &#x27;string&#x27;) {
                    switch (theme) {
                    default:
                        theme = require(&#x27;./theme/default&#x27;);
                    }
                } else {
                    theme = theme || {};
                }
                for (var key in this._themeConfig) {
                    delete this._themeConfig[key];
                }
                for (var key in ecConfig) {
                    this._themeConfig[key] = zrUtil.clone(ecConfig[key]);
                }
                theme.color &amp;&amp; (this._themeConfig.color = []);
                theme.symbolList &amp;&amp; (this._themeConfig.symbolList = []);
                zrUtil.merge(this._themeConfig, zrUtil.clone(theme), true);
            }
            if (!_canvasSupported) {
                this._themeConfig.textStyle.fontFamily = this._themeConfig.textStyle.fontFamily2;
            }
            this._timeline &amp;&amp; this._timeline.setTheme(true);
            this._optionRestore &amp;&amp; this.restore();
        },
        resize: function () {
            var self = this;
            return function () {
                self._clearEffect();
                self._zr.resize();
                if (self._option &amp;&amp; self._option.renderAsImage &amp;&amp; _canvasSupported) {
                    self._render(self._option);
                    return self;
                }
                self._zr.clearAnimation();
                self._island.resize();
                self._toolbox.resize();
                self._timeline &amp;&amp; self._timeline.resize();
                for (var i = 0, l = self._chartList.length; i &lt; l; i++) {
                    self._chartList[i].resize &amp;&amp; self._chartList[i].resize();
                }
                self.component.grid &amp;&amp; self.component.grid.refixAxisShape(self.component);
                self._zr.refresh();
                self._messageCenter.dispatch(ecConfig.EVENT.RESIZE, null, null, self);
                return self;
            };
        },
        _clearEffect: function () {
            this._zr.modLayer(ecConfig.EFFECT_ZLEVEL, { motionBlur: false });
            this._zr.painter.clearLayer(ecConfig.EFFECT_ZLEVEL);
        },
        clear: function () {
            this._disposeChartList();
            this._zr.clear();
            this._option = {};
            this._optionRestore = {};
            this.dom.style.backgroundColor = null;
            return this;
        },
        dispose: function () {
            var key = this.dom.getAttribute(DOM_ATTRIBUTE_KEY);
            key &amp;&amp; delete _instances[key];
            this._island.dispose();
            this._toolbox.dispose();
            this._timeline &amp;&amp; this._timeline.dispose();
            this._messageCenter.unbind();
            this.clear();
            this._zr.dispose();
            this._zr = null;
        }
    };
    return self;
});define(&#x27;echarts/config&#x27;, [], function () {
    var config = {
        CHART_TYPE_LINE: &#x27;line&#x27;,
        CHART_TYPE_BAR: &#x27;bar&#x27;,
        CHART_TYPE_SCATTER: &#x27;scatter&#x27;,
        CHART_TYPE_PIE: &#x27;pie&#x27;,
        CHART_TYPE_RADAR: &#x27;radar&#x27;,
        CHART_TYPE_MAP: &#x27;map&#x27;,
        CHART_TYPE_K: &#x27;k&#x27;,
        CHART_TYPE_ISLAND: &#x27;island&#x27;,
        CHART_TYPE_FORCE: &#x27;force&#x27;,
        CHART_TYPE_CHORD: &#x27;chord&#x27;,
        CHART_TYPE_GAUGE: &#x27;gauge&#x27;,
        CHART_TYPE_FUNNEL: &#x27;funnel&#x27;,
        CHART_TYPE_EVENTRIVER: &#x27;eventRiver&#x27;,
        COMPONENT_TYPE_TITLE: &#x27;title&#x27;,
        COMPONENT_TYPE_LEGEND: &#x27;legend&#x27;,
        COMPONENT_TYPE_DATARANGE: &#x27;dataRange&#x27;,
        COMPONENT_TYPE_DATAVIEW: &#x27;dataView&#x27;,
        COMPONENT_TYPE_DATAZOOM: &#x27;dataZoom&#x27;,
        COMPONENT_TYPE_TOOLBOX: &#x27;toolbox&#x27;,
        COMPONENT_TYPE_TOOLTIP: &#x27;tooltip&#x27;,
        COMPONENT_TYPE_GRID: &#x27;grid&#x27;,
        COMPONENT_TYPE_AXIS: &#x27;axis&#x27;,
        COMPONENT_TYPE_POLAR: &#x27;polar&#x27;,
        COMPONENT_TYPE_X_AXIS: &#x27;xAxis&#x27;,
        COMPONENT_TYPE_Y_AXIS: &#x27;yAxis&#x27;,
        COMPONENT_TYPE_AXIS_CATEGORY: &#x27;categoryAxis&#x27;,
        COMPONENT_TYPE_AXIS_VALUE: &#x27;valueAxis&#x27;,
        COMPONENT_TYPE_TIMELINE: &#x27;timeline&#x27;,
        COMPONENT_TYPE_ROAMCONTROLLER: &#x27;roamController&#x27;,
        backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,
        color: [
            &#x27;#ff7f50&#x27;,
            &#x27;#87cefa&#x27;,
            &#x27;#da70d6&#x27;,
            &#x27;#32cd32&#x27;,
            &#x27;#6495ed&#x27;,
            &#x27;#ff69b4&#x27;,
            &#x27;#ba55d3&#x27;,
            &#x27;#cd5c5c&#x27;,
            &#x27;#ffa500&#x27;,
            &#x27;#40e0d0&#x27;,
            &#x27;#1e90ff&#x27;,
            &#x27;#ff6347&#x27;,
            &#x27;#7b68ee&#x27;,
            &#x27;#00fa9a&#x27;,
            &#x27;#ffd700&#x27;,
            &#x27;#6699FF&#x27;,
            &#x27;#ff6666&#x27;,
            &#x27;#3cb371&#x27;,
            &#x27;#b8860b&#x27;,
            &#x27;#30e0e0&#x27;
        ],
        title: {
            text: &#x27;&#x27;,
            subtext: &#x27;&#x27;,
            x: &#x27;left&#x27;,
            y: &#x27;top&#x27;,
            backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,
            borderColor: &#x27;#ccc&#x27;,
            borderWidth: 0,
            padding: 5,
            itemGap: 5,
            textStyle: {
                fontSize: 18,
                fontWeight: &#x27;bolder&#x27;,
                color: &#x27;#333&#x27;
            },
            subtextStyle: { color: &#x27;#aaa&#x27; }
        },
        legend: {
            show: true,
            orient: &#x27;horizontal&#x27;,
            x: &#x27;center&#x27;,
            y: &#x27;top&#x27;,
            backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,
            borderColor: &#x27;#ccc&#x27;,
            borderWidth: 0,
            padding: 5,
            itemGap: 10,
            itemWidth: 20,
            itemHeight: 14,
            textStyle: { color: &#x27;#333&#x27; },
            selectedMode: true
        },
        dataRange: {
            show: true,
            orient: &#x27;vertical&#x27;,
            x: &#x27;left&#x27;,
            y: &#x27;bottom&#x27;,
            backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,
            borderColor: &#x27;#ccc&#x27;,
            borderWidth: 0,
            padding: 5,
            itemGap: 10,
            itemWidth: 20,
            itemHeight: 14,
            precision: 0,
            splitNumber: 5,
            calculable: false,
            hoverLink: true,
            realtime: true,
            color: [
                &#x27;#006edd&#x27;,
                &#x27;#e0ffff&#x27;
            ],
            textStyle: { color: &#x27;#333&#x27; }
        },
        toolbox: {
            show: false,
            orient: &#x27;horizontal&#x27;,
            x: &#x27;right&#x27;,
            y: &#x27;top&#x27;,
            color: [
                &#x27;#1e90ff&#x27;,
                &#x27;#22bb22&#x27;,
                &#x27;#4b0082&#x27;,
                &#x27;#d2691e&#x27;
            ],
            disableColor: &#x27;#ddd&#x27;,
            effectiveColor: &#x27;red&#x27;,
            backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,
            borderColor: &#x27;#ccc&#x27;,
            borderWidth: 0,
            padding: 5,
            itemGap: 10,
            itemSize: 16,
            showTitle: true,
            feature: {
                mark: {
                    show: false,
                    title: {
                        mark: &#x27;辅助线开关&#x27;,
                        markUndo: &#x27;删除辅助线&#x27;,
                        markClear: &#x27;清空辅助线&#x27;
                    },
                    lineStyle: {
                        width: 1,
                        color: &#x27;#1e90ff&#x27;,
                        type: &#x27;dashed&#x27;
                    }
                },
                dataZoom: {
                    show: false,
                    title: {
                        dataZoom: &#x27;区域缩放&#x27;,
                        dataZoomReset: &#x27;区域缩放后退&#x27;
                    }
                },
                dataView: {
                    show: false,
                    title: &#x27;数据视图&#x27;,
                    readOnly: false,
                    lang: [
                        &#x27;数据视图&#x27;,
                        &#x27;关闭&#x27;,
                        &#x27;刷新&#x27;
                    ]
                },
                magicType: {
                    show: false,
                    title: {
                        line: &#x27;折线图切换&#x27;,
                        bar: &#x27;柱形图切换&#x27;,
                        stack: &#x27;堆积&#x27;,
                        tiled: &#x27;平铺&#x27;,
                        force: &#x27;力导向布局图切换&#x27;,
                        chord: &#x27;和弦图切换&#x27;,
                        pie: &#x27;饼图切换&#x27;,
                        funnel: &#x27;漏斗图切换&#x27;
                    },
                    type: []
                },
                restore: {
                    show: false,
                    title: &#x27;还原&#x27;
                },
                saveAsImage: {
                    show: false,
                    title: &#x27;保存为图片&#x27;,
                    type: &#x27;png&#x27;,
                    lang: [&#x27;点击保存&#x27;]
                }
            }
        },
        tooltip: {
            show: true,
            showContent: true,
            trigger: &#x27;item&#x27;,
            islandFormatter: &#x27;{a} &lt;br/&gt;{b} : {c}&#x27;,
            showDelay: 20,
            hideDelay: 100,
            transitionDuration: 0.4,
            enterable: false,
            backgroundColor: &#x27;rgba(0,0,0,0.7)&#x27;,
            borderColor: &#x27;#333&#x27;,
            borderRadius: 4,
            borderWidth: 0,
            padding: 5,
            axisPointer: {
                type: &#x27;line&#x27;,
                lineStyle: {
                    color: &#x27;#48b&#x27;,
                    width: 2,
                    type: &#x27;solid&#x27;
                },
                crossStyle: {
                    color: &#x27;#1e90ff&#x27;,
                    width: 1,
                    type: &#x27;dashed&#x27;
                },
                shadowStyle: {
                    color: &#x27;rgba(150,150,150,0.3)&#x27;,
                    width: &#x27;auto&#x27;,
                    type: &#x27;default&#x27;
                }
            },
            textStyle: { color: &#x27;#fff&#x27; }
        },
        dataZoom: {
            show: false,
            orient: &#x27;horizontal&#x27;,
            backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,
            dataBackgroundColor: &#x27;#eee&#x27;,
            fillerColor: &#x27;rgba(144,197,237,0.2)&#x27;,
            handleColor: &#x27;rgba(70,130,180,0.8)&#x27;,
            showDetail: true,
            realtime: true
        },
        grid: {
            x: 80,
            y: 60,
            x2: 80,
            y2: 60,
            backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,
            borderWidth: 1,
            borderColor: &#x27;#ccc&#x27;
        },
        categoryAxis: {
            show: true,
            position: &#x27;bottom&#x27;,
            name: &#x27;&#x27;,
            nameLocation: &#x27;end&#x27;,
            nameTextStyle: {},
            boundaryGap: true,
            axisLine: {
                show: true,
                onZero: true,
                lineStyle: {
                    color: &#x27;#48b&#x27;,
                    width: 2,
                    type: &#x27;solid&#x27;
                }
            },
            axisTick: {
                show: true,
                interval: &#x27;auto&#x27;,
                inside: false,
                length: 5,
                lineStyle: {
                    color: &#x27;#333&#x27;,
                    width: 1
                }
            },
            axisLabel: {
                show: true,
                interval: &#x27;auto&#x27;,
                rotate: 0,
                margin: 8,
                textStyle: { color: &#x27;#333&#x27; }
            },
            splitLine: {
                show: true,
                lineStyle: {
                    color: [&#x27;#ccc&#x27;],
                    width: 1,
                    type: &#x27;solid&#x27;
                }
            },
            splitArea: {
                show: false,
                areaStyle: {
                    color: [
                        &#x27;rgba(250,250,250,0.3)&#x27;,
                        &#x27;rgba(200,200,200,0.3)&#x27;
                    ]
                }
            }
        },
        valueAxis: {
            show: true,
            position: &#x27;left&#x27;,
            name: &#x27;&#x27;,
            nameLocation: &#x27;end&#x27;,
            nameTextStyle: {},
            boundaryGap: [
                0,
                0
            ],
            axisLine: {
                show: true,
                onZero: true,
                lineStyle: {
                    color: &#x27;#48b&#x27;,
                    width: 2,
                    type: &#x27;solid&#x27;
                }
            },
            axisTick: {
                show: false,
                inside: false,
                length: 5,
                lineStyle: {
                    color: &#x27;#333&#x27;,
                    width: 1
                }
            },
            axisLabel: {
                show: true,
                rotate: 0,
                margin: 8,
                textStyle: { color: &#x27;#333&#x27; }
            },
            splitLine: {
                show: true,
                lineStyle: {
                    color: [&#x27;#ccc&#x27;],
                    width: 1,
                    type: &#x27;solid&#x27;
                }
            },
            splitArea: {
                show: false,
                areaStyle: {
                    color: [
                        &#x27;rgba(250,250,250,0.3)&#x27;,
                        &#x27;rgba(200,200,200,0.3)&#x27;
                    ]
                }
            }
        },
        polar: {
            center: [
                &#x27;50%&#x27;,
                &#x27;50%&#x27;
            ],
            radius: &#x27;75%&#x27;,
            startAngle: 90,
            boundaryGap: [
                0,
                0
            ],
            splitNumber: 5,
            name: {
                show: true,
                textStyle: { color: &#x27;#333&#x27; }
            },
            axisLine: {
                show: true,
                lineStyle: {
                    color: &#x27;#ccc&#x27;,
                    width: 1,
                    type: &#x27;solid&#x27;
                }
            },
            axisLabel: {
                show: false,
                textStyle: { color: &#x27;#333&#x27; }
            },
            splitArea: {
                show: true,
                areaStyle: {
                    color: [
                        &#x27;rgba(250,250,250,0.3)&#x27;,
                        &#x27;rgba(200,200,200,0.3)&#x27;
                    ]
                }
            },
            splitLine: {
                show: true,
                lineStyle: {
                    width: 1,
                    color: &#x27;#ccc&#x27;
                }
            },
            type: &#x27;polygon&#x27;
        },
        timeline: {
            show: true,
            type: &#x27;time&#x27;,
            notMerge: false,
            realtime: true,
            x: 80,
            x2: 80,
            y2: 0,
            height: 50,
            backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,
            borderColor: &#x27;#ccc&#x27;,
            borderWidth: 0,
            padding: 5,
            controlPosition: &#x27;left&#x27;,
            autoPlay: false,
            loop: true,
            playInterval: 2000,
            lineStyle: {
                width: 1,
                color: &#x27;#666&#x27;,
                type: &#x27;dashed&#x27;
            },
            label: {
                show: true,
                interval: &#x27;auto&#x27;,
                rotate: 0,
                textStyle: { color: &#x27;#333&#x27; }
            },
            checkpointStyle: {
                symbol: &#x27;auto&#x27;,
                symbolSize: &#x27;auto&#x27;,
                color: &#x27;auto&#x27;,
                borderColor: &#x27;auto&#x27;,
                borderWidth: &#x27;auto&#x27;,
                label: {
                    show: false,
                    textStyle: { color: &#x27;auto&#x27; }
                }
            },
            controlStyle: {
                normal: { color: &#x27;#333&#x27; },
                emphasis: { color: &#x27;#1e90ff&#x27; }
            },
            symbol: &#x27;emptyDiamond&#x27;,
            symbolSize: 4,
            currentIndex: 0
        },
        roamController: {
            show: true,
            x: &#x27;left&#x27;,
            y: &#x27;top&#x27;,
            width: 80,
            height: 120,
            backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,
            borderColor: &#x27;#ccc&#x27;,
            borderWidth: 0,
            padding: 5,
            handleColor: &#x27;#6495ed&#x27;,
            fillerColor: &#x27;#fff&#x27;,
            step: 15,
            mapTypeControl: null
        },
        bar: {
            clickable: true,
            legendHoverLink: true,
            xAxisIndex: 0,
            yAxisIndex: 0,
            barMinHeight: 0,
            barGap: &#x27;30%&#x27;,
            barCategoryGap: &#x27;20%&#x27;,
            itemStyle: {
                normal: {
                    barBorderColor: &#x27;#fff&#x27;,
                    barBorderRadius: 0,
                    barBorderWidth: 0,
                    label: { show: false }
                },
                emphasis: {
                    barBorderColor: &#x27;#fff&#x27;,
                    barBorderRadius: 0,
                    barBorderWidth: 0,
                    label: { show: false }
                }
            }
        },
        line: {
            clickable: true,
            legendHoverLink: true,
            xAxisIndex: 0,
            yAxisIndex: 0,
            itemStyle: {
                normal: {
                    label: { show: false },
                    lineStyle: {
                        width: 2,
                        type: &#x27;solid&#x27;,
                        shadowColor: &#x27;rgba(0,0,0,0)&#x27;,
                        shadowBlur: 0,
                        shadowOffsetX: 0,
                        shadowOffsetY: 0
                    }
                },
                emphasis: { label: { show: false } }
            },
            symbolSize: 2,
            showAllSymbol: false
        },
        k: {
            clickable: true,
            legendHoverLink: false,
            xAxisIndex: 0,
            yAxisIndex: 0,
            itemStyle: {
                normal: {
                    color: &#x27;#fff&#x27;,
                    color0: &#x27;#00aa11&#x27;,
                    lineStyle: {
                        width: 1,
                        color: &#x27;#ff3200&#x27;,
                        color0: &#x27;#00aa11&#x27;
                    }
                },
                emphasis: {}
            }
        },
        scatter: {
            clickable: true,
            legendHoverLink: true,
            xAxisIndex: 0,
            yAxisIndex: 0,
            symbolSize: 4,
            large: false,
            largeThreshold: 2000,
            itemStyle: {
                normal: {
                    label: {
                        show: false,
                        formatter: function (a, b, c) {
                            if (typeof c[2] != &#x27;undefined&#x27;) {
                                return c[2];
                            } else {
                                return c[0] + &#x27; , &#x27; + c[1];
                            }
                        }
                    }
                },
                emphasis: {
                    label: {
                        show: false,
                        formatter: function (a, b, c) {
                            if (typeof c[2] != &#x27;undefined&#x27;) {
                                return c[2];
                            } else {
                                return c[0] + &#x27; , &#x27; + c[1];
                            }
                        }
                    }
                }
            }
        },
        radar: {
            clickable: true,
            legendHoverLink: true,
            polarIndex: 0,
            itemStyle: {
                normal: {
                    label: { show: false },
                    lineStyle: {
                        width: 2,
                        type: &#x27;solid&#x27;
                    }
                },
                emphasis: { label: { show: false } }
            },
            symbolSize: 2
        },
        pie: {
            clickable: true,
            legendHoverLink: true,
            center: [
                &#x27;50%&#x27;,
                &#x27;50%&#x27;
            ],
            radius: [
                0,
                &#x27;75%&#x27;
            ],
            clockWise: true,
            startAngle: 90,
            minAngle: 0,
            selectedOffset: 10,
            itemStyle: {
                normal: {
                    borderColor: &#x27;rgba(0,0,0,0)&#x27;,
                    borderWidth: 1,
                    label: {
                        show: true,
                        position: &#x27;outer&#x27;
                    },
                    labelLine: {
                        show: true,
                        length: 20,
                        lineStyle: {
                            width: 1,
                            type: &#x27;solid&#x27;
                        }
                    }
                },
                emphasis: {
                    borderColor: &#x27;rgba(0,0,0,0)&#x27;,
                    borderWidth: 1,
                    label: { show: false },
                    labelLine: {
                        show: false,
                        length: 20,
                        lineStyle: {
                            width: 1,
                            type: &#x27;solid&#x27;
                        }
                    }
                }
            }
        },
        map: {
            mapType: &#x27;china&#x27;,
            mapValuePrecision: 0,
            showLegendSymbol: true,
            dataRangeHoverLink: true,
            hoverable: true,
            clickable: true,
            itemStyle: {
                normal: {
                    borderColor: &#x27;rgba(0,0,0,0)&#x27;,
                    borderWidth: 1,
                    areaStyle: { color: &#x27;#ccc&#x27; },
                    label: {
                        show: false,
                        textStyle: { color: &#x27;rgb(139,69,19)&#x27; }
                    }
                },
                emphasis: {
                    borderColor: &#x27;rgba(0,0,0,0)&#x27;,
                    borderWidth: 1,
                    areaStyle: { color: &#x27;rgba(255,215,0,0.8)&#x27; },
                    label: {
                        show: false,
                        textStyle: { color: &#x27;rgb(100,0,0)&#x27; }
                    }
                }
            }
        },
        force: {
            center: [
                &#x27;50%&#x27;,
                &#x27;50%&#x27;
            ],
            size: &#x27;100%&#x27;,
            preventOverlap: false,
            coolDown: 0.99,
            minRadius: 10,
            maxRadius: 20,
            ratioScaling: false,
            large: false,
            useWorker: false,
            steps: 1,
            scaling: 1,
            gravity: 1,
            symbol: &#x27;circle&#x27;,
            symbolSize: 0,
            linkSymbol: null,
            linkSymbolSize: [
                10,
                15
            ],
            draggable: true,
            clickable: true,
            roam: false,
            itemStyle: {
                normal: {
                    label: {
                        show: false,
                        position: &#x27;inside&#x27;
                    },
                    nodeStyle: {
                        brushType: &#x27;both&#x27;,
                        borderColor: &#x27;#5182ab&#x27;,
                        borderWidth: 1
                    },
                    linkStyle: {
                        color: &#x27;#5182ab&#x27;,
                        width: 1,
                        type: &#x27;line&#x27;
                    }
                },
                emphasis: {
                    label: { show: false },
                    nodeStyle: {},
                    linkStyle: { opacity: 0 }
                }
            }
        },
        chord: {
            clickable: true,
            radius: [
                &#x27;65%&#x27;,
                &#x27;75%&#x27;
            ],
            center: [
                &#x27;50%&#x27;,
                &#x27;50%&#x27;
            ],
            padding: 2,
            sort: &#x27;none&#x27;,
            sortSub: &#x27;none&#x27;,
            startAngle: 90,
            clockWise: true,
            ribbonType: true,
            minRadius: 10,
            maxRadius: 20,
            symbol: &#x27;circle&#x27;,
            showScale: false,
            showScaleText: false,
            itemStyle: {
                normal: {
                    borderWidth: 0,
                    borderColor: &#x27;#000&#x27;,
                    label: {
                        show: true,
                        rotate: false,
                        distance: 5
                    },
                    chordStyle: {
                        width: 1,
                        color: &#x27;black&#x27;,
                        borderWidth: 1,
                        borderColor: &#x27;#999&#x27;,
                        opacity: 0.5
                    }
                },
                emphasis: {
                    borderWidth: 0,
                    borderColor: &#x27;#000&#x27;,
                    chordStyle: {
                        width: 1,
                        color: &#x27;black&#x27;,
                        borderWidth: 1,
                        borderColor: &#x27;#999&#x27;
                    }
                }
            }
        },
        gauge: {
            center: [
                &#x27;50%&#x27;,
                &#x27;50%&#x27;
            ],
            legendHoverLink: true,
            radius: &#x27;75%&#x27;,
            startAngle: 225,
            endAngle: -45,
            min: 0,
            max: 100,
            precision: 0,
            splitNumber: 10,
            axisLine: {
                show: true,
                lineStyle: {
                    color: [
                        [
                            0.2,
                            &#x27;#228b22&#x27;
                        ],
                        [
                            0.8,
                            &#x27;#48b&#x27;
                        ],
                        [
                            1,
                            &#x27;#ff4500&#x27;
                        ]
                    ],
                    width: 30
                }
            },
            axisTick: {
                show: true,
                splitNumber: 5,
                length: 8,
                lineStyle: {
                    color: &#x27;#eee&#x27;,
                    width: 1,
                    type: &#x27;solid&#x27;
                }
            },
            axisLabel: {
                show: true,
                textStyle: { color: &#x27;auto&#x27; }
            },
            splitLine: {
                show: true,
                length: 30,
                lineStyle: {
                    color: &#x27;#eee&#x27;,
                    width: 2,
                    type: &#x27;solid&#x27;
                }
            },
            pointer: {
                show: true,
                length: &#x27;80%&#x27;,
                width: 8,
                color: &#x27;auto&#x27;
            },
            title: {
                show: true,
                offsetCenter: [
                    0,
                    &#x27;-40%&#x27;
                ],
                textStyle: {
                    color: &#x27;#333&#x27;,
                    fontSize: 15
                }
            },
            detail: {
                show: true,
                backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,
                borderWidth: 0,
                borderColor: &#x27;#ccc&#x27;,
                width: 100,
                height: 40,
                offsetCenter: [
                    0,
                    &#x27;40%&#x27;
                ],
                textStyle: {
                    color: &#x27;auto&#x27;,
                    fontSize: 30
                }
            }
        },
        funnel: {
            clickable: true,
            legendHoverLink: true,
            x: 80,
            y: 60,
            x2: 80,
            y2: 60,
            min: 0,
            max: 100,
            minSize: &#x27;0%&#x27;,
            maxSize: &#x27;100%&#x27;,
            sort: &#x27;descending&#x27;,
            gap: 0,
            funnelAlign: &#x27;center&#x27;,
            itemStyle: {
                normal: {
                    borderColor: &#x27;#fff&#x27;,
                    borderWidth: 1,
                    label: {
                        show: true,
                        position: &#x27;outer&#x27;
                    },
                    labelLine: {
                        show: true,
                        length: 10,
                        lineStyle: {
                            width: 1,
                            type: &#x27;solid&#x27;
                        }
                    }
                },
                emphasis: {
                    borderColor: &#x27;rgba(0,0,0,0)&#x27;,
                    borderWidth: 1,
                    label: { show: true },
                    labelLine: { show: true }
                }
            }
        },
        eventRiver: {
            clickable: true,
            legendHoverLink: true,
            itemStyle: {
                normal: {
                    borderColor: &#x27;rgba(0,0,0,0)&#x27;,
                    borderWidth: 1,
                    label: {
                        show: true,
                        position: &#x27;inside&#x27;,
                        formatter: &#x27;{b}&#x27;
                    }
                },
                emphasis: {
                    borderColor: &#x27;rgba(0,0,0,0)&#x27;,
                    borderWidth: 1,
                    label: { show: true }
                }
            }
        },
        island: {
            r: 15,
            calculateStep: 0.1
        },
        markPoint: {
            clickable: true,
            symbol: &#x27;pin&#x27;,
            symbolSize: 10,
            large: false,
            effect: {
                show: false,
                loop: true,
                period: 15,
                scaleSize: 2
            },
            itemStyle: {
                normal: {
                    borderWidth: 2,
                    label: {
                        show: true,
                        position: &#x27;inside&#x27;
                    }
                },
                emphasis: { label: { show: true } }
            }
        },
        markLine: {
            clickable: true,
            symbol: [
                &#x27;circle&#x27;,
                &#x27;arrow&#x27;
            ],
            symbolSize: [
                2,
                4
            ],
            large: false,
            effect: {
                show: false,
                loop: true,
                period: 15,
                scaleSize: 2
            },
            itemStyle: {
                normal: {
                    borderWidth: 1.5,
                    label: {
                        show: true,
                        position: &#x27;end&#x27;
                    },
                    lineStyle: { type: &#x27;dashed&#x27; }
                },
                emphasis: {
                    label: { show: false },
                    lineStyle: {}
                }
            }
        },
        textStyle: {
            decoration: &#x27;none&#x27;,
            fontFamily: &#x27;Arial, Verdana, sans-serif&#x27;,
            fontFamily2: &#x27;微软雅黑&#x27;,
            fontSize: 12,
            fontStyle: &#x27;normal&#x27;,
            fontWeight: &#x27;normal&#x27;
        },
        EVENT: {
            REFRESH: &#x27;refresh&#x27;,
            RESTORE: &#x27;restore&#x27;,
            RESIZE: &#x27;resize&#x27;,
            CLICK: &#x27;click&#x27;,
            DBLCLICK: &#x27;dblclick&#x27;,
            HOVER: &#x27;hover&#x27;,
            MOUSEOUT: &#x27;mouseout&#x27;,
            DATA_CHANGED: &#x27;dataChanged&#x27;,
            DATA_ZOOM: &#x27;dataZoom&#x27;,
            DATA_RANGE: &#x27;dataRange&#x27;,
            DATA_RANGE_HOVERLINK: &#x27;dataRangeHoverLink&#x27;,
            LEGEND_SELECTED: &#x27;legendSelected&#x27;,
            LEGEND_HOVERLINK: &#x27;legendHoverLink&#x27;,
            MAP_SELECTED: &#x27;mapSelected&#x27;,
            PIE_SELECTED: &#x27;pieSelected&#x27;,
            MAGIC_TYPE_CHANGED: &#x27;magicTypeChanged&#x27;,
            DATA_VIEW_CHANGED: &#x27;dataViewChanged&#x27;,
            TIMELINE_CHANGED: &#x27;timelineChanged&#x27;,
            MAP_ROAM: &#x27;mapRoam&#x27;,
            FORCE_LAYOUT_END: &#x27;forceLayoutEnd&#x27;,
            TOOLTIP_HOVER: &#x27;tooltipHover&#x27;,
            TOOLTIP_IN_GRID: &#x27;tooltipInGrid&#x27;,
            TOOLTIP_OUT_GRID: &#x27;tooltipOutGrid&#x27;,
            ROAMCONTROLLER: &#x27;roamController&#x27;
        },
        DRAG_ENABLE_TIME: 120,
        EFFECT_ZLEVEL: 7,
        symbolList: [
            &#x27;circle&#x27;,
            &#x27;rectangle&#x27;,
            &#x27;triangle&#x27;,
            &#x27;diamond&#x27;,
            &#x27;emptyCircle&#x27;,
            &#x27;emptyRectangle&#x27;,
            &#x27;emptyTriangle&#x27;,
            &#x27;emptyDiamond&#x27;
        ],
        loadingText: &#x27;Loading...&#x27;,
        calculable: false,
        calculableColor: &#x27;rgba(255,165,0,0.6)&#x27;,
        calculableHolderColor: &#x27;#ccc&#x27;,
        nameConnector: &#x27; &amp; &#x27;,
        valueConnector: &#x27;: &#x27;,
        animation: true,
        addDataAnimation: true,
        animationThreshold: 2000,
        animationDuration: 2000,
        animationEasing: &#x27;ExponentialOut&#x27;
    };
    return config;
});define(&#x27;zrender/tool/util&#x27;, [
    &#x27;require&#x27;,
    &#x27;../dep/excanvas&#x27;
], function (require) {
    var BUILTIN_OBJECT = {
        &#x27;[object Function]&#x27;: 1,
        &#x27;[object RegExp]&#x27;: 1,
        &#x27;[object Date]&#x27;: 1,
        &#x27;[object Error]&#x27;: 1,
        &#x27;[object CanvasGradient]&#x27;: 1
    };
    function clone(source) {
        if (typeof source == &#x27;object&#x27; &amp;&amp; source !== null) {
            var result = source;
            if (source instanceof Array) {
                result = [];
                for (var i = 0, len = source.length; i &lt; len; i++) {
                    result[i] = clone(source[i]);
                }
            } else if (!BUILTIN_OBJECT[Object.prototype.toString.call(source)]) {
                result = {};
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        result[key] = clone(source[key]);
                    }
                }
            }
            return result;
        }
        return source;
    }
    function mergeItem(target, source, key, overwrite) {
        if (source.hasOwnProperty(key)) {
            if (typeof target[key] == &#x27;object&#x27; &amp;&amp; !BUILTIN_OBJECT[Object.prototype.toString.call(target[key])]) {
                merge(target[key], source[key], overwrite);
            } else if (overwrite || !(key in target)) {
                target[key] = source[key];
            }
        }
    }
    function merge(target, source, overwrite) {
        for (var i in source) {
            mergeItem(target, source, i, overwrite);
        }
        return target;
    }
    var _ctx;
    function getContext() {
        if (!_ctx) {
            require(&#x27;../dep/excanvas&#x27;);
            if (window[&#x27;G_vmlCanvasManager&#x27;]) {
                var _div = document.createElement(&#x27;div&#x27;);
                _div.style.position = &#x27;absolute&#x27;;
                _div.style.top = &#x27;-1000px&#x27;;
                document.body.appendChild(_div);
                _ctx = G_vmlCanvasManager.initElement(_div).getContext(&#x27;2d&#x27;);
            } else {
                _ctx = document.createElement(&#x27;canvas&#x27;).getContext(&#x27;2d&#x27;);
            }
        }
        return _ctx;
    }
    var _canvas;
    var _pixelCtx;
    var _width;
    var _height;
    var _offsetX = 0;
    var _offsetY = 0;
    function getPixelContext() {
        if (!_pixelCtx) {
            _canvas = document.createElement(&#x27;canvas&#x27;);
            _width = _canvas.width;
            _height = _canvas.height;
            _pixelCtx = _canvas.getContext(&#x27;2d&#x27;);
        }
        return _pixelCtx;
    }
    function adjustCanvasSize(x, y) {
        var _v = 100;
        var _flag;
        if (x + _offsetX &gt; _width) {
            _width = x + _offsetX + _v;
            _canvas.width = _width;
            _flag = true;
        }
        if (y + _offsetY &gt; _height) {
            _height = y + _offsetY + _v;
            _canvas.height = _height;
            _flag = true;
        }
        if (x &lt; -_offsetX) {
            _offsetX = Math.ceil(-x / _v) * _v;
            _width += _offsetX;
            _canvas.width = _width;
            _flag = true;
        }
        if (y &lt; -_offsetY) {
            _offsetY = Math.ceil(-y / _v) * _v;
            _height += _offsetY;
            _canvas.height = _height;
            _flag = true;
        }
        if (_flag) {
            _pixelCtx.translate(_offsetX, _offsetY);
        }
    }
    function getPixelOffset() {
        return {
            x: _offsetX,
            y: _offsetY
        };
    }
    function indexOf(array, value) {
        if (array.indexOf) {
            return array.indexOf(value);
        }
        for (var i = 0, len = array.length; i &lt; len; i++) {
            if (array[i] === value) {
                return i;
            }
        }
        return -1;
    }
    function inherits(clazz, baseClazz) {
        var clazzPrototype = clazz.prototype;
        function F() {
        }
        F.prototype = baseClazz.prototype;
        clazz.prototype = new F();
        for (var prop in clazzPrototype) {
            clazz.prototype[prop] = clazzPrototype[prop];
        }
        clazz.constructor = clazz;
    }
    return {
        inherits: inherits,
        clone: clone,
        merge: merge,
        getContext: getContext,
        getPixelContext: getPixelContext,
        getPixelOffset: getPixelOffset,
        adjustCanvasSize: adjustCanvasSize,
        indexOf: indexOf
    };
});define(&#x27;zrender/tool/event&#x27;, [
    &#x27;require&#x27;,
    &#x27;../mixin/Eventful&#x27;
], function (require) {
    &#x27;use strict&#x27;;
    var Eventful = require(&#x27;../mixin/Eventful&#x27;);
    function getX(e) {
        return typeof e.zrenderX != &#x27;undefined&#x27; &amp;&amp; e.zrenderX || typeof e.offsetX != &#x27;undefined&#x27; &amp;&amp; e.offsetX || typeof e.layerX != &#x27;undefined&#x27; &amp;&amp; e.layerX || typeof e.clientX != &#x27;undefined&#x27; &amp;&amp; e.clientX;
    }
    function getY(e) {
        return typeof e.zrenderY != &#x27;undefined&#x27; &amp;&amp; e.zrenderY || typeof e.offsetY != &#x27;undefined&#x27; &amp;&amp; e.offsetY || typeof e.layerY != &#x27;undefined&#x27; &amp;&amp; e.layerY || typeof e.clientY != &#x27;undefined&#x27; &amp;&amp; e.clientY;
    }
    function getDelta(e) {
        return typeof e.zrenderDelta != &#x27;undefined&#x27; &amp;&amp; e.zrenderDelta || typeof e.wheelDelta != &#x27;undefined&#x27; &amp;&amp; e.wheelDelta || typeof e.detail != &#x27;undefined&#x27; &amp;&amp; -e.detail;
    }
    var stop = typeof window.addEventListener === &#x27;function&#x27; ? function (e) {
        e.preventDefault();
        e.stopPropagation();
        e.cancelBubble = true;
    } : function (e) {
        e.returnValue = false;
        e.cancelBubble = true;
    };
    return {
        getX: getX,
        getY: getY,
        getDelta: getDelta,
        stop: stop,
        Dispatcher: Eventful
    };
});define(&#x27;zrender/tool/env&#x27;, [], function () {
    function detect(ua) {
        var os = this.os = {};
        var browser = this.browser = {};
        var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
        var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
        var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
        var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
        var iphone = !ipad &amp;&amp; ua.match(/(iPhone\sOS)\s([\d_]+)/);
        var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
        var touchpad = webos &amp;&amp; ua.match(/TouchPad/);
        var kindle = ua.match(/Kindle\/([\d.]+)/);
        var silk = ua.match(/Silk\/([\d._]+)/);
        var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
        var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
        var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
        var playbook = ua.match(/PlayBook/);
        var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
        var firefox = ua.match(/Firefox\/([\d.]+)/);
        var ie = ua.match(/MSIE ([\d.]+)/);
        var safari = webkit &amp;&amp; ua.match(/Mobile\//) &amp;&amp; !chrome;
        var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) &amp;&amp; !chrome;
        var ie = ua.match(/MSIE\s([\d.]+)/);
        if (browser.webkit = !!webkit)
            browser.version = webkit[1];
        if (android)
            os.android = true, os.version = android[2];
        if (iphone &amp;&amp; !ipod)
            os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, &#x27;.&#x27;);
        if (ipad)
            os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, &#x27;.&#x27;);
        if (ipod)
            os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, &#x27;.&#x27;) : null;
        if (webos)
            os.webos = true, os.version = webos[2];
        if (touchpad)
            os.touchpad = true;
        if (blackberry)
            os.blackberry = true, os.version = blackberry[2];
        if (bb10)
            os.bb10 = true, os.version = bb10[2];
        if (rimtabletos)
            os.rimtabletos = true, os.version = rimtabletos[2];
        if (playbook)
            browser.playbook = true;
        if (kindle)
            os.kindle = true, os.version = kindle[1];
        if (silk)
            browser.silk = true, browser.version = silk[1];
        if (!silk &amp;&amp; os.android &amp;&amp; ua.match(/Kindle Fire/))
            browser.silk = true;
        if (chrome)
            browser.chrome = true, browser.version = chrome[1];
        if (firefox)
            browser.firefox = true, browser.version = firefox[1];
        if (ie)
            browser.ie = true, browser.version = ie[1];
        if (safari &amp;&amp; (ua.match(/Safari/) || !!os.ios))
            browser.safari = true;
        if (webview)
            browser.webview = true;
        if (ie)
            browser.ie = true, browser.version = ie[1];
        os.tablet = !!(ipad || playbook || android &amp;&amp; !ua.match(/Mobile/) || firefox &amp;&amp; ua.match(/Tablet/) || ie &amp;&amp; !ua.match(/Phone/) &amp;&amp; ua.match(/Touch/));
        os.phone = !!(!os.tablet &amp;&amp; !os.ipod &amp;&amp; (android || iphone || webos || blackberry || bb10 || chrome &amp;&amp; ua.match(/Android/) || chrome &amp;&amp; ua.match(/CriOS\/([\d.]+)/) || firefox &amp;&amp; ua.match(/Mobile/) || ie &amp;&amp; ua.match(/Touch/)));
        return {
            browser: browser,
            os: os,
            canvasSupported: document.createElement(&#x27;canvas&#x27;).getContext ? true : false
        };
    }
    return detect(navigator.userAgent);
});define(&#x27;zrender&#x27;, [&#x27;zrender/zrender&#x27;], function (main) {return main;});
define(&#x27;zrender/zrender&#x27;, [
    &#x27;require&#x27;,
    &#x27;./dep/excanvas&#x27;,
    &#x27;./tool/util&#x27;,
    &#x27;./tool/log&#x27;,
    &#x27;./tool/guid&#x27;,
    &#x27;./Handler&#x27;,
    &#x27;./Painter&#x27;,
    &#x27;./Storage&#x27;,
    &#x27;./animation/Animation&#x27;,
    &#x27;./tool/env&#x27;
], function (require) {
    require(&#x27;./dep/excanvas&#x27;);
    var util = require(&#x27;./tool/util&#x27;);
    var log = require(&#x27;./tool/log&#x27;);
    var guid = require(&#x27;./tool/guid&#x27;);
    var Handler = require(&#x27;./Handler&#x27;);
    var Painter = require(&#x27;./Painter&#x27;);
    var Storage = require(&#x27;./Storage&#x27;);
    var Animation = require(&#x27;./animation/Animation&#x27;);
    var _instances = {};
    var zrender = {};
    zrender.version = &#x27;2.0.6&#x27;;
    zrender.init = function (dom) {
        var zr = new ZRender(guid(), dom);
        _instances[zr.id] = zr;
        return zr;
    };
    zrender.dispose = function (zr) {
        if (zr) {
            zr.dispose();
        } else {
            for (var key in _instances) {
                _instances[key].dispose();
            }
            _instances = {};
        }
        return zrender;
    };
    zrender.getInstance = function (id) {
        return _instances[id];
    };
    zrender.delInstance = function (id) {
        delete _instances[id];
        return zrender;
    };
    function getFrameCallback(zrInstance) {
        return function () {
            var animatingElements = zrInstance.animatingElements;
            for (var i = 0, l = animatingElements.length; i &lt; l; i++) {
                zrInstance.storage.mod(animatingElements[i].id);
            }
            if (animatingElements.length || zrInstance._needsRefreshNextFrame) {
                zrInstance.refresh();
            }
        };
    }
    var ZRender = function (id, dom) {
        this.id = id;
        this.env = require(&#x27;./tool/env&#x27;);
        this.storage = new Storage();
        this.painter = new Painter(dom, this.storage);
        this.handler = new Handler(dom, this.storage, this.painter);
        this.animatingElements = [];
        this.animation = new Animation({ stage: { update: getFrameCallback(this) } });
        this.animation.start();
        var self = this;
        this.painter.refreshNextFrame = function () {
            self.refreshNextFrame();
        };
        this._needsRefreshNextFrame = false;
    };
    ZRender.prototype.getId = function () {
        return this.id;
    };
    ZRender.prototype.addShape = function (shape) {
        this.storage.addRoot(shape);
        return this;
    };
    ZRender.prototype.addGroup = function (group) {
        this.storage.addRoot(group);
        return this;
    };
    ZRender.prototype.delShape = function (shapeId) {
        this.storage.delRoot(shapeId);
        return this;
    };
    ZRender.prototype.delGroup = function (groupId) {
        this.storage.delRoot(groupId);
        return this;
    };
    ZRender.prototype.modShape = function (shapeId, shape) {
        this.storage.mod(shapeId, shape);
        return this;
    };
    ZRender.prototype.modGroup = function (groupId, group) {
        this.storage.mod(groupId, group);
        return this;
    };
    ZRender.prototype.modLayer = function (zLevel, config) {
        this.painter.modLayer(zLevel, config);
        return this;
    };
    ZRender.prototype.addHoverShape = function (shape) {
        this.storage.addHover(shape);
        return this;
    };
    ZRender.prototype.render = function (callback) {
        this.painter.render(callback);
        this._needsRefreshNextFrame = false;
        return this;
    };
    ZRender.prototype.refresh = function (callback) {
        this.painter.refresh(callback);
        this._needsRefreshNextFrame = false;
        return this;
    };
    ZRender.prototype.refreshNextFrame = function () {
        this._needsRefreshNextFrame = true;
        return this;
    };
    ZRender.prototype.refreshHover = function (callback) {
        this.painter.refreshHover(callback);
        return this;
    };
    ZRender.prototype.refreshShapes = function (shapeList, callback) {
        this.painter.refreshShapes(shapeList, callback);
        return this;
    };
    ZRender.prototype.resize = function () {
        this.painter.resize();
        return this;
    };
    ZRender.prototype.animate = function (el, path, loop) {
        if (typeof el === &#x27;string&#x27;) {
            el = this.storage.get(el);
        }
        if (el) {
            var target;
            if (path) {
                var pathSplitted = path.split(&#x27;.&#x27;);
                var prop = el;
                for (var i = 0, l = pathSplitted.length; i &lt; l; i++) {
                    if (!prop) {
                        continue;
                    }
                    prop = prop[pathSplitted[i]];
                }
                if (prop) {
                    target = prop;
                }
            } else {
                target = el;
            }
            if (!target) {
                log(&#x27;Property &quot;&#x27; + path + &#x27;&quot; is not existed in element &#x27; + el.id);
                return;
            }
            var animatingElements = this.animatingElements;
            if (typeof el.__aniCount === &#x27;undefined&#x27;) {
                el.__aniCount = 0;
            }
            if (el.__aniCount === 0) {
                animatingElements.push(el);
            }
            el.__aniCount++;
            return this.animation.animate(target, { loop: loop }).done(function () {
                el.__aniCount--;
                if (el.__aniCount === 0) {
                    var idx = util.indexOf(animatingElements, el);
                    animatingElements.splice(idx, 1);
                }
            });
        } else {
            log(&#x27;Element not existed&#x27;);
        }
    };
    ZRender.prototype.clearAnimation = function () {
        this.animation.clear();
    };
    ZRender.prototype.showLoading = function (loadingEffect) {
        this.painter.showLoading(loadingEffect);
        return this;
    };
    ZRender.prototype.hideLoading = function () {
        this.painter.hideLoading();
        return this;
    };
    ZRender.prototype.getWidth = function () {
        return this.painter.getWidth();
    };
    ZRender.prototype.getHeight = function () {
        return this.painter.getHeight();
    };
    ZRender.prototype.toDataURL = function (type, backgroundColor, args) {
        return this.painter.toDataURL(type, backgroundColor, args);
    };
    ZRender.prototype.shapeToImage = function (e, width, height) {
        var id = guid();
        return this.painter.shapeToImage(id, e, width, height);
    };
    ZRender.prototype.on = function (eventName, eventHandler) {
        this.handler.on(eventName, eventHandler);
        return this;
    };
    ZRender.prototype.un = function (eventName, eventHandler) {
        this.handler.un(eventName, eventHandler);
        return this;
    };
    ZRender.prototype.trigger = function (eventName, event) {
        this.handler.trigger(eventName, event);
        return this;
    };
    ZRender.prototype.clear = function () {
        this.storage.delRoot();
        this.painter.clear();
        return this;
    };
    ZRender.prototype.dispose = function () {
        this.animation.stop();
        this.clear();
        this.storage.dispose();
        this.painter.dispose();
        this.handler.dispose();
        this.animation = this.animatingElements = this.storage = this.painter = this.handler = null;
        zrender.delInstance(this.id);
    };
    return zrender;
});define(&#x27;zrender/config&#x27;, [], function () {
    var config = {
        EVENT: {
            RESIZE: &#x27;resize&#x27;,
            CLICK: &#x27;click&#x27;,
            DBLCLICK: &#x27;dblclick&#x27;,
            MOUSEWHEEL: &#x27;mousewheel&#x27;,
            MOUSEMOVE: &#x27;mousemove&#x27;,
            MOUSEOVER: &#x27;mouseover&#x27;,
            MOUSEOUT: &#x27;mouseout&#x27;,
            MOUSEDOWN: &#x27;mousedown&#x27;,
            MOUSEUP: &#x27;mouseup&#x27;,
            GLOBALOUT: &#x27;globalout&#x27;,
            DRAGSTART: &#x27;dragstart&#x27;,
            DRAGEND: &#x27;dragend&#x27;,
            DRAGENTER: &#x27;dragenter&#x27;,
            DRAGOVER: &#x27;dragover&#x27;,
            DRAGLEAVE: &#x27;dragleave&#x27;,
            DROP: &#x27;drop&#x27;,
            touchClickDelay: 300
        },
        catchBrushException: false,
        debugMode: 0
    };
    return config;
});define(&#x27;echarts/chart/island&#x27;, [
    &#x27;require&#x27;,
    &#x27;../component/base&#x27;,
    &#x27;./base&#x27;,
    &#x27;zrender/shape/Circle&#x27;,
    &#x27;../config&#x27;,
    &#x27;../util/ecData&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;zrender/tool/event&#x27;,
    &#x27;zrender/tool/color&#x27;,
    &#x27;../util/accMath&#x27;,
    &#x27;../chart&#x27;
], function (require) {
    var ComponentBase = require(&#x27;../component/base&#x27;);
    var ChartBase = require(&#x27;./base&#x27;);
    var CircleShape = require(&#x27;zrender/shape/Circle&#x27;);
    var ecConfig = require(&#x27;../config&#x27;);
    var ecData = require(&#x27;../util/ecData&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    var zrEvent = require(&#x27;zrender/tool/event&#x27;);
    function Island(ecTheme, messageCenter, zr, option, myChart) {
        ComponentBase.call(this, ecTheme, messageCenter, zr, {}, myChart);
        ChartBase.call(this);
        this._nameConnector;
        this._valueConnector;
        this._zrHeight = this.zr.getHeight();
        this._zrWidth = this.zr.getWidth();
        var self = this;
        self.shapeHandler.onmousewheel = function (param) {
            var shape = param.target;
            var event = param.event;
            var delta = zrEvent.getDelta(event);
            delta = delta &gt; 0 ? -1 : 1;
            shape.style.r -= delta;
            shape.style.r = shape.style.r &lt; 5 ? 5 : shape.style.r;
            var value = ecData.get(shape, &#x27;value&#x27;);
            var dvalue = value * self.option.island.calculateStep;
            if (dvalue &gt; 1) {
                value = Math.round(value - dvalue * delta);
            } else {
                value = (value - dvalue * delta).toFixed(2) - 0;
            }
            var name = ecData.get(shape, &#x27;name&#x27;);
            shape.style.text = name + &#x27;:&#x27; + value;
            ecData.set(shape, &#x27;value&#x27;, value);
            ecData.set(shape, &#x27;name&#x27;, name);
            self.zr.modShape(shape.id);
            self.zr.refresh();
            zrEvent.stop(event);
        };
    }
    Island.prototype = {
        type: ecConfig.CHART_TYPE_ISLAND,
        _combine: function (tarShape, srcShape) {
            var zrColor = require(&#x27;zrender/tool/color&#x27;);
            var accMath = require(&#x27;../util/accMath&#x27;);
            var value = accMath.accAdd(ecData.get(tarShape, &#x27;value&#x27;), ecData.get(srcShape, &#x27;value&#x27;));
            var name = ecData.get(tarShape, &#x27;name&#x27;) + this._nameConnector + ecData.get(srcShape, &#x27;name&#x27;);
            tarShape.style.text = name + this._valueConnector + value;
            ecData.set(tarShape, &#x27;value&#x27;, value);
            ecData.set(tarShape, &#x27;name&#x27;, name);
            tarShape.style.r = this.option.island.r;
            tarShape.style.color = zrColor.mix(tarShape.style.color, srcShape.style.color);
        },
        refresh: function (newOption) {
            if (newOption) {
                newOption.island = this.reformOption(newOption.island);
                this.option = newOption;
                this._nameConnector = this.option.nameConnector;
                this._valueConnector = this.option.valueConnector;
            }
        },
        getOption: function () {
            return this.option;
        },
        resize: function () {
            var newWidth = this.zr.getWidth();
            var newHieght = this.zr.getHeight();
            var xScale = newWidth / (this._zrWidth || newWidth);
            var yScale = newHieght / (this._zrHeight || newHieght);
            if (xScale === 1 &amp;&amp; yScale === 1) {
                return;
            }
            this._zrWidth = newWidth;
            this._zrHeight = newHieght;
            for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                this.zr.modShape(this.shapeList[i].id, {
                    style: {
                        x: Math.round(this.shapeList[i].style.x * xScale),
                        y: Math.round(this.shapeList[i].style.y * yScale)
                    }
                });
            }
        },
        add: function (shape) {
            var name = ecData.get(shape, &#x27;name&#x27;);
            var value = ecData.get(shape, &#x27;value&#x27;);
            var seriesName = ecData.get(shape, &#x27;series&#x27;) != null ? ecData.get(shape, &#x27;series&#x27;).name : &#x27;&#x27;;
            var font = this.getFont(this.option.island.textStyle);
            var islandShape = {
                zlevel: this._zlevelBase,
                style: {
                    x: shape.style.x,
                    y: shape.style.y,
                    r: this.option.island.r,
                    color: shape.style.color || shape.style.strokeColor,
                    text: name + this._valueConnector + value,
                    textFont: font
                },
                draggable: true,
                hoverable: true,
                onmousewheel: this.shapeHandler.onmousewheel,
                _type: &#x27;island&#x27;
            };
            if (islandShape.style.color === &#x27;#fff&#x27;) {
                islandShape.style.color = shape.style.strokeColor;
            }
            this.setCalculable(islandShape);
            islandShape.dragEnableTime = 0;
            ecData.pack(islandShape, { name: seriesName }, -1, value, -1, name);
            islandShape = new CircleShape(islandShape);
            this.shapeList.push(islandShape);
            this.zr.addShape(islandShape);
        },
        del: function (shape) {
            this.zr.delShape(shape.id);
            var newShapeList = [];
            for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                if (this.shapeList[i].id != shape.id) {
                    newShapeList.push(this.shapeList[i]);
                }
            }
            this.shapeList = newShapeList;
        },
        ondrop: function (param, status) {
            if (!this.isDrop || !param.target) {
                return;
            }
            var target = param.target;
            var dragged = param.dragged;
            this._combine(target, dragged);
            this.zr.modShape(target.id);
            status.dragIn = true;
            this.isDrop = false;
            return;
        },
        ondragend: function (param, status) {
            var target = param.target;
            if (!this.isDragend) {
                if (!status.dragIn) {
                    target.style.x = zrEvent.getX(param.event);
                    target.style.y = zrEvent.getY(param.event);
                    this.add(target);
                    status.needRefresh = true;
                }
            } else {
                if (status.dragIn) {
                    this.del(target);
                    status.needRefresh = true;
                }
            }
            this.isDragend = false;
            return;
        }
    };
    zrUtil.inherits(Island, ChartBase);
    zrUtil.inherits(Island, ComponentBase);
    require(&#x27;../chart&#x27;).define(&#x27;island&#x27;, Island);
    return Island;
});define(&#x27;echarts/component/toolbox&#x27;, [
    &#x27;require&#x27;,
    &#x27;./base&#x27;,
    &#x27;zrender/shape/Line&#x27;,
    &#x27;zrender/shape/Image&#x27;,
    &#x27;zrender/shape/Rectangle&#x27;,
    &#x27;../util/shape/Icon&#x27;,
    &#x27;../config&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;zrender/config&#x27;,
    &#x27;zrender/tool/event&#x27;,
    &#x27;./dataView&#x27;,
    &#x27;../component&#x27;
], function (require) {
    var Base = require(&#x27;./base&#x27;);
    var LineShape = require(&#x27;zrender/shape/Line&#x27;);
    var ImageShape = require(&#x27;zrender/shape/Image&#x27;);
    var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
    var IconShape = require(&#x27;../util/shape/Icon&#x27;);
    var ecConfig = require(&#x27;../config&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    var zrConfig = require(&#x27;zrender/config&#x27;);
    var zrEvent = require(&#x27;zrender/tool/event&#x27;);
    var _MAGICTYPE_STACK = &#x27;stack&#x27;;
    var _MAGICTYPE_TILED = &#x27;tiled&#x27;;
    function Toolbox(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.dom = myChart.dom;
        this._magicType = {};
        this._magicMap = {};
        this._isSilence = false;
        this._iconList;
        this._iconShapeMap = {};
        this._featureTitle = {};
        this._featureIcon = {};
        this._featureColor = {};
        this._featureOption = {};
        this._enableColor = &#x27;red&#x27;;
        this._disableColor = &#x27;#ccc&#x27;;
        this._markShapeList = [];
        var self = this;
        self._onMark = function (param) {
            self.__onMark(param);
        };
        self._onMarkUndo = function (param) {
            self.__onMarkUndo(param);
        };
        self._onMarkClear = function (param) {
            self.__onMarkClear(param);
        };
        self._onDataZoom = function (param) {
            self.__onDataZoom(param);
        };
        self._onDataZoomReset = function (param) {
            self.__onDataZoomReset(param);
        };
        self._onDataView = function (param) {
            self.__onDataView(param);
        };
        self._onRestore = function (param) {
            self.__onRestore(param);
        };
        self._onSaveAsImage = function (param) {
            self.__onSaveAsImage(param);
        };
        self._onMagicType = function (param) {
            self.__onMagicType(param);
        };
        self._onCustomHandler = function (param) {
            self.__onCustomHandler(param);
        };
        self._onmousemove = function (param) {
            return self.__onmousemove(param);
        };
        self._onmousedown = function (param) {
            return self.__onmousedown(param);
        };
        self._onmouseup = function (param) {
            return self.__onmouseup(param);
        };
        self._onclick = function (param) {
            return self.__onclick(param);
        };
    }
    Toolbox.prototype = {
        type: ecConfig.COMPONENT_TYPE_TOOLBOX,
        _buildShape: function () {
            this._iconList = [];
            var toolboxOption = this.option.toolbox;
            this._enableColor = toolboxOption.effectiveColor;
            this._disableColor = toolboxOption.disableColor;
            var feature = toolboxOption.feature;
            var iconName = [];
            for (var key in feature) {
                if (feature[key].show) {
                    switch (key) {
                    case &#x27;mark&#x27;:
                        iconName.push({
                            key: key,
                            name: &#x27;mark&#x27;
                        });
                        iconName.push({
                            key: key,
                            name: &#x27;markUndo&#x27;
                        });
                        iconName.push({
                            key: key,
                            name: &#x27;markClear&#x27;
                        });
                        break;
                    case &#x27;magicType&#x27;:
                        for (var i = 0, l = feature[key].type.length; i &lt; l; i++) {
                            feature[key].title[feature[key].type[i] + &#x27;Chart&#x27;] = feature[key].title[feature[key].type[i]];
                            if (feature[key].option) {
                                feature[key].option[feature[key].type[i] + &#x27;Chart&#x27;] = feature[key].option[feature[key].type[i]];
                            }
                            iconName.push({
                                key: key,
                                name: feature[key].type[i] + &#x27;Chart&#x27;
                            });
                        }
                        break;
                    case &#x27;dataZoom&#x27;:
                        iconName.push({
                            key: key,
                            name: &#x27;dataZoom&#x27;
                        });
                        iconName.push({
                            key: key,
                            name: &#x27;dataZoomReset&#x27;
                        });
                        break;
                    case &#x27;saveAsImage&#x27;:
                        if (this.canvasSupported) {
                            iconName.push({
                                key: key,
                                name: &#x27;saveAsImage&#x27;
                            });
                        }
                        break;
                    default:
                        iconName.push({
                            key: key,
                            name: key
                        });
                        break;
                    }
                }
            }
            if (iconName.length &gt; 0) {
                var name;
                var key;
                for (var i = 0, l = iconName.length; i &lt; l; i++) {
                    name = iconName[i].name;
                    key = iconName[i].key;
                    this._iconList.push(name);
                    this._featureTitle[name] = feature[key].title[name] || feature[key].title;
                    if (feature[key].icon) {
                        this._featureIcon[name] = feature[key].icon[name] || feature[key].icon;
                    }
                    if (feature[key].color) {
                        this._featureColor[name] = feature[key].color[name] || feature[key].color;
                    }
                    if (feature[key].option) {
                        this._featureOption[name] = feature[key].option[name] || feature[key].option;
                    }
                }
                this._itemGroupLocation = this._getItemGroupLocation();
                this._buildBackground();
                this._buildItem();
                for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                    this.zr.addShape(this.shapeList[i]);
                }
                if (this._iconShapeMap[&#x27;mark&#x27;]) {
                    this._iconDisable(this._iconShapeMap[&#x27;markUndo&#x27;]);
                    this._iconDisable(this._iconShapeMap[&#x27;markClear&#x27;]);
                }
                if (this._iconShapeMap[&#x27;dataZoomReset&#x27;] &amp;&amp; this._zoomQueue.length === 0) {
                    this._iconDisable(this._iconShapeMap[&#x27;dataZoomReset&#x27;]);
                }
            }
        },
        _buildItem: function () {
            var toolboxOption = this.option.toolbox;
            var iconLength = this._iconList.length;
            var lastX = this._itemGroupLocation.x;
            var lastY = this._itemGroupLocation.y;
            var itemSize = toolboxOption.itemSize;
            var itemGap = toolboxOption.itemGap;
            var itemShape;
            var color = toolboxOption.color instanceof Array ? toolboxOption.color : [toolboxOption.color];
            var textFont = this.getFont(toolboxOption.textStyle);
            var textPosition;
            var textAlign;
            var textBaseline;
            if (toolboxOption.orient === &#x27;horizontal&#x27;) {
                textPosition = this._itemGroupLocation.y / this.zr.getHeight() &lt; 0.5 ? &#x27;bottom&#x27; : &#x27;top&#x27;;
                textAlign = this._itemGroupLocation.x / this.zr.getWidth() &lt; 0.5 ? &#x27;left&#x27; : &#x27;right&#x27;;
                textBaseline = this._itemGroupLocation.y / this.zr.getHeight() &lt; 0.5 ? &#x27;top&#x27; : &#x27;bottom&#x27;;
            } else {
                textPosition = this._itemGroupLocation.x / this.zr.getWidth() &lt; 0.5 ? &#x27;right&#x27; : &#x27;left&#x27;;
            }
            this._iconShapeMap = {};
            var self = this;
            for (var i = 0; i &lt; iconLength; i++) {
                itemShape = {
                    type: &#x27;icon&#x27;,
                    zlevel: this._zlevelBase,
                    style: {
                        x: lastX,
                        y: lastY,
                        width: itemSize,
                        height: itemSize,
                        iconType: this._iconList[i],
                        lineWidth: 1,
                        strokeColor: this._featureColor[this._iconList[i]] || color[i % color.length],
                        brushType: &#x27;stroke&#x27;
                    },
                    highlightStyle: {
                        lineWidth: 1,
                        text: toolboxOption.showTitle ? this._featureTitle[this._iconList[i]] : undefined,
                        textFont: textFont,
                        textPosition: textPosition,
                        strokeColor: this._featureColor[this._iconList[i]] || color[i % color.length]
                    },
                    hoverable: true,
                    clickable: true
                };
                if (this._featureIcon[this._iconList[i]]) {
                    itemShape.style.image = this._featureIcon[this._iconList[i]].replace(new RegExp(&#x27;^image:\\/\\/&#x27;), &#x27;&#x27;);
                    itemShape.style.opacity = 0.8;
                    itemShape.highlightStyle.opacity = 1;
                    itemShape.type = &#x27;image&#x27;;
                }
                if (toolboxOption.orient === &#x27;horizontal&#x27;) {
                    if (i === 0 &amp;&amp; textAlign === &#x27;left&#x27;) {
                        itemShape.highlightStyle.textPosition = &#x27;specific&#x27;;
                        itemShape.highlightStyle.textAlign = textAlign;
                        itemShape.highlightStyle.textBaseline = textBaseline;
                        itemShape.highlightStyle.textX = lastX;
                        itemShape.highlightStyle.textY = textBaseline === &#x27;top&#x27; ? lastY + itemSize + 10 : lastY - 10;
                    }
                    if (i === iconLength - 1 &amp;&amp; textAlign === &#x27;right&#x27;) {
                        itemShape.highlightStyle.textPosition = &#x27;specific&#x27;;
                        itemShape.highlightStyle.textAlign = textAlign;
                        itemShape.highlightStyle.textBaseline = textBaseline;
                        itemShape.highlightStyle.textX = lastX + itemSize;
                        itemShape.highlightStyle.textY = textBaseline === &#x27;top&#x27; ? lastY + itemSize + 10 : lastY - 10;
                    }
                }
                switch (this._iconList[i]) {
                case &#x27;mark&#x27;:
                    itemShape.onclick = self._onMark;
                    break;
                case &#x27;markUndo&#x27;:
                    itemShape.onclick = self._onMarkUndo;
                    break;
                case &#x27;markClear&#x27;:
                    itemShape.onclick = self._onMarkClear;
                    break;
                case &#x27;dataZoom&#x27;:
                    itemShape.onclick = self._onDataZoom;
                    break;
                case &#x27;dataZoomReset&#x27;:
                    itemShape.onclick = self._onDataZoomReset;
                    break;
                case &#x27;dataView&#x27;:
                    if (!this._dataView) {
                        var DataView = require(&#x27;./dataView&#x27;);
                        this._dataView = new DataView(this.ecTheme, this.messageCenter, this.zr, this.option, this.myChart);
                    }
                    itemShape.onclick = self._onDataView;
                    break;
                case &#x27;restore&#x27;:
                    itemShape.onclick = self._onRestore;
                    break;
                case &#x27;saveAsImage&#x27;:
                    itemShape.onclick = self._onSaveAsImage;
                    break;
                default:
                    if (this._iconList[i].match(&#x27;Chart&#x27;)) {
                        itemShape._name = this._iconList[i].replace(&#x27;Chart&#x27;, &#x27;&#x27;);
                        itemShape.onclick = self._onMagicType;
                    } else {
                        itemShape.onclick = self._onCustomHandler;
                    }
                    break;
                }
                if (itemShape.type === &#x27;icon&#x27;) {
                    itemShape = new IconShape(itemShape);
                } else if (itemShape.type === &#x27;image&#x27;) {
                    itemShape = new ImageShape(itemShape);
                }
                this.shapeList.push(itemShape);
                this._iconShapeMap[this._iconList[i]] = itemShape;
                if (toolboxOption.orient === &#x27;horizontal&#x27;) {
                    lastX += itemSize + itemGap;
                } else {
                    lastY += itemSize + itemGap;
                }
            }
        },
        _buildBackground: function () {
            var toolboxOption = this.option.toolbox;
            var padding = this.reformCssArray(this.option.toolbox.padding);
            this.shapeList.push(new RectangleShape({
                zlevel: this._zlevelBase,
                hoverable: false,
                style: {
                    x: this._itemGroupLocation.x - padding[3],
                    y: this._itemGroupLocation.y - padding[0],
                    width: this._itemGroupLocation.width + padding[3] + padding[1],
                    height: this._itemGroupLocation.height + padding[0] + padding[2],
                    brushType: toolboxOption.borderWidth === 0 ? &#x27;fill&#x27; : &#x27;both&#x27;,
                    color: toolboxOption.backgroundColor,
                    strokeColor: toolboxOption.borderColor,
                    lineWidth: toolboxOption.borderWidth
                }
            }));
        },
        _getItemGroupLocation: function () {
            var toolboxOption = this.option.toolbox;
            var padding = this.reformCssArray(this.option.toolbox.padding);
            var iconLength = this._iconList.length;
            var itemGap = toolboxOption.itemGap;
            var itemSize = toolboxOption.itemSize;
            var totalWidth = 0;
            var totalHeight = 0;
            if (toolboxOption.orient === &#x27;horizontal&#x27;) {
                totalWidth = (itemSize + itemGap) * iconLength - itemGap;
                totalHeight = itemSize;
            } else {
                totalHeight = (itemSize + itemGap) * iconLength - itemGap;
                totalWidth = itemSize;
            }
            var x;
            var zrWidth = this.zr.getWidth();
            switch (toolboxOption.x) {
            case &#x27;center&#x27;:
                x = Math.floor((zrWidth - totalWidth) / 2);
                break;
            case &#x27;left&#x27;:
                x = padding[3] + toolboxOption.borderWidth;
                break;
            case &#x27;right&#x27;:
                x = zrWidth - totalWidth - padding[1] - toolboxOption.borderWidth;
                break;
            default:
                x = toolboxOption.x - 0;
                x = isNaN(x) ? 0 : x;
                break;
            }
            var y;
            var zrHeight = this.zr.getHeight();
            switch (toolboxOption.y) {
            case &#x27;top&#x27;:
                y = padding[0] + toolboxOption.borderWidth;
                break;
            case &#x27;bottom&#x27;:
                y = zrHeight - totalHeight - padding[2] - toolboxOption.borderWidth;
                break;
            case &#x27;center&#x27;:
                y = Math.floor((zrHeight - totalHeight) / 2);
                break;
            default:
                y = toolboxOption.y - 0;
                y = isNaN(y) ? 0 : y;
                break;
            }
            return {
                x: x,
                y: y,
                width: totalWidth,
                height: totalHeight
            };
        },
        __onmousemove: function (param) {
            if (this._marking) {
                this._markShape.style.xEnd = zrEvent.getX(param.event);
                this._markShape.style.yEnd = zrEvent.getY(param.event);
                this.zr.addHoverShape(this._markShape);
            }
            if (this._zooming) {
                this._zoomShape.style.width = zrEvent.getX(param.event) - this._zoomShape.style.x;
                this._zoomShape.style.height = zrEvent.getY(param.event) - this._zoomShape.style.y;
                this.zr.addHoverShape(this._zoomShape);
                this.dom.style.cursor = &#x27;crosshair&#x27;;
            }
            if (this._zoomStart &amp;&amp; (this.dom.style.cursor != &#x27;pointer&#x27; &amp;&amp; this.dom.style.cursor != &#x27;move&#x27;)) {
                this.dom.style.cursor = &#x27;crosshair&#x27;;
            }
        },
        __onmousedown: function (param) {
            if (param.target) {
                return;
            }
            this._zooming = true;
            var x = zrEvent.getX(param.event);
            var y = zrEvent.getY(param.event);
            var zoomOption = this.option.dataZoom || {};
            this._zoomShape = new RectangleShape({
                zlevel: this._zlevelBase,
                style: {
                    x: x,
                    y: y,
                    width: 1,
                    height: 1,
                    brushType: &#x27;both&#x27;
                },
                highlightStyle: {
                    lineWidth: 2,
                    color: zoomOption.fillerColor || ecConfig.dataZoom.fillerColor,
                    strokeColor: zoomOption.handleColor || ecConfig.dataZoom.handleColor,
                    brushType: &#x27;both&#x27;
                }
            });
            this.zr.addHoverShape(this._zoomShape);
            return true;
        },
        __onmouseup: function () {
            if (!this._zoomShape || Math.abs(this._zoomShape.style.width) &lt; 10 || Math.abs(this._zoomShape.style.height) &lt; 10) {
                this._zooming = false;
                return true;
            }
            if (this._zooming &amp;&amp; this.component.dataZoom) {
                this._zooming = false;
                var zoom = this.component.dataZoom.rectZoom(this._zoomShape.style);
                if (zoom) {
                    this._zoomQueue.push({
                        start: zoom.start,
                        end: zoom.end,
                        start2: zoom.start2,
                        end2: zoom.end2
                    });
                    this._iconEnable(this._iconShapeMap[&#x27;dataZoomReset&#x27;]);
                    this.zr.refresh();
                }
            }
            return true;
        },
        __onclick: function (param) {
            if (param.target) {
                return;
            }
            if (this._marking) {
                this._marking = false;
                this._markShapeList.push(this._markShape);
                this._iconEnable(this._iconShapeMap[&#x27;markUndo&#x27;]);
                this._iconEnable(this._iconShapeMap[&#x27;markClear&#x27;]);
                this.zr.addShape(this._markShape);
                this.zr.refresh();
            } else if (this._markStart) {
                this._marking = true;
                var x = zrEvent.getX(param.event);
                var y = zrEvent.getY(param.event);
                this._markShape = new LineShape({
                    zlevel: this._zlevelBase,
                    style: {
                        xStart: x,
                        yStart: y,
                        xEnd: x,
                        yEnd: y,
                        lineWidth: this.query(this.option, &#x27;toolbox.feature.mark.lineStyle.width&#x27;),
                        strokeColor: this.query(this.option, &#x27;toolbox.feature.mark.lineStyle.color&#x27;),
                        lineType: this.query(this.option, &#x27;toolbox.feature.mark.lineStyle.type&#x27;)
                    }
                });
                this.zr.addHoverShape(this._markShape);
            }
        },
        __onMark: function (param) {
            var target = param.target;
            if (this._marking || this._markStart) {
                this._resetMark();
                this.zr.refresh();
            } else {
                this._resetZoom();
                this.zr.modShape(target.id, { style: { strokeColor: this._enableColor } });
                this.zr.refresh();
                this._markStart = true;
                var self = this;
                setTimeout(function () {
                    self.zr &amp;&amp; self.zr.on(zrConfig.EVENT.CLICK, self._onclick) &amp;&amp; self.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                }, 10);
            }
            return true;
        },
        __onMarkUndo: function () {
            if (this._marking) {
                this._marking = false;
            } else {
                var len = this._markShapeList.length;
                if (len &gt;= 1) {
                    var target = this._markShapeList[len - 1];
                    this.zr.delShape(target.id);
                    this.zr.refresh();
                    this._markShapeList.pop();
                    if (len === 1) {
                        this._iconDisable(this._iconShapeMap[&#x27;markUndo&#x27;]);
                        this._iconDisable(this._iconShapeMap[&#x27;markClear&#x27;]);
                    }
                }
            }
            return true;
        },
        __onMarkClear: function () {
            if (this._marking) {
                this._marking = false;
            }
            var len = this._markShapeList.length;
            if (len &gt; 0) {
                while (len--) {
                    this.zr.delShape(this._markShapeList.pop().id);
                }
                this._iconDisable(this._iconShapeMap[&#x27;markUndo&#x27;]);
                this._iconDisable(this._iconShapeMap[&#x27;markClear&#x27;]);
                this.zr.refresh();
            }
            return true;
        },
        __onDataZoom: function (param) {
            var target = param.target;
            if (this._zooming || this._zoomStart) {
                this._resetZoom();
                this.zr.refresh();
                this.dom.style.cursor = &#x27;default&#x27;;
            } else {
                this._resetMark();
                this.zr.modShape(target.id, { style: { strokeColor: this._enableColor } });
                this.zr.refresh();
                this._zoomStart = true;
                var self = this;
                setTimeout(function () {
                    self.zr &amp;&amp; self.zr.on(zrConfig.EVENT.MOUSEDOWN, self._onmousedown) &amp;&amp; self.zr.on(zrConfig.EVENT.MOUSEUP, self._onmouseup) &amp;&amp; self.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                }, 10);
                this.dom.style.cursor = &#x27;crosshair&#x27;;
            }
            return true;
        },
        __onDataZoomReset: function () {
            if (this._zooming) {
                this._zooming = false;
            }
            this._zoomQueue.pop();
            if (this._zoomQueue.length &gt; 0) {
                this.component.dataZoom.absoluteZoom(this._zoomQueue[this._zoomQueue.length - 1]);
            } else {
                this.component.dataZoom.rectZoom();
                this._iconDisable(this._iconShapeMap[&#x27;dataZoomReset&#x27;]);
                this.zr.refresh();
            }
            return true;
        },
        _resetMark: function () {
            this._marking = false;
            if (this._markStart) {
                this._markStart = false;
                if (this._iconShapeMap[&#x27;mark&#x27;]) {
                    this.zr.modShape(this._iconShapeMap[&#x27;mark&#x27;].id, { style: { strokeColor: this._iconShapeMap[&#x27;mark&#x27;].highlightStyle.strokeColor } });
                }
                this.zr.un(zrConfig.EVENT.CLICK, this._onclick);
                this.zr.un(zrConfig.EVENT.MOUSEMOVE, this._onmousemove);
            }
        },
        _resetZoom: function () {
            this._zooming = false;
            if (this._zoomStart) {
                this._zoomStart = false;
                if (this._iconShapeMap[&#x27;dataZoom&#x27;]) {
                    this.zr.modShape(this._iconShapeMap[&#x27;dataZoom&#x27;].id, { style: { strokeColor: this._iconShapeMap[&#x27;dataZoom&#x27;].highlightStyle.strokeColor } });
                }
                this.zr.un(zrConfig.EVENT.MOUSEDOWN, this._onmousedown);
                this.zr.un(zrConfig.EVENT.MOUSEUP, this._onmouseup);
                this.zr.un(zrConfig.EVENT.MOUSEMOVE, this._onmousemove);
            }
        },
        _iconDisable: function (target) {
            if (target.type != &#x27;image&#x27;) {
                this.zr.modShape(target.id, {
                    hoverable: false,
                    clickable: false,
                    style: { strokeColor: this._disableColor }
                });
            } else {
                this.zr.modShape(target.id, {
                    hoverable: false,
                    clickable: false,
                    style: { opacity: 0.3 }
                });
            }
        },
        _iconEnable: function (target) {
            if (target.type != &#x27;image&#x27;) {
                this.zr.modShape(target.id, {
                    hoverable: true,
                    clickable: true,
                    style: { strokeColor: target.highlightStyle.strokeColor }
                });
            } else {
                this.zr.modShape(target.id, {
                    hoverable: true,
                    clickable: true,
                    style: { opacity: 0.8 }
                });
            }
        },
        __onDataView: function () {
            this._dataView.show(this.option);
            return true;
        },
        __onRestore: function () {
            this._resetMark();
            this._resetZoom();
            this.messageCenter.dispatch(ecConfig.EVENT.RESTORE, null, null, this.myChart);
            return true;
        },
        __onSaveAsImage: function () {
            var saveOption = this.option.toolbox.feature.saveAsImage;
            var imgType = saveOption.type || &#x27;png&#x27;;
            if (imgType != &#x27;png&#x27; &amp;&amp; imgType != &#x27;jpeg&#x27;) {
                imgType = &#x27;png&#x27;;
            }
            var image;
            if (!this.myChart.isConnected()) {
                image = this.zr.toDataURL(&#x27;image/&#x27; + imgType, this.option.backgroundColor &amp;&amp; this.option.backgroundColor.replace(&#x27; &#x27;, &#x27;&#x27;) === &#x27;rgba(0,0,0,0)&#x27; ? &#x27;#fff&#x27; : this.option.backgroundColor);
            } else {
                image = this.myChart.getConnectedDataURL(imgType);
            }
            var downloadDiv = document.createElement(&#x27;div&#x27;);
            downloadDiv.id = &#x27;__echarts_download_wrap__&#x27;;
            downloadDiv.style.cssText = &#x27;position:fixed;&#x27; + &#x27;z-index:99999;&#x27; + &#x27;display:block;&#x27; + &#x27;top:0;left:0;&#x27; + &#x27;background-color:rgba(33,33,33,0.5);&#x27; + &#x27;text-align:center;&#x27; + &#x27;width:100%;&#x27; + &#x27;height:100%;&#x27; + &#x27;line-height:&#x27; + document.documentElement.clientHeight + &#x27;px;&#x27;;
            var downloadLink = document.createElement(&#x27;a&#x27;);
            downloadLink.href = image;
            downloadLink.setAttribute(&#x27;download&#x27;, (saveOption.name ? saveOption.name : this.option.title &amp;&amp; (this.option.title.text || this.option.title.subtext) ? this.option.title.text || this.option.title.subtext : &#x27;ECharts&#x27;) + &#x27;.&#x27; + imgType);
            downloadLink.innerHTML = &#x27;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;&#x27; + image + &#x27;&quot; title=&quot;&#x27; + (!!(window.attachEvent &amp;&amp; navigator.userAgent.indexOf(&#x27;Opera&#x27;) === -1) ? &#x27;右键-&gt;图片另存为&#x27; : saveOption.lang ? saveOption.lang[0] : &#x27;点击保存&#x27;) + &#x27;&quot;/&gt;&#x27;;
            downloadDiv.appendChild(downloadLink);
            document.body.appendChild(downloadDiv);
            downloadLink = null;
            downloadDiv = null;
            setTimeout(function () {
                var _d = document.getElementById(&#x27;__echarts_download_wrap__&#x27;);
                if (_d) {
                    _d.onclick = function () {
                        var d = document.getElementById(&#x27;__echarts_download_wrap__&#x27;);
                        d.onclick = null;
                        d.innerHTML = &#x27;&#x27;;
                        document.body.removeChild(d);
                        d = null;
                    };
                    _d = null;
                }
            }, 500);
            return;
        },
        __onMagicType: function (param) {
            this._resetMark();
            var itemName = param.target._name;
            if (!this._magicType[itemName]) {
                this._magicType[itemName] = true;
                if (itemName === ecConfig.CHART_TYPE_LINE) {
                    this._magicType[ecConfig.CHART_TYPE_BAR] = false;
                } else if (itemName === ecConfig.CHART_TYPE_BAR) {
                    this._magicType[ecConfig.CHART_TYPE_LINE] = false;
                }
                if (itemName === ecConfig.CHART_TYPE_PIE) {
                    this._magicType[ecConfig.CHART_TYPE_FUNNEL] = false;
                } else if (itemName === ecConfig.CHART_TYPE_FUNNEL) {
                    this._magicType[ecConfig.CHART_TYPE_PIE] = false;
                }
                if (itemName === ecConfig.CHART_TYPE_FORCE) {
                    this._magicType[ecConfig.CHART_TYPE_CHORD] = false;
                } else if (itemName === ecConfig.CHART_TYPE_CHORD) {
                    this._magicType[ecConfig.CHART_TYPE_FORCE] = false;
                }
                if (itemName === _MAGICTYPE_STACK) {
                    this._magicType[_MAGICTYPE_TILED] = false;
                } else if (itemName === _MAGICTYPE_TILED) {
                    this._magicType[_MAGICTYPE_STACK] = false;
                }
                this.messageCenter.dispatch(ecConfig.EVENT.MAGIC_TYPE_CHANGED, param.event, { magicType: this._magicType }, this.myChart);
            }
            return true;
        },
        setMagicType: function (magicType) {
            this._resetMark();
            this._magicType = magicType;
            !this._isSilence &amp;&amp; this.messageCenter.dispatch(ecConfig.EVENT.MAGIC_TYPE_CHANGED, null, { magicType: this._magicType }, this.myChart);
        },
        __onCustomHandler: function (param) {
            var target = param.target.style.iconType;
            var featureHandler = this.option.toolbox.feature[target].onclick;
            if (typeof featureHandler === &#x27;function&#x27;) {
                featureHandler.call(this, this.option);
            }
        },
        reset: function (newOption, isRestore) {
            isRestore &amp;&amp; this.clear();
            if (this.query(newOption, &#x27;toolbox.show&#x27;) &amp;&amp; this.query(newOption, &#x27;toolbox.feature.magicType.show&#x27;)) {
                var magicType = newOption.toolbox.feature.magicType.type;
                var len = magicType.length;
                this._magicMap = {};
                while (len--) {
                    this._magicMap[magicType[len]] = true;
                }
                len = newOption.series.length;
                var oriType;
                var axis;
                while (len--) {
                    oriType = newOption.series[len].type;
                    if (this._magicMap[oriType]) {
                        axis = newOption.xAxis instanceof Array ? newOption.xAxis[newOption.series[len].xAxisIndex || 0] : newOption.xAxis;
                        if (axis &amp;&amp; (axis.type || &#x27;category&#x27;) === &#x27;category&#x27;) {
                            axis.__boundaryGap = axis.boundaryGap != null ? axis.boundaryGap : true;
                        }
                        axis = newOption.yAxis instanceof Array ? newOption.yAxis[newOption.series[len].yAxisIndex || 0] : newOption.yAxis;
                        if (axis &amp;&amp; axis.type === &#x27;category&#x27;) {
                            axis.__boundaryGap = axis.boundaryGap != null ? axis.boundaryGap : true;
                        }
                        newOption.series[len].__type = oriType;
                        newOption.series[len].__itemStyle = zrUtil.clone(newOption.series[len].itemStyle || {});
                    }
                    if (this._magicMap[_MAGICTYPE_STACK] || this._magicMap[_MAGICTYPE_TILED]) {
                        newOption.series[len].__stack = newOption.series[len].stack;
                    }
                }
            }
            this._magicType = isRestore ? {} : this._magicType || {};
            for (var itemName in this._magicType) {
                if (this._magicType[itemName]) {
                    this.option = newOption;
                    this.getMagicOption();
                    break;
                }
            }
            var zoomOption = newOption.dataZoom;
            if (zoomOption &amp;&amp; zoomOption.show) {
                var start = zoomOption.start != null &amp;&amp; zoomOption.start &gt;= 0 &amp;&amp; zoomOption.start &lt;= 100 ? zoomOption.start : 0;
                var end = zoomOption.end != null &amp;&amp; zoomOption.end &gt;= 0 &amp;&amp; zoomOption.end &lt;= 100 ? zoomOption.end : 100;
                if (start &gt; end) {
                    start = start + end;
                    end = start - end;
                    start = start - end;
                }
                this._zoomQueue = [{
                        start: start,
                        end: end,
                        start2: 0,
                        end2: 100
                    }];
            } else {
                this._zoomQueue = [];
            }
        },
        getMagicOption: function () {
            var axis;
            var chartType;
            if (this._magicType[ecConfig.CHART_TYPE_LINE] || this._magicType[ecConfig.CHART_TYPE_BAR]) {
                var boundaryGap = this._magicType[ecConfig.CHART_TYPE_LINE] ? false : true;
                for (var i = 0, l = this.option.series.length; i &lt; l; i++) {
                    chartType = this.option.series[i].type;
                    if (chartType == ecConfig.CHART_TYPE_LINE || chartType == ecConfig.CHART_TYPE_BAR) {
                        axis = this.option.xAxis instanceof Array ? this.option.xAxis[this.option.series[i].xAxisIndex || 0] : this.option.xAxis;
                        if (axis &amp;&amp; (axis.type || &#x27;category&#x27;) === &#x27;category&#x27;) {
                            axis.boundaryGap = boundaryGap ? true : axis.__boundaryGap;
                        }
                        axis = this.option.yAxis instanceof Array ? this.option.yAxis[this.option.series[i].yAxisIndex || 0] : this.option.yAxis;
                        if (axis &amp;&amp; axis.type === &#x27;category&#x27;) {
                            axis.boundaryGap = boundaryGap ? true : axis.__boundaryGap;
                        }
                    }
                }
                this._defaultMagic(ecConfig.CHART_TYPE_LINE, ecConfig.CHART_TYPE_BAR);
            }
            this._defaultMagic(ecConfig.CHART_TYPE_CHORD, ecConfig.CHART_TYPE_FORCE);
            this._defaultMagic(ecConfig.CHART_TYPE_PIE, ecConfig.CHART_TYPE_FUNNEL);
            if (this._magicType[_MAGICTYPE_STACK] || this._magicType[_MAGICTYPE_TILED]) {
                for (var i = 0, l = this.option.series.length; i &lt; l; i++) {
                    if (this._magicType[_MAGICTYPE_STACK]) {
                        this.option.series[i].stack = &#x27;_ECHARTS_STACK_KENER_2014_&#x27;;
                        chartType = _MAGICTYPE_STACK;
                    } else if (this._magicType[_MAGICTYPE_TILED]) {
                        this.option.series[i].stack = null;
                        chartType = _MAGICTYPE_TILED;
                    }
                    if (this._featureOption[chartType + &#x27;Chart&#x27;]) {
                        zrUtil.merge(this.option.series[i], this._featureOption[chartType + &#x27;Chart&#x27;] || {}, true);
                    }
                }
            }
            return this.option;
        },
        _defaultMagic: function (cType1, cType2) {
            if (this._magicType[cType1] || this._magicType[cType2]) {
                for (var i = 0, l = this.option.series.length; i &lt; l; i++) {
                    var chartType = this.option.series[i].type;
                    if (chartType == cType1 || chartType == cType2) {
                        this.option.series[i].type = this._magicType[cType1] ? cType1 : cType2;
                        this.option.series[i].itemStyle = zrUtil.clone(this.option.series[i].__itemStyle);
                        chartType = this.option.series[i].type;
                        if (this._featureOption[chartType + &#x27;Chart&#x27;]) {
                            zrUtil.merge(this.option.series[i], this._featureOption[chartType + &#x27;Chart&#x27;] || {}, true);
                        }
                    }
                }
            }
        },
        silence: function (s) {
            this._isSilence = s;
        },
        resize: function () {
            this._resetMark();
            this.clear();
            if (this.option &amp;&amp; this.option.toolbox &amp;&amp; this.option.toolbox.show) {
                this._buildShape();
            }
            if (this._dataView) {
                this._dataView.resize();
            }
        },
        hideDataView: function () {
            if (this._dataView) {
                this._dataView.hide();
            }
        },
        clear: function (notMark) {
            if (this.zr) {
                this.zr.delShape(this.shapeList);
                this.shapeList = [];
                if (!notMark) {
                    this.zr.delShape(this._markShapeList);
                    this._markShapeList = [];
                }
            }
        },
        onbeforDispose: function () {
            if (this._dataView) {
                this._dataView.dispose();
                this._dataView = null;
            }
            this._markShapeList = null;
        },
        refresh: function (newOption) {
            if (newOption) {
                this._resetMark();
                this._resetZoom();
                newOption.toolbox = this.reformOption(newOption.toolbox);
                this.option = newOption;
                this.clear(true);
                if (newOption.toolbox.show) {
                    this._buildShape();
                }
                this.hideDataView();
            }
        }
    };
    zrUtil.inherits(Toolbox, Base);
    require(&#x27;../component&#x27;).define(&#x27;toolbox&#x27;, Toolbox);
    return Toolbox;
});define(&#x27;echarts/component&#x27;, [], function () {
    var self = {};
    var _componentLibrary = {};
    self.define = function (name, clazz) {
        _componentLibrary[name] = clazz;
        return self;
    };
    self.get = function (name) {
        return _componentLibrary[name];
    };
    return self;
});define(&#x27;echarts/component/title&#x27;, [
    &#x27;require&#x27;,
    &#x27;./base&#x27;,
    &#x27;zrender/shape/Text&#x27;,
    &#x27;zrender/shape/Rectangle&#x27;,
    &#x27;../config&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;zrender/tool/area&#x27;,
    &#x27;zrender/tool/color&#x27;,
    &#x27;../component&#x27;
], function (require) {
    var Base = require(&#x27;./base&#x27;);
    var TextShape = require(&#x27;zrender/shape/Text&#x27;);
    var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
    var ecConfig = require(&#x27;../config&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    var zrArea = require(&#x27;zrender/tool/area&#x27;);
    var zrColor = require(&#x27;zrender/tool/color&#x27;);
    function Title(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.refresh(option);
    }
    Title.prototype = {
        type: ecConfig.COMPONENT_TYPE_TITLE,
        _buildShape: function () {
            this._itemGroupLocation = this._getItemGroupLocation();
            this._buildBackground();
            this._buildItem();
            for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },
        _buildItem: function () {
            var text = this.titleOption.text;
            var link = this.titleOption.link;
            var target = this.titleOption.target;
            var subtext = this.titleOption.subtext;
            var sublink = this.titleOption.sublink;
            var subtarget = this.titleOption.subtarget;
            var font = this.getFont(this.titleOption.textStyle);
            var subfont = this.getFont(this.titleOption.subtextStyle);
            var x = this._itemGroupLocation.x;
            var y = this._itemGroupLocation.y;
            var width = this._itemGroupLocation.width;
            var height = this._itemGroupLocation.height;
            var textShape = {
                zlevel: this._zlevelBase,
                style: {
                    y: y,
                    color: this.titleOption.textStyle.color,
                    text: text,
                    textFont: font,
                    textBaseline: &#x27;top&#x27;
                },
                highlightStyle: {
                    color: zrColor.lift(this.titleOption.textStyle.color, 1),
                    brushType: &#x27;fill&#x27;
                },
                hoverable: false
            };
            if (link) {
                textShape.hoverable = true;
                textShape.clickable = true;
                textShape.onclick = function () {
                    if (!target || target != &#x27;self&#x27;) {
                        window.open(link);
                    } else {
                        window.location = link;
                    }
                };
            }
            var subtextShape = {
                zlevel: this._zlevelBase,
                style: {
                    y: y + height,
                    color: this.titleOption.subtextStyle.color,
                    text: subtext,
                    textFont: subfont,
                    textBaseline: &#x27;bottom&#x27;
                },
                highlightStyle: {
                    color: zrColor.lift(this.titleOption.subtextStyle.color, 1),
                    brushType: &#x27;fill&#x27;
                },
                hoverable: false
            };
            if (sublink) {
                subtextShape.hoverable = true;
                subtextShape.clickable = true;
                subtextShape.onclick = function () {
                    if (!subtarget || subtarget != &#x27;self&#x27;) {
                        window.open(sublink);
                    } else {
                        window.location = sublink;
                    }
                };
            }
            switch (this.titleOption.x) {
            case &#x27;center&#x27;:
                textShape.style.x = subtextShape.style.x = x + width / 2;
                textShape.style.textAlign = subtextShape.style.textAlign = &#x27;center&#x27;;
                break;
            case &#x27;left&#x27;:
                textShape.style.x = subtextShape.style.x = x;
                textShape.style.textAlign = subtextShape.style.textAlign = &#x27;left&#x27;;
                break;
            case &#x27;right&#x27;:
                textShape.style.x = subtextShape.style.x = x + width;
                textShape.style.textAlign = subtextShape.style.textAlign = &#x27;right&#x27;;
                break;
            default:
                x = this.titleOption.x - 0;
                x = isNaN(x) ? 0 : x;
                textShape.style.x = subtextShape.style.x = x;
                break;
            }
            if (this.titleOption.textAlign) {
                textShape.style.textAlign = subtextShape.style.textAlign = this.titleOption.textAlign;
            }
            this.shapeList.push(new TextShape(textShape));
            subtext !== &#x27;&#x27; &amp;&amp; this.shapeList.push(new TextShape(subtextShape));
        },
        _buildBackground: function () {
            var padding = this.reformCssArray(this.titleOption.padding);
            this.shapeList.push(new RectangleShape({
                zlevel: this._zlevelBase,
                hoverable: false,
                style: {
                    x: this._itemGroupLocation.x - padding[3],
                    y: this._itemGroupLocation.y - padding[0],
                    width: this._itemGroupLocation.width + padding[3] + padding[1],
                    height: this._itemGroupLocation.height + padding[0] + padding[2],
                    brushType: this.titleOption.borderWidth === 0 ? &#x27;fill&#x27; : &#x27;both&#x27;,
                    color: this.titleOption.backgroundColor,
                    strokeColor: this.titleOption.borderColor,
                    lineWidth: this.titleOption.borderWidth
                }
            }));
        },
        _getItemGroupLocation: function () {
            var padding = this.reformCssArray(this.titleOption.padding);
            var text = this.titleOption.text;
            var subtext = this.titleOption.subtext;
            var font = this.getFont(this.titleOption.textStyle);
            var subfont = this.getFont(this.titleOption.subtextStyle);
            var totalWidth = Math.max(zrArea.getTextWidth(text, font), zrArea.getTextWidth(subtext, subfont));
            var totalHeight = zrArea.getTextHeight(text, font) + (subtext === &#x27;&#x27; ? 0 : this.titleOption.itemGap + zrArea.getTextHeight(subtext, subfont));
            var x;
            var zrWidth = this.zr.getWidth();
            switch (this.titleOption.x) {
            case &#x27;center&#x27;:
                x = Math.floor((zrWidth - totalWidth) / 2);
                break;
            case &#x27;left&#x27;:
                x = padding[3] + this.titleOption.borderWidth;
                break;
            case &#x27;right&#x27;:
                x = zrWidth - totalWidth - padding[1] - this.titleOption.borderWidth;
                break;
            default:
                x = this.titleOption.x - 0;
                x = isNaN(x) ? 0 : x;
                break;
            }
            var y;
            var zrHeight = this.zr.getHeight();
            switch (this.titleOption.y) {
            case &#x27;top&#x27;:
                y = padding[0] + this.titleOption.borderWidth;
                break;
            case &#x27;bottom&#x27;:
                y = zrHeight - totalHeight - padding[2] - this.titleOption.borderWidth;
                break;
            case &#x27;center&#x27;:
                y = Math.floor((zrHeight - totalHeight) / 2);
                break;
            default:
                y = this.titleOption.y - 0;
                y = isNaN(y) ? 0 : y;
                break;
            }
            return {
                x: x,
                y: y,
                width: totalWidth,
                height: totalHeight
            };
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.option.title = this.reformOption(this.option.title);
                this.titleOption = this.option.title;
                this.titleOption.textStyle = zrUtil.merge(this.titleOption.textStyle, this.ecTheme.textStyle);
                this.titleOption.subtextStyle = zrUtil.merge(this.titleOption.subtextStyle, this.ecTheme.textStyle);
            }
            this.clear();
            this._buildShape();
        }
    };
    zrUtil.inherits(Title, Base);
    require(&#x27;../component&#x27;).define(&#x27;title&#x27;, Title);
    return Title;
});define(&#x27;echarts/component/tooltip&#x27;, [
    &#x27;require&#x27;,
    &#x27;./base&#x27;,
    &#x27;../util/shape/Cross&#x27;,
    &#x27;zrender/shape/Line&#x27;,
    &#x27;zrender/shape/Rectangle&#x27;,
    &#x27;../config&#x27;,
    &#x27;../util/ecData&#x27;,
    &#x27;zrender/config&#x27;,
    &#x27;zrender/tool/event&#x27;,
    &#x27;zrender/tool/area&#x27;,
    &#x27;zrender/tool/color&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;zrender/shape/Base&#x27;,
    &#x27;../component&#x27;
], function (require) {
    var Base = require(&#x27;./base&#x27;);
    var CrossShape = require(&#x27;../util/shape/Cross&#x27;);
    var LineShape = require(&#x27;zrender/shape/Line&#x27;);
    var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
    var rectangleInstance = new RectangleShape({});
    var ecConfig = require(&#x27;../config&#x27;);
    var ecData = require(&#x27;../util/ecData&#x27;);
    var zrConfig = require(&#x27;zrender/config&#x27;);
    var zrEvent = require(&#x27;zrender/tool/event&#x27;);
    var zrArea = require(&#x27;zrender/tool/area&#x27;);
    var zrColor = require(&#x27;zrender/tool/color&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    var zrShapeBase = require(&#x27;zrender/shape/Base&#x27;);
    function Tooltip(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.dom = myChart.dom;
        var self = this;
        self._onmousemove = function (param) {
            return self.__onmousemove(param);
        };
        self._onglobalout = function (param) {
            return self.__onglobalout(param);
        };
        this.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
        this.zr.on(zrConfig.EVENT.GLOBALOUT, self._onglobalout);
        self._hide = function (param) {
            return self.__hide(param);
        };
        self._tryShow = function (param) {
            return self.__tryShow(param);
        };
        self._refixed = function (param) {
            return self.__refixed(param);
        };
        self._setContent = function (ticket, res) {
            return self.__setContent(ticket, res);
        };
        this._tDom = this._tDom || document.createElement(&#x27;div&#x27;);
        this._tDom.onselectstart = function () {
            return false;
        };
        this._tDom.onmouseover = function () {
            self._mousein = true;
        };
        this._tDom.onmouseout = function () {
            self._mousein = false;
        };
        this._tDom.style.position = &#x27;absolute&#x27;;
        this.hasAppend = false;
        this._axisLineShape &amp;&amp; this.zr.delShape(this._axisLineShape.id);
        this._axisLineShape = new LineShape({
            zlevel: this._zlevelBase,
            invisible: true,
            hoverable: false
        });
        this.shapeList.push(this._axisLineShape);
        this.zr.addShape(this._axisLineShape);
        this._axisShadowShape &amp;&amp; this.zr.delShape(this._axisShadowShape.id);
        this._axisShadowShape = new LineShape({
            zlevel: 1,
            invisible: true,
            hoverable: false
        });
        this.shapeList.push(this._axisShadowShape);
        this.zr.addShape(this._axisShadowShape);
        this._axisCrossShape &amp;&amp; this.zr.delShape(this._axisCrossShape.id);
        this._axisCrossShape = new CrossShape({
            zlevel: this._zlevelBase,
            invisible: true,
            hoverable: false
        });
        this.shapeList.push(this._axisCrossShape);
        this.zr.addShape(this._axisCrossShape);
        this.showing = false;
        this.refresh(option);
    }
    Tooltip.prototype = {
        type: ecConfig.COMPONENT_TYPE_TOOLTIP,
        _gCssText: &#x27;position:absolute;display:block;border-style:solid;white-space:nowrap;&#x27;,
        _style: function (opt) {
            if (!opt) {
                return &#x27;&#x27;;
            }
            var cssText = [];
            if (opt.transitionDuration) {
                var transitionText = &#x27;left &#x27; + opt.transitionDuration + &#x27;s,&#x27; + &#x27;top &#x27; + opt.transitionDuration + &#x27;s&#x27;;
                cssText.push(&#x27;transition:&#x27; + transitionText);
                cssText.push(&#x27;-moz-transition:&#x27; + transitionText);
                cssText.push(&#x27;-webkit-transition:&#x27; + transitionText);
                cssText.push(&#x27;-o-transition:&#x27; + transitionText);
            }
            if (opt.backgroundColor) {
                cssText.push(&#x27;background-Color:&#x27; + zrColor.toHex(opt.backgroundColor));
                cssText.push(&#x27;filter:alpha(opacity=70)&#x27;);
                cssText.push(&#x27;background-Color:&#x27; + opt.backgroundColor);
            }
            if (opt.borderWidth != null) {
                cssText.push(&#x27;border-width:&#x27; + opt.borderWidth + &#x27;px&#x27;);
            }
            if (opt.borderColor != null) {
                cssText.push(&#x27;border-color:&#x27; + opt.borderColor);
            }
            if (opt.borderRadius != null) {
                cssText.push(&#x27;border-radius:&#x27; + opt.borderRadius + &#x27;px&#x27;);
                cssText.push(&#x27;-moz-border-radius:&#x27; + opt.borderRadius + &#x27;px&#x27;);
                cssText.push(&#x27;-webkit-border-radius:&#x27; + opt.borderRadius + &#x27;px&#x27;);
                cssText.push(&#x27;-o-border-radius:&#x27; + opt.borderRadius + &#x27;px&#x27;);
            }
            var textStyle = opt.textStyle;
            if (textStyle) {
                textStyle.color &amp;&amp; cssText.push(&#x27;color:&#x27; + textStyle.color);
                textStyle.decoration &amp;&amp; cssText.push(&#x27;text-decoration:&#x27; + textStyle.decoration);
                textStyle.align &amp;&amp; cssText.push(&#x27;text-align:&#x27; + textStyle.align);
                textStyle.fontFamily &amp;&amp; cssText.push(&#x27;font-family:&#x27; + textStyle.fontFamily);
                textStyle.fontSize &amp;&amp; cssText.push(&#x27;font-size:&#x27; + textStyle.fontSize + &#x27;px&#x27;);
                textStyle.fontSize &amp;&amp; cssText.push(&#x27;line-height:&#x27; + Math.round(textStyle.fontSize * 3 / 2) + &#x27;px&#x27;);
                textStyle.fontStyle &amp;&amp; cssText.push(&#x27;font-style:&#x27; + textStyle.fontStyle);
                textStyle.fontWeight &amp;&amp; cssText.push(&#x27;font-weight:&#x27; + textStyle.fontWeight);
            }
            var padding = opt.padding;
            if (padding != null) {
                padding = this.reformCssArray(padding);
                cssText.push(&#x27;padding:&#x27; + padding[0] + &#x27;px &#x27; + padding[1] + &#x27;px &#x27; + padding[2] + &#x27;px &#x27; + padding[3] + &#x27;px&#x27;);
            }
            cssText = cssText.join(&#x27;;&#x27;) + &#x27;;&#x27;;
            return cssText;
        },
        __hide: function () {
            this._lastDataIndex = -1;
            this._lastSeriesIndex = -1;
            this._lastItemTriggerId = -1;
            if (this._tDom) {
                this._tDom.style.display = &#x27;none&#x27;;
            }
            var needRefresh = false;
            if (!this._axisLineShape.invisible) {
                this._axisLineShape.invisible = true;
                this.zr.modShape(this._axisLineShape.id);
                needRefresh = true;
            }
            if (!this._axisShadowShape.invisible) {
                this._axisShadowShape.invisible = true;
                this.zr.modShape(this._axisShadowShape.id);
                needRefresh = true;
            }
            if (!this._axisCrossShape.invisible) {
                this._axisCrossShape.invisible = true;
                this.zr.modShape(this._axisCrossShape.id);
                needRefresh = true;
            }
            if (this._lastTipShape &amp;&amp; this._lastTipShape.tipShape.length &gt; 0) {
                this.zr.delShape(this._lastTipShape.tipShape);
                this._lastTipShape = false;
                this.shapeList.length = 2;
            }
            needRefresh &amp;&amp; this.zr.refresh();
            this.showing = false;
        },
        _show: function (position, x, y, specialCssText) {
            var domHeight = this._tDom.offsetHeight;
            var domWidth = this._tDom.offsetWidth;
            if (position) {
                if (typeof position === &#x27;function&#x27;) {
                    position = position([
                        x,
                        y
                    ]);
                }
                if (position instanceof Array) {
                    x = position[0];
                    y = position[1];
                }
            }
            if (x + domWidth &gt; this._zrWidth) {
                x -= domWidth + 40;
            }
            if (y + domHeight &gt; this._zrHeight) {
                y -= domHeight - 20;
            }
            if (y &lt; 20) {
                y = 0;
            }
            this._tDom.style.cssText = this._gCssText + this._defaultCssText + (specialCssText ? specialCssText : &#x27;&#x27;) + &#x27;left:&#x27; + x + &#x27;px;top:&#x27; + y + &#x27;px;&#x27;;
            if (domHeight &lt; 10 || domWidth &lt; 10) {
                setTimeout(this._refixed, 20);
            }
            this.showing = true;
        },
        __refixed: function () {
            if (this._tDom) {
                var cssText = &#x27;&#x27;;
                var domHeight = this._tDom.offsetHeight;
                var domWidth = this._tDom.offsetWidth;
                if (this._tDom.offsetLeft + domWidth &gt; this._zrWidth) {
                    cssText += &#x27;left:&#x27; + (this._zrWidth - domWidth - 20) + &#x27;px;&#x27;;
                }
                if (this._tDom.offsetTop + domHeight &gt; this._zrHeight) {
                    cssText += &#x27;top:&#x27; + (this._zrHeight - domHeight - 10) + &#x27;px;&#x27;;
                }
                if (cssText !== &#x27;&#x27;) {
                    this._tDom.style.cssText += cssText;
                }
            }
        },
        __tryShow: function () {
            var needShow;
            var trigger;
            if (!this._curTarget) {
                this._findPolarTrigger() || this._findAxisTrigger();
            } else {
                if (this._curTarget._type === &#x27;island&#x27; &amp;&amp; this.option.tooltip.show) {
                    this._showItemTrigger();
                    return;
                }
                var serie = ecData.get(this._curTarget, &#x27;series&#x27;);
                var data = ecData.get(this._curTarget, &#x27;data&#x27;);
                needShow = this.deepQuery([
                    data,
                    serie,
                    this.option
                ], &#x27;tooltip.show&#x27;);
                if (serie == null || data == null || !needShow) {
                    clearTimeout(this._hidingTicket);
                    clearTimeout(this._showingTicket);
                    this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                } else {
                    trigger = this.deepQuery([
                        data,
                        serie,
                        this.option
                    ], &#x27;tooltip.trigger&#x27;);
                    trigger === &#x27;axis&#x27; ? this._showAxisTrigger(serie.xAxisIndex, serie.yAxisIndex, ecData.get(this._curTarget, &#x27;dataIndex&#x27;)) : this._showItemTrigger();
                }
            }
        },
        _findAxisTrigger: function () {
            if (!this.component.xAxis || !this.component.yAxis) {
                this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                return;
            }
            var series = this.option.series;
            var xAxisIndex;
            var yAxisIndex;
            for (var i = 0, l = series.length; i &lt; l; i++) {
                if (this.deepQuery([
                        series[i],
                        this.option
                    ], &#x27;tooltip.trigger&#x27;) === &#x27;axis&#x27;) {
                    xAxisIndex = series[i].xAxisIndex || 0;
                    yAxisIndex = series[i].yAxisIndex || 0;
                    if (this.component.xAxis.getAxis(xAxisIndex) &amp;&amp; this.component.xAxis.getAxis(xAxisIndex).type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {
                        this._showAxisTrigger(xAxisIndex, yAxisIndex, this._getNearestDataIndex(&#x27;x&#x27;, this.component.xAxis.getAxis(xAxisIndex)));
                        return;
                    } else if (this.component.yAxis.getAxis(yAxisIndex) &amp;&amp; this.component.yAxis.getAxis(yAxisIndex).type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {
                        this._showAxisTrigger(xAxisIndex, yAxisIndex, this._getNearestDataIndex(&#x27;y&#x27;, this.component.yAxis.getAxis(yAxisIndex)));
                        return;
                    } else {
                        this._showAxisTrigger(xAxisIndex, yAxisIndex, -1);
                        return;
                    }
                }
            }
            if (this.option.tooltip.axisPointer.type === &#x27;cross&#x27;) {
                this._showAxisTrigger(-1, -1, -1);
            }
        },
        _findPolarTrigger: function () {
            if (!this.component.polar) {
                return false;
            }
            var x = zrEvent.getX(this._event);
            var y = zrEvent.getY(this._event);
            var polarIndex = this.component.polar.getNearestIndex([
                x,
                y
            ]);
            var valueIndex;
            if (polarIndex) {
                valueIndex = polarIndex.valueIndex;
                polarIndex = polarIndex.polarIndex;
            } else {
                polarIndex = -1;
            }
            if (polarIndex != -1) {
                return this._showPolarTrigger(polarIndex, valueIndex);
            }
            return false;
        },
        _getNearestDataIndex: function (direction, categoryAxis) {
            var dataIndex = -1;
            var x = zrEvent.getX(this._event);
            var y = zrEvent.getY(this._event);
            if (direction === &#x27;x&#x27;) {
                var left;
                var right;
                var xEnd = this.component.grid.getXend();
                var curCoord = categoryAxis.getCoordByIndex(dataIndex);
                while (curCoord &lt; xEnd) {
                    right = curCoord;
                    if (curCoord &lt;= x) {
                        left = curCoord;
                    } else {
                        break;
                    }
                    curCoord = categoryAxis.getCoordByIndex(++dataIndex);
                }
                if (dataIndex &lt;= 0) {
                    dataIndex = 0;
                } else if (x - left &lt;= right - x) {
                    dataIndex -= 1;
                } else {
                    if (categoryAxis.getNameByIndex(dataIndex) == null) {
                        dataIndex -= 1;
                    }
                }
                return dataIndex;
            } else {
                var top;
                var bottom;
                var yStart = this.component.grid.getY();
                var curCoord = categoryAxis.getCoordByIndex(dataIndex);
                while (curCoord &gt; yStart) {
                    top = curCoord;
                    if (curCoord &gt;= y) {
                        bottom = curCoord;
                    } else {
                        break;
                    }
                    curCoord = categoryAxis.getCoordByIndex(++dataIndex);
                }
                if (dataIndex &lt;= 0) {
                    dataIndex = 0;
                } else if (y - top &gt;= bottom - y) {
                    dataIndex -= 1;
                } else {
                    if (categoryAxis.getNameByIndex(dataIndex) == null) {
                        dataIndex -= 1;
                    }
                }
                return dataIndex;
            }
            return -1;
        },
        _showAxisTrigger: function (xAxisIndex, yAxisIndex, dataIndex) {
            !this._event.connectTrigger &amp;&amp; this.messageCenter.dispatch(ecConfig.EVENT.TOOLTIP_IN_GRID, this._event, null, this.myChart);
            if (this.component.xAxis == null || this.component.yAxis == null || xAxisIndex == null || yAxisIndex == null) {
                clearTimeout(this._hidingTicket);
                clearTimeout(this._showingTicket);
                this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                return;
            }
            var series = this.option.series;
            var seriesArray = [];
            var seriesIndex = [];
            var categoryAxis;
            var formatter;
            var position;
            var showContent;
            var specialCssText = &#x27;&#x27;;
            if (this.option.tooltip.trigger === &#x27;axis&#x27;) {
                if (!this.option.tooltip.show) {
                    return;
                }
                formatter = this.option.tooltip.formatter;
                position = this.option.tooltip.position;
            }
            var axisLayout = xAxisIndex != -1 &amp;&amp; this.component.xAxis.getAxis(xAxisIndex).type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY ? &#x27;xAxis&#x27; : yAxisIndex != -1 &amp;&amp; this.component.yAxis.getAxis(yAxisIndex).type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY ? &#x27;yAxis&#x27; : false;
            var x;
            var y;
            if (axisLayout) {
                var axisIndex = axisLayout == &#x27;xAxis&#x27; ? xAxisIndex : yAxisIndex;
                categoryAxis = this.component[axisLayout].getAxis(axisIndex);
                for (var i = 0, l = series.length; i &lt; l; i++) {
                    if (!this._isSelected(series[i].name)) {
                        continue;
                    }
                    if (series[i][axisLayout + &#x27;Index&#x27;] === axisIndex &amp;&amp; this.deepQuery([
                            series[i],
                            this.option
                        ], &#x27;tooltip.trigger&#x27;) === &#x27;axis&#x27;) {
                        showContent = this.query(series[i], &#x27;tooltip.showContent&#x27;) || showContent;
                        formatter = this.query(series[i], &#x27;tooltip.formatter&#x27;) || formatter;
                        position = this.query(series[i], &#x27;tooltip.position&#x27;) || position;
                        specialCssText += this._style(this.query(series[i], &#x27;tooltip&#x27;));
                        if (series[i].stack != null &amp;&amp; axisLayout == &#x27;xAxis&#x27;) {
                            seriesArray.unshift(series[i]);
                            seriesIndex.unshift(i);
                        } else {
                            seriesArray.push(series[i]);
                            seriesIndex.push(i);
                        }
                    }
                }
                this.messageCenter.dispatch(ecConfig.EVENT.TOOLTIP_HOVER, this._event, {
                    seriesIndex: seriesIndex,
                    dataIndex: dataIndex
                }, this.myChart);
                var rect;
                if (axisLayout == &#x27;xAxis&#x27;) {
                    x = this.subPixelOptimize(categoryAxis.getCoordByIndex(dataIndex), this._axisLineWidth);
                    y = zrEvent.getY(this._event);
                    rect = [
                        x,
                        this.component.grid.getY(),
                        x,
                        this.component.grid.getYend()
                    ];
                } else {
                    x = zrEvent.getX(this._event);
                    y = this.subPixelOptimize(categoryAxis.getCoordByIndex(dataIndex), this._axisLineWidth);
                    rect = [
                        this.component.grid.getX(),
                        y,
                        this.component.grid.getXend(),
                        y
                    ];
                }
                this._styleAxisPointer(seriesArray, rect[0], rect[1], rect[2], rect[3], categoryAxis.getGap(), x, y);
            } else {
                x = zrEvent.getX(this._event);
                y = zrEvent.getY(this._event);
                this._styleAxisPointer(series, this.component.grid.getX(), y, this.component.grid.getXend(), y, 0, x, y);
                if (dataIndex &gt;= 0) {
                    this._showItemTrigger(true);
                } else {
                    clearTimeout(this._hidingTicket);
                    clearTimeout(this._showingTicket);
                    this._tDom.style.display = &#x27;none&#x27;;
                }
            }
            if (seriesArray.length &gt; 0) {
                if (this._lastDataIndex != dataIndex || this._lastSeriesIndex != seriesIndex[0]) {
                    this._lastDataIndex = dataIndex;
                    this._lastSeriesIndex = seriesIndex[0];
                    var data;
                    var value;
                    if (typeof formatter === &#x27;function&#x27;) {
                        var params = [];
                        for (var i = 0, l = seriesArray.length; i &lt; l; i++) {
                            data = seriesArray[i].data[dataIndex];
                            value = data != null ? data.value != null ? data.value : data : &#x27;-&#x27;;
                            params.push({
                                seriesIndex: seriesIndex[i],
                                seriesName: seriesArray[i].name || &#x27;&#x27;,
                                series: seriesArray[i],
                                dataIndex: dataIndex,
                                data: data,
                                name: categoryAxis.getNameByIndex(dataIndex),
                                value: value,
                                0: seriesArray[i].name || &#x27;&#x27;,
                                1: categoryAxis.getNameByIndex(dataIndex),
                                2: value,
                                3: data
                            });
                        }
                        this._curTicket = &#x27;axis:&#x27; + dataIndex;
                        this._tDom.innerHTML = formatter.call(this.myChart, params, this._curTicket, this._setContent);
                    } else if (typeof formatter === &#x27;string&#x27;) {
                        this._curTicket = NaN;
                        formatter = formatter.replace(&#x27;{a}&#x27;, &#x27;{a0}&#x27;).replace(&#x27;{b}&#x27;, &#x27;{b0}&#x27;).replace(&#x27;{c}&#x27;, &#x27;{c0}&#x27;);
                        for (var i = 0, l = seriesArray.length; i &lt; l; i++) {
                            formatter = formatter.replace(&#x27;{a&#x27; + i + &#x27;}&#x27;, this._encodeHTML(seriesArray[i].name || &#x27;&#x27;));
                            formatter = formatter.replace(&#x27;{b&#x27; + i + &#x27;}&#x27;, this._encodeHTML(categoryAxis.getNameByIndex(dataIndex)));
                            data = seriesArray[i].data[dataIndex];
                            data = data != null ? data.value != null ? data.value : data : &#x27;-&#x27;;
                            formatter = formatter.replace(&#x27;{c&#x27; + i + &#x27;}&#x27;, data instanceof Array ? data : this.numAddCommas(data));
                        }
                        this._tDom.innerHTML = formatter;
                    } else {
                        this._curTicket = NaN;
                        formatter = this._encodeHTML(categoryAxis.getNameByIndex(dataIndex));
                        for (var i = 0, l = seriesArray.length; i &lt; l; i++) {
                            formatter += &#x27;&lt;br/&gt;&#x27; + this._encodeHTML(seriesArray[i].name || &#x27;&#x27;) + &#x27; : &#x27;;
                            data = seriesArray[i].data[dataIndex];
                            data = data != null ? data.value != null ? data.value : data : &#x27;-&#x27;;
                            formatter += data instanceof Array ? data : this.numAddCommas(data);
                        }
                        this._tDom.innerHTML = formatter;
                    }
                }
                if (showContent === false || !this.option.tooltip.showContent) {
                    return;
                }
                if (!this.hasAppend) {
                    this._tDom.style.left = this._zrWidth / 2 + &#x27;px&#x27;;
                    this._tDom.style.top = this._zrHeight / 2 + &#x27;px&#x27;;
                    this.dom.firstChild.appendChild(this._tDom);
                    this.hasAppend = true;
                }
                this._show(position, x + 10, y + 10, specialCssText);
            }
        },
        _showPolarTrigger: function (polarIndex, dataIndex) {
            if (this.component.polar == null || polarIndex == null || dataIndex == null || dataIndex &lt; 0) {
                return false;
            }
            var series = this.option.series;
            var seriesArray = [];
            var seriesIndex = [];
            var formatter;
            var position;
            var showContent;
            var specialCssText = &#x27;&#x27;;
            if (this.option.tooltip.trigger === &#x27;axis&#x27;) {
                if (!this.option.tooltip.show) {
                    return false;
                }
                formatter = this.option.tooltip.formatter;
                position = this.option.tooltip.position;
            }
            var indicatorName = this.option.polar[polarIndex].indicator[dataIndex].text;
            for (var i = 0, l = series.length; i &lt; l; i++) {
                if (!this._isSelected(series[i].name)) {
                    continue;
                }
                if (series[i].polarIndex === polarIndex &amp;&amp; this.deepQuery([
                        series[i],
                        this.option
                    ], &#x27;tooltip.trigger&#x27;) === &#x27;axis&#x27;) {
                    showContent = this.query(series[i], &#x27;tooltip.showContent&#x27;) || showContent;
                    formatter = this.query(series[i], &#x27;tooltip.formatter&#x27;) || formatter;
                    position = this.query(series[i], &#x27;tooltip.position&#x27;) || position;
                    specialCssText += this._style(this.query(series[i], &#x27;tooltip&#x27;));
                    seriesArray.push(series[i]);
                    seriesIndex.push(i);
                }
            }
            if (seriesArray.length &gt; 0) {
                var polarData;
                var data;
                var value;
                var params = [];
                for (var i = 0, l = seriesArray.length; i &lt; l; i++) {
                    polarData = seriesArray[i].data;
                    for (var j = 0, k = polarData.length; j &lt; k; j++) {
                        data = polarData[j];
                        if (!this._isSelected(data.name)) {
                            continue;
                        }
                        data = data != null ? data : {
                            name: &#x27;&#x27;,
                            value: { dataIndex: &#x27;-&#x27; }
                        };
                        value = data.value[dataIndex].value != null ? data.value[dataIndex].value : data.value[dataIndex];
                        params.push({
                            seriesIndex: seriesIndex[i],
                            seriesName: seriesArray[i].name || &#x27;&#x27;,
                            series: seriesArray[i],
                            dataIndex: dataIndex,
                            data: data,
                            name: data.name,
                            indicator: indicatorName,
                            value: value,
                            0: seriesArray[i].name || &#x27;&#x27;,
                            1: data.name,
                            2: value,
                            3: indicatorName
                        });
                    }
                }
                if (params.length &lt;= 0) {
                    return;
                }
                if (this._lastDataIndex != dataIndex || this._lastSeriesIndex != seriesIndex[0]) {
                    this._lastDataIndex = dataIndex;
                    this._lastSeriesIndex = seriesIndex[0];
                    if (typeof formatter === &#x27;function&#x27;) {
                        this._curTicket = &#x27;axis:&#x27; + dataIndex;
                        this._tDom.innerHTML = formatter.call(this.myChart, params, this._curTicket, this._setContent);
                    } else if (typeof formatter === &#x27;string&#x27;) {
                        formatter = formatter.replace(&#x27;{a}&#x27;, &#x27;{a0}&#x27;).replace(&#x27;{b}&#x27;, &#x27;{b0}&#x27;).replace(&#x27;{c}&#x27;, &#x27;{c0}&#x27;).replace(&#x27;{d}&#x27;, &#x27;{d0}&#x27;);
                        for (var i = 0, l = params.length; i &lt; l; i++) {
                            formatter = formatter.replace(&#x27;{a&#x27; + i + &#x27;}&#x27;, this._encodeHTML(params[i].seriesName));
                            formatter = formatter.replace(&#x27;{b&#x27; + i + &#x27;}&#x27;, this._encodeHTML(params[i].name));
                            formatter = formatter.replace(&#x27;{c&#x27; + i + &#x27;}&#x27;, this.numAddCommas(params[i].value));
                            formatter = formatter.replace(&#x27;{d&#x27; + i + &#x27;}&#x27;, this._encodeHTML(params[i].indicator));
                        }
                        this._tDom.innerHTML = formatter;
                    } else {
                        formatter = this._encodeHTML(params[0].name) + &#x27;&lt;br/&gt;&#x27; + this._encodeHTML(params[0].indicator) + &#x27; : &#x27; + this.numAddCommas(params[0].value);
                        for (var i = 1, l = params.length; i &lt; l; i++) {
                            formatter += &#x27;&lt;br/&gt;&#x27; + this._encodeHTML(params[i].name) + &#x27;&lt;br/&gt;&#x27;;
                            formatter += this._encodeHTML(params[i].indicator) + &#x27; : &#x27; + this.numAddCommas(params[i].value);
                        }
                        this._tDom.innerHTML = formatter;
                    }
                }
                if (showContent === false || !this.option.tooltip.showContent) {
                    return;
                }
                if (!this.hasAppend) {
                    this._tDom.style.left = this._zrWidth / 2 + &#x27;px&#x27;;
                    this._tDom.style.top = this._zrHeight / 2 + &#x27;px&#x27;;
                    this.dom.firstChild.appendChild(this._tDom);
                    this.hasAppend = true;
                }
                this._show(position, zrEvent.getX(this._event), zrEvent.getY(this._event), specialCssText);
                return true;
            }
        },
        _showItemTrigger: function (axisTrigger) {
            if (!this._curTarget) {
                return;
            }
            var serie = ecData.get(this._curTarget, &#x27;series&#x27;);
            var seriesIndex = ecData.get(this._curTarget, &#x27;seriesIndex&#x27;);
            var data = ecData.get(this._curTarget, &#x27;data&#x27;);
            var dataIndex = ecData.get(this._curTarget, &#x27;dataIndex&#x27;);
            var name = ecData.get(this._curTarget, &#x27;name&#x27;);
            var value = ecData.get(this._curTarget, &#x27;value&#x27;);
            var special = ecData.get(this._curTarget, &#x27;special&#x27;);
            var special2 = ecData.get(this._curTarget, &#x27;special2&#x27;);
            var formatter;
            var position;
            var showContent;
            var specialCssText = &#x27;&#x27;;
            if (this._curTarget._type != &#x27;island&#x27;) {
                var trigger = axisTrigger ? &#x27;axis&#x27; : &#x27;item&#x27;;
                if (this.option.tooltip.trigger === trigger) {
                    formatter = this.option.tooltip.formatter;
                    position = this.option.tooltip.position;
                }
                if (this.query(serie, &#x27;tooltip.trigger&#x27;) === trigger) {
                    showContent = this.query(serie, &#x27;tooltip.showContent&#x27;) || showContent;
                    formatter = this.query(serie, &#x27;tooltip.formatter&#x27;) || formatter;
                    position = this.query(serie, &#x27;tooltip.position&#x27;) || position;
                    specialCssText += this._style(this.query(serie, &#x27;tooltip&#x27;));
                }
                showContent = this.query(data, &#x27;tooltip.showContent&#x27;) || showContent;
                formatter = this.query(data, &#x27;tooltip.formatter&#x27;) || formatter;
                position = this.query(data, &#x27;tooltip.position&#x27;) || position;
                specialCssText += this._style(this.query(data, &#x27;tooltip&#x27;));
            } else {
                this._lastItemTriggerId = NaN;
                showContent = this.deepQuery([
                    data,
                    serie,
                    this.option
                ], &#x27;tooltip.showContent&#x27;);
                formatter = this.deepQuery([
                    data,
                    serie,
                    this.option
                ], &#x27;tooltip.islandFormatter&#x27;);
                position = this.deepQuery([
                    data,
                    serie,
                    this.option
                ], &#x27;tooltip.islandPosition&#x27;);
            }
            if (this._lastItemTriggerId !== this._curTarget.id) {
                this._lastItemTriggerId = this._curTarget.id;
                if (typeof formatter === &#x27;function&#x27;) {
                    this._curTicket = (serie.name || &#x27;&#x27;) + &#x27;:&#x27; + dataIndex;
                    this._tDom.innerHTML = formatter.call(this.myChart, {
                        seriesIndex: seriesIndex,
                        seriesName: serie.name || &#x27;&#x27;,
                        series: serie,
                        dataIndex: dataIndex,
                        data: data,
                        name: name,
                        value: value,
                        percent: special,
                        indicator: special,
                        value2: special2,
                        indicator2: special2,
                        0: serie.name || &#x27;&#x27;,
                        1: name,
                        2: value,
                        3: special,
                        4: special2,
                        5: data,
                        6: seriesIndex,
                        7: dataIndex
                    }, this._curTicket, this._setContent);
                } else if (typeof formatter === &#x27;string&#x27;) {
                    this._curTicket = NaN;
                    formatter = formatter.replace(&#x27;{a}&#x27;, &#x27;{a0}&#x27;).replace(&#x27;{b}&#x27;, &#x27;{b0}&#x27;).replace(&#x27;{c}&#x27;, &#x27;{c0}&#x27;);
                    formatter = formatter.replace(&#x27;{a0}&#x27;, this._encodeHTML(serie.name || &#x27;&#x27;)).replace(&#x27;{b0}&#x27;, this._encodeHTML(name)).replace(&#x27;{c0}&#x27;, value instanceof Array ? value : this.numAddCommas(value));
                    formatter = formatter.replace(&#x27;{d}&#x27;, &#x27;{d0}&#x27;).replace(&#x27;{d0}&#x27;, special || &#x27;&#x27;);
                    formatter = formatter.replace(&#x27;{e}&#x27;, &#x27;{e0}&#x27;).replace(&#x27;{e0}&#x27;, ecData.get(this._curTarget, &#x27;special2&#x27;) || &#x27;&#x27;);
                    this._tDom.innerHTML = formatter;
                } else {
                    this._curTicket = NaN;
                    if (serie.type === ecConfig.CHART_TYPE_RADAR &amp;&amp; special) {
                        this._tDom.innerHTML = this._itemFormatter.radar.call(this, serie, name, value, special);
                    } else if (serie.type === ecConfig.CHART_TYPE_EVENTRIVER) {
                        this._tDom.innerHTML = this._itemFormatter.eventRiver.call(this, serie, name, value, data);
                    } else {
                        this._tDom.innerHTML = &#x27;&#x27; + (serie.name != null ? this._encodeHTML(serie.name) + &#x27;&lt;br/&gt;&#x27; : &#x27;&#x27;) + (name === &#x27;&#x27; ? &#x27;&#x27; : this._encodeHTML(name) + &#x27; : &#x27;) + (value instanceof Array ? value : this.numAddCommas(value));
                    }
                }
            }
            if (!this._axisLineShape.invisible || !this._axisShadowShape.invisible) {
                this._axisLineShape.invisible = true;
                this.zr.modShape(this._axisLineShape.id);
                this._axisShadowShape.invisible = true;
                this.zr.modShape(this._axisShadowShape.id);
                this.zr.refresh();
            }
            if (showContent === false || !this.option.tooltip.showContent) {
                return;
            }
            if (!this.hasAppend) {
                this._tDom.style.left = this._zrWidth / 2 + &#x27;px&#x27;;
                this._tDom.style.top = this._zrHeight / 2 + &#x27;px&#x27;;
                this.dom.firstChild.appendChild(this._tDom);
                this.hasAppend = true;
            }
            this._show(position, zrEvent.getX(this._event) + 20, zrEvent.getY(this._event) - 20, specialCssText);
        },
        _itemFormatter: {
            radar: function (serie, name, value, indicator) {
                var html = &#x27;&#x27;;
                html += this._encodeHTML(name === &#x27;&#x27; ? serie.name || &#x27;&#x27; : name);
                html += html === &#x27;&#x27; ? &#x27;&#x27; : &#x27;&lt;br /&gt;&#x27;;
                for (var i = 0; i &lt; indicator.length; i++) {
                    html += this._encodeHTML(indicator[i].text) + &#x27; : &#x27; + this.numAddCommas(value[i]) + &#x27;&lt;br /&gt;&#x27;;
                }
                return html;
            },
            chord: function (serie, name, value, special, special2) {
                if (special2 == null) {
                    return this._encodeHTML(name) + &#x27; (&#x27; + this.numAddCommas(value) + &#x27;)&#x27;;
                } else {
                    var name1 = this._encodeHTML(name);
                    var name2 = this._encodeHTML(special);
                    return &#x27;&#x27; + (serie.name != null ? this._encodeHTML(serie.name) + &#x27;&lt;br/&gt;&#x27; : &#x27;&#x27;) + name1 + &#x27; -&gt; &#x27; + name2 + &#x27; (&#x27; + this.numAddCommas(value) + &#x27;)&#x27; + &#x27;&lt;br /&gt;&#x27; + name2 + &#x27; -&gt; &#x27; + name1 + &#x27; (&#x27; + this.numAddCommas(special2) + &#x27;)&#x27;;
                }
            },
            eventRiver: function (serie, name, value, data) {
                var html = &#x27;&#x27;;
                html += this._encodeHTML(serie.name === &#x27;&#x27; ? &#x27;&#x27; : serie.name + &#x27; : &#x27;);
                html += this._encodeHTML(name);
                html += html === &#x27;&#x27; ? &#x27;&#x27; : &#x27;&lt;br /&gt;&#x27;;
                data = data.evolution;
                for (var i = 0, l = data.length; i &lt; l; i++) {
                    html += &#x27;&lt;div style=&quot;padding-top:5px;&quot;&gt;&#x27;;
                    if (!data[i].detail) {
                        continue;
                    }
                    if (data[i].detail.img) {
                        html += &#x27;&lt;img src=&quot;&#x27; + data[i].detail.img + &#x27;&quot; style=&quot;float:left;width:40px;height:40px;&quot;&gt;&#x27;;
                    }
                    html += &#x27;&lt;div style=&quot;margin-left:45px;&quot;&gt;&#x27; + data[i].time + &#x27;&lt;br/&gt;&#x27;;
                    html += &#x27;&lt;a href=&quot;&#x27; + data[i].detail.link + &#x27;&quot; target=&quot;_blank&quot;&gt;&#x27;;
                    html += data[i].detail.text + &#x27;&lt;/a&gt;&lt;/div&gt;&#x27;;
                    html += &#x27;&lt;/div&gt;&#x27;;
                }
                return html;
            }
        },
        _styleAxisPointer: function (seriesArray, xStart, yStart, xEnd, yEnd, gap, x, y) {
            if (seriesArray.length &gt; 0) {
                var queryTarget;
                var curType;
                var axisPointer = this.option.tooltip.axisPointer;
                var pointType = axisPointer.type;
                var style = {
                    line: {},
                    cross: {},
                    shadow: {}
                };
                for (var pType in style) {
                    style[pType].color = axisPointer[pType + &#x27;Style&#x27;].color;
                    style[pType].width = axisPointer[pType + &#x27;Style&#x27;].width;
                    style[pType].type = axisPointer[pType + &#x27;Style&#x27;].type;
                }
                for (var i = 0, l = seriesArray.length; i &lt; l; i++) {
                    if (this.deepQuery([
                            seriesArray[i],
                            this.option
                        ], &#x27;tooltip.trigger&#x27;) === &#x27;axis&#x27;) {
                        queryTarget = seriesArray[i];
                        curType = this.query(queryTarget, &#x27;tooltip.axisPointer.type&#x27;);
                        pointType = curType || pointType;
                        if (curType) {
                            style[curType].color = this.query(queryTarget, &#x27;tooltip.axisPointer.&#x27; + curType + &#x27;Style.color&#x27;) || style[curType].color;
                            style[curType].width = this.query(queryTarget, &#x27;tooltip.axisPointer.&#x27; + curType + &#x27;Style.width&#x27;) || style[curType].width;
                            style[curType].type = this.query(queryTarget, &#x27;tooltip.axisPointer.&#x27; + curType + &#x27;Style.type&#x27;) || style[curType].type;
                        }
                    }
                }
                if (pointType === &#x27;line&#x27;) {
                    this._axisLineShape.style = {
                        xStart: xStart,
                        yStart: yStart,
                        xEnd: xEnd,
                        yEnd: yEnd,
                        strokeColor: style.line.color,
                        lineWidth: style.line.width,
                        lineType: style.line.type
                    };
                    this._axisLineShape.invisible = false;
                    this.zr.modShape(this._axisLineShape.id);
                } else if (pointType === &#x27;cross&#x27;) {
                    this._axisCrossShape.style = {
                        brushType: &#x27;stroke&#x27;,
                        rect: this.component.grid.getArea(),
                        x: x,
                        y: y,
                        text: (&#x27;( &#x27; + this.component.xAxis.getAxis(0).getValueFromCoord(x) + &#x27; , &#x27; + this.component.yAxis.getAxis(0).getValueFromCoord(y) + &#x27; )&#x27;).replace(&#x27;  , &#x27;, &#x27; &#x27;).replace(&#x27; ,  &#x27;, &#x27; &#x27;),
                        textPosition: &#x27;specific&#x27;,
                        strokeColor: style.cross.color,
                        lineWidth: style.cross.width,
                        lineType: style.cross.type
                    };
                    if (this.component.grid.getXend() - x &gt; 100) {
                        this._axisCrossShape.style.textAlign = &#x27;left&#x27;;
                        this._axisCrossShape.style.textX = x + 10;
                    } else {
                        this._axisCrossShape.style.textAlign = &#x27;right&#x27;;
                        this._axisCrossShape.style.textX = x - 10;
                    }
                    if (y - this.component.grid.getY() &gt; 50) {
                        this._axisCrossShape.style.textBaseline = &#x27;bottom&#x27;;
                        this._axisCrossShape.style.textY = y - 10;
                    } else {
                        this._axisCrossShape.style.textBaseline = &#x27;top&#x27;;
                        this._axisCrossShape.style.textY = y + 10;
                    }
                    this._axisCrossShape.invisible = false;
                    this.zr.modShape(this._axisCrossShape.id);
                } else if (pointType === &#x27;shadow&#x27;) {
                    if (style.shadow.width == null || style.shadow.width === &#x27;auto&#x27; || isNaN(style.shadow.width)) {
                        style.shadow.width = gap;
                    }
                    if (xStart === xEnd) {
                        if (Math.abs(this.component.grid.getX() - xStart) &lt; 2) {
                            style.shadow.width /= 2;
                            xStart = xEnd = xEnd + style.shadow.width / 2;
                        } else if (Math.abs(this.component.grid.getXend() - xStart) &lt; 2) {
                            style.shadow.width /= 2;
                            xStart = xEnd = xEnd - style.shadow.width / 2;
                        }
                    } else if (yStart === yEnd) {
                        if (Math.abs(this.component.grid.getY() - yStart) &lt; 2) {
                            style.shadow.width /= 2;
                            yStart = yEnd = yEnd + style.shadow.width / 2;
                        } else if (Math.abs(this.component.grid.getYend() - yStart) &lt; 2) {
                            style.shadow.width /= 2;
                            yStart = yEnd = yEnd - style.shadow.width / 2;
                        }
                    }
                    this._axisShadowShape.style = {
                        xStart: xStart,
                        yStart: yStart,
                        xEnd: xEnd,
                        yEnd: yEnd,
                        strokeColor: style.shadow.color,
                        lineWidth: style.shadow.width
                    };
                    this._axisShadowShape.invisible = false;
                    this.zr.modShape(this._axisShadowShape.id);
                }
                this.zr.refresh();
            }
        },
        __onmousemove: function (param) {
            clearTimeout(this._hidingTicket);
            clearTimeout(this._showingTicket);
            if (this._mousein &amp;&amp; this._enterable) {
                return;
            }
            var target = param.target;
            var mx = zrEvent.getX(param.event);
            var my = zrEvent.getY(param.event);
            if (!target) {
                this._curTarget = false;
                this._event = param.event;
                this._event.zrenderX = mx;
                this._event.zrenderY = my;
                if (this._needAxisTrigger &amp;&amp; this.component.grid &amp;&amp; zrArea.isInside(rectangleInstance, this.component.grid.getArea(), mx, my)) {
                    this._showingTicket = setTimeout(this._tryShow, this._showDelay);
                } else if (this._needAxisTrigger &amp;&amp; this.component.polar &amp;&amp; this.component.polar.isInside([
                        mx,
                        my
                    ]) != -1) {
                    this._showingTicket = setTimeout(this._tryShow, this._showDelay);
                } else {
                    !this._event.connectTrigger &amp;&amp; this.messageCenter.dispatch(ecConfig.EVENT.TOOLTIP_OUT_GRID, this._event, null, this.myChart);
                    this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                }
            } else {
                this._curTarget = target;
                this._event = param.event;
                this._event.zrenderX = mx;
                this._event.zrenderY = my;
                var polarIndex;
                if (this._needAxisTrigger &amp;&amp; this.component.polar &amp;&amp; (polarIndex = this.component.polar.isInside([
                        mx,
                        my
                    ])) != -1) {
                    var series = this.option.series;
                    for (var i = 0, l = series.length; i &lt; l; i++) {
                        if (series[i].polarIndex === polarIndex &amp;&amp; this.deepQuery([
                                series[i],
                                this.option
                            ], &#x27;tooltip.trigger&#x27;) === &#x27;axis&#x27;) {
                            this._curTarget = null;
                            break;
                        }
                    }
                }
                this._showingTicket = setTimeout(this._tryShow, this._showDelay);
            }
        },
        __onglobalout: function () {
            clearTimeout(this._hidingTicket);
            clearTimeout(this._showingTicket);
            this._hidingTicket = setTimeout(this._hide, this._hideDelay);
        },
        __setContent: function (ticket, content) {
            if (!this._tDom) {
                return;
            }
            if (ticket === this._curTicket) {
                this._tDom.innerHTML = content;
            }
            setTimeout(this._refixed, 20);
        },
        ontooltipHover: function (param, tipShape) {
            if (!this._lastTipShape || this._lastTipShape &amp;&amp; this._lastTipShape.dataIndex != param.dataIndex) {
                if (this._lastTipShape &amp;&amp; this._lastTipShape.tipShape.length &gt; 0) {
                    this.zr.delShape(this._lastTipShape.tipShape);
                    this.shapeList.length = 2;
                }
                for (var i = 0, l = tipShape.length; i &lt; l; i++) {
                    tipShape[i].zlevel = this._zlevelBase;
                    tipShape[i].style = zrShapeBase.prototype.getHighlightStyle(tipShape[i].style, tipShape[i].highlightStyle);
                    tipShape[i].draggable = false;
                    tipShape[i].hoverable = false;
                    tipShape[i].clickable = false;
                    tipShape[i].ondragend = null;
                    tipShape[i].ondragover = null;
                    tipShape[i].ondrop = null;
                    this.shapeList.push(tipShape[i]);
                    this.zr.addShape(tipShape[i]);
                }
                this._lastTipShape = {
                    dataIndex: param.dataIndex,
                    tipShape: tipShape
                };
            }
        },
        ondragend: function () {
            this._hide();
        },
        onlegendSelected: function (param) {
            this._selectedMap = param.selected;
        },
        _setSelectedMap: function () {
            if (this.component.legend) {
                this._selectedMap = zrUtil.clone(this.component.legend.getSelectedMap());
            } else {
                this._selectedMap = {};
            }
        },
        _isSelected: function (itemName) {
            if (this._selectedMap[itemName] != null) {
                return this._selectedMap[itemName];
            } else {
                return true;
            }
        },
        showTip: function (params) {
            if (!params) {
                return;
            }
            var seriesIndex;
            var series = this.option.series;
            if (params.seriesIndex != null) {
                seriesIndex = params.seriesIndex;
            } else {
                var seriesName = params.seriesName;
                for (var i = 0, l = series.length; i &lt; l; i++) {
                    if (series[i].name === seriesName) {
                        seriesIndex = i;
                        break;
                    }
                }
            }
            var serie = series[seriesIndex];
            if (serie == null) {
                return;
            }
            var chart = this.myChart.chart[serie.type];
            var isAxisTrigger = this.deepQuery([
                serie,
                this.option
            ], &#x27;tooltip.trigger&#x27;) === &#x27;axis&#x27;;
            if (!chart) {
                return;
            }
            if (isAxisTrigger) {
                var dataIndex = params.dataIndex;
                switch (chart.type) {
                case ecConfig.CHART_TYPE_LINE:
                case ecConfig.CHART_TYPE_BAR:
                case ecConfig.CHART_TYPE_K:
                    if (this.component.xAxis == null || this.component.yAxis == null || serie.data.length &lt;= dataIndex) {
                        return;
                    }
                    var xAxisIndex = serie.xAxisIndex || 0;
                    var yAxisIndex = serie.yAxisIndex || 0;
                    if (this.component.xAxis.getAxis(xAxisIndex).type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {
                        this._event = {
                            zrenderX: this.component.xAxis.getAxis(xAxisIndex).getCoordByIndex(dataIndex),
                            zrenderY: this.component.grid.getY() + (this.component.grid.getYend() - this.component.grid.getY()) / 4
                        };
                    } else {
                        this._event = {
                            zrenderX: this.component.grid.getX() + (this.component.grid.getXend() - this.component.grid.getX()) / 4,
                            zrenderY: this.component.yAxis.getAxis(yAxisIndex).getCoordByIndex(dataIndex)
                        };
                    }
                    this._showAxisTrigger(xAxisIndex, yAxisIndex, dataIndex);
                    break;
                case ecConfig.CHART_TYPE_RADAR:
                    if (this.component.polar == null || serie.data[0].value.length &lt;= dataIndex) {
                        return;
                    }
                    var polarIndex = serie.polarIndex || 0;
                    var vector = this.component.polar.getVector(polarIndex, dataIndex, &#x27;max&#x27;);
                    this._event = {
                        zrenderX: vector[0],
                        zrenderY: vector[1]
                    };
                    this._showPolarTrigger(polarIndex, dataIndex);
                    break;
                }
            } else {
                var shapeList = chart.shapeList;
                var x;
                var y;
                switch (chart.type) {
                case ecConfig.CHART_TYPE_LINE:
                case ecConfig.CHART_TYPE_BAR:
                case ecConfig.CHART_TYPE_K:
                case ecConfig.CHART_TYPE_SCATTER:
                    var dataIndex = params.dataIndex;
                    for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                        if (ecData.get(shapeList[i], &#x27;seriesIndex&#x27;) == seriesIndex &amp;&amp; ecData.get(shapeList[i], &#x27;dataIndex&#x27;) == dataIndex) {
                            this._curTarget = shapeList[i];
                            x = shapeList[i].style.x;
                            y = chart.type != ecConfig.CHART_TYPE_K ? shapeList[i].style.y : shapeList[i].style.y[0];
                            break;
                        }
                    }
                    break;
                case ecConfig.CHART_TYPE_RADAR:
                    var dataIndex = params.dataIndex;
                    for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                        if (shapeList[i].type === &#x27;polygon&#x27; &amp;&amp; ecData.get(shapeList[i], &#x27;seriesIndex&#x27;) == seriesIndex &amp;&amp; ecData.get(shapeList[i], &#x27;dataIndex&#x27;) == dataIndex) {
                            this._curTarget = shapeList[i];
                            var vector = this.component.polar.getCenter(serie.polarIndex || 0);
                            x = vector[0];
                            y = vector[1];
                            break;
                        }
                    }
                    break;
                case ecConfig.CHART_TYPE_PIE:
                    var name = params.name;
                    for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                        if (shapeList[i].type === &#x27;sector&#x27; &amp;&amp; ecData.get(shapeList[i], &#x27;seriesIndex&#x27;) == seriesIndex &amp;&amp; ecData.get(shapeList[i], &#x27;name&#x27;) == name) {
                            this._curTarget = shapeList[i];
                            var style = this._curTarget.style;
                            var midAngle = (style.startAngle + style.endAngle) / 2 * Math.PI / 180;
                            x = this._curTarget.style.x + Math.cos(midAngle) * style.r / 1.5;
                            y = this._curTarget.style.y - Math.sin(midAngle) * style.r / 1.5;
                            break;
                        }
                    }
                    break;
                case ecConfig.CHART_TYPE_MAP:
                    var name = params.name;
                    var mapType = serie.mapType;
                    for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                        if (shapeList[i].type === &#x27;text&#x27; &amp;&amp; shapeList[i]._mapType === mapType &amp;&amp; shapeList[i].style._name === name) {
                            this._curTarget = shapeList[i];
                            x = this._curTarget.style.x + this._curTarget.position[0];
                            y = this._curTarget.style.y + this._curTarget.position[1];
                            break;
                        }
                    }
                    break;
                case ecConfig.CHART_TYPE_CHORD:
                    var name = params.name;
                    for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                        if (shapeList[i].type === &#x27;sector&#x27; &amp;&amp; ecData.get(shapeList[i], &#x27;name&#x27;) == name) {
                            this._curTarget = shapeList[i];
                            var style = this._curTarget.style;
                            var midAngle = (style.startAngle + style.endAngle) / 2 * Math.PI / 180;
                            x = this._curTarget.style.x + Math.cos(midAngle) * (style.r - 2);
                            y = this._curTarget.style.y - Math.sin(midAngle) * (style.r - 2);
                            this.zr.trigger(zrConfig.EVENT.MOUSEMOVE, {
                                zrenderX: x,
                                zrenderY: y
                            });
                            return;
                        }
                    }
                    break;
                case ecConfig.CHART_TYPE_FORCE:
                    var name = params.name;
                    for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                        if (shapeList[i].type === &#x27;circle&#x27; &amp;&amp; ecData.get(shapeList[i], &#x27;name&#x27;) == name) {
                            this._curTarget = shapeList[i];
                            x = this._curTarget.position[0];
                            y = this._curTarget.position[1];
                            break;
                        }
                    }
                    break;
                }
                if (x != null &amp;&amp; y != null) {
                    this._event = {
                        zrenderX: x,
                        zrenderY: y
                    };
                    this.zr.addHoverShape(this._curTarget);
                    this.zr.refreshHover();
                    this._showItemTrigger();
                }
            }
        },
        hideTip: function () {
            this._hide();
        },
        refresh: function (newOption) {
            this._zrHeight = this.zr.getHeight();
            this._zrWidth = this.zr.getWidth();
            if (this._lastTipShape &amp;&amp; this._lastTipShape.tipShape.length &gt; 0) {
                this.zr.delShape(this._lastTipShape.tipShape);
            }
            this._lastTipShape = false;
            this.shapeList.length = 2;
            this._lastDataIndex = -1;
            this._lastSeriesIndex = -1;
            this._lastItemTriggerId = -1;
            if (newOption) {
                this.option = newOption;
                this.option.tooltip = this.reformOption(this.option.tooltip);
                this.option.tooltip.textStyle = zrUtil.merge(this.option.tooltip.textStyle, this.ecTheme.textStyle);
                this._needAxisTrigger = false;
                if (this.option.tooltip.trigger === &#x27;axis&#x27;) {
                    this._needAxisTrigger = true;
                }
                var series = this.option.series;
                for (var i = 0, l = series.length; i &lt; l; i++) {
                    if (this.query(series[i], &#x27;tooltip.trigger&#x27;) === &#x27;axis&#x27;) {
                        this._needAxisTrigger = true;
                        break;
                    }
                }
                this._showDelay = this.option.tooltip.showDelay;
                this._hideDelay = this.option.tooltip.hideDelay;
                this._defaultCssText = this._style(this.option.tooltip);
                this._setSelectedMap();
                this._axisLineWidth = this.option.tooltip.axisPointer.lineStyle.width;
                this._enterable = this.option.tooltip.enterable;
            }
            if (this.showing) {
                var self = this;
                setTimeout(function () {
                    self.zr.trigger(zrConfig.EVENT.MOUSEMOVE, self.zr.handler._event);
                }, 50);
            }
        },
        onbeforDispose: function () {
            if (this._lastTipShape &amp;&amp; this._lastTipShape.tipShape.length &gt; 0) {
                this.zr.delShape(this._lastTipShape.tipShape);
            }
            clearTimeout(this._hidingTicket);
            clearTimeout(this._showingTicket);
            this.zr.un(zrConfig.EVENT.MOUSEMOVE, this._onmousemove);
            this.zr.un(zrConfig.EVENT.GLOBALOUT, this._onglobalout);
            if (this.hasAppend) {
                this.dom.firstChild.removeChild(this._tDom);
            }
            this._tDom = null;
        },
        _encodeHTML: function (source) {
            return String(source).replace(/&amp;/g, &#x27;&amp;amp;&#x27;).replace(/&lt;/g, &#x27;&amp;lt;&#x27;).replace(/&gt;/g, &#x27;&amp;gt;&#x27;).replace(/&quot;/g, &#x27;&amp;quot;&#x27;).replace(/&#x27;/g, &#x27;&amp;#39;&#x27;);
        }
    };
    zrUtil.inherits(Tooltip, Base);
    require(&#x27;../component&#x27;).define(&#x27;tooltip&#x27;, Tooltip);
    return Tooltip;
});define(&#x27;echarts/component/legend&#x27;, [
    &#x27;require&#x27;,
    &#x27;./base&#x27;,
    &#x27;zrender/shape/Text&#x27;,
    &#x27;zrender/shape/Rectangle&#x27;,
    &#x27;zrender/shape/Sector&#x27;,
    &#x27;../util/shape/Icon&#x27;,
    &#x27;../util/shape/Candle&#x27;,
    &#x27;../config&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;zrender/tool/area&#x27;,
    &#x27;../component&#x27;
], function (require) {
    var Base = require(&#x27;./base&#x27;);
    var TextShape = require(&#x27;zrender/shape/Text&#x27;);
    var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
    var SectorShape = require(&#x27;zrender/shape/Sector&#x27;);
    var IconShape = require(&#x27;../util/shape/Icon&#x27;);
    var CandleShape = require(&#x27;../util/shape/Candle&#x27;);
    var ecConfig = require(&#x27;../config&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    var zrArea = require(&#x27;zrender/tool/area&#x27;);
    function Legend(ecTheme, messageCenter, zr, option, myChart) {
        if (!this.query(option, &#x27;legend.data&#x27;)) {
            console.error(&#x27;option.legend.data has not been defined.&#x27;);
            return;
        }
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        var self = this;
        self._legendSelected = function (param) {
            self.__legendSelected(param);
        };
        self._dispatchHoverLink = function (param) {
            return self.__dispatchHoverLink(param);
        };
        this._colorIndex = 0;
        this._colorMap = {};
        this._selectedMap = {};
        this._hasDataMap = {};
        this.refresh(option);
    }
    Legend.prototype = {
        type: ecConfig.COMPONENT_TYPE_LEGEND,
        _buildShape: function () {
            if (!this.legendOption.show) {
                return;
            }
            this._itemGroupLocation = this._getItemGroupLocation();
            this._buildBackground();
            this._buildItem();
            for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },
        _buildItem: function () {
            var data = this.legendOption.data;
            var dataLength = data.length;
            var itemName;
            var itemType;
            var itemShape;
            var textShape;
            var textStyle = this.legendOption.textStyle;
            var dataTextStyle;
            var dataFont;
            var formattedName;
            var zrWidth = this.zr.getWidth();
            var zrHeight = this.zr.getHeight();
            var lastX = this._itemGroupLocation.x;
            var lastY = this._itemGroupLocation.y;
            var itemWidth = this.legendOption.itemWidth;
            var itemHeight = this.legendOption.itemHeight;
            var itemGap = this.legendOption.itemGap;
            var color;
            if (this.legendOption.orient === &#x27;vertical&#x27; &amp;&amp; this.legendOption.x === &#x27;right&#x27;) {
                lastX = this._itemGroupLocation.x + this._itemGroupLocation.width - itemWidth;
            }
            for (var i = 0; i &lt; dataLength; i++) {
                dataTextStyle = zrUtil.merge(data[i].textStyle || {}, textStyle);
                dataFont = this.getFont(dataTextStyle);
                itemName = this._getName(data[i]);
                formattedName = this._getFormatterName(itemName);
                if (itemName === &#x27;&#x27;) {
                    if (this.legendOption.orient === &#x27;horizontal&#x27;) {
                        lastX = this._itemGroupLocation.x;
                        lastY += itemHeight + itemGap;
                    } else {
                        this.legendOption.x === &#x27;right&#x27; ? lastX -= this._itemGroupLocation.maxWidth + itemGap : lastX += this._itemGroupLocation.maxWidth + itemGap;
                        lastY = this._itemGroupLocation.y;
                    }
                    continue;
                }
                itemType = data[i].icon || this._getSomethingByName(itemName).type;
                color = this.getColor(itemName);
                if (this.legendOption.orient === &#x27;horizontal&#x27;) {
                    if (zrWidth - lastX &lt; 200 &amp;&amp; itemWidth + 5 + zrArea.getTextWidth(formattedName, dataFont) + (i === dataLength - 1 || data[i + 1] === &#x27;&#x27; ? 0 : itemGap) &gt;= zrWidth - lastX) {
                        lastX = this._itemGroupLocation.x;
                        lastY += itemHeight + itemGap;
                    }
                } else {
                    if (zrHeight - lastY &lt; 200 &amp;&amp; itemHeight + (i === dataLength - 1 || data[i + 1] === &#x27;&#x27; ? 0 : itemGap) &gt;= zrHeight - lastY) {
                        this.legendOption.x === &#x27;right&#x27; ? lastX -= this._itemGroupLocation.maxWidth + itemGap : lastX += this._itemGroupLocation.maxWidth + itemGap;
                        lastY = this._itemGroupLocation.y;
                    }
                }
                itemShape = this._getItemShapeByType(lastX, lastY, itemWidth, itemHeight, this._selectedMap[itemName] &amp;&amp; this._hasDataMap[itemName] ? color : &#x27;#ccc&#x27;, itemType, color);
                itemShape._name = itemName;
                itemShape = new IconShape(itemShape);
                textShape = {
                    zlevel: this._zlevelBase,
                    style: {
                        x: lastX + itemWidth + 5,
                        y: lastY + itemHeight / 2,
                        color: this._selectedMap[itemName] ? dataTextStyle.color === &#x27;auto&#x27; ? color : dataTextStyle.color : &#x27;#ccc&#x27;,
                        text: formattedName,
                        textFont: dataFont,
                        textBaseline: &#x27;middle&#x27;
                    },
                    highlightStyle: {
                        color: color,
                        brushType: &#x27;fill&#x27;
                    },
                    hoverable: !!this.legendOption.selectedMode,
                    clickable: !!this.legendOption.selectedMode
                };
                if (this.legendOption.orient === &#x27;vertical&#x27; &amp;&amp; this.legendOption.x === &#x27;right&#x27;) {
                    textShape.style.x -= itemWidth + 10;
                    textShape.style.textAlign = &#x27;right&#x27;;
                }
                textShape._name = itemName;
                textShape = new TextShape(textShape);
                if (this.legendOption.selectedMode) {
                    itemShape.onclick = textShape.onclick = this._legendSelected;
                    itemShape.onmouseover = textShape.onmouseover = this._dispatchHoverLink;
                    itemShape.hoverConnect = textShape.id;
                    textShape.hoverConnect = itemShape.id;
                }
                this.shapeList.push(itemShape);
                this.shapeList.push(textShape);
                if (this.legendOption.orient === &#x27;horizontal&#x27;) {
                    lastX += itemWidth + 5 + zrArea.getTextWidth(formattedName, dataFont) + itemGap;
                } else {
                    lastY += itemHeight + itemGap;
                }
            }
            if (this.legendOption.orient === &#x27;horizontal&#x27; &amp;&amp; this.legendOption.x === &#x27;center&#x27; &amp;&amp; lastY != this._itemGroupLocation.y) {
                this._mLineOptimize();
            }
        },
        _getName: function (data) {
            return typeof data.name != &#x27;undefined&#x27; ? data.name : data;
        },
        _getFormatterName: function (itemName) {
            var formatter = this.legendOption.formatter;
            var formattedName;
            if (typeof formatter === &#x27;function&#x27;) {
                formattedName = formatter.call(this.myChart, itemName);
            } else if (typeof formatter === &#x27;string&#x27;) {
                formattedName = formatter.replace(&#x27;{name}&#x27;, itemName);
            } else {
                formattedName = itemName;
            }
            return formattedName;
        },
        _getFormatterNameFromData: function (data) {
            var itemName = this._getName(data);
            return this._getFormatterName(itemName);
        },
        _mLineOptimize: function () {
            var lineOffsetArray = [];
            var lastX = this._itemGroupLocation.x;
            for (var i = 2, l = this.shapeList.length; i &lt; l; i++) {
                if (this.shapeList[i].style.x === lastX) {
                    lineOffsetArray.push((this._itemGroupLocation.width - (this.shapeList[i - 1].style.x + zrArea.getTextWidth(this.shapeList[i - 1].style.text, this.shapeList[i - 1].style.textFont) - lastX)) / 2);
                } else if (i === l - 1) {
                    lineOffsetArray.push((this._itemGroupLocation.width - (this.shapeList[i].style.x + zrArea.getTextWidth(this.shapeList[i].style.text, this.shapeList[i].style.textFont) - lastX)) / 2);
                }
            }
            var curLineIndex = -1;
            for (var i = 1, l = this.shapeList.length; i &lt; l; i++) {
                if (this.shapeList[i].style.x === lastX) {
                    curLineIndex++;
                }
                if (lineOffsetArray[curLineIndex] === 0) {
                    continue;
                } else {
                    this.shapeList[i].style.x += lineOffsetArray[curLineIndex];
                }
            }
        },
        _buildBackground: function () {
            var padding = this.reformCssArray(this.legendOption.padding);
            this.shapeList.push(new RectangleShape({
                zlevel: this._zlevelBase,
                hoverable: false,
                style: {
                    x: this._itemGroupLocation.x - padding[3],
                    y: this._itemGroupLocation.y - padding[0],
                    width: this._itemGroupLocation.width + padding[3] + padding[1],
                    height: this._itemGroupLocation.height + padding[0] + padding[2],
                    brushType: this.legendOption.borderWidth === 0 ? &#x27;fill&#x27; : &#x27;both&#x27;,
                    color: this.legendOption.backgroundColor,
                    strokeColor: this.legendOption.borderColor,
                    lineWidth: this.legendOption.borderWidth
                }
            }));
        },
        _getItemGroupLocation: function () {
            var data = this.legendOption.data;
            var dataLength = data.length;
            var itemGap = this.legendOption.itemGap;
            var itemWidth = this.legendOption.itemWidth + 5;
            var itemHeight = this.legendOption.itemHeight;
            var textStyle = this.legendOption.textStyle;
            var font = this.getFont(textStyle);
            var totalWidth = 0;
            var totalHeight = 0;
            var padding = this.reformCssArray(this.legendOption.padding);
            var zrWidth = this.zr.getWidth() - padding[1] - padding[3];
            var zrHeight = this.zr.getHeight() - padding[0] - padding[2];
            var temp = 0;
            var maxWidth = 0;
            if (this.legendOption.orient === &#x27;horizontal&#x27;) {
                totalHeight = itemHeight;
                for (var i = 0; i &lt; dataLength; i++) {
                    if (this._getName(data[i]) === &#x27;&#x27;) {
                        temp -= itemGap;
                        if (temp &gt; zrWidth) {
                            totalWidth = zrWidth;
                            totalHeight += itemHeight + itemGap;
                        } else {
                            totalWidth = Math.max(totalWidth, temp);
                        }
                        totalHeight += itemHeight + itemGap;
                        temp = 0;
                        continue;
                    }
                    temp += itemWidth + zrArea.getTextWidth(this._getFormatterNameFromData(data[i]), data[i].textStyle ? this.getFont(zrUtil.merge(data[i].textStyle || {}, textStyle)) : font) + itemGap;
                }
                totalHeight = Math.max(totalHeight, itemHeight);
                temp -= itemGap;
                if (temp &gt; zrWidth) {
                    totalWidth = zrWidth;
                    totalHeight += itemHeight + itemGap;
                } else {
                    totalWidth = Math.max(totalWidth, temp);
                }
            } else {
                for (var i = 0; i &lt; dataLength; i++) {
                    maxWidth = Math.max(maxWidth, zrArea.getTextWidth(this._getFormatterNameFromData(data[i]), data[i].textStyle ? this.getFont(zrUtil.merge(data[i].textStyle || {}, textStyle)) : font));
                }
                maxWidth += itemWidth;
                totalWidth = maxWidth;
                for (var i = 0; i &lt; dataLength; i++) {
                    if (this._getName(data[i]) === &#x27;&#x27;) {
                        temp -= itemGap;
                        if (temp &gt; zrHeight) {
                            totalHeight = zrHeight;
                            totalWidth += maxWidth + itemGap;
                        } else {
                            totalHeight = Math.max(totalHeight, temp);
                        }
                        totalWidth += maxWidth + itemGap;
                        temp = 0;
                        continue;
                    }
                    temp += itemHeight + itemGap;
                }
                totalWidth = Math.max(totalWidth, maxWidth);
                temp -= itemGap;
                if (temp &gt; zrHeight) {
                    totalHeight = zrHeight;
                    totalWidth += maxWidth + itemGap;
                } else {
                    totalHeight = Math.max(totalHeight, temp);
                }
            }
            zrWidth = this.zr.getWidth();
            zrHeight = this.zr.getHeight();
            var x;
            switch (this.legendOption.x) {
            case &#x27;center&#x27;:
                x = Math.floor((zrWidth - totalWidth) / 2);
                break;
            case &#x27;left&#x27;:
                x = padding[3] + this.legendOption.borderWidth;
                break;
            case &#x27;right&#x27;:
                x = zrWidth - totalWidth - padding[1] - padding[3] - this.legendOption.borderWidth * 2;
                break;
            default:
                x = this.parsePercent(this.legendOption.x, zrWidth);
                break;
            }
            var y;
            switch (this.legendOption.y) {
            case &#x27;top&#x27;:
                y = padding[0] + this.legendOption.borderWidth;
                break;
            case &#x27;bottom&#x27;:
                y = zrHeight - totalHeight - padding[0] - padding[2] - this.legendOption.borderWidth * 2;
                break;
            case &#x27;center&#x27;:
                y = Math.floor((zrHeight - totalHeight) / 2);
                break;
            default:
                y = this.parsePercent(this.legendOption.y, zrHeight);
                break;
            }
            return {
                x: x,
                y: y,
                width: totalWidth,
                height: totalHeight,
                maxWidth: maxWidth
            };
        },
        _getSomethingByName: function (name) {
            var series = this.option.series;
            var data;
            for (var i = 0, l = series.length; i &lt; l; i++) {
                if (series[i].name === name) {
                    return {
                        type: series[i].type,
                        series: series[i],
                        seriesIndex: i,
                        data: null,
                        dataIndex: -1
                    };
                }
                if (series[i].type === ecConfig.CHART_TYPE_PIE || series[i].type === ecConfig.CHART_TYPE_RADAR || series[i].type === ecConfig.CHART_TYPE_CHORD || series[i].type === ecConfig.CHART_TYPE_FORCE || series[i].type === ecConfig.CHART_TYPE_FUNNEL) {
                    data = series[i].categories || series[i].data || series[i].nodes;
                    for (var j = 0, k = data.length; j &lt; k; j++) {
                        if (data[j].name === name) {
                            return {
                                type: series[i].type,
                                series: series[i],
                                seriesIndex: i,
                                data: data[j],
                                dataIndex: j
                            };
                        }
                    }
                }
            }
            return {
                type: &#x27;bar&#x27;,
                series: null,
                seriesIndex: -1,
                data: null,
                dataIndex: -1
            };
        },
        _getItemShapeByType: function (x, y, width, height, color, itemType, defaultColor) {
            var highlightColor = color === &#x27;#ccc&#x27; ? defaultColor : color;
            var itemShape = {
                zlevel: this._zlevelBase,
                style: {
                    iconType: &#x27;legendicon&#x27; + itemType,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    color: color,
                    strokeColor: color,
                    lineWidth: 2
                },
                highlightStyle: {
                    color: highlightColor,
                    strokeColor: highlightColor,
                    lineWidth: 1
                },
                hoverable: this.legendOption.selectedMode,
                clickable: this.legendOption.selectedMode
            };
            var imageLocation;
            if (itemType.match(&#x27;image&#x27;)) {
                var imageLocation = itemType.replace(new RegExp(&#x27;^image:\\/\\/&#x27;), &#x27;&#x27;);
                itemType = &#x27;image&#x27;;
            }
            switch (itemType) {
            case &#x27;line&#x27;:
                itemShape.style.brushType = &#x27;stroke&#x27;;
                itemShape.highlightStyle.lineWidth = 3;
                break;
            case &#x27;radar&#x27;:
            case &#x27;scatter&#x27;:
                itemShape.highlightStyle.lineWidth = 3;
                break;
            case &#x27;k&#x27;:
                itemShape.style.brushType = &#x27;both&#x27;;
                itemShape.highlightStyle.lineWidth = 3;
                itemShape.highlightStyle.color = itemShape.style.color = this.query(this.ecTheme, &#x27;k.itemStyle.normal.color&#x27;) || &#x27;#fff&#x27;;
                itemShape.style.strokeColor = color != &#x27;#ccc&#x27; ? this.query(this.ecTheme, &#x27;k.itemStyle.normal.lineStyle.color&#x27;) || &#x27;#ff3200&#x27; : color;
                break;
            case &#x27;image&#x27;:
                itemShape.style.iconType = &#x27;image&#x27;;
                itemShape.style.image = imageLocation;
                if (color === &#x27;#ccc&#x27;) {
                    itemShape.style.opacity = 0.5;
                }
                break;
            }
            return itemShape;
        },
        __legendSelected: function (param) {
            var itemName = param.target._name;
            if (this.legendOption.selectedMode === &#x27;single&#x27;) {
                for (var k in this._selectedMap) {
                    this._selectedMap[k] = false;
                }
            }
            this._selectedMap[itemName] = !this._selectedMap[itemName];
            this.messageCenter.dispatch(ecConfig.EVENT.LEGEND_SELECTED, param.event, {
                selected: this._selectedMap,
                target: itemName
            }, this.myChart);
        },
        __dispatchHoverLink: function (param) {
            this.messageCenter.dispatch(ecConfig.EVENT.LEGEND_HOVERLINK, param.event, { target: param.target._name }, this.myChart);
            return;
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption || this.option;
                this.option.legend = this.reformOption(this.option.legend);
                this.legendOption = this.option.legend;
                var data = this.legendOption.data || [];
                var itemName;
                var something;
                var color;
                var queryTarget;
                if (this.legendOption.selected) {
                    for (var k in this.legendOption.selected) {
                        this._selectedMap[k] = typeof this._selectedMap[k] != &#x27;undefined&#x27; ? this._selectedMap[k] : this.legendOption.selected[k];
                    }
                }
                for (var i = 0, dataLength = data.length; i &lt; dataLength; i++) {
                    itemName = this._getName(data[i]);
                    if (itemName === &#x27;&#x27;) {
                        continue;
                    }
                    something = this._getSomethingByName(itemName);
                    if (!something.series) {
                        this._hasDataMap[itemName] = false;
                    } else {
                        this._hasDataMap[itemName] = true;
                        if (something.data &amp;&amp; (something.type === ecConfig.CHART_TYPE_PIE || something.type === ecConfig.CHART_TYPE_FORCE || something.type === ecConfig.CHART_TYPE_FUNNEL)) {
                            queryTarget = [
                                something.data,
                                something.series
                            ];
                        } else {
                            queryTarget = [something.series];
                        }
                        color = this.getItemStyleColor(this.deepQuery(queryTarget, &#x27;itemStyle.normal.color&#x27;), something.seriesIndex, something.dataIndex, something.data);
                        if (color &amp;&amp; something.type != ecConfig.CHART_TYPE_K) {
                            this.setColor(itemName, color);
                        }
                        this._selectedMap[itemName] = this._selectedMap[itemName] != null ? this._selectedMap[itemName] : true;
                    }
                }
            }
            this.clear();
            this._buildShape();
        },
        getRelatedAmount: function (name) {
            var amount = 0;
            var series = this.option.series;
            var data;
            for (var i = 0, l = series.length; i &lt; l; i++) {
                if (series[i].name === name) {
                    amount++;
                }
                if (series[i].type === ecConfig.CHART_TYPE_PIE || series[i].type === ecConfig.CHART_TYPE_RADAR || series[i].type === ecConfig.CHART_TYPE_CHORD || series[i].type === ecConfig.CHART_TYPE_FORCE || series[i].type === ecConfig.CHART_TYPE_FUNNEL) {
                    data = series[i].type != ecConfig.CHART_TYPE_FORCE ? series[i].data : series[i].categories;
                    for (var j = 0, k = data.length; j &lt; k; j++) {
                        if (data[j].name === name &amp;&amp; data[j].value != &#x27;-&#x27;) {
                            amount++;
                        }
                    }
                }
            }
            return amount;
        },
        setColor: function (legendName, color) {
            this._colorMap[legendName] = color;
        },
        getColor: function (legendName) {
            if (!this._colorMap[legendName]) {
                this._colorMap[legendName] = this.zr.getColor(this._colorIndex++);
            }
            return this._colorMap[legendName];
        },
        hasColor: function (legendName) {
            return this._colorMap[legendName] ? this._colorMap[legendName] : false;
        },
        add: function (name, color) {
            var data = this.legendOption.data;
            for (var i = 0, dataLength = data.length; i &lt; dataLength; i++) {
                if (this._getName(data[i]) === name) {
                    return;
                }
            }
            this.legendOption.data.push(name);
            this.setColor(name, color);
            this._selectedMap[name] = true;
            this._hasDataMap[name] = true;
        },
        del: function (name) {
            var data = this.legendOption.data;
            for (var i = 0, dataLength = data.length; i &lt; dataLength; i++) {
                if (this._getName(data[i]) === name) {
                    return this.legendOption.data.splice(i, 1);
                }
            }
        },
        getItemShape: function (name) {
            if (name == null) {
                return;
            }
            var shape;
            for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                shape = this.shapeList[i];
                if (shape._name === name &amp;&amp; shape.type != &#x27;text&#x27;) {
                    return shape;
                }
            }
        },
        setItemShape: function (name, itemShape) {
            var shape;
            for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                shape = this.shapeList[i];
                if (shape._name === name &amp;&amp; shape.type != &#x27;text&#x27;) {
                    if (!this._selectedMap[name]) {
                        itemShape.style.color = &#x27;#ccc&#x27;;
                        itemShape.style.strokeColor = &#x27;#ccc&#x27;;
                    }
                    this.zr.modShape(shape.id, itemShape);
                }
            }
        },
        isSelected: function (itemName) {
            if (typeof this._selectedMap[itemName] != &#x27;undefined&#x27;) {
                return this._selectedMap[itemName];
            } else {
                return true;
            }
        },
        getSelectedMap: function () {
            return this._selectedMap;
        },
        setSelected: function (itemName, selectStatus) {
            if (this.legendOption.selectedMode === &#x27;single&#x27;) {
                for (var k in this._selectedMap) {
                    this._selectedMap[k] = false;
                }
            }
            this._selectedMap[itemName] = selectStatus;
            this.messageCenter.dispatch(ecConfig.EVENT.LEGEND_SELECTED, null, {
                selected: this._selectedMap,
                target: itemName
            }, this.myChart);
        },
        onlegendSelected: function (param, status) {
            var legendSelected = param.selected;
            for (var itemName in legendSelected) {
                if (this._selectedMap[itemName] != legendSelected[itemName]) {
                    status.needRefresh = true;
                }
                this._selectedMap[itemName] = legendSelected[itemName];
            }
            return;
        }
    };
    var legendIcon = {
        line: function (ctx, style) {
            var dy = style.height / 2;
            ctx.moveTo(style.x, style.y + dy);
            ctx.lineTo(style.x + style.width, style.y + dy);
        },
        pie: function (ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            SectorShape.prototype.buildPath(ctx, {
                x: x + width / 2,
                y: y + height + 2,
                r: height + 2,
                r0: 6,
                startAngle: 45,
                endAngle: 135
            });
        },
        eventRiver: function (ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            ctx.moveTo(x, y + height);
            ctx.bezierCurveTo(x + width, y + height, x, y + 4, x + width, y + 4);
            ctx.lineTo(x + width, y);
            ctx.bezierCurveTo(x, y, x + width, y + height - 4, x, y + height - 4);
            ctx.lineTo(x, y + height);
        },
        k: function (ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            CandleShape.prototype.buildPath(ctx, {
                x: x + width / 2,
                y: [
                    y + 1,
                    y + 1,
                    y + height - 6,
                    y + height
                ],
                width: width - 6
            });
        },
        bar: function (ctx, style) {
            var x = style.x;
            var y = style.y + 1;
            var width = style.width;
            var height = style.height - 2;
            var r = 3;
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + width - r, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + r);
            ctx.lineTo(x + width, y + height - r);
            ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
            ctx.lineTo(x + r, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
        },
        force: function (ctx, style) {
            IconShape.prototype.iconLibrary.circle(ctx, style);
        },
        radar: function (ctx, style) {
            var n = 6;
            var x = style.x + style.width / 2;
            var y = style.y + style.height / 2;
            var r = style.height / 2;
            var dStep = 2 * Math.PI / n;
            var deg = -Math.PI / 2;
            var xStart = x + r * Math.cos(deg);
            var yStart = y + r * Math.sin(deg);
            ctx.moveTo(xStart, yStart);
            deg += dStep;
            for (var i = 0, end = n - 1; i &lt; end; i++) {
                ctx.lineTo(x + r * Math.cos(deg), y + r * Math.sin(deg));
                deg += dStep;
            }
            ctx.lineTo(xStart, yStart);
        }
    };
    legendIcon.chord = legendIcon.pie;
    legendIcon.map = legendIcon.bar;
    for (var k in legendIcon) {
        IconShape.prototype.iconLibrary[&#x27;legendicon&#x27; + k] = legendIcon[k];
    }
    zrUtil.inherits(Legend, Base);
    require(&#x27;../component&#x27;).define(&#x27;legend&#x27;, Legend);
    return Legend;
});define(&#x27;echarts/util/ecData&#x27;, [], function () {
    function pack(shape, series, seriesIndex, data, dataIndex, name, special, special2) {
        var value;
        if (typeof data != &#x27;undefined&#x27;) {
            value = data.value == null ? data : data.value;
        }
        shape._echartsData = {
            &#x27;_series&#x27;: series,
            &#x27;_seriesIndex&#x27;: seriesIndex,
            &#x27;_data&#x27;: data,
            &#x27;_dataIndex&#x27;: dataIndex,
            &#x27;_name&#x27;: name,
            &#x27;_value&#x27;: value,
            &#x27;_special&#x27;: special,
            &#x27;_special2&#x27;: special2
        };
        return shape._echartsData;
    }
    function get(shape, key) {
        var data = shape._echartsData;
        if (!key) {
            return data;
        }
        switch (key) {
        case &#x27;series&#x27;:
        case &#x27;seriesIndex&#x27;:
        case &#x27;data&#x27;:
        case &#x27;dataIndex&#x27;:
        case &#x27;name&#x27;:
        case &#x27;value&#x27;:
        case &#x27;special&#x27;:
        case &#x27;special2&#x27;:
            return data &amp;&amp; data[&#x27;_&#x27; + key];
        }
        return null;
    }
    function set(shape, key, value) {
        shape._echartsData = shape._echartsData || {};
        switch (key) {
        case &#x27;series&#x27;:
        case &#x27;seriesIndex&#x27;:
        case &#x27;data&#x27;:
        case &#x27;dataIndex&#x27;:
        case &#x27;name&#x27;:
        case &#x27;value&#x27;:
        case &#x27;special&#x27;:
        case &#x27;special2&#x27;:
            shape._echartsData[&#x27;_&#x27; + key] = value;
            break;
        }
    }
    function clone(source, target) {
        target._echartsData = {
            &#x27;_series&#x27;: source._echartsData._series,
            &#x27;_seriesIndex&#x27;: source._echartsData._seriesIndex,
            &#x27;_data&#x27;: source._echartsData._data,
            &#x27;_dataIndex&#x27;: source._echartsData._dataIndex,
            &#x27;_name&#x27;: source._echartsData._name,
            &#x27;_value&#x27;: source._echartsData._value,
            &#x27;_special&#x27;: source._echartsData._special,
            &#x27;_special2&#x27;: source._echartsData._special2
        };
    }
    return {
        pack: pack,
        set: set,
        get: get,
        clone: clone
    };
});define(&#x27;echarts/chart&#x27;, [], function () {
    var self = {};
    var _chartLibrary = {};
    self.define = function (name, clazz) {
        _chartLibrary[name] = clazz;
        return self;
    };
    self.get = function (name) {
        return _chartLibrary[name];
    };
    return self;
});define(&#x27;zrender/tool/color&#x27;, [
    &#x27;require&#x27;,
    &#x27;../tool/util&#x27;
], function (require) {
    var util = require(&#x27;../tool/util&#x27;);
    var _ctx;
    var palette = [
        &#x27;#ff9277&#x27;,
        &#x27; #dddd00&#x27;,
        &#x27; #ffc877&#x27;,
        &#x27; #bbe3ff&#x27;,
        &#x27; #d5ffbb&#x27;,
        &#x27;#bbbbff&#x27;,
        &#x27; #ddb000&#x27;,
        &#x27; #b0dd00&#x27;,
        &#x27; #e2bbff&#x27;,
        &#x27; #ffbbe3&#x27;,
        &#x27;#ff7777&#x27;,
        &#x27; #ff9900&#x27;,
        &#x27; #83dd00&#x27;,
        &#x27; #77e3ff&#x27;,
        &#x27; #778fff&#x27;,
        &#x27;#c877ff&#x27;,
        &#x27; #ff77ab&#x27;,
        &#x27; #ff6600&#x27;,
        &#x27; #aa8800&#x27;,
        &#x27; #77c7ff&#x27;,
        &#x27;#ad77ff&#x27;,
        &#x27; #ff77ff&#x27;,
        &#x27; #dd0083&#x27;,
        &#x27; #777700&#x27;,
        &#x27; #00aa00&#x27;,
        &#x27;#0088aa&#x27;,
        &#x27; #8400dd&#x27;,
        &#x27; #aa0088&#x27;,
        &#x27; #dd0000&#x27;,
        &#x27; #772e00&#x27;
    ];
    var _palette = palette;
    var highlightColor = &#x27;rgba(255,255,0,0.5)&#x27;;
    var _highlightColor = highlightColor;
    var colorRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;
    var _nameColors = {
        aliceblue: &#x27;#f0f8ff&#x27;,
        antiquewhite: &#x27;#faebd7&#x27;,
        aqua: &#x27;#0ff&#x27;,
        aquamarine: &#x27;#7fffd4&#x27;,
        azure: &#x27;#f0ffff&#x27;,
        beige: &#x27;#f5f5dc&#x27;,
        bisque: &#x27;#ffe4c4&#x27;,
        black: &#x27;#000&#x27;,
        blanchedalmond: &#x27;#ffebcd&#x27;,
        blue: &#x27;#00f&#x27;,
        blueviolet: &#x27;#8a2be2&#x27;,
        brown: &#x27;#a52a2a&#x27;,
        burlywood: &#x27;#deb887&#x27;,
        cadetblue: &#x27;#5f9ea0&#x27;,
        chartreuse: &#x27;#7fff00&#x27;,
        chocolate: &#x27;#d2691e&#x27;,
        coral: &#x27;#ff7f50&#x27;,
        cornflowerblue: &#x27;#6495ed&#x27;,
        cornsilk: &#x27;#fff8dc&#x27;,
        crimson: &#x27;#dc143c&#x27;,
        cyan: &#x27;#0ff&#x27;,
        darkblue: &#x27;#00008b&#x27;,
        darkcyan: &#x27;#008b8b&#x27;,
        darkgoldenrod: &#x27;#b8860b&#x27;,
        darkgray: &#x27;#a9a9a9&#x27;,
        darkgrey: &#x27;#a9a9a9&#x27;,
        darkgreen: &#x27;#006400&#x27;,
        darkkhaki: &#x27;#bdb76b&#x27;,
        darkmagenta: &#x27;#8b008b&#x27;,
        darkolivegreen: &#x27;#556b2f&#x27;,
        darkorange: &#x27;#ff8c00&#x27;,
        darkorchid: &#x27;#9932cc&#x27;,
        darkred: &#x27;#8b0000&#x27;,
        darksalmon: &#x27;#e9967a&#x27;,
        darkseagreen: &#x27;#8fbc8f&#x27;,
        darkslateblue: &#x27;#483d8b&#x27;,
        darkslategray: &#x27;#2f4f4f&#x27;,
        darkslategrey: &#x27;#2f4f4f&#x27;,
        darkturquoise: &#x27;#00ced1&#x27;,
        darkviolet: &#x27;#9400d3&#x27;,
        deeppink: &#x27;#ff1493&#x27;,
        deepskyblue: &#x27;#00bfff&#x27;,
        dimgray: &#x27;#696969&#x27;,
        dimgrey: &#x27;#696969&#x27;,
        dodgerblue: &#x27;#1e90ff&#x27;,
        firebrick: &#x27;#b22222&#x27;,
        floralwhite: &#x27;#fffaf0&#x27;,
        forestgreen: &#x27;#228b22&#x27;,
        fuchsia: &#x27;#f0f&#x27;,
        gainsboro: &#x27;#dcdcdc&#x27;,
        ghostwhite: &#x27;#f8f8ff&#x27;,
        gold: &#x27;#ffd700&#x27;,
        goldenrod: &#x27;#daa520&#x27;,
        gray: &#x27;#808080&#x27;,
        grey: &#x27;#808080&#x27;,
        green: &#x27;#008000&#x27;,
        greenyellow: &#x27;#adff2f&#x27;,
        honeydew: &#x27;#f0fff0&#x27;,
        hotpink: &#x27;#ff69b4&#x27;,
        indianred: &#x27;#cd5c5c&#x27;,
        indigo: &#x27;#4b0082&#x27;,
        ivory: &#x27;#fffff0&#x27;,
        khaki: &#x27;#f0e68c&#x27;,
        lavender: &#x27;#e6e6fa&#x27;,
        lavenderblush: &#x27;#fff0f5&#x27;,
        lawngreen: &#x27;#7cfc00&#x27;,
        lemonchiffon: &#x27;#fffacd&#x27;,
        lightblue: &#x27;#add8e6&#x27;,
        lightcoral: &#x27;#f08080&#x27;,
        lightcyan: &#x27;#e0ffff&#x27;,
        lightgoldenrodyellow: &#x27;#fafad2&#x27;,
        lightgray: &#x27;#d3d3d3&#x27;,
        lightgrey: &#x27;#d3d3d3&#x27;,
        lightgreen: &#x27;#90ee90&#x27;,
        lightpink: &#x27;#ffb6c1&#x27;,
        lightsalmon: &#x27;#ffa07a&#x27;,
        lightseagreen: &#x27;#20b2aa&#x27;,
        lightskyblue: &#x27;#87cefa&#x27;,
        lightslategray: &#x27;#789&#x27;,
        lightslategrey: &#x27;#789&#x27;,
        lightsteelblue: &#x27;#b0c4de&#x27;,
        lightyellow: &#x27;#ffffe0&#x27;,
        lime: &#x27;#0f0&#x27;,
        limegreen: &#x27;#32cd32&#x27;,
        linen: &#x27;#faf0e6&#x27;,
        magenta: &#x27;#f0f&#x27;,
        maroon: &#x27;#800000&#x27;,
        mediumaquamarine: &#x27;#66cdaa&#x27;,
        mediumblue: &#x27;#0000cd&#x27;,
        mediumorchid: &#x27;#ba55d3&#x27;,
        mediumpurple: &#x27;#9370d8&#x27;,
        mediumseagreen: &#x27;#3cb371&#x27;,
        mediumslateblue: &#x27;#7b68ee&#x27;,
        mediumspringgreen: &#x27;#00fa9a&#x27;,
        mediumturquoise: &#x27;#48d1cc&#x27;,
        mediumvioletred: &#x27;#c71585&#x27;,
        midnightblue: &#x27;#191970&#x27;,
        mintcream: &#x27;#f5fffa&#x27;,
        mistyrose: &#x27;#ffe4e1&#x27;,
        moccasin: &#x27;#ffe4b5&#x27;,
        navajowhite: &#x27;#ffdead&#x27;,
        navy: &#x27;#000080&#x27;,
        oldlace: &#x27;#fdf5e6&#x27;,
        olive: &#x27;#808000&#x27;,
        olivedrab: &#x27;#6b8e23&#x27;,
        orange: &#x27;#ffa500&#x27;,
        orangered: &#x27;#ff4500&#x27;,
        orchid: &#x27;#da70d6&#x27;,
        palegoldenrod: &#x27;#eee8aa&#x27;,
        palegreen: &#x27;#98fb98&#x27;,
        paleturquoise: &#x27;#afeeee&#x27;,
        palevioletred: &#x27;#d87093&#x27;,
        papayawhip: &#x27;#ffefd5&#x27;,
        peachpuff: &#x27;#ffdab9&#x27;,
        peru: &#x27;#cd853f&#x27;,
        pink: &#x27;#ffc0cb&#x27;,
        plum: &#x27;#dda0dd&#x27;,
        powderblue: &#x27;#b0e0e6&#x27;,
        purple: &#x27;#800080&#x27;,
        red: &#x27;#f00&#x27;,
        rosybrown: &#x27;#bc8f8f&#x27;,
        royalblue: &#x27;#4169e1&#x27;,
        saddlebrown: &#x27;#8b4513&#x27;,
        salmon: &#x27;#fa8072&#x27;,
        sandybrown: &#x27;#f4a460&#x27;,
        seagreen: &#x27;#2e8b57&#x27;,
        seashell: &#x27;#fff5ee&#x27;,
        sienna: &#x27;#a0522d&#x27;,
        silver: &#x27;#c0c0c0&#x27;,
        skyblue: &#x27;#87ceeb&#x27;,
        slateblue: &#x27;#6a5acd&#x27;,
        slategray: &#x27;#708090&#x27;,
        slategrey: &#x27;#708090&#x27;,
        snow: &#x27;#fffafa&#x27;,
        springgreen: &#x27;#00ff7f&#x27;,
        steelblue: &#x27;#4682b4&#x27;,
        tan: &#x27;#d2b48c&#x27;,
        teal: &#x27;#008080&#x27;,
        thistle: &#x27;#d8bfd8&#x27;,
        tomato: &#x27;#ff6347&#x27;,
        turquoise: &#x27;#40e0d0&#x27;,
        violet: &#x27;#ee82ee&#x27;,
        wheat: &#x27;#f5deb3&#x27;,
        white: &#x27;#fff&#x27;,
        whitesmoke: &#x27;#f5f5f5&#x27;,
        yellow: &#x27;#ff0&#x27;,
        yellowgreen: &#x27;#9acd32&#x27;
    };
    function customPalette(userPalete) {
        palette = userPalete;
    }
    function resetPalette() {
        palette = _palette;
    }
    function getColor(idx, userPalete) {
        idx = idx | 0;
        userPalete = userPalete || palette;
        return userPalete[idx % userPalete.length];
    }
    function customHighlight(userHighlightColor) {
        highlightColor = userHighlightColor;
    }
    function resetHighlight() {
        _highlightColor = highlightColor;
    }
    function getHighlightColor() {
        return highlightColor;
    }
    function getRadialGradient(x0, y0, r0, x1, y1, r1, colorList) {
        if (!_ctx) {
            _ctx = util.getContext();
        }
        var gradient = _ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
        for (var i = 0, l = colorList.length; i &lt; l; i++) {
            gradient.addColorStop(colorList[i][0], colorList[i][1]);
        }
        gradient.__nonRecursion = true;
        return gradient;
    }
    function getLinearGradient(x0, y0, x1, y1, colorList) {
        if (!_ctx) {
            _ctx = util.getContext();
        }
        var gradient = _ctx.createLinearGradient(x0, y0, x1, y1);
        for (var i = 0, l = colorList.length; i &lt; l; i++) {
            gradient.addColorStop(colorList[i][0], colorList[i][1]);
        }
        gradient.__nonRecursion = true;
        return gradient;
    }
    function getStepColors(start, end, step) {
        start = toRGBA(start);
        end = toRGBA(end);
        start = getData(start);
        end = getData(end);
        var colors = [];
        var stepR = (end[0] - start[0]) / step;
        var stepG = (end[1] - start[1]) / step;
        var stepB = (end[2] - start[2]) / step;
        var stepA = (end[3] - start[3]) / step;
        for (var i = 0, r = start[0], g = start[1], b = start[2], a = start[3]; i &lt; step; i++) {
            colors[i] = toColor([
                adjust(Math.floor(r), [
                    0,
                    255
                ]),
                adjust(Math.floor(g), [
                    0,
                    255
                ]),
                adjust(Math.floor(b), [
                    0,
                    255
                ]),
                a.toFixed(4) - 0
            ], &#x27;rgba&#x27;);
            r += stepR;
            g += stepG;
            b += stepB;
            a += stepA;
        }
        r = end[0];
        g = end[1];
        b = end[2];
        a = end[3];
        colors[i] = toColor([
            r,
            g,
            b,
            a
        ], &#x27;rgba&#x27;);
        return colors;
    }
    function getGradientColors(colors, step) {
        var ret = [];
        var len = colors.length;
        if (step === undefined) {
            step = 20;
        }
        if (len === 1) {
            ret = getStepColors(colors[0], colors[0], step);
        } else if (len &gt; 1) {
            for (var i = 0, n = len - 1; i &lt; n; i++) {
                var steps = getStepColors(colors[i], colors[i + 1], step);
                if (i &lt; n - 1) {
                    steps.pop();
                }
                ret = ret.concat(steps);
            }
        }
        return ret;
    }
    function toColor(data, format) {
        format = format || &#x27;rgb&#x27;;
        if (data &amp;&amp; (data.length === 3 || data.length === 4)) {
            data = map(data, function (c) {
                return c &gt; 1 ? Math.ceil(c) : c;
            });
            if (format.indexOf(&#x27;hex&#x27;) &gt; -1) {
                return &#x27;#&#x27; + ((1 &lt;&lt; 24) + (data[0] &lt;&lt; 16) + (data[1] &lt;&lt; 8) + +data[2]).toString(16).slice(1);
            } else if (format.indexOf(&#x27;hs&#x27;) &gt; -1) {
                var sx = map(data.slice(1, 3), function (c) {
                    return c + &#x27;%&#x27;;
                });
                data[1] = sx[0];
                data[2] = sx[1];
            }
            if (format.indexOf(&#x27;a&#x27;) &gt; -1) {
                if (data.length === 3) {
                    data.push(1);
                }
                data[3] = adjust(data[3], [
                    0,
                    1
                ]);
                return format + &#x27;(&#x27; + data.slice(0, 4).join(&#x27;,&#x27;) + &#x27;)&#x27;;
            }
            return format + &#x27;(&#x27; + data.slice(0, 3).join(&#x27;,&#x27;) + &#x27;)&#x27;;
        }
    }
    function toArray(color) {
        color = trim(color);
        if (color.indexOf(&#x27;rgba&#x27;) &lt; 0) {
            color = toRGBA(color);
        }
        var data = [];
        var i = 0;
        color.replace(/[\d.]+/g, function (n) {
            if (i &lt; 3) {
                n = n | 0;
            } else {
                n = +n;
            }
            data[i++] = n;
        });
        return data;
    }
    function convert(color, format) {
        if (!isCalculableColor(color)) {
            return color;
        }
        var data = getData(color);
        var alpha = data[3];
        if (typeof alpha === &#x27;undefined&#x27;) {
            alpha = 1;
        }
        if (color.indexOf(&#x27;hsb&#x27;) &gt; -1) {
            data = _HSV_2_RGB(data);
        } else if (color.indexOf(&#x27;hsl&#x27;) &gt; -1) {
            data = _HSL_2_RGB(data);
        }
        if (format.indexOf(&#x27;hsb&#x27;) &gt; -1 || format.indexOf(&#x27;hsv&#x27;) &gt; -1) {
            data = _RGB_2_HSB(data);
        } else if (format.indexOf(&#x27;hsl&#x27;) &gt; -1) {
            data = _RGB_2_HSL(data);
        }
        data[3] = alpha;
        return toColor(data, format);
    }
    function toRGBA(color) {
        return convert(color, &#x27;rgba&#x27;);
    }
    function toRGB(color) {
        return convert(color, &#x27;rgb&#x27;);
    }
    function toHex(color) {
        return convert(color, &#x27;hex&#x27;);
    }
    function toHSVA(color) {
        return convert(color, &#x27;hsva&#x27;);
    }
    function toHSV(color) {
        return convert(color, &#x27;hsv&#x27;);
    }
    function toHSBA(color) {
        return convert(color, &#x27;hsba&#x27;);
    }
    function toHSB(color) {
        return convert(color, &#x27;hsb&#x27;);
    }
    function toHSLA(color) {
        return convert(color, &#x27;hsla&#x27;);
    }
    function toHSL(color) {
        return convert(color, &#x27;hsl&#x27;);
    }
    function toName(color) {
        for (var key in _nameColors) {
            if (toHex(_nameColors[key]) === toHex(color)) {
                return key;
            }
        }
        return null;
    }
    function trim(color) {
        return String(color).replace(/\s+/g, &#x27;&#x27;);
    }
    function normalize(color) {
        if (_nameColors[color]) {
            color = _nameColors[color];
        }
        color = trim(color);
        color = color.replace(/hsv/i, &#x27;hsb&#x27;);
        if (/^#[\da-f]{3}$/i.test(color)) {
            color = parseInt(color.slice(1), 16);
            var r = (color &amp; 3840) &lt;&lt; 8;
            var g = (color &amp; 240) &lt;&lt; 4;
            var b = color &amp; 15;
            color = &#x27;#&#x27; + ((1 &lt;&lt; 24) + (r &lt;&lt; 4) + r + (g &lt;&lt; 4) + g + (b &lt;&lt; 4) + b).toString(16).slice(1);
        }
        return color;
    }
    function lift(color, level) {
        if (!isCalculableColor(color)) {
            return color;
        }
        var direct = level &gt; 0 ? 1 : -1;
        if (typeof level === &#x27;undefined&#x27;) {
            level = 0;
        }
        level = Math.abs(level) &gt; 1 ? 1 : Math.abs(level);
        color = toRGB(color);
        var data = getData(color);
        for (var i = 0; i &lt; 3; i++) {
            if (direct === 1) {
                data[i] = data[i] * (1 - level) | 0;
            } else {
                data[i] = (255 - data[i]) * level + data[i] | 0;
            }
        }
        return &#x27;rgb(&#x27; + data.join(&#x27;,&#x27;) + &#x27;)&#x27;;
    }
    function reverse(color) {
        if (!isCalculableColor(color)) {
            return color;
        }
        var data = getData(toRGBA(color));
        data = map(data, function (c) {
            return 255 - c;
        });
        return toColor(data, &#x27;rgb&#x27;);
    }
    function mix(color1, color2, weight) {
        if (!isCalculableColor(color1) || !isCalculableColor(color2)) {
            return color1;
        }
        if (typeof weight === &#x27;undefined&#x27;) {
            weight = 0.5;
        }
        weight = 1 - adjust(weight, [
            0,
            1
        ]);
        var w = weight * 2 - 1;
        var data1 = getData(toRGBA(color1));
        var data2 = getData(toRGBA(color2));
        var d = data1[3] - data2[3];
        var weight1 = ((w * d === -1 ? w : (w + d) / (1 + w * d)) + 1) / 2;
        var weight2 = 1 - weight1;
        var data = [];
        for (var i = 0; i &lt; 3; i++) {
            data[i] = data1[i] * weight1 + data2[i] * weight2;
        }
        var alpha = data1[3] * weight + data2[3] * (1 - weight);
        alpha = Math.max(0, Math.min(1, alpha));
        if (data1[3] === 1 &amp;&amp; data2[3] === 1) {
            return toColor(data, &#x27;rgb&#x27;);
        }
        data[3] = alpha;
        return toColor(data, &#x27;rgba&#x27;);
    }
    function random() {
        return &#x27;#&#x27; + (Math.random().toString(16) + &#x27;0000&#x27;).slice(2, 8);
    }
    function getData(color) {
        color = normalize(color);
        var r = color.match(colorRegExp);
        if (r === null) {
            throw new Error(&#x27;The color format error&#x27;);
        }
        var d;
        var a;
        var data = [];
        var rgb;
        if (r[2]) {
            d = r[2].replace(&#x27;#&#x27;, &#x27;&#x27;).split(&#x27;&#x27;);
            rgb = [
                d[0] + d[1],
                d[2] + d[3],
                d[4] + d[5]
            ];
            data = map(rgb, function (c) {
                return adjust(parseInt(c, 16), [
                    0,
                    255
                ]);
            });
        } else if (r[4]) {
            var rgba = r[4].split(&#x27;,&#x27;);
            a = rgba[3];
            rgb = rgba.slice(0, 3);
            data = map(rgb, function (c) {
                c = Math.floor(c.indexOf(&#x27;%&#x27;) &gt; 0 ? parseInt(c, 0) * 2.55 : c);
                return adjust(c, [
                    0,
                    255
                ]);
            });
            if (typeof a !== &#x27;undefined&#x27;) {
                data.push(adjust(parseFloat(a), [
                    0,
                    1
                ]));
            }
        } else if (r[5] || r[6]) {
            var hsxa = (r[5] || r[6]).split(&#x27;,&#x27;);
            var h = parseInt(hsxa[0], 0) / 360;
            var s = hsxa[1];
            var x = hsxa[2];
            a = hsxa[3];
            data = map([
                s,
                x
            ], function (c) {
                return adjust(parseFloat(c) / 100, [
                    0,
                    1
                ]);
            });
            data.unshift(h);
            if (typeof a !== &#x27;undefined&#x27;) {
                data.push(adjust(parseFloat(a), [
                    0,
                    1
                ]));
            }
        }
        return data;
    }
    function alpha(color, a) {
        if (!isCalculableColor(color)) {
            return color;
        }
        if (a === null) {
            a = 1;
        }
        var data = getData(toRGBA(color));
        data[3] = adjust(Number(a).toFixed(4), [
            0,
            1
        ]);
        return toColor(data, &#x27;rgba&#x27;);
    }
    function map(array, fun) {
        if (typeof fun !== &#x27;function&#x27;) {
            throw new TypeError();
        }
        var len = array ? array.length : 0;
        for (var i = 0; i &lt; len; i++) {
            array[i] = fun(array[i]);
        }
        return array;
    }
    function adjust(value, region) {
        if (value &lt;= region[0]) {
            value = region[0];
        } else if (value &gt;= region[1]) {
            value = region[1];
        }
        return value;
    }
    function isCalculableColor(color) {
        return color instanceof Array || typeof color === &#x27;string&#x27;;
    }
    function _HSV_2_RGB(data) {
        var H = data[0];
        var S = data[1];
        var V = data[2];
        var R;
        var G;
        var B;
        if (S === 0) {
            R = V * 255;
            G = V * 255;
            B = V * 255;
        } else {
            var h = H * 6;
            if (h === 6) {
                h = 0;
            }
            var i = h | 0;
            var v1 = V * (1 - S);
            var v2 = V * (1 - S * (h - i));
            var v3 = V * (1 - S * (1 - (h - i)));
            var r = 0;
            var g = 0;
            var b = 0;
            if (i === 0) {
                r = V;
                g = v3;
                b = v1;
            } else if (i === 1) {
                r = v2;
                g = V;
                b = v1;
            } else if (i === 2) {
                r = v1;
                g = V;
                b = v3;
            } else if (i === 3) {
                r = v1;
                g = v2;
                b = V;
            } else if (i === 4) {
                r = v3;
                g = v1;
                b = V;
            } else {
                r = V;
                g = v1;
                b = v2;
            }
            R = r * 255;
            G = g * 255;
            B = b * 255;
        }
        return [
            R,
            G,
            B
        ];
    }
    function _HSL_2_RGB(data) {
        var H = data[0];
        var S = data[1];
        var L = data[2];
        var R;
        var G;
        var B;
        if (S === 0) {
            R = L * 255;
            G = L * 255;
            B = L * 255;
        } else {
            var v2;
            if (L &lt; 0.5) {
                v2 = L * (1 + S);
            } else {
                v2 = L + S - S * L;
            }
            var v1 = 2 * L - v2;
            R = 255 * _HUE_2_RGB(v1, v2, H + 1 / 3);
            G = 255 * _HUE_2_RGB(v1, v2, H);
            B = 255 * _HUE_2_RGB(v1, v2, H - 1 / 3);
        }
        return [
            R,
            G,
            B
        ];
    }
    function _HUE_2_RGB(v1, v2, vH) {
        if (vH &lt; 0) {
            vH += 1;
        }
        if (vH &gt; 1) {
            vH -= 1;
        }
        if (6 * vH &lt; 1) {
            return v1 + (v2 - v1) * 6 * vH;
        }
        if (2 * vH &lt; 1) {
            return v2;
        }
        if (3 * vH &lt; 2) {
            return v1 + (v2 - v1) * (2 / 3 - vH) * 6;
        }
        return v1;
    }
    function _RGB_2_HSB(data) {
        var R = data[0] / 255;
        var G = data[1] / 255;
        var B = data[2] / 255;
        var vMin = Math.min(R, G, B);
        var vMax = Math.max(R, G, B);
        var delta = vMax - vMin;
        var V = vMax;
        var H;
        var S;
        if (delta === 0) {
            H = 0;
            S = 0;
        } else {
            S = delta / vMax;
            var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
            var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
            var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
            if (R === vMax) {
                H = deltaB - deltaG;
            } else if (G === vMax) {
                H = 1 / 3 + deltaR - deltaB;
            } else if (B === vMax) {
                H = 2 / 3 + deltaG - deltaR;
            }
            if (H &lt; 0) {
                H += 1;
            }
            if (H &gt; 1) {
                H -= 1;
            }
        }
        H = H * 360;
        S = S * 100;
        V = V * 100;
        return [
            H,
            S,
            V
        ];
    }
    function _RGB_2_HSL(data) {
        var R = data[0] / 255;
        var G = data[1] / 255;
        var B = data[2] / 255;
        var vMin = Math.min(R, G, B);
        var vMax = Math.max(R, G, B);
        var delta = vMax - vMin;
        var L = (vMax + vMin) / 2;
        var H;
        var S;
        if (delta === 0) {
            H = 0;
            S = 0;
        } else {
            if (L &lt; 0.5) {
                S = delta / (vMax + vMin);
            } else {
                S = delta / (2 - vMax - vMin);
            }
            var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
            var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
            var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
            if (R === vMax) {
                H = deltaB - deltaG;
            } else if (G === vMax) {
                H = 1 / 3 + deltaR - deltaB;
            } else if (B === vMax) {
                H = 2 / 3 + deltaG - deltaR;
            }
            if (H &lt; 0) {
                H += 1;
            }
            if (H &gt; 1) {
                H -= 1;
            }
        }
        H = H * 360;
        S = S * 100;
        L = L * 100;
        return [
            H,
            S,
            L
        ];
    }
    return {
        customPalette: customPalette,
        resetPalette: resetPalette,
        getColor: getColor,
        getHighlightColor: getHighlightColor,
        customHighlight: customHighlight,
        resetHighlight: resetHighlight,
        getRadialGradient: getRadialGradient,
        getLinearGradient: getLinearGradient,
        getGradientColors: getGradientColors,
        getStepColors: getStepColors,
        reverse: reverse,
        mix: mix,
        lift: lift,
        trim: trim,
        random: random,
        toRGB: toRGB,
        toRGBA: toRGBA,
        toHex: toHex,
        toHSL: toHSL,
        toHSLA: toHSLA,
        toHSB: toHSB,
        toHSBA: toHSBA,
        toHSV: toHSV,
        toHSVA: toHSVA,
        toName: toName,
        toColor: toColor,
        toArray: toArray,
        alpha: alpha,
        getData: getData
    };
});define(&#x27;echarts/component/timeline&#x27;, [
    &#x27;require&#x27;,
    &#x27;./base&#x27;,
    &#x27;zrender/shape/Rectangle&#x27;,
    &#x27;../util/shape/Icon&#x27;,
    &#x27;../util/shape/Chain&#x27;,
    &#x27;../config&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;zrender/tool/area&#x27;,
    &#x27;zrender/tool/event&#x27;,
    &#x27;../component&#x27;
], function (require) {
    var Base = require(&#x27;./base&#x27;);
    var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
    var IconShape = require(&#x27;../util/shape/Icon&#x27;);
    var ChainShape = require(&#x27;../util/shape/Chain&#x27;);
    var ecConfig = require(&#x27;../config&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    var zrArea = require(&#x27;zrender/tool/area&#x27;);
    var zrEvent = require(&#x27;zrender/tool/event&#x27;);
    function Timeline(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        var self = this;
        self._onclick = function (param) {
            return self.__onclick(param);
        };
        self._ondrift = function (dx, dy) {
            return self.__ondrift(this, dx, dy);
        };
        self._ondragend = function () {
            return self.__ondragend();
        };
        self._setCurrentOption = function () {
            var timelineOption = self.timelineOption;
            self.currentIndex %= timelineOption.data.length;
            var curOption = self.options[self.currentIndex] || {};
            self.myChart.setOption(curOption, timelineOption.notMerge);
            self.messageCenter.dispatch(ecConfig.EVENT.TIMELINE_CHANGED, null, {
                currentIndex: self.currentIndex,
                data: timelineOption.data[self.currentIndex].name != null ? timelineOption.data[self.currentIndex].name : timelineOption.data[self.currentIndex]
            }, self.myChart);
        };
        self._onFrame = function () {
            self._setCurrentOption();
            self._syncHandleShape();
            if (self.timelineOption.autoPlay) {
                self.playTicket = setTimeout(function () {
                    self.currentIndex += 1;
                    if (!self.timelineOption.loop &amp;&amp; self.currentIndex &gt;= self.timelineOption.data.length) {
                        self.currentIndex = self.timelineOption.data.length - 1;
                        self.stop();
                        return;
                    }
                    self._onFrame();
                }, self.timelineOption.playInterval);
            }
        };
        this.setTheme(false);
        this.options = this.option.options;
        this.currentIndex = this.timelineOption.currentIndex % this.timelineOption.data.length;
        if (!this.timelineOption.notMerge &amp;&amp; this.currentIndex !== 0) {
            this.options[this.currentIndex] = zrUtil.merge(this.options[this.currentIndex], this.options[0]);
        }
        if (this.timelineOption.show) {
            this._buildShape();
            this._syncHandleShape();
        }
        this._setCurrentOption();
        if (this.timelineOption.autoPlay) {
            var self = this;
            this.playTicket = setTimeout(function () {
                self.play();
            }, this.ecTheme.animationDuration);
        }
    }
    Timeline.prototype = {
        type: ecConfig.COMPONENT_TYPE_TIMELINE,
        _buildShape: function () {
            this._location = this._getLocation();
            this._buildBackground();
            this._buildControl();
            this._chainPoint = this._getChainPoint();
            if (this.timelineOption.label.show) {
                var interval = this._getInterval();
                for (var i = 0, len = this._chainPoint.length; i &lt; len; i += interval) {
                    this._chainPoint[i].showLabel = true;
                }
            }
            this._buildChain();
            this._buildHandle();
            for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },
        _getLocation: function () {
            var timelineOption = this.timelineOption;
            var padding = this.reformCssArray(this.timelineOption.padding);
            var zrWidth = this.zr.getWidth();
            var x = this.parsePercent(timelineOption.x, zrWidth);
            var x2 = this.parsePercent(timelineOption.x2, zrWidth);
            var width;
            if (timelineOption.width == null) {
                width = zrWidth - x - x2;
                x2 = zrWidth - x2;
            } else {
                width = this.parsePercent(timelineOption.width, zrWidth);
                x2 = x + width;
            }
            var zrHeight = this.zr.getHeight();
            var height = this.parsePercent(timelineOption.height, zrHeight);
            var y;
            var y2;
            if (timelineOption.y != null) {
                y = this.parsePercent(timelineOption.y, zrHeight);
                y2 = y + height;
            } else {
                y2 = zrHeight - this.parsePercent(timelineOption.y2, zrHeight);
                y = y2 - height;
            }
            return {
                x: x + padding[3],
                y: y + padding[0],
                x2: x2 - padding[1],
                y2: y2 - padding[2],
                width: width - padding[1] - padding[3],
                height: height - padding[0] - padding[2]
            };
        },
        _getReformedLabel: function (idx) {
            var timelineOption = this.timelineOption;
            var data = timelineOption.data[idx].name != null ? timelineOption.data[idx].name : timelineOption.data[idx];
            var formatter = timelineOption.data[idx].formatter || timelineOption.label.formatter;
            if (formatter) {
                if (typeof formatter === &#x27;function&#x27;) {
                    data = formatter.call(this.myChart, data);
                } else if (typeof formatter === &#x27;string&#x27;) {
                    data = formatter.replace(&#x27;{value}&#x27;, data);
                }
            }
            return data;
        },
        _getInterval: function () {
            var chainPoint = this._chainPoint;
            var timelineOption = this.timelineOption;
            var interval = timelineOption.label.interval;
            if (interval === &#x27;auto&#x27;) {
                var fontSize = timelineOption.label.textStyle.fontSize;
                var data = timelineOption.data;
                var dataLength = timelineOption.data.length;
                if (dataLength &gt; 3) {
                    var isEnough = false;
                    var labelSpace;
                    var labelSize;
                    interval = 0;
                    while (!isEnough &amp;&amp; interval &lt; dataLength) {
                        interval++;
                        isEnough = true;
                        for (var i = interval; i &lt; dataLength; i += interval) {
                            labelSpace = chainPoint[i].x - chainPoint[i - interval].x;
                            if (timelineOption.label.rotate !== 0) {
                                labelSize = fontSize;
                            } else if (data[i].textStyle) {
                                labelSize = zrArea.getTextWidth(chainPoint[i].name, chainPoint[i].textFont);
                            } else {
                                var label = chainPoint[i].name + &#x27;&#x27;;
                                var wLen = (label.match(/\w/g) || &#x27;&#x27;).length;
                                var oLen = label.length - wLen;
                                labelSize = wLen * fontSize * 2 / 3 + oLen * fontSize;
                            }
                            if (labelSpace &lt; labelSize) {
                                isEnough = false;
                                break;
                            }
                        }
                    }
                } else {
                    interval = 1;
                }
            } else {
                interval = interval - 0 + 1;
            }
            return interval;
        },
        _getChainPoint: function () {
            var timelineOption = this.timelineOption;
            var symbol = timelineOption.symbol.toLowerCase();
            var symbolSize = timelineOption.symbolSize;
            var rotate = timelineOption.label.rotate;
            var textStyle = timelineOption.label.textStyle;
            var textFont = this.getFont(textStyle);
            var dataTextStyle;
            var data = timelineOption.data;
            var x = this._location.x;
            var y = this._location.y + this._location.height / 4 * 3;
            var width = this._location.x2 - this._location.x;
            var len = data.length;
            function _getName(i) {
                return data[i].name != null ? data[i].name : data[i] + &#x27;&#x27;;
            }
            var xList = [];
            if (len &gt; 1) {
                var boundaryGap = width / len;
                boundaryGap = boundaryGap &gt; 50 ? 50 : boundaryGap &lt; 20 ? 5 : boundaryGap;
                width -= boundaryGap * 2;
                if (timelineOption.type === &#x27;number&#x27;) {
                    for (var i = 0; i &lt; len; i++) {
                        xList.push(x + boundaryGap + width / (len - 1) * i);
                    }
                } else {
                    xList[0] = new Date(_getName(0).replace(/-/g, &#x27;/&#x27;));
                    xList[len - 1] = new Date(_getName(len - 1).replace(/-/g, &#x27;/&#x27;)) - xList[0];
                    for (var i = 1; i &lt; len; i++) {
                        xList[i] = x + boundaryGap + width * (new Date(_getName(i).replace(/-/g, &#x27;/&#x27;)) - xList[0]) / xList[len - 1];
                    }
                    xList[0] = x + boundaryGap;
                }
            } else {
                xList.push(x + width / 2);
            }
            var list = [];
            var curSymbol;
            var n;
            var isEmpty;
            var textAlign;
            var rotation;
            for (var i = 0; i &lt; len; i++) {
                x = xList[i];
                curSymbol = data[i].symbol &amp;&amp; data[i].symbol.toLowerCase() || symbol;
                if (curSymbol.match(&#x27;empty&#x27;)) {
                    curSymbol = curSymbol.replace(&#x27;empty&#x27;, &#x27;&#x27;);
                    isEmpty = true;
                } else {
                    isEmpty = false;
                }
                if (curSymbol.match(&#x27;star&#x27;)) {
                    n = curSymbol.replace(&#x27;star&#x27;, &#x27;&#x27;) - 0 || 5;
                    curSymbol = &#x27;star&#x27;;
                }
                dataTextStyle = data[i].textStyle ? zrUtil.merge(data[i].textStyle || {}, textStyle) : textStyle;
                textAlign = dataTextStyle.align || &#x27;center&#x27;;
                if (rotate) {
                    textAlign = rotate &gt; 0 ? &#x27;right&#x27; : &#x27;left&#x27;;
                    rotation = [
                        rotate * Math.PI / 180,
                        x,
                        y - 5
                    ];
                } else {
                    rotation = false;
                }
                list.push({
                    x: x,
                    n: n,
                    isEmpty: isEmpty,
                    symbol: curSymbol,
                    symbolSize: data[i].symbolSize || symbolSize,
                    color: data[i].color,
                    borderColor: data[i].borderColor,
                    borderWidth: data[i].borderWidth,
                    name: this._getReformedLabel(i),
                    textColor: dataTextStyle.color,
                    textAlign: textAlign,
                    textBaseline: dataTextStyle.baseline || &#x27;middle&#x27;,
                    textX: x,
                    textY: y - (rotate ? 5 : 0),
                    textFont: data[i].textStyle ? this.getFont(dataTextStyle) : textFont,
                    rotation: rotation,
                    showLabel: false
                });
            }
            return list;
        },
        _buildBackground: function () {
            var timelineOption = this.timelineOption;
            var padding = this.reformCssArray(this.timelineOption.padding);
            var width = this._location.width;
            var height = this._location.height;
            if (timelineOption.borderWidth !== 0 || timelineOption.backgroundColor.replace(/\s/g, &#x27;&#x27;) != &#x27;rgba(0,0,0,0)&#x27;) {
                this.shapeList.push(new RectangleShape({
                    zlevel: this._zlevelBase,
                    hoverable: false,
                    style: {
                        x: this._location.x - padding[3],
                        y: this._location.y - padding[0],
                        width: width + padding[1] + padding[3],
                        height: height + padding[0] + padding[2],
                        brushType: timelineOption.borderWidth === 0 ? &#x27;fill&#x27; : &#x27;both&#x27;,
                        color: timelineOption.backgroundColor,
                        strokeColor: timelineOption.borderColor,
                        lineWidth: timelineOption.borderWidth
                    }
                }));
            }
        },
        _buildControl: function () {
            var self = this;
            var timelineOption = this.timelineOption;
            var lineStyle = timelineOption.lineStyle;
            var controlStyle = timelineOption.controlStyle;
            if (timelineOption.controlPosition === &#x27;none&#x27;) {
                return;
            }
            var iconSize = 15;
            var iconGap = 5;
            var x;
            if (timelineOption.controlPosition === &#x27;left&#x27;) {
                x = this._location.x;
                this._location.x += (iconSize + iconGap) * 3;
            } else {
                x = this._location.x2 - ((iconSize + iconGap) * 3 - iconGap);
                this._location.x2 -= (iconSize + iconGap) * 3;
            }
            var y = this._location.y;
            var iconStyle = {
                zlevel: this._zlevelBase + 1,
                style: {
                    iconType: &#x27;timelineControl&#x27;,
                    symbol: &#x27;last&#x27;,
                    x: x,
                    y: y,
                    width: iconSize,
                    height: iconSize,
                    brushType: &#x27;stroke&#x27;,
                    color: controlStyle.normal.color,
                    strokeColor: controlStyle.normal.color,
                    lineWidth: lineStyle.width
                },
                highlightStyle: {
                    color: controlStyle.emphasis.color,
                    strokeColor: controlStyle.emphasis.color,
                    lineWidth: lineStyle.width + 1
                },
                clickable: true
            };
            this._ctrLastShape = new IconShape(iconStyle);
            this._ctrLastShape.onclick = function () {
                self.last();
            };
            this.shapeList.push(this._ctrLastShape);
            x += iconSize + iconGap;
            this._ctrPlayShape = new IconShape(zrUtil.clone(iconStyle));
            this._ctrPlayShape.style.brushType = &#x27;fill&#x27;;
            this._ctrPlayShape.style.symbol = &#x27;play&#x27;;
            this._ctrPlayShape.style.status = this.timelineOption.autoPlay ? &#x27;playing&#x27; : &#x27;stop&#x27;;
            this._ctrPlayShape.style.x = x;
            this._ctrPlayShape.onclick = function () {
                if (self._ctrPlayShape.style.status === &#x27;stop&#x27;) {
                    self.play();
                } else {
                    self.stop();
                }
            };
            this.shapeList.push(this._ctrPlayShape);
            x += iconSize + iconGap;
            this._ctrNextShape = new IconShape(zrUtil.clone(iconStyle));
            this._ctrNextShape.style.symbol = &#x27;next&#x27;;
            this._ctrNextShape.style.x = x;
            this._ctrNextShape.onclick = function () {
                self.next();
            };
            this.shapeList.push(this._ctrNextShape);
        },
        _buildChain: function () {
            var timelineOption = this.timelineOption;
            var lineStyle = timelineOption.lineStyle;
            this._timelineShae = {
                zlevel: this._zlevelBase,
                style: {
                    x: this._location.x,
                    y: this.subPixelOptimize(this._location.y, lineStyle.width),
                    width: this._location.x2 - this._location.x,
                    height: this._location.height,
                    chainPoint: this._chainPoint,
                    brushType: &#x27;both&#x27;,
                    strokeColor: lineStyle.color,
                    lineWidth: lineStyle.width,
                    lineType: lineStyle.type
                },
                hoverable: false,
                clickable: true,
                onclick: this._onclick
            };
            this._timelineShae = new ChainShape(this._timelineShae);
            this.shapeList.push(this._timelineShae);
        },
        _buildHandle: function () {
            var curPoint = this._chainPoint[this.currentIndex];
            var symbolSize = curPoint.symbolSize + 1;
            symbolSize = symbolSize &lt; 5 ? 5 : symbolSize;
            this._handleShape = {
                zlevel: this._zlevelBase + 1,
                hoverable: false,
                draggable: true,
                style: {
                    iconType: &#x27;diamond&#x27;,
                    n: curPoint.n,
                    x: curPoint.x - symbolSize,
                    y: this._location.y + this._location.height / 4 - symbolSize,
                    width: symbolSize * 2,
                    height: symbolSize * 2,
                    brushType: &#x27;both&#x27;,
                    textPosition: &#x27;specific&#x27;,
                    textX: curPoint.x,
                    textY: this._location.y - this._location.height / 4,
                    textAlign: &#x27;center&#x27;,
                    textBaseline: &#x27;middle&#x27;
                },
                highlightStyle: {},
                ondrift: this._ondrift,
                ondragend: this._ondragend
            };
            this._handleShape = new IconShape(this._handleShape);
            this.shapeList.push(this._handleShape);
        },
        _syncHandleShape: function () {
            if (!this.timelineOption.show) {
                return;
            }
            var timelineOption = this.timelineOption;
            var cpStyle = timelineOption.checkpointStyle;
            var curPoint = this._chainPoint[this.currentIndex];
            this._handleShape.style.text = cpStyle.label.show ? curPoint.name : &#x27;&#x27;;
            this._handleShape.style.textFont = curPoint.textFont;
            this._handleShape.style.n = curPoint.n;
            if (cpStyle.symbol === &#x27;auto&#x27;) {
                this._handleShape.style.iconType = curPoint.symbol != &#x27;none&#x27; ? curPoint.symbol : &#x27;diamond&#x27;;
            } else {
                this._handleShape.style.iconType = cpStyle.symbol;
                if (cpStyle.symbol.match(&#x27;star&#x27;)) {
                    this._handleShape.style.n = cpStyle.symbol.replace(&#x27;star&#x27;, &#x27;&#x27;) - 0 || 5;
                    this._handleShape.style.iconType = &#x27;star&#x27;;
                }
            }
            var symbolSize;
            if (cpStyle.symbolSize === &#x27;auto&#x27;) {
                symbolSize = curPoint.symbolSize + 2;
                symbolSize = symbolSize &lt; 5 ? 5 : symbolSize;
            } else {
                symbolSize = cpStyle.symbolSize - 0;
            }
            this._handleShape.style.color = cpStyle.color === &#x27;auto&#x27; ? curPoint.color ? curPoint.color : timelineOption.controlStyle.emphasis.color : cpStyle.color;
            this._handleShape.style.textColor = cpStyle.label.textStyle.color === &#x27;auto&#x27; ? this._handleShape.style.color : cpStyle.label.textStyle.color;
            this._handleShape.highlightStyle.strokeColor = this._handleShape.style.strokeColor = cpStyle.borderColor === &#x27;auto&#x27; ? curPoint.borderColor ? curPoint.borderColor : &#x27;#fff&#x27; : cpStyle.borderColor;
            this._handleShape.style.lineWidth = cpStyle.borderWidth === &#x27;auto&#x27; ? curPoint.borderWidth ? curPoint.borderWidth : 0 : cpStyle.borderWidth - 0;
            this._handleShape.highlightStyle.lineWidth = this._handleShape.style.lineWidth + 1;
            this.zr.animate(this._handleShape.id, &#x27;style&#x27;).when(500, {
                x: curPoint.x - symbolSize,
                textX: curPoint.x,
                y: this._location.y + this._location.height / 4 - symbolSize,
                width: symbolSize * 2,
                height: symbolSize * 2
            }).start(&#x27;ExponentialOut&#x27;);
        },
        _findChainIndex: function (x) {
            var chainPoint = this._chainPoint;
            var len = chainPoint.length;
            if (x &lt;= chainPoint[0].x) {
                return 0;
            } else if (x &gt;= chainPoint[len - 1].x) {
                return len - 1;
            }
            for (var i = 0; i &lt; len - 1; i++) {
                if (x &gt;= chainPoint[i].x &amp;&amp; x &lt;= chainPoint[i + 1].x) {
                    return Math.abs(x - chainPoint[i].x) &lt; Math.abs(x - chainPoint[i + 1].x) ? i : i + 1;
                }
            }
        },
        __onclick: function (param) {
            var x = zrEvent.getX(param.event);
            var newIndex = this._findChainIndex(x);
            if (newIndex === this.currentIndex) {
                return true;
            }
            this.currentIndex = newIndex;
            this.timelineOption.autoPlay &amp;&amp; this.stop();
            clearTimeout(this.playTicket);
            this._onFrame();
        },
        __ondrift: function (shape, dx) {
            this.timelineOption.autoPlay &amp;&amp; this.stop();
            var chainPoint = this._chainPoint;
            var len = chainPoint.length;
            var newIndex;
            if (shape.style.x + dx &lt;= chainPoint[0].x - chainPoint[0].symbolSize) {
                shape.style.x = chainPoint[0].x - chainPoint[0].symbolSize;
                newIndex = 0;
            } else if (shape.style.x + dx &gt;= chainPoint[len - 1].x - chainPoint[len - 1].symbolSize) {
                shape.style.x = chainPoint[len - 1].x - chainPoint[len - 1].symbolSize;
                newIndex = len - 1;
            } else {
                shape.style.x += dx;
                newIndex = this._findChainIndex(shape.style.x);
            }
            var curPoint = chainPoint[newIndex];
            var symbolSize = curPoint.symbolSize + 2;
            shape.style.iconType = curPoint.symbol;
            shape.style.n = curPoint.n;
            shape.style.textX = shape.style.x + symbolSize / 2;
            shape.style.y = this._location.y + this._location.height / 4 - symbolSize;
            shape.style.width = symbolSize * 2;
            shape.style.height = symbolSize * 2;
            shape.style.text = curPoint.name;
            if (newIndex === this.currentIndex) {
                return true;
            }
            this.currentIndex = newIndex;
            if (this.timelineOption.realtime) {
                clearTimeout(this.playTicket);
                var self = this;
                this.playTicket = setTimeout(function () {
                    self._setCurrentOption();
                }, 200);
            }
            return true;
        },
        __ondragend: function () {
            this.isDragend = true;
        },
        ondragend: function (param, status) {
            if (!this.isDragend || !param.target) {
                return;
            }
            !this.timelineOption.realtime &amp;&amp; this._setCurrentOption();
            status.dragOut = true;
            status.dragIn = true;
            status.needRefresh = false;
            this.isDragend = false;
            this._syncHandleShape();
            return;
        },
        last: function () {
            this.timelineOption.autoPlay &amp;&amp; this.stop();
            this.currentIndex -= 1;
            if (this.currentIndex &lt; 0) {
                this.currentIndex = this.timelineOption.data.length - 1;
            }
            this._onFrame();
            return this.currentIndex;
        },
        next: function () {
            this.timelineOption.autoPlay &amp;&amp; this.stop();
            this.currentIndex += 1;
            if (this.currentIndex &gt;= this.timelineOption.data.length) {
                this.currentIndex = 0;
            }
            this._onFrame();
            return this.currentIndex;
        },
        play: function (targetIndex, autoPlay) {
            if (this._ctrPlayShape &amp;&amp; this._ctrPlayShape.style.status != &#x27;playing&#x27;) {
                this._ctrPlayShape.style.status = &#x27;playing&#x27;;
                this.zr.modShape(this._ctrPlayShape.id);
                this.zr.refresh();
            }
            this.timelineOption.autoPlay = autoPlay != null ? autoPlay : true;
            if (!this.timelineOption.autoPlay) {
                clearTimeout(this.playTicket);
            }
            this.currentIndex = targetIndex != null ? targetIndex : this.currentIndex + 1;
            if (this.currentIndex &gt;= this.timelineOption.data.length) {
                this.currentIndex = 0;
            }
            this._onFrame();
            return this.currentIndex;
        },
        stop: function () {
            if (this._ctrPlayShape &amp;&amp; this._ctrPlayShape.style.status != &#x27;stop&#x27;) {
                this._ctrPlayShape.style.status = &#x27;stop&#x27;;
                this.zr.modShape(this._ctrPlayShape.id);
                this.zr.refresh();
            }
            this.timelineOption.autoPlay = false;
            clearTimeout(this.playTicket);
            return this.currentIndex;
        },
        resize: function () {
            if (this.timelineOption.show) {
                this.clear();
                this._buildShape();
                this._syncHandleShape();
            }
        },
        setTheme: function (needRefresh) {
            this.timelineOption = this.reformOption(zrUtil.clone(this.option.timeline));
            this.timelineOption.label.textStyle = zrUtil.merge(this.timelineOption.label.textStyle || {}, this.ecTheme.textStyle);
            this.timelineOption.checkpointStyle.label.textStyle = zrUtil.merge(this.timelineOption.checkpointStyle.label.textStyle || {}, this.ecTheme.textStyle);
            if (!this.myChart.canvasSupported) {
                this.timelineOption.realtime = false;
            }
            if (this.timelineOption.show &amp;&amp; needRefresh) {
                this.clear();
                this._buildShape();
                this._syncHandleShape();
            }
        },
        onbeforDispose: function () {
            clearTimeout(this.playTicket);
        }
    };
    function timelineControl(ctx, style) {
        var lineWidth = 2;
        var x = style.x + lineWidth;
        var y = style.y + lineWidth + 2;
        var width = style.width - lineWidth;
        var height = style.height - lineWidth;
        var symbol = style.symbol;
        if (symbol === &#x27;last&#x27;) {
            ctx.moveTo(x + width - 2, y + height / 3);
            ctx.lineTo(x + width - 2, y);
            ctx.lineTo(x + 2, y + height / 2);
            ctx.lineTo(x + width - 2, y + height);
            ctx.lineTo(x + width - 2, y + height / 3 * 2);
            ctx.moveTo(x, y);
            ctx.lineTo(x, y);
        } else if (symbol === &#x27;next&#x27;) {
            ctx.moveTo(x + 2, y + height / 3);
            ctx.lineTo(x + 2, y);
            ctx.lineTo(x + width - 2, y + height / 2);
            ctx.lineTo(x + 2, y + height);
            ctx.lineTo(x + 2, y + height / 3 * 2);
            ctx.moveTo(x, y);
            ctx.lineTo(x, y);
        } else if (symbol === &#x27;play&#x27;) {
            if (style.status === &#x27;stop&#x27;) {
                ctx.moveTo(x + 2, y);
                ctx.lineTo(x + width - 2, y + height / 2);
                ctx.lineTo(x + 2, y + height);
                ctx.lineTo(x + 2, y);
            } else {
                var delta = style.brushType === &#x27;both&#x27; ? 2 : 3;
                ctx.rect(x + 2, y, delta, height);
                ctx.rect(x + width - delta - 2, y, delta, height);
            }
        } else if (symbol.match(&#x27;image&#x27;)) {
            var imageLocation = &#x27;&#x27;;
            imageLocation = symbol.replace(new RegExp(&#x27;^image:\\/\\/&#x27;), &#x27;&#x27;);
            symbol = IconShape.prototype.iconLibrary.image;
            symbol(ctx, {
                x: x,
                y: y,
                width: width,
                height: height,
                image: imageLocation
            });
        }
    }
    IconShape.prototype.iconLibrary[&#x27;timelineControl&#x27;] = timelineControl;
    zrUtil.inherits(Timeline, Base);
    require(&#x27;../component&#x27;).define(&#x27;timeline&#x27;, Timeline);
    return Timeline;
});define(&#x27;zrender/shape/Image&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Base&#x27;,
    &#x27;../tool/util&#x27;
], function (require) {
    var Base = require(&#x27;./Base&#x27;);
    var ZImage = function (options) {
        Base.call(this, options);
    };
    ZImage.prototype = {
        type: &#x27;image&#x27;,
        brush: function (ctx, isHighlight, refreshNextFrame) {
            var style = this.style || {};
            if (isHighlight) {
                style = this.getHighlightStyle(style, this.highlightStyle || {});
            }
            var image = style.image;
            var self = this;
            if (!this._imageCache) {
                this._imageCache = {};
            }
            if (typeof image === &#x27;string&#x27;) {
                var src = image;
                if (this._imageCache[src]) {
                    image = this._imageCache[src];
                } else {
                    image = new Image();
                    image.onload = function () {
                        image.onload = null;
                        self.modSelf();
                        refreshNextFrame();
                    };
                    image.src = src;
                    this._imageCache[src] = image;
                }
            }
            if (image) {
                if (image.nodeName.toUpperCase() == &#x27;IMG&#x27;) {
                    if (window.ActiveXObject) {
                        if (image.readyState != &#x27;complete&#x27;) {
                            return;
                        }
                    } else {
                        if (!image.complete) {
                            return;
                        }
                    }
                }
                var width = style.width || image.width;
                var height = style.height || image.height;
                var x = style.x;
                var y = style.y;
                if (!image.width || !image.height) {
                    return;
                }
                ctx.save();
                this.doClip(ctx);
                this.setContext(ctx, style);
                this.setTransform(ctx);
                if (style.sWidth &amp;&amp; style.sHeight) {
                    var sx = style.sx || 0;
                    var sy = style.sy || 0;
                    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
                } else if (style.sx &amp;&amp; style.sy) {
                    var sx = style.sx;
                    var sy = style.sy;
                    var sWidth = width - sx;
                    var sHeight = height - sy;
                    ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
                } else {
                    ctx.drawImage(image, x, y, width, height);
                }
                if (!style.width) {
                    style.width = width;
                }
                if (!style.height) {
                    style.height = height;
                }
                if (!this.style.width) {
                    this.style.width = width;
                }
                if (!this.style.height) {
                    this.style.height = height;
                }
                this.drawText(ctx, style, this.style);
                ctx.restore();
            }
        },
        getRect: function (style) {
            return {
                x: style.x,
                y: style.y,
                width: style.width,
                height: style.height
            };
        },
        clearCache: function () {
            this._imageCache = {};
        }
    };
    require(&#x27;../tool/util&#x27;).inherits(ZImage, Base);
    return ZImage;
});define(&#x27;zrender/loadingEffect/Bar&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Base&#x27;,
    &#x27;../tool/util&#x27;,
    &#x27;../tool/color&#x27;,
    &#x27;../shape/Rectangle&#x27;
], function (require) {
    var Base = require(&#x27;./Base&#x27;);
    var util = require(&#x27;../tool/util&#x27;);
    var zrColor = require(&#x27;../tool/color&#x27;);
    var RectangleShape = require(&#x27;../shape/Rectangle&#x27;);
    function Bar(options) {
        Base.call(this, options);
    }
    util.inherits(Bar, Base);
    Bar.prototype._start = function (addShapeHandle, refreshHandle) {
        var options = util.merge(this.options, {
            textStyle: { color: &#x27;#888&#x27; },
            backgroundColor: &#x27;rgba(250, 250, 250, 0.8)&#x27;,
            effectOption: {
                x: 0,
                y: this.canvasHeight / 2 - 30,
                width: this.canvasWidth,
                height: 5,
                brushType: &#x27;fill&#x27;,
                timeInterval: 100
            }
        });
        var textShape = this.createTextShape(options.textStyle);
        var background = this.createBackgroundShape(options.backgroundColor);
        var effectOption = options.effectOption;
        var barShape = new RectangleShape({ highlightStyle: util.clone(effectOption) });
        barShape.highlightStyle.color = effectOption.color || zrColor.getLinearGradient(effectOption.x, effectOption.y, effectOption.x + effectOption.width, effectOption.y + effectOption.height, [
            [
                0,
                &#x27;#ff6400&#x27;
            ],
            [
                0.5,
                &#x27;#ffe100&#x27;
            ],
            [
                1,
                &#x27;#b1ff00&#x27;
            ]
        ]);
        if (options.progress != null) {
            addShapeHandle(background);
            barShape.highlightStyle.width = this.adjust(options.progress, [
                0,
                1
            ]) * options.effectOption.width;
            addShapeHandle(barShape);
            addShapeHandle(textShape);
            refreshHandle();
            return;
        } else {
            barShape.highlightStyle.width = 0;
            return setInterval(function () {
                addShapeHandle(background);
                if (barShape.highlightStyle.width &lt; effectOption.width) {
                    barShape.highlightStyle.width += 8;
                } else {
                    barShape.highlightStyle.width = 0;
                }
                addShapeHandle(barShape);
                addShapeHandle(textShape);
                refreshHandle();
            }, effectOption.timeInterval);
        }
    };
    return Bar;
});define(&#x27;zrender/loadingEffect/Bubble&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Base&#x27;,
    &#x27;../tool/util&#x27;,
    &#x27;../tool/color&#x27;,
    &#x27;../shape/Circle&#x27;
], function (require) {
    var Base = require(&#x27;./Base&#x27;);
    var util = require(&#x27;../tool/util&#x27;);
    var zrColor = require(&#x27;../tool/color&#x27;);
    var CircleShape = require(&#x27;../shape/Circle&#x27;);
    function Bubble(options) {
        Base.call(this, options);
    }
    util.inherits(Bubble, Base);
    Bubble.prototype._start = function (addShapeHandle, refreshHandle) {
        var options = util.merge(this.options, {
            textStyle: { color: &#x27;#888&#x27; },
            backgroundColor: &#x27;rgba(250, 250, 250, 0.8)&#x27;,
            effect: {
                n: 50,
                lineWidth: 2,
                brushType: &#x27;stroke&#x27;,
                color: &#x27;random&#x27;,
                timeInterval: 100
            }
        });
        var textShape = this.createTextShape(options.textStyle);
        var background = this.createBackgroundShape(options.backgroundColor);
        var effectOption = options.effect;
        var n = effectOption.n;
        var brushType = effectOption.brushType;
        var lineWidth = effectOption.lineWidth;
        var shapeList = [];
        var canvasWidth = this.canvasWidth;
        var canvasHeight = this.canvasHeight;
        for (var i = 0; i &lt; n; i++) {
            var color = effectOption.color == &#x27;random&#x27; ? zrColor.alpha(zrColor.random(), 0.3) : effectOption.color;
            shapeList[i] = new CircleShape({
                highlightStyle: {
                    x: Math.ceil(Math.random() * canvasWidth),
                    y: Math.ceil(Math.random() * canvasHeight),
                    r: Math.ceil(Math.random() * 40),
                    brushType: brushType,
                    color: color,
                    strokeColor: color,
                    lineWidth: lineWidth
                },
                animationY: Math.ceil(Math.random() * 20)
            });
        }
        return setInterval(function () {
            addShapeHandle(background);
            for (var i = 0; i &lt; n; i++) {
                var style = shapeList[i].highlightStyle;
                if (style.y - shapeList[i].animationY + style.r &lt;= 0) {
                    shapeList[i].highlightStyle.y = canvasHeight + style.r;
                    shapeList[i].highlightStyle.x = Math.ceil(Math.random() * canvasWidth);
                }
                shapeList[i].highlightStyle.y -= shapeList[i].animationY;
                addShapeHandle(shapeList[i]);
            }
            addShapeHandle(textShape);
            refreshHandle();
        }, effectOption.timeInterval);
    };
    return Bubble;
});define(&#x27;zrender/loadingEffect/DynamicLine&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Base&#x27;,
    &#x27;../tool/util&#x27;,
    &#x27;../tool/color&#x27;,
    &#x27;../shape/Line&#x27;
], function (require) {
    var Base = require(&#x27;./Base&#x27;);
    var util = require(&#x27;../tool/util&#x27;);
    var zrColor = require(&#x27;../tool/color&#x27;);
    var LineShape = require(&#x27;../shape/Line&#x27;);
    function DynamicLine(options) {
        Base.call(this, options);
    }
    util.inherits(DynamicLine, Base);
    DynamicLine.prototype._start = function (addShapeHandle, refreshHandle) {
        var options = util.merge(this.options, {
            textStyle: { color: &#x27;#fff&#x27; },
            backgroundColor: &#x27;rgba(0, 0, 0, 0.8)&#x27;,
            effectOption: {
                n: 30,
                lineWidth: 1,
                color: &#x27;random&#x27;,
                timeInterval: 100
            }
        });
        var textShape = this.createTextShape(options.textStyle);
        var background = this.createBackgroundShape(options.backgroundColor);
        var effectOption = options.effectOption;
        var n = effectOption.n;
        var lineWidth = effectOption.lineWidth;
        var shapeList = [];
        var canvasWidth = this.canvasWidth;
        var canvasHeight = this.canvasHeight;
        for (var i = 0; i &lt; n; i++) {
            var xStart = -Math.ceil(Math.random() * 1000);
            var len = Math.ceil(Math.random() * 400);
            var pos = Math.ceil(Math.random() * canvasHeight);
            var color = effectOption.color == &#x27;random&#x27; ? zrColor.random() : effectOption.color;
            shapeList[i] = new LineShape({
                highlightStyle: {
                    xStart: xStart,
                    yStart: pos,
                    xEnd: xStart + len,
                    yEnd: pos,
                    strokeColor: color,
                    lineWidth: lineWidth
                },
                animationX: Math.ceil(Math.random() * 100),
                len: len
            });
        }
        return setInterval(function () {
            addShapeHandle(background);
            for (var i = 0; i &lt; n; i++) {
                var style = shapeList[i].highlightStyle;
                if (style.xStart &gt;= canvasWidth) {
                    shapeList[i].len = Math.ceil(Math.random() * 400);
                    style.xStart = -400;
                    style.xEnd = -400 + shapeList[i].len;
                    style.yStart = Math.ceil(Math.random() * canvasHeight);
                    style.yEnd = style.yStart;
                }
                style.xStart += shapeList[i].animationX;
                style.xEnd += shapeList[i].animationX;
                addShapeHandle(shapeList[i]);
            }
            addShapeHandle(textShape);
            refreshHandle();
        }, effectOption.timeInterval);
    };
    return DynamicLine;
});define(&#x27;zrender/loadingEffect/Ring&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Base&#x27;,
    &#x27;../tool/util&#x27;,
    &#x27;../tool/color&#x27;,
    &#x27;../shape/Ring&#x27;,
    &#x27;../shape/Sector&#x27;
], function (require) {
    var Base = require(&#x27;./Base&#x27;);
    var util = require(&#x27;../tool/util&#x27;);
    var zrColor = require(&#x27;../tool/color&#x27;);
    var RingShape = require(&#x27;../shape/Ring&#x27;);
    var SectorShape = require(&#x27;../shape/Sector&#x27;);
    function Ring(options) {
        Base.call(this, options);
    }
    util.inherits(Ring, Base);
    Ring.prototype._start = function (addShapeHandle, refreshHandle) {
        var options = util.merge(this.options, {
            textStyle: { color: &#x27;#07a&#x27; },
            backgroundColor: &#x27;rgba(250, 250, 250, 0.8)&#x27;,
            effect: {
                x: this.canvasWidth / 2,
                y: this.canvasHeight / 2,
                r0: 60,
                r: 100,
                color: &#x27;#bbdcff&#x27;,
                brushType: &#x27;fill&#x27;,
                textPosition: &#x27;inside&#x27;,
                textFont: &#x27;normal 30px verdana&#x27;,
                textColor: &#x27;rgba(30, 144, 255, 0.6)&#x27;,
                timeInterval: 100
            }
        });
        var effectOption = options.effect;
        var textStyle = options.textStyle;
        if (textStyle.x == null) {
            textStyle.x = effectOption.x;
        }
        if (textStyle.y == null) {
            textStyle.y = effectOption.y + (effectOption.r0 + effectOption.r) / 2 - 5;
        }
        var textShape = this.createTextShape(options.textStyle);
        var background = this.createBackgroundShape(options.backgroundColor);
        var x = effectOption.x;
        var y = effectOption.y;
        var r0 = effectOption.r0 + 6;
        var r = effectOption.r - 6;
        var color = effectOption.color;
        var darkColor = zrColor.lift(color, 0.1);
        var shapeRing = new RingShape({ highlightStyle: util.clone(effectOption) });
        var shapeList = [];
        var clolrList = zrColor.getGradientColors([
            &#x27;#ff6400&#x27;,
            &#x27;#ffe100&#x27;,
            &#x27;#97ff00&#x27;
        ], 25);
        var preAngle = 15;
        var endAngle = 240;
        for (var i = 0; i &lt; 16; i++) {
            shapeList.push(new SectorShape({
                highlightStyle: {
                    x: x,
                    y: y,
                    r0: r0,
                    r: r,
                    startAngle: endAngle - preAngle,
                    endAngle: endAngle,
                    brushType: &#x27;fill&#x27;,
                    color: darkColor
                },
                _color: zrColor.getLinearGradient(x + r0 * Math.cos(endAngle, true), y - r0 * Math.sin(endAngle, true), x + r0 * Math.cos(endAngle - preAngle, true), y - r0 * Math.sin(endAngle - preAngle, true), [
                    [
                        0,
                        clolrList[i * 2]
                    ],
                    [
                        1,
                        clolrList[i * 2 + 1]
                    ]
                ])
            }));
            endAngle -= preAngle;
        }
        endAngle = 360;
        for (var i = 0; i &lt; 4; i++) {
            shapeList.push(new SectorShape({
                highlightStyle: {
                    x: x,
                    y: y,
                    r0: r0,
                    r: r,
                    startAngle: endAngle - preAngle,
                    endAngle: endAngle,
                    brushType: &#x27;fill&#x27;,
                    color: darkColor
                },
                _color: zrColor.getLinearGradient(x + r0 * Math.cos(endAngle, true), y - r0 * Math.sin(endAngle, true), x + r0 * Math.cos(endAngle - preAngle, true), y - r0 * Math.sin(endAngle - preAngle, true), [
                    [
                        0,
                        clolrList[i * 2 + 32]
                    ],
                    [
                        1,
                        clolrList[i * 2 + 33]
                    ]
                ])
            }));
            endAngle -= preAngle;
        }
        var n = 0;
        if (options.progress != null) {
            addShapeHandle(background);
            n = this.adjust(options.progress, [
                0,
                1
            ]).toFixed(2) * 100 / 5;
            shapeRing.highlightStyle.text = n * 5 + &#x27;%&#x27;;
            addShapeHandle(shapeRing);
            for (var i = 0; i &lt; 20; i++) {
                shapeList[i].highlightStyle.color = i &lt; n ? shapeList[i]._color : darkColor;
                addShapeHandle(shapeList[i]);
            }
            addShapeHandle(textShape);
            refreshHandle();
            return;
        }
        return setInterval(function () {
            addShapeHandle(background);
            n += n &gt;= 20 ? -20 : 1;
            addShapeHandle(shapeRing);
            for (var i = 0; i &lt; 20; i++) {
                shapeList[i].highlightStyle.color = i &lt; n ? shapeList[i]._color : darkColor;
                addShapeHandle(shapeList[i]);
            }
            addShapeHandle(textShape);
            refreshHandle();
        }, effectOption.timeInterval);
    };
    return Ring;
});define(&#x27;zrender/loadingEffect/Spin&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Base&#x27;,
    &#x27;../tool/util&#x27;,
    &#x27;../tool/color&#x27;,
    &#x27;../tool/area&#x27;,
    &#x27;../shape/Sector&#x27;
], function (require) {
    var Base = require(&#x27;./Base&#x27;);
    var util = require(&#x27;../tool/util&#x27;);
    var zrColor = require(&#x27;../tool/color&#x27;);
    var zrArea = require(&#x27;../tool/area&#x27;);
    var SectorShape = require(&#x27;../shape/Sector&#x27;);
    function Spin(options) {
        Base.call(this, options);
    }
    util.inherits(Spin, Base);
    Spin.prototype._start = function (addShapeHandle, refreshHandle) {
        var options = util.merge(this.options, {
            textStyle: {
                color: &#x27;#fff&#x27;,
                textAlign: &#x27;start&#x27;
            },
            backgroundColor: &#x27;rgba(0, 0, 0, 0.8)&#x27;
        });
        var textShape = this.createTextShape(options.textStyle);
        var textGap = 10;
        var textWidth = zrArea.getTextWidth(textShape.highlightStyle.text, textShape.highlightStyle.textFont);
        var textHeight = zrArea.getTextHeight(textShape.highlightStyle.text, textShape.highlightStyle.textFont);
        var effectOption = util.merge(this.options.effect || {}, {
            r0: 9,
            r: 15,
            n: 18,
            color: &#x27;#fff&#x27;,
            timeInterval: 100
        });
        var location = this.getLocation(this.options.textStyle, textWidth + textGap + effectOption.r * 2, Math.max(effectOption.r * 2, textHeight));
        effectOption.x = location.x + effectOption.r;
        effectOption.y = textShape.highlightStyle.y = location.y + location.height / 2;
        textShape.highlightStyle.x = effectOption.x + effectOption.r + textGap;
        var background = this.createBackgroundShape(options.backgroundColor);
        var n = effectOption.n;
        var x = effectOption.x;
        var y = effectOption.y;
        var r0 = effectOption.r0;
        var r = effectOption.r;
        var color = effectOption.color;
        var shapeList = [];
        var preAngle = Math.round(180 / n);
        for (var i = 0; i &lt; n; i++) {
            shapeList[i] = new SectorShape({
                highlightStyle: {
                    x: x,
                    y: y,
                    r0: r0,
                    r: r,
                    startAngle: preAngle * i * 2,
                    endAngle: preAngle * i * 2 + preAngle,
                    color: zrColor.alpha(color, (i + 1) / n),
                    brushType: &#x27;fill&#x27;
                }
            });
        }
        var pos = [
            0,
            x,
            y
        ];
        return setInterval(function () {
            addShapeHandle(background);
            pos[0] -= 0.3;
            for (var i = 0; i &lt; n; i++) {
                shapeList[i].rotation = pos;
                addShapeHandle(shapeList[i]);
            }
            addShapeHandle(textShape);
            refreshHandle();
        }, effectOption.timeInterval);
    };
    return Spin;
});define(&#x27;zrender/loadingEffect/Whirling&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Base&#x27;,
    &#x27;../tool/util&#x27;,
    &#x27;../tool/area&#x27;,
    &#x27;../shape/Ring&#x27;,
    &#x27;../shape/Droplet&#x27;,
    &#x27;../shape/Circle&#x27;
], function (require) {
    var Base = require(&#x27;./Base&#x27;);
    var util = require(&#x27;../tool/util&#x27;);
    var zrArea = require(&#x27;../tool/area&#x27;);
    var RingShape = require(&#x27;../shape/Ring&#x27;);
    var DropletShape = require(&#x27;../shape/Droplet&#x27;);
    var CircleShape = require(&#x27;../shape/Circle&#x27;);
    function Whirling(options) {
        Base.call(this, options);
    }
    util.inherits(Whirling, Base);
    Whirling.prototype._start = function (addShapeHandle, refreshHandle) {
        var options = util.merge(this.options, {
            textStyle: {
                color: &#x27;#888&#x27;,
                textAlign: &#x27;start&#x27;
            },
            backgroundColor: &#x27;rgba(250, 250, 250, 0.8)&#x27;
        });
        var textShape = this.createTextShape(options.textStyle);
        var textGap = 10;
        var textWidth = zrArea.getTextWidth(textShape.highlightStyle.text, textShape.highlightStyle.textFont);
        var textHeight = zrArea.getTextHeight(textShape.highlightStyle.text, textShape.highlightStyle.textFont);
        var effectOption = util.merge(this.options.effect || {}, {
            r: 18,
            colorIn: &#x27;#fff&#x27;,
            colorOut: &#x27;#555&#x27;,
            colorWhirl: &#x27;#6cf&#x27;,
            timeInterval: 50
        });
        var location = this.getLocation(this.options.textStyle, textWidth + textGap + effectOption.r * 2, Math.max(effectOption.r * 2, textHeight));
        effectOption.x = location.x + effectOption.r;
        effectOption.y = textShape.highlightStyle.y = location.y + location.height / 2;
        textShape.highlightStyle.x = effectOption.x + effectOption.r + textGap;
        var background = this.createBackgroundShape(options.backgroundColor);
        var droplet = new DropletShape({
            highlightStyle: {
                a: Math.round(effectOption.r / 2),
                b: Math.round(effectOption.r - effectOption.r / 6),
                brushType: &#x27;fill&#x27;,
                color: effectOption.colorWhirl
            }
        });
        var circleIn = new CircleShape({
            highlightStyle: {
                r: Math.round(effectOption.r / 6),
                brushType: &#x27;fill&#x27;,
                color: effectOption.colorIn
            }
        });
        var circleOut = new RingShape({
            highlightStyle: {
                r0: Math.round(effectOption.r - effectOption.r / 3),
                r: effectOption.r,
                brushType: &#x27;fill&#x27;,
                color: effectOption.colorOut
            }
        });
        var pos = [
            0,
            effectOption.x,
            effectOption.y
        ];
        droplet.highlightStyle.x = circleIn.highlightStyle.x = circleOut.highlightStyle.x = pos[1];
        droplet.highlightStyle.y = circleIn.highlightStyle.y = circleOut.highlightStyle.y = pos[2];
        return setInterval(function () {
            addShapeHandle(background);
            addShapeHandle(circleOut);
            pos[0] -= 0.3;
            droplet.rotation = pos;
            addShapeHandle(droplet);
            addShapeHandle(circleIn);
            addShapeHandle(textShape);
            refreshHandle();
        }, effectOption.timeInterval);
    };
    return Whirling;
});define(&#x27;echarts/theme/default&#x27;, [], function () {
    var config = {};
    return config;
});define(&#x27;zrender/dep/excanvas&#x27;, [&#x27;require&#x27;], function (require) {
    if (!document.createElement(&#x27;canvas&#x27;).getContext) {
        (function () {
            var m = Math;
            var mr = m.round;
            var ms = m.sin;
            var mc = m.cos;
            var abs = m.abs;
            var sqrt = m.sqrt;
            var Z = 10;
            var Z2 = Z / 2;
            var IE_VERSION = +navigator.userAgent.match(/MSIE ([\d.]+)?/)[1];
            function getContext() {
                return this.context_ || (this.context_ = new CanvasRenderingContext2D_(this));
            }
            var slice = Array.prototype.slice;
            function bind(f, obj, var_args) {
                var a = slice.call(arguments, 2);
                return function () {
                    return f.apply(obj, a.concat(slice.call(arguments)));
                };
            }
            function encodeHtmlAttribute(s) {
                return String(s).replace(/&amp;/g, &#x27;&amp;amp;&#x27;).replace(/&quot;/g, &#x27;&amp;quot;&#x27;);
            }
            function addNamespace(doc, prefix, urn) {
                if (!doc.namespaces[prefix]) {
                    doc.namespaces.add(prefix, urn, &#x27;#default#VML&#x27;);
                }
            }
            function addNamespacesAndStylesheet(doc) {
                addNamespace(doc, &#x27;g_vml_&#x27;, &#x27;urn:schemas-microsoft-com:vml&#x27;);
                addNamespace(doc, &#x27;g_o_&#x27;, &#x27;urn:schemas-microsoft-com:office:office&#x27;);
                if (!doc.styleSheets[&#x27;ex_canvas_&#x27;]) {
                    var ss = doc.createStyleSheet();
                    ss.owningElement.id = &#x27;ex_canvas_&#x27;;
                    ss.cssText = &#x27;canvas{display:inline-block;overflow:hidden;&#x27; + &#x27;text-align:left;width:300px;height:150px}&#x27;;
                }
            }
            addNamespacesAndStylesheet(document);
            var G_vmlCanvasManager_ = {
                init: function (opt_doc) {
                    var doc = opt_doc || document;
                    doc.createElement(&#x27;canvas&#x27;);
                    doc.attachEvent(&#x27;onreadystatechange&#x27;, bind(this.init_, this, doc));
                },
                init_: function (doc) {
                    var els = doc.getElementsByTagName(&#x27;canvas&#x27;);
                    for (var i = 0; i &lt; els.length; i++) {
                        this.initElement(els[i]);
                    }
                },
                initElement: function (el) {
                    if (!el.getContext) {
                        el.getContext = getContext;
                        addNamespacesAndStylesheet(el.ownerDocument);
                        el.innerHTML = &#x27;&#x27;;
                        el.attachEvent(&#x27;onpropertychange&#x27;, onPropertyChange);
                        el.attachEvent(&#x27;onresize&#x27;, onResize);
                        var attrs = el.attributes;
                        if (attrs.width &amp;&amp; attrs.width.specified) {
                            el.style.width = attrs.width.nodeValue + &#x27;px&#x27;;
                        } else {
                            el.width = el.clientWidth;
                        }
                        if (attrs.height &amp;&amp; attrs.height.specified) {
                            el.style.height = attrs.height.nodeValue + &#x27;px&#x27;;
                        } else {
                            el.height = el.clientHeight;
                        }
                    }
                    return el;
                }
            };
            function onPropertyChange(e) {
                var el = e.srcElement;
                switch (e.propertyName) {
                case &#x27;width&#x27;:
                    el.getContext().clearRect();
                    el.style.width = el.attributes.width.nodeValue + &#x27;px&#x27;;
                    el.firstChild.style.width = el.clientWidth + &#x27;px&#x27;;
                    break;
                case &#x27;height&#x27;:
                    el.getContext().clearRect();
                    el.style.height = el.attributes.height.nodeValue + &#x27;px&#x27;;
                    el.firstChild.style.height = el.clientHeight + &#x27;px&#x27;;
                    break;
                }
            }
            function onResize(e) {
                var el = e.srcElement;
                if (el.firstChild) {
                    el.firstChild.style.width = el.clientWidth + &#x27;px&#x27;;
                    el.firstChild.style.height = el.clientHeight + &#x27;px&#x27;;
                }
            }
            G_vmlCanvasManager_.init();
            var decToHex = [];
            for (var i = 0; i &lt; 16; i++) {
                for (var j = 0; j &lt; 16; j++) {
                    decToHex[i * 16 + j] = i.toString(16) + j.toString(16);
                }
            }
            function createMatrixIdentity() {
                return [
                    [
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        1,
                        0
                    ],
                    [
                        0,
                        0,
                        1
                    ]
                ];
            }
            function matrixMultiply(m1, m2) {
                var result = createMatrixIdentity();
                for (var x = 0; x &lt; 3; x++) {
                    for (var y = 0; y &lt; 3; y++) {
                        var sum = 0;
                        for (var z = 0; z &lt; 3; z++) {
                            sum += m1[x][z] * m2[z][y];
                        }
                        result[x][y] = sum;
                    }
                }
                return result;
            }
            function copyState(o1, o2) {
                o2.fillStyle = o1.fillStyle;
                o2.lineCap = o1.lineCap;
                o2.lineJoin = o1.lineJoin;
                o2.lineWidth = o1.lineWidth;
                o2.miterLimit = o1.miterLimit;
                o2.shadowBlur = o1.shadowBlur;
                o2.shadowColor = o1.shadowColor;
                o2.shadowOffsetX = o1.shadowOffsetX;
                o2.shadowOffsetY = o1.shadowOffsetY;
                o2.strokeStyle = o1.strokeStyle;
                o2.globalAlpha = o1.globalAlpha;
                o2.font = o1.font;
                o2.textAlign = o1.textAlign;
                o2.textBaseline = o1.textBaseline;
                o2.scaleX_ = o1.scaleX_;
                o2.scaleY_ = o1.scaleY_;
                o2.lineScale_ = o1.lineScale_;
            }
            var colorData = {
                aliceblue: &#x27;#F0F8FF&#x27;,
                antiquewhite: &#x27;#FAEBD7&#x27;,
                aquamarine: &#x27;#7FFFD4&#x27;,
                azure: &#x27;#F0FFFF&#x27;,
                beige: &#x27;#F5F5DC&#x27;,
                bisque: &#x27;#FFE4C4&#x27;,
                black: &#x27;#000000&#x27;,
                blanchedalmond: &#x27;#FFEBCD&#x27;,
                blueviolet: &#x27;#8A2BE2&#x27;,
                brown: &#x27;#A52A2A&#x27;,
                burlywood: &#x27;#DEB887&#x27;,
                cadetblue: &#x27;#5F9EA0&#x27;,
                chartreuse: &#x27;#7FFF00&#x27;,
                chocolate: &#x27;#D2691E&#x27;,
                coral: &#x27;#FF7F50&#x27;,
                cornflowerblue: &#x27;#6495ED&#x27;,
                cornsilk: &#x27;#FFF8DC&#x27;,
                crimson: &#x27;#DC143C&#x27;,
                cyan: &#x27;#00FFFF&#x27;,
                darkblue: &#x27;#00008B&#x27;,
                darkcyan: &#x27;#008B8B&#x27;,
                darkgoldenrod: &#x27;#B8860B&#x27;,
                darkgray: &#x27;#A9A9A9&#x27;,
                darkgreen: &#x27;#006400&#x27;,
                darkgrey: &#x27;#A9A9A9&#x27;,
                darkkhaki: &#x27;#BDB76B&#x27;,
                darkmagenta: &#x27;#8B008B&#x27;,
                darkolivegreen: &#x27;#556B2F&#x27;,
                darkorange: &#x27;#FF8C00&#x27;,
                darkorchid: &#x27;#9932CC&#x27;,
                darkred: &#x27;#8B0000&#x27;,
                darksalmon: &#x27;#E9967A&#x27;,
                darkseagreen: &#x27;#8FBC8F&#x27;,
                darkslateblue: &#x27;#483D8B&#x27;,
                darkslategray: &#x27;#2F4F4F&#x27;,
                darkslategrey: &#x27;#2F4F4F&#x27;,
                darkturquoise: &#x27;#00CED1&#x27;,
                darkviolet: &#x27;#9400D3&#x27;,
                deeppink: &#x27;#FF1493&#x27;,
                deepskyblue: &#x27;#00BFFF&#x27;,
                dimgray: &#x27;#696969&#x27;,
                dimgrey: &#x27;#696969&#x27;,
                dodgerblue: &#x27;#1E90FF&#x27;,
                firebrick: &#x27;#B22222&#x27;,
                floralwhite: &#x27;#FFFAF0&#x27;,
                forestgreen: &#x27;#228B22&#x27;,
                gainsboro: &#x27;#DCDCDC&#x27;,
                ghostwhite: &#x27;#F8F8FF&#x27;,
                gold: &#x27;#FFD700&#x27;,
                goldenrod: &#x27;#DAA520&#x27;,
                grey: &#x27;#808080&#x27;,
                greenyellow: &#x27;#ADFF2F&#x27;,
                honeydew: &#x27;#F0FFF0&#x27;,
                hotpink: &#x27;#FF69B4&#x27;,
                indianred: &#x27;#CD5C5C&#x27;,
                indigo: &#x27;#4B0082&#x27;,
                ivory: &#x27;#FFFFF0&#x27;,
                khaki: &#x27;#F0E68C&#x27;,
                lavender: &#x27;#E6E6FA&#x27;,
                lavenderblush: &#x27;#FFF0F5&#x27;,
                lawngreen: &#x27;#7CFC00&#x27;,
                lemonchiffon: &#x27;#FFFACD&#x27;,
                lightblue: &#x27;#ADD8E6&#x27;,
                lightcoral: &#x27;#F08080&#x27;,
                lightcyan: &#x27;#E0FFFF&#x27;,
                lightgoldenrodyellow: &#x27;#FAFAD2&#x27;,
                lightgreen: &#x27;#90EE90&#x27;,
                lightgrey: &#x27;#D3D3D3&#x27;,
                lightpink: &#x27;#FFB6C1&#x27;,
                lightsalmon: &#x27;#FFA07A&#x27;,
                lightseagreen: &#x27;#20B2AA&#x27;,
                lightskyblue: &#x27;#87CEFA&#x27;,
                lightslategray: &#x27;#778899&#x27;,
                lightslategrey: &#x27;#778899&#x27;,
                lightsteelblue: &#x27;#B0C4DE&#x27;,
                lightyellow: &#x27;#FFFFE0&#x27;,
                limegreen: &#x27;#32CD32&#x27;,
                linen: &#x27;#FAF0E6&#x27;,
                magenta: &#x27;#FF00FF&#x27;,
                mediumaquamarine: &#x27;#66CDAA&#x27;,
                mediumblue: &#x27;#0000CD&#x27;,
                mediumorchid: &#x27;#BA55D3&#x27;,
                mediumpurple: &#x27;#9370DB&#x27;,
                mediumseagreen: &#x27;#3CB371&#x27;,
                mediumslateblue: &#x27;#7B68EE&#x27;,
                mediumspringgreen: &#x27;#00FA9A&#x27;,
                mediumturquoise: &#x27;#48D1CC&#x27;,
                mediumvioletred: &#x27;#C71585&#x27;,
                midnightblue: &#x27;#191970&#x27;,
                mintcream: &#x27;#F5FFFA&#x27;,
                mistyrose: &#x27;#FFE4E1&#x27;,
                moccasin: &#x27;#FFE4B5&#x27;,
                navajowhite: &#x27;#FFDEAD&#x27;,
                oldlace: &#x27;#FDF5E6&#x27;,
                olivedrab: &#x27;#6B8E23&#x27;,
                orange: &#x27;#FFA500&#x27;,
                orangered: &#x27;#FF4500&#x27;,
                orchid: &#x27;#DA70D6&#x27;,
                palegoldenrod: &#x27;#EEE8AA&#x27;,
                palegreen: &#x27;#98FB98&#x27;,
                paleturquoise: &#x27;#AFEEEE&#x27;,
                palevioletred: &#x27;#DB7093&#x27;,
                papayawhip: &#x27;#FFEFD5&#x27;,
                peachpuff: &#x27;#FFDAB9&#x27;,
                peru: &#x27;#CD853F&#x27;,
                pink: &#x27;#FFC0CB&#x27;,
                plum: &#x27;#DDA0DD&#x27;,
                powderblue: &#x27;#B0E0E6&#x27;,
                rosybrown: &#x27;#BC8F8F&#x27;,
                royalblue: &#x27;#4169E1&#x27;,
                saddlebrown: &#x27;#8B4513&#x27;,
                salmon: &#x27;#FA8072&#x27;,
                sandybrown: &#x27;#F4A460&#x27;,
                seagreen: &#x27;#2E8B57&#x27;,
                seashell: &#x27;#FFF5EE&#x27;,
                sienna: &#x27;#A0522D&#x27;,
                skyblue: &#x27;#87CEEB&#x27;,
                slateblue: &#x27;#6A5ACD&#x27;,
                slategray: &#x27;#708090&#x27;,
                slategrey: &#x27;#708090&#x27;,
                snow: &#x27;#FFFAFA&#x27;,
                springgreen: &#x27;#00FF7F&#x27;,
                steelblue: &#x27;#4682B4&#x27;,
                tan: &#x27;#D2B48C&#x27;,
                thistle: &#x27;#D8BFD8&#x27;,
                tomato: &#x27;#FF6347&#x27;,
                turquoise: &#x27;#40E0D0&#x27;,
                violet: &#x27;#EE82EE&#x27;,
                wheat: &#x27;#F5DEB3&#x27;,
                whitesmoke: &#x27;#F5F5F5&#x27;,
                yellowgreen: &#x27;#9ACD32&#x27;
            };
            function getRgbHslContent(styleString) {
                var start = styleString.indexOf(&#x27;(&#x27;, 3);
                var end = styleString.indexOf(&#x27;)&#x27;, start + 1);
                var parts = styleString.substring(start + 1, end).split(&#x27;,&#x27;);
                if (parts.length != 4 || styleString.charAt(3) != &#x27;a&#x27;) {
                    parts[3] = 1;
                }
                return parts;
            }
            function percent(s) {
                return parseFloat(s) / 100;
            }
            function clamp(v, min, max) {
                return Math.min(max, Math.max(min, v));
            }
            function hslToRgb(parts) {
                var r, g, b, h, s, l;
                h = parseFloat(parts[0]) / 360 % 360;
                if (h &lt; 0)
                    h++;
                s = clamp(percent(parts[1]), 0, 1);
                l = clamp(percent(parts[2]), 0, 1);
                if (s == 0) {
                    r = g = b = l;
                } else {
                    var q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
                    var p = 2 * l - q;
                    r = hueToRgb(p, q, h + 1 / 3);
                    g = hueToRgb(p, q, h);
                    b = hueToRgb(p, q, h - 1 / 3);
                }
                return &#x27;#&#x27; + decToHex[Math.floor(r * 255)] + decToHex[Math.floor(g * 255)] + decToHex[Math.floor(b * 255)];
            }
            function hueToRgb(m1, m2, h) {
                if (h &lt; 0)
                    h++;
                if (h &gt; 1)
                    h--;
                if (6 * h &lt; 1)
                    return m1 + (m2 - m1) * 6 * h;
                else if (2 * h &lt; 1)
                    return m2;
                else if (3 * h &lt; 2)
                    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
                else
                    return m1;
            }
            var processStyleCache = {};
            function processStyle(styleString) {
                if (styleString in processStyleCache) {
                    return processStyleCache[styleString];
                }
                var str, alpha = 1;
                styleString = String(styleString);
                if (styleString.charAt(0) == &#x27;#&#x27;) {
                    str = styleString;
                } else if (/^rgb/.test(styleString)) {
                    var parts = getRgbHslContent(styleString);
                    var str = &#x27;#&#x27;, n;
                    for (var i = 0; i &lt; 3; i++) {
                        if (parts[i].indexOf(&#x27;%&#x27;) != -1) {
                            n = Math.floor(percent(parts[i]) * 255);
                        } else {
                            n = +parts[i];
                        }
                        str += decToHex[clamp(n, 0, 255)];
                    }
                    alpha = +parts[3];
                } else if (/^hsl/.test(styleString)) {
                    var parts = getRgbHslContent(styleString);
                    str = hslToRgb(parts);
                    alpha = parts[3];
                } else {
                    str = colorData[styleString] || styleString;
                }
                return processStyleCache[styleString] = {
                    color: str,
                    alpha: alpha
                };
            }
            var DEFAULT_STYLE = {
                style: &#x27;normal&#x27;,
                variant: &#x27;normal&#x27;,
                weight: &#x27;normal&#x27;,
                size: 12,
                family: &#x27;微软雅黑&#x27;
            };
            var fontStyleCache = {};
            function processFontStyle(styleString) {
                if (fontStyleCache[styleString]) {
                    return fontStyleCache[styleString];
                }
                var el = document.createElement(&#x27;div&#x27;);
                var style = el.style;
                var fontFamily;
                try {
                    style.font = styleString;
                    fontFamily = style.fontFamily.split(&#x27;,&#x27;)[0];
                } catch (ex) {
                }
                return fontStyleCache[styleString] = {
                    style: style.fontStyle || DEFAULT_STYLE.style,
                    variant: style.fontVariant || DEFAULT_STYLE.variant,
                    weight: style.fontWeight || DEFAULT_STYLE.weight,
                    size: style.fontSize || DEFAULT_STYLE.size,
                    family: fontFamily || DEFAULT_STYLE.family
                };
            }
            function getComputedStyle(style, element) {
                var computedStyle = {};
                for (var p in style) {
                    computedStyle[p] = style[p];
                }
                var canvasFontSize = parseFloat(element.currentStyle.fontSize), fontSize = parseFloat(style.size);
                if (typeof style.size == &#x27;number&#x27;) {
                    computedStyle.size = style.size;
                } else if (style.size.indexOf(&#x27;px&#x27;) != -1) {
                    computedStyle.size = fontSize;
                } else if (style.size.indexOf(&#x27;em&#x27;) != -1) {
                    computedStyle.size = canvasFontSize * fontSize;
                } else if (style.size.indexOf(&#x27;%&#x27;) != -1) {
                    computedStyle.size = canvasFontSize / 100 * fontSize;
                } else if (style.size.indexOf(&#x27;pt&#x27;) != -1) {
                    computedStyle.size = fontSize / 0.75;
                } else {
                    computedStyle.size = canvasFontSize;
                }
                return computedStyle;
            }
            function buildStyle(style) {
                return style.style + &#x27; &#x27; + style.variant + &#x27; &#x27; + style.weight + &#x27; &#x27; + style.size + &#x27;px \&#x27;&#x27; + style.family + &#x27;\&#x27;&#x27;;
            }
            var lineCapMap = {
                &#x27;butt&#x27;: &#x27;flat&#x27;,
                &#x27;round&#x27;: &#x27;round&#x27;
            };
            function processLineCap(lineCap) {
                return lineCapMap[lineCap] || &#x27;square&#x27;;
            }
            function CanvasRenderingContext2D_(canvasElement) {
                this.m_ = createMatrixIdentity();
                this.mStack_ = [];
                this.aStack_ = [];
                this.currentPath_ = [];
                this.strokeStyle = &#x27;#000&#x27;;
                this.fillStyle = &#x27;#000&#x27;;
                this.lineWidth = 1;
                this.lineJoin = &#x27;miter&#x27;;
                this.lineCap = &#x27;butt&#x27;;
                this.miterLimit = Z * 1;
                this.globalAlpha = 1;
                this.font = &#x27;12px 微软雅黑&#x27;;
                this.textAlign = &#x27;left&#x27;;
                this.textBaseline = &#x27;alphabetic&#x27;;
                this.canvas = canvasElement;
                var cssText = &#x27;width:&#x27; + canvasElement.clientWidth + &#x27;px;height:&#x27; + canvasElement.clientHeight + &#x27;px;overflow:hidden;position:absolute&#x27;;
                var el = canvasElement.ownerDocument.createElement(&#x27;div&#x27;);
                el.style.cssText = cssText;
                canvasElement.appendChild(el);
                var overlayEl = el.cloneNode(false);
                overlayEl.style.backgroundColor = &#x27;#fff&#x27;;
                overlayEl.style.filter = &#x27;alpha(opacity=0)&#x27;;
                canvasElement.appendChild(overlayEl);
                this.element_ = el;
                this.scaleX_ = 1;
                this.scaleY_ = 1;
                this.lineScale_ = 1;
            }
            var contextPrototype = CanvasRenderingContext2D_.prototype;
            contextPrototype.clearRect = function () {
                if (this.textMeasureEl_) {
                    this.textMeasureEl_.removeNode(true);
                    this.textMeasureEl_ = null;
                }
                this.element_.innerHTML = &#x27;&#x27;;
            };
            contextPrototype.beginPath = function () {
                this.currentPath_ = [];
            };
            contextPrototype.moveTo = function (aX, aY) {
                var p = getCoords(this, aX, aY);
                this.currentPath_.push({
                    type: &#x27;moveTo&#x27;,
                    x: p.x,
                    y: p.y
                });
                this.currentX_ = p.x;
                this.currentY_ = p.y;
            };
            contextPrototype.lineTo = function (aX, aY) {
                var p = getCoords(this, aX, aY);
                this.currentPath_.push({
                    type: &#x27;lineTo&#x27;,
                    x: p.x,
                    y: p.y
                });
                this.currentX_ = p.x;
                this.currentY_ = p.y;
            };
            contextPrototype.bezierCurveTo = function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
                var p = getCoords(this, aX, aY);
                var cp1 = getCoords(this, aCP1x, aCP1y);
                var cp2 = getCoords(this, aCP2x, aCP2y);
                bezierCurveTo(this, cp1, cp2, p);
            };
            function bezierCurveTo(self, cp1, cp2, p) {
                self.currentPath_.push({
                    type: &#x27;bezierCurveTo&#x27;,
                    cp1x: cp1.x,
                    cp1y: cp1.y,
                    cp2x: cp2.x,
                    cp2y: cp2.y,
                    x: p.x,
                    y: p.y
                });
                self.currentX_ = p.x;
                self.currentY_ = p.y;
            }
            contextPrototype.quadraticCurveTo = function (aCPx, aCPy, aX, aY) {
                var cp = getCoords(this, aCPx, aCPy);
                var p = getCoords(this, aX, aY);
                var cp1 = {
                    x: this.currentX_ + 2 / 3 * (cp.x - this.currentX_),
                    y: this.currentY_ + 2 / 3 * (cp.y - this.currentY_)
                };
                var cp2 = {
                    x: cp1.x + (p.x - this.currentX_) / 3,
                    y: cp1.y + (p.y - this.currentY_) / 3
                };
                bezierCurveTo(this, cp1, cp2, p);
            };
            contextPrototype.arc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
                aRadius *= Z;
                var arcType = aClockwise ? &#x27;at&#x27; : &#x27;wa&#x27;;
                var xStart = aX + mc(aStartAngle) * aRadius - Z2;
                var yStart = aY + ms(aStartAngle) * aRadius - Z2;
                var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
                var yEnd = aY + ms(aEndAngle) * aRadius - Z2;
                if (xStart == xEnd &amp;&amp; !aClockwise) {
                    xStart += 0.125;
                }
                var p = getCoords(this, aX, aY);
                var pStart = getCoords(this, xStart, yStart);
                var pEnd = getCoords(this, xEnd, yEnd);
                this.currentPath_.push({
                    type: arcType,
                    x: p.x,
                    y: p.y,
                    radius: aRadius,
                    xStart: pStart.x,
                    yStart: pStart.y,
                    xEnd: pEnd.x,
                    yEnd: pEnd.y
                });
            };
            contextPrototype.rect = function (aX, aY, aWidth, aHeight) {
                this.moveTo(aX, aY);
                this.lineTo(aX + aWidth, aY);
                this.lineTo(aX + aWidth, aY + aHeight);
                this.lineTo(aX, aY + aHeight);
                this.closePath();
            };
            contextPrototype.strokeRect = function (aX, aY, aWidth, aHeight) {
                var oldPath = this.currentPath_;
                this.beginPath();
                this.moveTo(aX, aY);
                this.lineTo(aX + aWidth, aY);
                this.lineTo(aX + aWidth, aY + aHeight);
                this.lineTo(aX, aY + aHeight);
                this.closePath();
                this.stroke();
                this.currentPath_ = oldPath;
            };
            contextPrototype.fillRect = function (aX, aY, aWidth, aHeight) {
                var oldPath = this.currentPath_;
                this.beginPath();
                this.moveTo(aX, aY);
                this.lineTo(aX + aWidth, aY);
                this.lineTo(aX + aWidth, aY + aHeight);
                this.lineTo(aX, aY + aHeight);
                this.closePath();
                this.fill();
                this.currentPath_ = oldPath;
            };
            contextPrototype.createLinearGradient = function (aX0, aY0, aX1, aY1) {
                var gradient = new CanvasGradient_(&#x27;gradient&#x27;);
                gradient.x0_ = aX0;
                gradient.y0_ = aY0;
                gradient.x1_ = aX1;
                gradient.y1_ = aY1;
                return gradient;
            };
            contextPrototype.createRadialGradient = function (aX0, aY0, aR0, aX1, aY1, aR1) {
                var gradient = new CanvasGradient_(&#x27;gradientradial&#x27;);
                gradient.x0_ = aX0;
                gradient.y0_ = aY0;
                gradient.r0_ = aR0;
                gradient.x1_ = aX1;
                gradient.y1_ = aY1;
                gradient.r1_ = aR1;
                return gradient;
            };
            contextPrototype.drawImage = function (image, var_args) {
                var dx, dy, dw, dh, sx, sy, sw, sh;
                var oldRuntimeWidth = image.runtimeStyle.width;
                var oldRuntimeHeight = image.runtimeStyle.height;
                image.runtimeStyle.width = &#x27;auto&#x27;;
                image.runtimeStyle.height = &#x27;auto&#x27;;
                var w = image.width;
                var h = image.height;
                image.runtimeStyle.width = oldRuntimeWidth;
                image.runtimeStyle.height = oldRuntimeHeight;
                if (arguments.length == 3) {
                    dx = arguments[1];
                    dy = arguments[2];
                    sx = sy = 0;
                    sw = dw = w;
                    sh = dh = h;
                } else if (arguments.length == 5) {
                    dx = arguments[1];
                    dy = arguments[2];
                    dw = arguments[3];
                    dh = arguments[4];
                    sx = sy = 0;
                    sw = w;
                    sh = h;
                } else if (arguments.length == 9) {
                    sx = arguments[1];
                    sy = arguments[2];
                    sw = arguments[3];
                    sh = arguments[4];
                    dx = arguments[5];
                    dy = arguments[6];
                    dw = arguments[7];
                    dh = arguments[8];
                } else {
                    throw Error(&#x27;Invalid number of arguments&#x27;);
                }
                var d = getCoords(this, dx, dy);
                var w2 = sw / 2;
                var h2 = sh / 2;
                var vmlStr = [];
                var W = 10;
                var H = 10;
                var scaleX = scaleY = 1;
                vmlStr.push(&#x27; &lt;g_vml_:group&#x27;, &#x27; coordsize=&quot;&#x27;, Z * W, &#x27;,&#x27;, Z * H, &#x27;&quot;&#x27;, &#x27; coordorigin=&quot;0,0&quot;&#x27;, &#x27; style=&quot;width:&#x27;, W, &#x27;px;height:&#x27;, H, &#x27;px;position:absolute;&#x27;);
                if (this.m_[0][0] != 1 || this.m_[0][1] || this.m_[1][1] != 1 || this.m_[1][0]) {
                    var filter = [];
                    var scaleX = this.scaleX_;
                    var scaleY = this.scaleY_;
                    filter.push(&#x27;M11=&#x27;, this.m_[0][0] / scaleX, &#x27;,&#x27;, &#x27;M12=&#x27;, this.m_[1][0] / scaleY, &#x27;,&#x27;, &#x27;M21=&#x27;, this.m_[0][1] / scaleX, &#x27;,&#x27;, &#x27;M22=&#x27;, this.m_[1][1] / scaleY, &#x27;,&#x27;, &#x27;Dx=&#x27;, mr(d.x / Z), &#x27;,&#x27;, &#x27;Dy=&#x27;, mr(d.y / Z), &#x27;&#x27;);
                    var max = d;
                    var c2 = getCoords(this, dx + dw, dy);
                    var c3 = getCoords(this, dx, dy + dh);
                    var c4 = getCoords(this, dx + dw, dy + dh);
                    max.x = m.max(max.x, c2.x, c3.x, c4.x);
                    max.y = m.max(max.y, c2.y, c3.y, c4.y);
                    vmlStr.push(&#x27;padding:0 &#x27;, mr(max.x / Z), &#x27;px &#x27;, mr(max.y / Z), &#x27;px 0;filter:progid:DXImageTransform.Microsoft.Matrix(&#x27;, filter.join(&#x27;&#x27;), &#x27;, SizingMethod=\&#x27;clip\&#x27;);&#x27;);
                } else {
                    vmlStr.push(&#x27;top:&#x27;, mr(d.y / Z), &#x27;px;left:&#x27;, mr(d.x / Z), &#x27;px;&#x27;);
                }
                vmlStr.push(&#x27; &quot;&gt;&#x27;);
                if (sx || sy) {
                    vmlStr.push(&#x27;&lt;div style=&quot;overflow: hidden; width:&#x27;, Math.ceil((dw + sx * dw / sw) * scaleX), &#x27;px;&#x27;, &#x27; height:&#x27;, Math.ceil((dh + sy * dh / sh) * scaleY), &#x27;px;&#x27;, &#x27; filter:progid:DxImageTransform.Microsoft.Matrix(Dx=&#x27;, -sx * dw / sw * scaleX, &#x27;,Dy=&#x27;, -sy * dh / sh * scaleY, &#x27;);&quot;&gt;&#x27;);
                }
                vmlStr.push(&#x27;&lt;div style=&quot;width:&#x27;, Math.round(scaleX * w * dw / sw), &#x27;px;&#x27;, &#x27; height:&#x27;, Math.round(scaleY * h * dh / sh), &#x27;px;&#x27;, &#x27; filter:&#x27;);
                if (this.globalAlpha &lt; 1) {
                    vmlStr.push(&#x27; progid:DXImageTransform.Microsoft.Alpha(opacity=&#x27; + this.globalAlpha * 100 + &#x27;)&#x27;);
                }
                vmlStr.push(&#x27; progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&#x27;, image.src, &#x27;,sizingMethod=scale)&quot;&gt;&#x27;);
                if (sx || sy)
                    vmlStr.push(&#x27;&lt;/div&gt;&#x27;);
                vmlStr.push(&#x27;&lt;/div&gt;&lt;/div&gt;&#x27;);
                this.element_.insertAdjacentHTML(&#x27;BeforeEnd&#x27;, vmlStr.join(&#x27;&#x27;));
            };
            contextPrototype.stroke = function (aFill) {
                var lineStr = [];
                var lineOpen = false;
                var W = 10;
                var H = 10;
                lineStr.push(&#x27;&lt;g_vml_:shape&#x27;, &#x27; filled=&quot;&#x27;, !!aFill, &#x27;&quot;&#x27;, &#x27; style=&quot;position:absolute;width:&#x27;, W, &#x27;px;height:&#x27;, H, &#x27;px;&quot;&#x27;, &#x27; coordorigin=&quot;0,0&quot;&#x27;, &#x27; coordsize=&quot;&#x27;, Z * W, &#x27;,&#x27;, Z * H, &#x27;&quot;&#x27;, &#x27; stroked=&quot;&#x27;, !aFill, &#x27;&quot;&#x27;, &#x27; path=&quot;&#x27;);
                var newSeq = false;
                var min = {
                    x: null,
                    y: null
                };
                var max = {
                    x: null,
                    y: null
                };
                for (var i = 0; i &lt; this.currentPath_.length; i++) {
                    var p = this.currentPath_[i];
                    var c;
                    switch (p.type) {
                    case &#x27;moveTo&#x27;:
                        c = p;
                        lineStr.push(&#x27; m &#x27;, mr(p.x), &#x27;,&#x27;, mr(p.y));
                        break;
                    case &#x27;lineTo&#x27;:
                        lineStr.push(&#x27; l &#x27;, mr(p.x), &#x27;,&#x27;, mr(p.y));
                        break;
                    case &#x27;close&#x27;:
                        lineStr.push(&#x27; x &#x27;);
                        p = null;
                        break;
                    case &#x27;bezierCurveTo&#x27;:
                        lineStr.push(&#x27; c &#x27;, mr(p.cp1x), &#x27;,&#x27;, mr(p.cp1y), &#x27;,&#x27;, mr(p.cp2x), &#x27;,&#x27;, mr(p.cp2y), &#x27;,&#x27;, mr(p.x), &#x27;,&#x27;, mr(p.y));
                        break;
                    case &#x27;at&#x27;:
                    case &#x27;wa&#x27;:
                        lineStr.push(&#x27; &#x27;, p.type, &#x27; &#x27;, mr(p.x - this.scaleX_ * p.radius), &#x27;,&#x27;, mr(p.y - this.scaleY_ * p.radius), &#x27; &#x27;, mr(p.x + this.scaleX_ * p.radius), &#x27;,&#x27;, mr(p.y + this.scaleY_ * p.radius), &#x27; &#x27;, mr(p.xStart), &#x27;,&#x27;, mr(p.yStart), &#x27; &#x27;, mr(p.xEnd), &#x27;,&#x27;, mr(p.yEnd));
                        break;
                    }
                    if (p) {
                        if (min.x == null || p.x &lt; min.x) {
                            min.x = p.x;
                        }
                        if (max.x == null || p.x &gt; max.x) {
                            max.x = p.x;
                        }
                        if (min.y == null || p.y &lt; min.y) {
                            min.y = p.y;
                        }
                        if (max.y == null || p.y &gt; max.y) {
                            max.y = p.y;
                        }
                    }
                }
                lineStr.push(&#x27; &quot;&gt;&#x27;);
                if (!aFill) {
                    appendStroke(this, lineStr);
                } else {
                    appendFill(this, lineStr, min, max);
                }
                lineStr.push(&#x27;&lt;/g_vml_:shape&gt;&#x27;);
                this.element_.insertAdjacentHTML(&#x27;beforeEnd&#x27;, lineStr.join(&#x27;&#x27;));
            };
            function appendStroke(ctx, lineStr) {
                var a = processStyle(ctx.strokeStyle);
                var color = a.color;
                var opacity = a.alpha * ctx.globalAlpha;
                var lineWidth = ctx.lineScale_ * ctx.lineWidth;
                if (lineWidth &lt; 1) {
                    opacity *= lineWidth;
                }
                lineStr.push(&#x27;&lt;g_vml_:stroke&#x27;, &#x27; opacity=&quot;&#x27;, opacity, &#x27;&quot;&#x27;, &#x27; joinstyle=&quot;&#x27;, ctx.lineJoin, &#x27;&quot;&#x27;, &#x27; miterlimit=&quot;&#x27;, ctx.miterLimit, &#x27;&quot;&#x27;, &#x27; endcap=&quot;&#x27;, processLineCap(ctx.lineCap), &#x27;&quot;&#x27;, &#x27; weight=&quot;&#x27;, lineWidth, &#x27;px&quot;&#x27;, &#x27; color=&quot;&#x27;, color, &#x27;&quot; /&gt;&#x27;);
            }
            function appendFill(ctx, lineStr, min, max) {
                var fillStyle = ctx.fillStyle;
                var arcScaleX = ctx.scaleX_;
                var arcScaleY = ctx.scaleY_;
                var width = max.x - min.x;
                var height = max.y - min.y;
                if (fillStyle instanceof CanvasGradient_) {
                    var angle = 0;
                    var focus = {
                        x: 0,
                        y: 0
                    };
                    var shift = 0;
                    var expansion = 1;
                    if (fillStyle.type_ == &#x27;gradient&#x27;) {
                        var x0 = fillStyle.x0_ / arcScaleX;
                        var y0 = fillStyle.y0_ / arcScaleY;
                        var x1 = fillStyle.x1_ / arcScaleX;
                        var y1 = fillStyle.y1_ / arcScaleY;
                        var p0 = getCoords(ctx, x0, y0);
                        var p1 = getCoords(ctx, x1, y1);
                        var dx = p1.x - p0.x;
                        var dy = p1.y - p0.y;
                        angle = Math.atan2(dx, dy) * 180 / Math.PI;
                        if (angle &lt; 0) {
                            angle += 360;
                        }
                        if (angle &lt; 0.000001) {
                            angle = 0;
                        }
                    } else {
                        var p0 = getCoords(ctx, fillStyle.x0_, fillStyle.y0_);
                        focus = {
                            x: (p0.x - min.x) / width,
                            y: (p0.y - min.y) / height
                        };
                        width /= arcScaleX * Z;
                        height /= arcScaleY * Z;
                        var dimension = m.max(width, height);
                        shift = 2 * fillStyle.r0_ / dimension;
                        expansion = 2 * fillStyle.r1_ / dimension - shift;
                    }
                    var stops = fillStyle.colors_;
                    stops.sort(function (cs1, cs2) {
                        return cs1.offset - cs2.offset;
                    });
                    var length = stops.length;
                    var color1 = stops[0].color;
                    var color2 = stops[length - 1].color;
                    var opacity1 = stops[0].alpha * ctx.globalAlpha;
                    var opacity2 = stops[length - 1].alpha * ctx.globalAlpha;
                    var colors = [];
                    for (var i = 0; i &lt; length; i++) {
                        var stop = stops[i];
                        colors.push(stop.offset * expansion + shift + &#x27; &#x27; + stop.color);
                    }
                    lineStr.push(&#x27;&lt;g_vml_:fill type=&quot;&#x27;, fillStyle.type_, &#x27;&quot;&#x27;, &#x27; method=&quot;none&quot; focus=&quot;100%&quot;&#x27;, &#x27; color=&quot;&#x27;, color1, &#x27;&quot;&#x27;, &#x27; color2=&quot;&#x27;, color2, &#x27;&quot;&#x27;, &#x27; colors=&quot;&#x27;, colors.join(&#x27;,&#x27;), &#x27;&quot;&#x27;, &#x27; opacity=&quot;&#x27;, opacity2, &#x27;&quot;&#x27;, &#x27; g_o_:opacity2=&quot;&#x27;, opacity1, &#x27;&quot;&#x27;, &#x27; angle=&quot;&#x27;, angle, &#x27;&quot;&#x27;, &#x27; focusposition=&quot;&#x27;, focus.x, &#x27;,&#x27;, focus.y, &#x27;&quot; /&gt;&#x27;);
                } else if (fillStyle instanceof CanvasPattern_) {
                    if (width &amp;&amp; height) {
                        var deltaLeft = -min.x;
                        var deltaTop = -min.y;
                        lineStr.push(&#x27;&lt;g_vml_:fill&#x27;, &#x27; position=&quot;&#x27;, deltaLeft / width * arcScaleX * arcScaleX, &#x27;,&#x27;, deltaTop / height * arcScaleY * arcScaleY, &#x27;&quot;&#x27;, &#x27; type=&quot;tile&quot;&#x27;, &#x27; src=&quot;&#x27;, fillStyle.src_, &#x27;&quot; /&gt;&#x27;);
                    }
                } else {
                    var a = processStyle(ctx.fillStyle);
                    var color = a.color;
                    var opacity = a.alpha * ctx.globalAlpha;
                    lineStr.push(&#x27;&lt;g_vml_:fill color=&quot;&#x27;, color, &#x27;&quot; opacity=&quot;&#x27;, opacity, &#x27;&quot; /&gt;&#x27;);
                }
            }
            contextPrototype.fill = function () {
                this.stroke(true);
            };
            contextPrototype.closePath = function () {
                this.currentPath_.push({ type: &#x27;close&#x27; });
            };
            function getCoords(ctx, aX, aY) {
                var m = ctx.m_;
                return {
                    x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,
                    y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2
                };
            }
            ;
            contextPrototype.save = function () {
                var o = {};
                copyState(this, o);
                this.aStack_.push(o);
                this.mStack_.push(this.m_);
                this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
            };
            contextPrototype.restore = function () {
                if (this.aStack_.length) {
                    copyState(this.aStack_.pop(), this);
                    this.m_ = this.mStack_.pop();
                }
            };
            function matrixIsFinite(m) {
                return isFinite(m[0][0]) &amp;&amp; isFinite(m[0][1]) &amp;&amp; isFinite(m[1][0]) &amp;&amp; isFinite(m[1][1]) &amp;&amp; isFinite(m[2][0]) &amp;&amp; isFinite(m[2][1]);
            }
            function setM(ctx, m, updateLineScale) {
                if (!matrixIsFinite(m)) {
                    return;
                }
                ctx.m_ = m;
                ctx.scaleX_ = Math.sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1]);
                ctx.scaleY_ = Math.sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1]);
                if (updateLineScale) {
                    var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
                    ctx.lineScale_ = sqrt(abs(det));
                }
            }
            contextPrototype.translate = function (aX, aY) {
                var m1 = [
                    [
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        1,
                        0
                    ],
                    [
                        aX,
                        aY,
                        1
                    ]
                ];
                setM(this, matrixMultiply(m1, this.m_), false);
            };
            contextPrototype.rotate = function (aRot) {
                var c = mc(aRot);
                var s = ms(aRot);
                var m1 = [
                    [
                        c,
                        s,
                        0
                    ],
                    [
                        -s,
                        c,
                        0
                    ],
                    [
                        0,
                        0,
                        1
                    ]
                ];
                setM(this, matrixMultiply(m1, this.m_), false);
            };
            contextPrototype.scale = function (aX, aY) {
                var m1 = [
                    [
                        aX,
                        0,
                        0
                    ],
                    [
                        0,
                        aY,
                        0
                    ],
                    [
                        0,
                        0,
                        1
                    ]
                ];
                setM(this, matrixMultiply(m1, this.m_), true);
            };
            contextPrototype.transform = function (m11, m12, m21, m22, dx, dy) {
                var m1 = [
                    [
                        m11,
                        m12,
                        0
                    ],
                    [
                        m21,
                        m22,
                        0
                    ],
                    [
                        dx,
                        dy,
                        1
                    ]
                ];
                setM(this, matrixMultiply(m1, this.m_), true);
            };
            contextPrototype.setTransform = function (m11, m12, m21, m22, dx, dy) {
                var m = [
                    [
                        m11,
                        m12,
                        0
                    ],
                    [
                        m21,
                        m22,
                        0
                    ],
                    [
                        dx,
                        dy,
                        1
                    ]
                ];
                setM(this, m, true);
            };
            contextPrototype.drawText_ = function (text, x, y, maxWidth, stroke) {
                var m = this.m_, delta = 1000, left = 0, right = delta, offset = {
                        x: 0,
                        y: 0
                    }, lineStr = [];
                var fontStyle = getComputedStyle(processFontStyle(this.font), this.element_);
                var fontStyleString = buildStyle(fontStyle);
                var elementStyle = this.element_.currentStyle;
                var textAlign = this.textAlign.toLowerCase();
                switch (textAlign) {
                case &#x27;left&#x27;:
                case &#x27;center&#x27;:
                case &#x27;right&#x27;:
                    break;
                case &#x27;end&#x27;:
                    textAlign = elementStyle.direction == &#x27;ltr&#x27; ? &#x27;right&#x27; : &#x27;left&#x27;;
                    break;
                case &#x27;start&#x27;:
                    textAlign = elementStyle.direction == &#x27;rtl&#x27; ? &#x27;right&#x27; : &#x27;left&#x27;;
                    break;
                default:
                    textAlign = &#x27;left&#x27;;
                }
                switch (this.textBaseline) {
                case &#x27;hanging&#x27;:
                case &#x27;top&#x27;:
                    offset.y = fontStyle.size / 1.75;
                    break;
                case &#x27;middle&#x27;:
                    break;
                default:
                case null:
                case &#x27;alphabetic&#x27;:
                case &#x27;ideographic&#x27;:
                case &#x27;bottom&#x27;:
                    offset.y = -fontStyle.size / 2.25;
                    break;
                }
                switch (textAlign) {
                case &#x27;right&#x27;:
                    left = delta;
                    right = 0.05;
                    break;
                case &#x27;center&#x27;:
                    left = right = delta / 2;
                    break;
                }
                var d = getCoords(this, x + offset.x, y + offset.y);
                lineStr.push(&#x27;&lt;g_vml_:line from=&quot;&#x27;, -left, &#x27; 0&quot; to=&quot;&#x27;, right, &#x27; 0.05&quot; &#x27;, &#x27; coordsize=&quot;100 100&quot; coordorigin=&quot;0 0&quot;&#x27;, &#x27; filled=&quot;&#x27;, !stroke, &#x27;&quot; stroked=&quot;&#x27;, !!stroke, &#x27;&quot; style=&quot;position:absolute;width:1px;height:1px;&quot;&gt;&#x27;);
                if (stroke) {
                    appendStroke(this, lineStr);
                } else {
                    appendFill(this, lineStr, {
                        x: -left,
                        y: 0
                    }, {
                        x: right,
                        y: fontStyle.size
                    });
                }
                var skewM = m[0][0].toFixed(3) + &#x27;,&#x27; + m[1][0].toFixed(3) + &#x27;,&#x27; + m[0][1].toFixed(3) + &#x27;,&#x27; + m[1][1].toFixed(3) + &#x27;,0,0&#x27;;
                var skewOffset = mr(d.x / Z) + &#x27;,&#x27; + mr(d.y / Z);
                lineStr.push(&#x27;&lt;g_vml_:skew on=&quot;t&quot; matrix=&quot;&#x27;, skewM, &#x27;&quot; &#x27;, &#x27; offset=&quot;&#x27;, skewOffset, &#x27;&quot; origin=&quot;&#x27;, left, &#x27; 0&quot; /&gt;&#x27;, &#x27;&lt;g_vml_:path textpathok=&quot;true&quot; /&gt;&#x27;, &#x27;&lt;g_vml_:textpath on=&quot;true&quot; string=&quot;&#x27;, encodeHtmlAttribute(text), &#x27;&quot; style=&quot;v-text-align:&#x27;, textAlign, &#x27;;font:&#x27;, encodeHtmlAttribute(fontStyleString), &#x27;&quot; /&gt;&lt;/g_vml_:line&gt;&#x27;);
                this.element_.insertAdjacentHTML(&#x27;beforeEnd&#x27;, lineStr.join(&#x27;&#x27;));
            };
            contextPrototype.fillText = function (text, x, y, maxWidth) {
                this.drawText_(text, x, y, maxWidth, false);
            };
            contextPrototype.strokeText = function (text, x, y, maxWidth) {
                this.drawText_(text, x, y, maxWidth, true);
            };
            contextPrototype.measureText = function (text) {
                if (!this.textMeasureEl_) {
                    var s = &#x27;&lt;span style=&quot;position:absolute;&#x27; + &#x27;top:-20000px;left:0;padding:0;margin:0;border:none;&#x27; + &#x27;white-space:pre;&quot;&gt;&lt;/span&gt;&#x27;;
                    this.element_.insertAdjacentHTML(&#x27;beforeEnd&#x27;, s);
                    this.textMeasureEl_ = this.element_.lastChild;
                }
                var doc = this.element_.ownerDocument;
                this.textMeasureEl_.innerHTML = &#x27;&#x27;;
                try {
                    this.textMeasureEl_.style.font = this.font;
                } catch (ex) {
                }
                this.textMeasureEl_.appendChild(doc.createTextNode(text));
                return { width: this.textMeasureEl_.offsetWidth };
            };
            contextPrototype.clip = function () {
            };
            contextPrototype.arcTo = function () {
            };
            contextPrototype.createPattern = function (image, repetition) {
                return new CanvasPattern_(image, repetition);
            };
            function CanvasGradient_(aType) {
                this.type_ = aType;
                this.x0_ = 0;
                this.y0_ = 0;
                this.r0_ = 0;
                this.x1_ = 0;
                this.y1_ = 0;
                this.r1_ = 0;
                this.colors_ = [];
            }
            CanvasGradient_.prototype.addColorStop = function (aOffset, aColor) {
                aColor = processStyle(aColor);
                this.colors_.push({
                    offset: aOffset,
                    color: aColor.color,
                    alpha: aColor.alpha
                });
            };
            function CanvasPattern_(image, repetition) {
                assertImageIsValid(image);
                switch (repetition) {
                case &#x27;repeat&#x27;:
                case null:
                case &#x27;&#x27;:
                    this.repetition_ = &#x27;repeat&#x27;;
                    break;
                case &#x27;repeat-x&#x27;:
                case &#x27;repeat-y&#x27;:
                case &#x27;no-repeat&#x27;:
                    this.repetition_ = repetition;
                    break;
                default:
                    throwException(&#x27;SYNTAX_ERR&#x27;);
                }
                this.src_ = image.src;
                this.width_ = image.width;
                this.height_ = image.height;
            }
            function throwException(s) {
                throw new DOMException_(s);
            }
            function assertImageIsValid(img) {
                if (!img || img.nodeType != 1 || img.tagName != &#x27;IMG&#x27;) {
                    throwException(&#x27;TYPE_MISMATCH_ERR&#x27;);
                }
                if (img.readyState != &#x27;complete&#x27;) {
                    throwException(&#x27;INVALID_STATE_ERR&#x27;);
                }
            }
            function DOMException_(s) {
                this.code = this[s];
                this.message = s + &#x27;: DOM Exception &#x27; + this.code;
            }
            var p = DOMException_.prototype = new Error();
            p.INDEX_SIZE_ERR = 1;
            p.DOMSTRING_SIZE_ERR = 2;
            p.HIERARCHY_REQUEST_ERR = 3;
            p.WRONG_DOCUMENT_ERR = 4;
            p.INVALID_CHARACTER_ERR = 5;
            p.NO_DATA_ALLOWED_ERR = 6;
            p.NO_MODIFICATION_ALLOWED_ERR = 7;
            p.NOT_FOUND_ERR = 8;
            p.NOT_SUPPORTED_ERR = 9;
            p.INUSE_ATTRIBUTE_ERR = 10;
            p.INVALID_STATE_ERR = 11;
            p.SYNTAX_ERR = 12;
            p.INVALID_MODIFICATION_ERR = 13;
            p.NAMESPACE_ERR = 14;
            p.INVALID_ACCESS_ERR = 15;
            p.VALIDATION_ERR = 16;
            p.TYPE_MISMATCH_ERR = 17;
            G_vmlCanvasManager = G_vmlCanvasManager_;
            CanvasRenderingContext2D = CanvasRenderingContext2D_;
            CanvasGradient = CanvasGradient_;
            CanvasPattern = CanvasPattern_;
            DOMException = DOMException_;
        }());
    } else {
        G_vmlCanvasManager = false;
    }
    return G_vmlCanvasManager;
});define(&#x27;zrender/mixin/Eventful&#x27;, [&#x27;require&#x27;], function (require) {
    var Eventful = function () {
        this._handlers = {};
    };
    Eventful.prototype.one = function (event, handler, context) {
        var _h = this._handlers;
        if (!handler || !event) {
            return this;
        }
        if (!_h[event]) {
            _h[event] = [];
        }
        _h[event].push({
            h: handler,
            one: true,
            ctx: context || this
        });
        return this;
    };
    Eventful.prototype.bind = function (event, handler, context) {
        var _h = this._handlers;
        if (!handler || !event) {
            return this;
        }
        if (!_h[event]) {
            _h[event] = [];
        }
        _h[event].push({
            h: handler,
            one: false,
            ctx: context || this
        });
        return this;
    };
    Eventful.prototype.unbind = function (event, handler) {
        var _h = this._handlers;
        if (!event) {
            this._handlers = {};
            return this;
        }
        if (handler) {
            if (_h[event]) {
                var newList = [];
                for (var i = 0, l = _h[event].length; i &lt; l; i++) {
                    if (_h[event][i][&#x27;h&#x27;] != handler) {
                        newList.push(_h[event][i]);
                    }
                }
                _h[event] = newList;
            }
            if (_h[event] &amp;&amp; _h[event].length === 0) {
                delete _h[event];
            }
        } else {
            delete _h[event];
        }
        return this;
    };
    Eventful.prototype.dispatch = function (type) {
        if (this._handlers[type]) {
            var args = arguments;
            var argLen = args.length;
            if (argLen &gt; 3) {
                args = Array.prototype.slice.call(args, 1);
            }
            var _h = this._handlers[type];
            var len = _h.length;
            for (var i = 0; i &lt; len;) {
                switch (argLen) {
                case 1:
                    _h[i][&#x27;h&#x27;].call(_h[i][&#x27;ctx&#x27;]);
                    break;
                case 2:
                    _h[i][&#x27;h&#x27;].call(_h[i][&#x27;ctx&#x27;], args[1]);
                    break;
                case 3:
                    _h[i][&#x27;h&#x27;].call(_h[i][&#x27;ctx&#x27;], args[1], args[2]);
                    break;
                default:
                    _h[i][&#x27;h&#x27;].apply(_h[i][&#x27;ctx&#x27;], args);
                    break;
                }
                if (_h[i][&#x27;one&#x27;]) {
                    _h.splice(i, 1);
                    len--;
                } else {
                    i++;
                }
            }
        }
        return this;
    };
    Eventful.prototype.dispatchWithContext = function (type) {
        if (this._handlers[type]) {
            var args = arguments;
            var argLen = args.length;
            if (argLen &gt; 4) {
                args = Array.prototype.slice.call(args, 1, args.length - 1);
            }
            var ctx = args[args.length - 1];
            var _h = this._handlers[type];
            var len = _h.length;
            for (var i = 0; i &lt; len;) {
                switch (argLen) {
                case 1:
                    _h[i][&#x27;h&#x27;].call(ctx);
                    break;
                case 2:
                    _h[i][&#x27;h&#x27;].call(ctx, args[1]);
                    break;
                case 3:
                    _h[i][&#x27;h&#x27;].call(ctx, args[1], args[2]);
                    break;
                default:
                    _h[i][&#x27;h&#x27;].apply(ctx, args);
                    break;
                }
                if (_h[i][&#x27;one&#x27;]) {
                    _h.splice(i, 1);
                    len--;
                } else {
                    i++;
                }
            }
        }
        return this;
    };
    return Eventful;
});define(&#x27;zrender/tool/log&#x27;, [
    &#x27;require&#x27;,
    &#x27;../config&#x27;
], function (require) {
    var config = require(&#x27;../config&#x27;);
    return function () {
        if (config.debugMode === 0) {
            return;
        } else if (config.debugMode == 1) {
            for (var k in arguments) {
                throw new Error(arguments[k]);
            }
        } else if (config.debugMode &gt; 1) {
            for (var k in arguments) {
                console.log(arguments[k]);
            }
        }
    };
});define(&#x27;zrender/tool/guid&#x27;, [], function () {
    var idStart = 2311;
    return function () {
        return &#x27;zrender__&#x27; + idStart++;
    };
});define(&#x27;zrender/Handler&#x27;, [
    &#x27;require&#x27;,
    &#x27;./config&#x27;,
    &#x27;./tool/env&#x27;,
    &#x27;./tool/event&#x27;,
    &#x27;./tool/util&#x27;,
    &#x27;./tool/vector&#x27;,
    &#x27;./tool/matrix&#x27;,
    &#x27;./mixin/Eventful&#x27;
], function (require) {
    &#x27;use strict&#x27;;
    var config = require(&#x27;./config&#x27;);
    var env = require(&#x27;./tool/env&#x27;);
    var eventTool = require(&#x27;./tool/event&#x27;);
    var util = require(&#x27;./tool/util&#x27;);
    var vec2 = require(&#x27;./tool/vector&#x27;);
    var mat2d = require(&#x27;./tool/matrix&#x27;);
    var EVENT = config.EVENT;
    var Eventful = require(&#x27;./mixin/Eventful&#x27;);
    var domHandlerNames = [
        &#x27;resize&#x27;,
        &#x27;click&#x27;,
        &#x27;dblclick&#x27;,
        &#x27;mousewheel&#x27;,
        &#x27;mousemove&#x27;,
        &#x27;mouseout&#x27;,
        &#x27;mouseup&#x27;,
        &#x27;mousedown&#x27;,
        &#x27;touchstart&#x27;,
        &#x27;touchend&#x27;,
        &#x27;touchmove&#x27;
    ];
    var domHandlers = {
        resize: function (event) {
            event = event || window.event;
            this._lastHover = null;
            this._isMouseDown = 0;
            this.dispatch(EVENT.RESIZE, event);
        },
        click: function (event) {
            event = this._zrenderEventFixed(event);
            var _lastHover = this._lastHover;
            if (_lastHover &amp;&amp; _lastHover.clickable || !_lastHover) {
                if (this._clickThreshold &lt; 5) {
                    this._dispatchAgency(_lastHover, EVENT.CLICK, event);
                }
            }
            this._mousemoveHandler(event);
        },
        dblclick: function (event) {
            event = event || window.event;
            event = this._zrenderEventFixed(event);
            var _lastHover = this._lastHover;
            if (_lastHover &amp;&amp; _lastHover.clickable || !_lastHover) {
                if (this._clickThreshold &lt; 5) {
                    this._dispatchAgency(_lastHover, EVENT.DBLCLICK, event);
                }
            }
            this._mousemoveHandler(event);
        },
        mousewheel: function (event) {
            event = this._zrenderEventFixed(event);
            var delta = event.wheelDelta || -event.detail;
            var scale = delta &gt; 0 ? 1.1 : 1 / 1.1;
            var layers = this.painter.getLayers();
            var needsRefresh = false;
            for (var z in layers) {
                if (z !== &#x27;hover&#x27;) {
                    var layer = layers[z];
                    var pos = layer.position;
                    if (layer.zoomable) {
                        layer.__zoom = layer.__zoom || 1;
                        var newZoom = layer.__zoom;
                        newZoom *= scale;
                        newZoom = Math.max(Math.min(layer.maxZoom, newZoom), layer.minZoom);
                        scale = newZoom / layer.__zoom;
                        layer.__zoom = newZoom;
                        pos[0] -= (this._mouseX - pos[0]) * (scale - 1);
                        pos[1] -= (this._mouseY - pos[1]) * (scale - 1);
                        layer.scale[0] *= scale;
                        layer.scale[1] *= scale;
                        layer.dirty = true;
                        needsRefresh = true;
                        eventTool.stop(event);
                    }
                }
            }
            if (needsRefresh) {
                this.painter.refresh();
            }
            this._dispatchAgency(this._lastHover, EVENT.MOUSEWHEEL, event);
            this._mousemoveHandler(event);
        },
        mousemove: function (event) {
            if (this.painter.isLoading()) {
                return;
            }
            this._clickThreshold++;
            event = this._zrenderEventFixed(event);
            this._lastX = this._mouseX;
            this._lastY = this._mouseY;
            this._mouseX = eventTool.getX(event);
            this._mouseY = eventTool.getY(event);
            var dx = this._mouseX - this._lastX;
            var dy = this._mouseY - this._lastY;
            this._processDragStart(event);
            this._hasfound = 0;
            this._event = event;
            this._iterateAndFindHover();
            if (!this._hasfound) {
                if (!this._draggingTarget || this._lastHover &amp;&amp; this._lastHover != this._draggingTarget) {
                    this._processOutShape(event);
                    this._processDragLeave(event);
                }
                this._lastHover = null;
                this.storage.delHover();
                this.painter.clearHover();
            }
            var cursor = &#x27;default&#x27;;
            if (this._draggingTarget) {
                this.storage.drift(this._draggingTarget.id, dx, dy);
                this._draggingTarget.modSelf();
                this.storage.addHover(this._draggingTarget);
            } else if (this._isMouseDown) {
                var layers = this.painter.getLayers();
                var needsRefresh = false;
                for (var z in layers) {
                    if (z !== &#x27;hover&#x27;) {
                        var layer = layers[z];
                        if (layer.panable) {
                            cursor = &#x27;move&#x27;;
                            layer.position[0] += dx;
                            layer.position[1] += dy;
                            needsRefresh = true;
                            layer.dirty = true;
                        }
                    }
                }
                if (needsRefresh) {
                    this.painter.refresh();
                }
            }
            if (this._draggingTarget || this._hasfound &amp;&amp; this._lastHover.draggable) {
                cursor = &#x27;move&#x27;;
            } else if (this._hasfound &amp;&amp; this._lastHover.clickable) {
                cursor = &#x27;pointer&#x27;;
            }
            this.root.style.cursor = cursor;
            this._dispatchAgency(this._lastHover, EVENT.MOUSEMOVE, event);
            if (this._draggingTarget || this._hasfound || this.storage.hasHoverShape()) {
                this.painter.refreshHover();
            }
        },
        mouseout: function (event) {
            event = this._zrenderEventFixed(event);
            var element = event.toElement || event.relatedTarget;
            if (element != this.root) {
                while (element &amp;&amp; element.nodeType != 9) {
                    if (element == this.root) {
                        this._mousemoveHandler(event);
                        return;
                    }
                    element = element.parentNode;
                }
            }
            event.zrenderX = this._lastX;
            event.zrenderY = this._lastY;
            this.root.style.cursor = &#x27;default&#x27;;
            this._isMouseDown = 0;
            this._processOutShape(event);
            this._processDrop(event);
            this._processDragEnd(event);
            if (!this.painter.isLoading()) {
                this.painter.refreshHover();
            }
            this.dispatch(EVENT.GLOBALOUT, event);
        },
        mousedown: function (event) {
            this._clickThreshold = 0;
            if (this._lastDownButton == 2) {
                this._lastDownButton = event.button;
                this._mouseDownTarget = null;
                return;
            }
            this._lastMouseDownMoment = new Date();
            event = this._zrenderEventFixed(event);
            this._isMouseDown = 1;
            this._mouseDownTarget = this._lastHover;
            this._dispatchAgency(this._lastHover, EVENT.MOUSEDOWN, event);
            this._lastDownButton = event.button;
        },
        mouseup: function (event) {
            event = this._zrenderEventFixed(event);
            this.root.style.cursor = &#x27;default&#x27;;
            this._isMouseDown = 0;
            this._clickThreshold = 0;
            this._mouseDownTarget = null;
            this._dispatchAgency(this._lastHover, EVENT.MOUSEUP, event);
            this._processDrop(event);
            this._processDragEnd(event);
        },
        touchstart: function (event) {
            event = this._zrenderEventFixed(event, true);
            this._lastTouchMoment = new Date();
            this._mobildFindFixed(event);
            this._mousedownHandler(event);
        },
        touchmove: function (event) {
            event = this._zrenderEventFixed(event, true);
            this._mousemoveHandler(event);
            if (this._isDragging) {
                eventTool.stop(event);
            }
        },
        touchend: function (event) {
            event = this._zrenderEventFixed(event, true);
            this._mouseupHandler(event);
            var now = new Date();
            if (now - this._lastTouchMoment &lt; EVENT.touchClickDelay) {
                this._mobildFindFixed(event);
                this._clickHandler(event);
                if (now - this._lastClickMoment &lt; EVENT.touchClickDelay / 2) {
                    this._dblclickHandler(event);
                    if (this._lastHover &amp;&amp; this._lastHover.clickable) {
                        eventTool.stop(event);
                    }
                }
                this._lastClickMoment = now;
            }
            this.painter.clearHover();
        }
    };
    function bind1Arg(handler, context) {
        return function (e) {
            return handler.call(context, e);
        };
    }
    function bind3Arg(handler, context) {
        return function (arg1, arg2, arg3) {
            return handler.call(context, arg1, arg2, arg3);
        };
    }
    function initDomHandler(instance) {
        var len = domHandlerNames.length;
        while (len--) {
            var name = domHandlerNames[len];
            instance[&#x27;_&#x27; + name + &#x27;Handler&#x27;] = bind1Arg(domHandlers[name], instance);
        }
    }
    var Handler = function (root, storage, painter) {
        Eventful.call(this);
        this.root = root;
        this.storage = storage;
        this.painter = painter;
        this._lastX = this._lastY = this._mouseX = this._mouseY = 0;
        this._findHover = bind3Arg(findHover, this);
        this._domHover = painter.getDomHover();
        initDomHandler(this);
        if (window.addEventListener) {
            window.addEventListener(&#x27;resize&#x27;, this._resizeHandler);
            if (env.os.tablet || env.os.phone) {
                root.addEventListener(&#x27;touchstart&#x27;, this._touchstartHandler);
                root.addEventListener(&#x27;touchmove&#x27;, this._touchmoveHandler);
                root.addEventListener(&#x27;touchend&#x27;, this._touchendHandler);
            } else {
                root.addEventListener(&#x27;click&#x27;, this._clickHandler);
                root.addEventListener(&#x27;dblclick&#x27;, this._dblclickHandler);
                root.addEventListener(&#x27;mousewheel&#x27;, this._mousewheelHandler);
                root.addEventListener(&#x27;mousemove&#x27;, this._mousemoveHandler);
                root.addEventListener(&#x27;mousedown&#x27;, this._mousedownHandler);
                root.addEventListener(&#x27;mouseup&#x27;, this._mouseupHandler);
            }
            root.addEventListener(&#x27;DOMMouseScroll&#x27;, this._mousewheelHandler);
            root.addEventListener(&#x27;mouseout&#x27;, this._mouseoutHandler);
        } else {
            window.attachEvent(&#x27;onresize&#x27;, this._resizeHandler);
            root.attachEvent(&#x27;onclick&#x27;, this._clickHandler);
            root.ondblclick = this._dblclickHandler;
            root.attachEvent(&#x27;onmousewheel&#x27;, this._mousewheelHandler);
            root.attachEvent(&#x27;onmousemove&#x27;, this._mousemoveHandler);
            root.attachEvent(&#x27;onmouseout&#x27;, this._mouseoutHandler);
            root.attachEvent(&#x27;onmousedown&#x27;, this._mousedownHandler);
            root.attachEvent(&#x27;onmouseup&#x27;, this._mouseupHandler);
        }
    };
    Handler.prototype.on = function (eventName, handler) {
        this.bind(eventName, handler);
        return this;
    };
    Handler.prototype.un = function (eventName, handler) {
        this.unbind(eventName, handler);
        return this;
    };
    Handler.prototype.trigger = function (eventName, eventArgs) {
        switch (eventName) {
        case EVENT.RESIZE:
        case EVENT.CLICK:
        case EVENT.DBLCLICK:
        case EVENT.MOUSEWHEEL:
        case EVENT.MOUSEMOVE:
        case EVENT.MOUSEDOWN:
        case EVENT.MOUSEUP:
        case EVENT.MOUSEOUT:
            this[&#x27;_&#x27; + eventName + &#x27;Handler&#x27;](eventArgs);
            break;
        }
    };
    Handler.prototype.dispose = function () {
        var root = this.root;
        if (window.removeEventListener) {
            window.removeEventListener(&#x27;resize&#x27;, this._resizeHandler);
            if (env.os.tablet || env.os.phone) {
                root.removeEventListener(&#x27;touchstart&#x27;, this._touchstartHandler);
                root.removeEventListener(&#x27;touchmove&#x27;, this._touchmoveHandler);
                root.removeEventListener(&#x27;touchend&#x27;, this._touchendHandler);
            } else {
                root.removeEventListener(&#x27;click&#x27;, this._clickHandler);
                root.removeEventListener(&#x27;dblclick&#x27;, this._dblclickHandler);
                root.removeEventListener(&#x27;mousewheel&#x27;, this._mousewheelHandler);
                root.removeEventListener(&#x27;mousemove&#x27;, this._mousemoveHandler);
                root.removeEventListener(&#x27;mousedown&#x27;, this._mousedownHandler);
                root.removeEventListener(&#x27;mouseup&#x27;, this._mouseupHandler);
            }
            root.removeEventListener(&#x27;DOMMouseScroll&#x27;, this._mousewheelHandler);
            root.removeEventListener(&#x27;mouseout&#x27;, this._mouseoutHandler);
        } else {
            window.detachEvent(&#x27;onresize&#x27;, this._resizeHandler);
            root.detachEvent(&#x27;onclick&#x27;, this._clickHandler);
            root.detachEvent(&#x27;dblclick&#x27;, this._dblclickHandler);
            root.detachEvent(&#x27;onmousewheel&#x27;, this._mousewheelHandler);
            root.detachEvent(&#x27;onmousemove&#x27;, this._mousemoveHandler);
            root.detachEvent(&#x27;onmouseout&#x27;, this._mouseoutHandler);
            root.detachEvent(&#x27;onmousedown&#x27;, this._mousedownHandler);
            root.detachEvent(&#x27;onmouseup&#x27;, this._mouseupHandler);
        }
        this.root = this._domHover = this.storage = this.painter = null;
        this.un();
    };
    Handler.prototype._processDragStart = function (event) {
        var _lastHover = this._lastHover;
        if (this._isMouseDown &amp;&amp; _lastHover &amp;&amp; _lastHover.draggable &amp;&amp; !this._draggingTarget &amp;&amp; this._mouseDownTarget == _lastHover) {
            if (_lastHover.dragEnableTime &amp;&amp; new Date() - this._lastMouseDownMoment &lt; _lastHover.dragEnableTime) {
                return;
            }
            var _draggingTarget = _lastHover;
            this._draggingTarget = _draggingTarget;
            this._isDragging = 1;
            _draggingTarget.invisible = true;
            this.storage.mod(_draggingTarget.id);
            this._dispatchAgency(_draggingTarget, EVENT.DRAGSTART, event);
            this.painter.refresh();
        }
    };
    Handler.prototype._processDragEnter = function (event) {
        if (this._draggingTarget) {
            this._dispatchAgency(this._lastHover, EVENT.DRAGENTER, event, this._draggingTarget);
        }
    };
    Handler.prototype._processDragOver = function (event) {
        if (this._draggingTarget) {
            this._dispatchAgency(this._lastHover, EVENT.DRAGOVER, event, this._draggingTarget);
        }
    };
    Handler.prototype._processDragLeave = function (event) {
        if (this._draggingTarget) {
            this._dispatchAgency(this._lastHover, EVENT.DRAGLEAVE, event, this._draggingTarget);
        }
    };
    Handler.prototype._processDrop = function (event) {
        if (this._draggingTarget) {
            this._draggingTarget.invisible = false;
            this.storage.mod(this._draggingTarget.id);
            this.painter.refresh();
            this._dispatchAgency(this._lastHover, EVENT.DROP, event, this._draggingTarget);
        }
    };
    Handler.prototype._processDragEnd = function (event) {
        if (this._draggingTarget) {
            this._dispatchAgency(this._draggingTarget, EVENT.DRAGEND, event);
            this._lastHover = null;
        }
        this._isDragging = 0;
        this._draggingTarget = null;
    };
    Handler.prototype._processOverShape = function (event) {
        this._dispatchAgency(this._lastHover, EVENT.MOUSEOVER, event);
    };
    Handler.prototype._processOutShape = function (event) {
        this._dispatchAgency(this._lastHover, EVENT.MOUSEOUT, event);
    };
    Handler.prototype._dispatchAgency = function (targetShape, eventName, event, draggedShape) {
        var eventHandler = &#x27;on&#x27; + eventName;
        var eventPacket = {
            type: eventName,
            event: event,
            target: targetShape,
            cancelBubble: false
        };
        var el = targetShape;
        if (draggedShape) {
            eventPacket.dragged = draggedShape;
        }
        while (el) {
            el[eventHandler] &amp;&amp; (eventPacket.cancelBubble = el[eventHandler](eventPacket));
            el.dispatch(eventName, eventPacket);
            el = el.parent;
            if (eventPacket.cancelBubble) {
                break;
            }
        }
        if (targetShape) {
            if (!eventPacket.cancelBubble) {
                this.dispatch(eventName, eventPacket);
            }
        } else if (!draggedShape) {
            this.dispatch(eventName, {
                type: eventName,
                event: event
            });
        }
    };
    Handler.prototype._iterateAndFindHover = function () {
        var invTransform = mat2d.create();
        return function () {
            var list = this.storage.getShapeList();
            var currentZLevel;
            var currentLayer;
            var tmp = [
                0,
                0
            ];
            for (var i = list.length - 1; i &gt;= 0; i--) {
                var shape = list[i];
                if (currentZLevel !== shape.zlevel) {
                    currentLayer = this.painter.getLayer(shape.zlevel, currentLayer);
                    tmp[0] = this._mouseX;
                    tmp[1] = this._mouseY;
                    if (currentLayer.needTransform) {
                        mat2d.invert(invTransform, currentLayer.transform);
                        vec2.applyTransform(tmp, tmp, invTransform);
                    }
                }
                if (this._findHover(shape, tmp[0], tmp[1])) {
                    break;
                }
            }
        };
    }();
    var MOBILE_TOUCH_OFFSETS = [
        { x: 10 },
        { x: -20 },
        {
            x: 10,
            y: 10
        },
        { y: -20 }
    ];
    Handler.prototype._mobildFindFixed = function (event) {
        this._lastHover = null;
        this._mouseX = event.zrenderX;
        this._mouseY = event.zrenderY;
        this._event = event;
        this._iterateAndFindHover();
        for (var i = 0; !this._lastHover &amp;&amp; i &lt; MOBILE_TOUCH_OFFSETS.length; i++) {
            var offset = MOBILE_TOUCH_OFFSETS[i];
            offset.x &amp;&amp; (this._mouseX += offset.x);
            offset.y &amp;&amp; (this._mouseX += offset.y);
            this._iterateAndFindHover();
        }
        if (this._lastHover) {
            event.zrenderX = this._mouseX;
            event.zrenderY = this._mouseY;
        }
    };
    function findHover(shape, x, y) {
        if (this._draggingTarget &amp;&amp; this._draggingTarget.id == shape.id || shape.isSilent()) {
            return false;
        }
        var event = this._event;
        if (shape.isCover(x, y)) {
            if (shape.hoverable) {
                this.storage.addHover(shape);
            }
            var p = shape.parent;
            while (p) {
                if (p.clipShape &amp;&amp; !p.clipShape.isCover(this._mouseX, this._mouseY)) {
                    return false;
                }
                p = p.parent;
            }
            if (this._lastHover != shape) {
                this._processOutShape(event);
                this._processDragLeave(event);
                this._lastHover = shape;
                this._processDragEnter(event);
            }
            this._processOverShape(event);
            this._processDragOver(event);
            this._hasfound = 1;
            return true;
        }
        return false;
    }
    Handler.prototype._zrenderEventFixed = function (event, isTouch) {
        if (event.zrenderFixed) {
            return event;
        }
        if (!isTouch) {
            event = event || window.event;
            var target = event.toElement || event.relatedTarget || event.srcElement || event.target;
            if (target &amp;&amp; target != this._domHover) {
                event.zrenderX = (typeof event.offsetX != &#x27;undefined&#x27; ? event.offsetX : event.layerX) + target.offsetLeft;
                event.zrenderY = (typeof event.offsetY != &#x27;undefined&#x27; ? event.offsetY : event.layerY) + target.offsetTop;
            }
        } else {
            var touch = event.type != &#x27;touchend&#x27; ? event.targetTouches[0] : event.changedTouches[0];
            if (touch) {
                var rBounding = this.root.getBoundingClientRect();
                event.zrenderX = touch.clientX - rBounding.left;
                event.zrenderY = touch.clientY - rBounding.top;
            }
        }
        event.zrenderFixed = 1;
        return event;
    };
    util.merge(Handler.prototype, Eventful.prototype, true);
    return Handler;
});define(&#x27;zrender/Painter&#x27;, [
    &#x27;require&#x27;,
    &#x27;./config&#x27;,
    &#x27;./tool/util&#x27;,
    &#x27;./tool/log&#x27;,
    &#x27;./tool/matrix&#x27;,
    &#x27;./loadingEffect/Base&#x27;,
    &#x27;./mixin/Transformable&#x27;,
    &#x27;./shape/Image&#x27;
], function (require) {
    &#x27;use strict&#x27;;
    var config = require(&#x27;./config&#x27;);
    var util = require(&#x27;./tool/util&#x27;);
    var log = require(&#x27;./tool/log&#x27;);
    var matrix = require(&#x27;./tool/matrix&#x27;);
    var BaseLoadingEffect = require(&#x27;./loadingEffect/Base&#x27;);
    var Transformable = require(&#x27;./mixin/Transformable&#x27;);
    var devicePixelRatio = window.devicePixelRatio || 1;
    devicePixelRatio = Math.max(devicePixelRatio, 1);
    var vmlCanvasManager = window[&#x27;G_vmlCanvasManager&#x27;];
    function returnFalse() {
        return false;
    }
    function doNothing() {
    }
    var Painter = function (root, storage) {
        this.root = root;
        this.storage = storage;
        root.innerHTML = &#x27;&#x27;;
        this._width = this._getWidth();
        this._height = this._getHeight();
        var domRoot = document.createElement(&#x27;div&#x27;);
        this._domRoot = domRoot;
        domRoot.style.position = &#x27;relative&#x27;;
        domRoot.style.overflow = &#x27;hidden&#x27;;
        domRoot.style.width = this._width + &#x27;px&#x27;;
        domRoot.style.height = this._height + &#x27;px&#x27;;
        root.appendChild(domRoot);
        this._layers = {};
        this._zlevelList = [];
        this._layerConfig = {};
        this._loadingEffect = new BaseLoadingEffect({});
        this.shapeToImage = this._createShapeToImageProcessor();
        this._bgDom = createDom(&#x27;bg&#x27;, &#x27;div&#x27;, this);
        domRoot.appendChild(this._bgDom);
        this._bgDom.onselectstart = returnFalse;
        this._bgDom.style[&#x27;-webkit-user-select&#x27;] = &#x27;none&#x27;;
        this._bgDom.style[&#x27;user-select&#x27;] = &#x27;none&#x27;;
        this._bgDom.style[&#x27;-webkit-touch-callout&#x27;] = &#x27;none&#x27;;
        var hoverLayer = new Layer(&#x27;_zrender_hover_&#x27;, this);
        this._layers[&#x27;hover&#x27;] = hoverLayer;
        domRoot.appendChild(hoverLayer.dom);
        hoverLayer.initContext();
        hoverLayer.dom.onselectstart = returnFalse;
        hoverLayer.dom.style[&#x27;-webkit-user-select&#x27;] = &#x27;none&#x27;;
        hoverLayer.dom.style[&#x27;user-select&#x27;] = &#x27;none&#x27;;
        hoverLayer.dom.style[&#x27;-webkit-touch-callout&#x27;] = &#x27;none&#x27;;
        this.refreshNextFrame = null;
    };
    Painter.prototype.render = function (callback) {
        if (this.isLoading()) {
            this.hideLoading();
        }
        this.refresh(callback, true);
        return this;
    };
    Painter.prototype.refresh = function (callback, paintAll) {
        var list = this.storage.getShapeList(true);
        this._paintList(list, paintAll);
        if (typeof callback == &#x27;function&#x27;) {
            callback();
        }
        return this;
    };
    Painter.prototype._paintList = function (list, paintAll) {
        if (typeof paintAll == &#x27;undefined&#x27;) {
            paintAll = false;
        }
        this._updateLayerStatus(list);
        var currentLayer;
        var currentZLevel;
        var ctx;
        for (var id in this._layers) {
            if (id !== &#x27;hover&#x27;) {
                this._layers[id].unusedCount++;
                this._layers[id].updateTransform();
            }
        }
        var invTransform = [];
        for (var i = 0, l = list.length; i &lt; l; i++) {
            var shape = list[i];
            if (currentZLevel !== shape.zlevel) {
                if (currentLayer) {
                    if (currentLayer.needTransform) {
                        ctx.restore();
                    }
                    ctx.flush &amp;&amp; ctx.flush();
                }
                currentLayer = this.getLayer(shape.zlevel);
                ctx = currentLayer.ctx;
                currentZLevel = shape.zlevel;
                currentLayer.unusedCount = 0;
                if (currentLayer.dirty || paintAll) {
                    currentLayer.clear();
                }
                if (currentLayer.needTransform) {
                    ctx.save();
                    currentLayer.setTransform(ctx);
                }
            }
            if (shape.__startClip &amp;&amp; !vmlCanvasManager) {
                var clipShape = shape.__startClip;
                ctx.save();
                if (clipShape.needTransform) {
                    var m = clipShape.transform;
                    matrix.invert(invTransform, m);
                    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                }
                ctx.beginPath();
                clipShape.buildPath(ctx, clipShape.style);
                ctx.clip();
                if (clipShape.needTransform) {
                    var m = invTransform;
                    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                }
            }
            if ((currentLayer.dirty || paintAll) &amp;&amp; !shape.invisible) {
                if (!shape.onbrush || shape.onbrush &amp;&amp; !shape.onbrush(ctx, false)) {
                    if (config.catchBrushException) {
                        try {
                            shape.brush(ctx, false, this.refreshNextFrame);
                        } catch (error) {
                            log(error, &#x27;brush error of &#x27; + shape.type, shape);
                        }
                    } else {
                        shape.brush(ctx, false, this.refreshNextFrame);
                    }
                }
            }
            if (shape.__stopClip &amp;&amp; !vmlCanvasManager) {
                ctx.restore();
            }
            shape.__dirty = false;
        }
        if (currentLayer) {
            if (currentLayer.needTransform) {
                ctx.restore();
            }
            ctx.flush &amp;&amp; ctx.flush();
        }
        for (var id in this._layers) {
            if (id !== &#x27;hover&#x27;) {
                var layer = this._layers[id];
                layer.dirty = false;
                if (layer.unusedCount == 1) {
                    layer.clear();
                }
            }
        }
    };
    Painter.prototype.getLayer = function (zlevel) {
        var currentLayer = this._layers[zlevel];
        if (!currentLayer) {
            var len = this._zlevelList.length;
            var prevLayer = null;
            var i = -1;
            if (len &gt; 0 &amp;&amp; zlevel &gt; this._zlevelList[0]) {
                for (i = 0; i &lt; len - 1; i++) {
                    if (this._zlevelList[i] &lt; zlevel &amp;&amp; this._zlevelList[i + 1] &gt; zlevel) {
                        break;
                    }
                }
                prevLayer = this._layers[this._zlevelList[i]];
            }
            this._zlevelList.splice(i + 1, 0, zlevel);
            currentLayer = new Layer(zlevel, this);
            var prevDom = prevLayer ? prevLayer.dom : this._bgDom;
            if (prevDom.nextSibling) {
                prevDom.parentNode.insertBefore(currentLayer.dom, prevDom.nextSibling);
            } else {
                prevDom.parentNode.appendChild(currentLayer.dom);
            }
            currentLayer.initContext();
            this._layers[zlevel] = currentLayer;
            if (this._layerConfig[zlevel]) {
                util.merge(currentLayer, this._layerConfig[zlevel], true);
            }
            currentLayer.updateTransform();
        }
        return currentLayer;
    };
    Painter.prototype.getLayers = function () {
        return this._layers;
    };
    Painter.prototype._updateLayerStatus = function (list) {
        var layers = this._layers;
        var elCounts = {};
        for (var z in layers) {
            if (z !== &#x27;hover&#x27;) {
                elCounts[z] = layers[z].elCount;
                layers[z].elCount = 0;
            }
        }
        for (var i = 0, l = list.length; i &lt; l; i++) {
            var shape = list[i];
            var zlevel = shape.zlevel;
            var layer = layers[zlevel];
            if (layer) {
                layer.elCount++;
                if (layer.dirty) {
                    continue;
                }
                layer.dirty = shape.__dirty;
            }
        }
        for (var z in layers) {
            if (z !== &#x27;hover&#x27;) {
                if (elCounts[z] !== layers[z].elCount) {
                    layers[z].dirty = true;
                }
            }
        }
    };
    Painter.prototype.refreshShapes = function (shapeList, callback) {
        for (var i = 0, l = shapeList.length; i &lt; l; i++) {
            var shape = shapeList[i];
            shape.modSelf();
        }
        this.refresh(callback);
        return this;
    };
    Painter.prototype.setLoadingEffect = function (loadingEffect) {
        this._loadingEffect = loadingEffect;
        return this;
    };
    Painter.prototype.clear = function () {
        for (var k in this._layers) {
            if (k == &#x27;hover&#x27;) {
                continue;
            }
            this._layers[k].clear();
        }
        return this;
    };
    Painter.prototype.modLayer = function (zlevel, config) {
        if (config) {
            if (!this._layerConfig[zlevel]) {
                this._layerConfig[zlevel] = config;
            } else {
                util.merge(this._layerConfig[zlevel], config, true);
            }
            var layer = this._layers[zlevel];
            if (layer) {
                util.merge(layer, this._layerConfig[zlevel], true);
            }
        }
    };
    Painter.prototype.delLayer = function (zlevel) {
        var layer = this._layers[zlevel];
        if (!layer) {
            return;
        }
        this.modLayer(zlevel, {
            position: layer.position,
            rotation: layer.rotation,
            scale: layer.scale
        });
        layer.dom.parentNode.removeChild(layer.dom);
        delete this._layers[zlevel];
        this._zlevelList.splice(util.indexOf(this._zlevelList, zlevel), 1);
    };
    Painter.prototype.refreshHover = function () {
        this.clearHover();
        var list = this.storage.getHoverShapes(true);
        for (var i = 0, l = list.length; i &lt; l; i++) {
            this._brushHover(list[i]);
        }
        var ctx = this._layers.hover.ctx;
        ctx.flush &amp;&amp; ctx.flush();
        this.storage.delHover();
        return this;
    };
    Painter.prototype.clearHover = function () {
        var hover = this._layers.hover;
        hover &amp;&amp; hover.clear();
        return this;
    };
    Painter.prototype.showLoading = function (loadingEffect) {
        this._loadingEffect &amp;&amp; this._loadingEffect.stop();
        loadingEffect &amp;&amp; this.setLoadingEffect(loadingEffect);
        this._loadingEffect.start(this);
        this.loading = true;
        return this;
    };
    Painter.prototype.hideLoading = function () {
        this._loadingEffect.stop();
        this.clearHover();
        this.loading = false;
        return this;
    };
    Painter.prototype.isLoading = function () {
        return this.loading;
    };
    Painter.prototype.resize = function () {
        var domRoot = this._domRoot;
        domRoot.style.display = &#x27;none&#x27;;
        var width = this._getWidth();
        var height = this._getHeight();
        domRoot.style.display = &#x27;&#x27;;
        if (this._width != width || height != this._height) {
            this._width = width;
            this._height = height;
            domRoot.style.width = width + &#x27;px&#x27;;
            domRoot.style.height = height + &#x27;px&#x27;;
            for (var id in this._layers) {
                this._layers[id].resize(width, height);
            }
            this.refresh(null, true);
        }
        return this;
    };
    Painter.prototype.clearLayer = function (zLevel) {
        var layer = this._layers[zLevel];
        if (layer) {
            layer.clear();
        }
    };
    Painter.prototype.dispose = function () {
        if (this.isLoading()) {
            this.hideLoading();
        }
        this.root.innerHTML = &#x27;&#x27;;
        this.root = this.storage = this._domRoot = this._layers = null;
    };
    Painter.prototype.getDomHover = function () {
        return this._layers.hover.dom;
    };
    Painter.prototype.toDataURL = function (type, backgroundColor, args) {
        if (vmlCanvasManager) {
            return null;
        }
        var imageDom = createDom(&#x27;image&#x27;, &#x27;canvas&#x27;, this);
        this._bgDom.appendChild(imageDom);
        var ctx = imageDom.getContext(&#x27;2d&#x27;);
        devicePixelRatio != 1 &amp;&amp; ctx.scale(devicePixelRatio, devicePixelRatio);
        ctx.fillStyle = backgroundColor || &#x27;#fff&#x27;;
        ctx.rect(0, 0, this._width * devicePixelRatio, this._height * devicePixelRatio);
        ctx.fill();
        var self = this;
        this.storage.iterShape(function (shape) {
            if (!shape.invisible) {
                if (!shape.onbrush || shape.onbrush &amp;&amp; !shape.onbrush(ctx, false)) {
                    if (config.catchBrushException) {
                        try {
                            shape.brush(ctx, false, self.refreshNextFrame);
                        } catch (error) {
                            log(error, &#x27;brush error of &#x27; + shape.type, shape);
                        }
                    } else {
                        shape.brush(ctx, false, self.refreshNextFrame);
                    }
                }
            }
        }, {
            normal: &#x27;up&#x27;,
            update: true
        });
        var image = imageDom.toDataURL(type, args);
        ctx = null;
        this._bgDom.removeChild(imageDom);
        return image;
    };
    Painter.prototype.getWidth = function () {
        return this._width;
    };
    Painter.prototype.getHeight = function () {
        return this._height;
    };
    Painter.prototype._getWidth = function () {
        var root = this.root;
        var stl = root.currentStyle || document.defaultView.getComputedStyle(root);
        return ((root.clientWidth || parseInt(stl.width, 10)) - parseInt(stl.paddingLeft, 10) - parseInt(stl.paddingRight, 10)).toFixed(0) - 0;
    };
    Painter.prototype._getHeight = function () {
        var root = this.root;
        var stl = root.currentStyle || document.defaultView.getComputedStyle(root);
        return ((root.clientHeight || parseInt(stl.height, 10)) - parseInt(stl.paddingTop, 10) - parseInt(stl.paddingBottom, 10)).toFixed(0) - 0;
    };
    Painter.prototype._brushHover = function (shape) {
        var ctx = this._layers.hover.ctx;
        if (!shape.onbrush || shape.onbrush &amp;&amp; !shape.onbrush(ctx, true)) {
            var layer = this.getLayer(shape.zlevel);
            if (layer.needTransform) {
                ctx.save();
                layer.setTransform(ctx);
            }
            if (config.catchBrushException) {
                try {
                    shape.brush(ctx, true, this.refreshNextFrame);
                } catch (error) {
                    log(error, &#x27;hoverBrush error of &#x27; + shape.type, shape);
                }
            } else {
                shape.brush(ctx, true, this.refreshNextFrame);
            }
            if (layer.needTransform) {
                ctx.restore();
            }
        }
    };
    Painter.prototype._shapeToImage = function (id, shape, width, height, devicePixelRatio) {
        var canvas = document.createElement(&#x27;canvas&#x27;);
        var ctx = canvas.getContext(&#x27;2d&#x27;);
        var devicePixelRatio = window.devicePixelRatio || 1;
        canvas.style.width = width + &#x27;px&#x27;;
        canvas.style.height = height + &#x27;px&#x27;;
        canvas.setAttribute(&#x27;width&#x27;, width * devicePixelRatio);
        canvas.setAttribute(&#x27;height&#x27;, height * devicePixelRatio);
        ctx.clearRect(0, 0, width * devicePixelRatio, height * devicePixelRatio);
        var shapeTransform = {
            position: shape.position,
            rotation: shape.rotation,
            scale: shape.scale
        };
        shape.position = [
            0,
            0,
            0
        ];
        shape.rotation = 0;
        shape.scale = [
            1,
            1
        ];
        if (shape) {
            shape.brush(ctx, false);
        }
        var ImageShape = require(&#x27;./shape/Image&#x27;);
        var imgShape = new ImageShape({
            id: id,
            style: {
                x: 0,
                y: 0,
                image: canvas
            }
        });
        if (shapeTransform.position != null) {
            imgShape.position = shape.position = shapeTransform.position;
        }
        if (shapeTransform.rotation != null) {
            imgShape.rotation = shape.rotation = shapeTransform.rotation;
        }
        if (shapeTransform.scale != null) {
            imgShape.scale = shape.scale = shapeTransform.scale;
        }
        return imgShape;
    };
    Painter.prototype._createShapeToImageProcessor = function () {
        if (vmlCanvasManager) {
            return doNothing;
        }
        var me = this;
        return function (id, e, width, height) {
            return me._shapeToImage(id, e, width, height, devicePixelRatio);
        };
    };
    function createDom(id, type, painter) {
        var newDom = document.createElement(type);
        var width = painter._width;
        var height = painter._height;
        newDom.style.position = &#x27;absolute&#x27;;
        newDom.style.left = 0;
        newDom.style.top = 0;
        newDom.style.width = width + &#x27;px&#x27;;
        newDom.style.height = height + &#x27;px&#x27;;
        newDom.setAttribute(&#x27;width&#x27;, width * devicePixelRatio);
        newDom.setAttribute(&#x27;height&#x27;, height * devicePixelRatio);
        newDom.setAttribute(&#x27;data-zr-dom-id&#x27;, id);
        return newDom;
    }
    var Layer = function (id, painter) {
        this.dom = createDom(id, &#x27;canvas&#x27;, painter);
        this.dom.onselectstart = returnFalse;
        this.dom.style[&#x27;-webkit-user-select&#x27;] = &#x27;none&#x27;;
        this.dom.style[&#x27;user-select&#x27;] = &#x27;none&#x27;;
        this.dom.style[&#x27;-webkit-touch-callout&#x27;] = &#x27;none&#x27;;
        vmlCanvasManager &amp;&amp; vmlCanvasManager.initElement(this.dom);
        this.domBack = null;
        this.ctxBack = null;
        this.painter = painter;
        this.unusedCount = 0;
        this.config = null;
        this.dirty = true;
        this.elCount = 0;
        this.clearColor = 0;
        this.motionBlur = false;
        this.lastFrameAlpha = 0.7;
        this.zoomable = false;
        this.panable = false;
        this.maxZoom = Infinity;
        this.minZoom = 0;
        Transformable.call(this);
    };
    Layer.prototype.initContext = function () {
        this.ctx = this.dom.getContext(&#x27;2d&#x27;);
        if (devicePixelRatio != 1) {
            this.ctx.scale(devicePixelRatio, devicePixelRatio);
        }
    };
    Layer.prototype.createBackBuffer = function () {
        if (vmlCanvasManager) {
            return;
        }
        this.domBack = createDom(&#x27;back-&#x27; + this.id, &#x27;canvas&#x27;, this.painter);
        this.ctxBack = this.domBack.getContext(&#x27;2d&#x27;);
        if (devicePixelRatio != 1) {
            this.ctxBack.scale(devicePixelRatio, devicePixelRatio);
        }
    };
    Layer.prototype.resize = function (width, height) {
        this.dom.style.width = width + &#x27;px&#x27;;
        this.dom.style.height = height + &#x27;px&#x27;;
        this.dom.setAttribute(&#x27;width&#x27;, width * devicePixelRatio);
        this.dom.setAttribute(&#x27;height&#x27;, height * devicePixelRatio);
        if (devicePixelRatio != 1) {
            this.ctx.scale(devicePixelRatio, devicePixelRatio);
        }
        if (this.domBack) {
            this.domBack.setAttribute(&#x27;width&#x27;, width * devicePixelRatio);
            this.domBack.setAttribute(&#x27;height&#x27;, height * devicePixelRatio);
            if (devicePixelRatio != 1) {
                this.ctxBack.scale(devicePixelRatio, devicePixelRatio);
            }
        }
    };
    Layer.prototype.clear = function () {
        var dom = this.dom;
        var ctx = this.ctx;
        var width = dom.width;
        var height = dom.height;
        var haveClearColor = this.clearColor &amp;&amp; !vmlCanvasManager;
        var haveMotionBLur = this.motionBlur &amp;&amp; !vmlCanvasManager;
        var lastFrameAlpha = this.lastFrameAlpha;
        if (haveMotionBLur) {
            if (!this.domBack) {
                this.createBackBuffer();
            }
            this.ctxBack.globalCompositeOperation = &#x27;copy&#x27;;
            this.ctxBack.drawImage(dom, 0, 0, width / devicePixelRatio, height / devicePixelRatio);
        }
        if (haveClearColor) {
            ctx.save();
            ctx.fillStyle = this.config.clearColor;
            ctx.fillRect(0, 0, width / devicePixelRatio, height / devicePixelRatio);
            ctx.restore();
        } else {
            ctx.clearRect(0, 0, width / devicePixelRatio, height / devicePixelRatio);
        }
        if (haveMotionBLur) {
            var domBack = this.domBack;
            ctx.save();
            ctx.globalAlpha = lastFrameAlpha;
            ctx.drawImage(domBack, 0, 0, width / devicePixelRatio, height / devicePixelRatio);
            ctx.restore();
        }
    };
    util.merge(Layer.prototype, Transformable.prototype);
    return Painter;
});define(&#x27;zrender/Storage&#x27;, [
    &#x27;require&#x27;,
    &#x27;./tool/util&#x27;,
    &#x27;./Group&#x27;
], function (require) {
    &#x27;use strict&#x27;;
    var util = require(&#x27;./tool/util&#x27;);
    var Group = require(&#x27;./Group&#x27;);
    var defaultIterateOption = {
        hover: false,
        normal: &#x27;down&#x27;,
        update: false
    };
    function shapeCompareFunc(a, b) {
        if (a.zlevel == b.zlevel) {
            if (a.z == b.z) {
                return a.__renderidx - b.__renderidx;
            }
            return a.z - b.z;
        }
        return a.zlevel - b.zlevel;
    }
    var Storage = function () {
        this._elements = {};
        this._hoverElements = [];
        this._roots = [];
        this._shapeList = [];
        this._shapeListOffset = 0;
    };
    Storage.prototype.iterShape = function (fun, option) {
        if (!option) {
            option = defaultIterateOption;
        }
        if (option.hover) {
            for (var i = 0, l = this._hoverElements.length; i &lt; l; i++) {
                var el = this._hoverElements[i];
                el.updateTransform();
                if (fun(el)) {
                    return this;
                }
            }
        }
        if (option.update) {
            this.updateShapeList();
        }
        switch (option.normal) {
        case &#x27;down&#x27;:
            var l = this._shapeList.length;
            while (l--) {
                if (fun(this._shapeList[l])) {
                    return this;
                }
            }
            break;
        default:
            for (var i = 0, l = this._shapeList.length; i &lt; l; i++) {
                if (fun(this._shapeList[i])) {
                    return this;
                }
            }
            break;
        }
        return this;
    };
    Storage.prototype.getHoverShapes = function (update) {
        var hoverElements = [];
        for (var i = 0, l = this._hoverElements.length; i &lt; l; i++) {
            hoverElements.push(this._hoverElements[i]);
            var target = this._hoverElements[i].hoverConnect;
            if (target) {
                var shape;
                target = target instanceof Array ? target : [target];
                for (var j = 0, k = target.length; j &lt; k; j++) {
                    shape = target[j].id ? target[j] : this.get(target[j]);
                    if (shape) {
                        hoverElements.push(shape);
                    }
                }
            }
        }
        hoverElements.sort(shapeCompareFunc);
        if (update) {
            for (var i = 0, l = hoverElements.length; i &lt; l; i++) {
                hoverElements[i].updateTransform();
            }
        }
        return hoverElements;
    };
    Storage.prototype.getShapeList = function (update) {
        if (update) {
            this.updateShapeList();
        }
        return this._shapeList;
    };
    Storage.prototype.updateShapeList = function () {
        this._shapeListOffset = 0;
        for (var i = 0, len = this._roots.length; i &lt; len; i++) {
            var root = this._roots[i];
            this._updateAndAddShape(root);
        }
        this._shapeList.length = this._shapeListOffset;
        for (var i = 0, len = this._shapeList.length; i &lt; len; i++) {
            this._shapeList[i].__renderidx = i;
        }
        this._shapeList.sort(shapeCompareFunc);
    };
    Storage.prototype._updateAndAddShape = function (el, clipShapes) {
        if (el.ignore) {
            return;
        }
        el.updateTransform();
        if (el.type == &#x27;group&#x27;) {
            if (el.clipShape) {
                el.clipShape.parent = el;
                el.clipShape.updateTransform();
                if (clipShapes) {
                    clipShapes = clipShapes.slice();
                    clipShapes.push(el.clipShape);
                } else {
                    clipShapes = [el.clipShape];
                }
            }
            for (var i = 0; i &lt; el._children.length; i++) {
                var child = el._children[i];
                child.__dirty = el.__dirty || child.__dirty;
                this._updateAndAddShape(child, clipShapes);
            }
            el.__dirty = false;
        } else {
            el.__clipShapes = clipShapes;
            this._shapeList[this._shapeListOffset++] = el;
        }
    };
    Storage.prototype.mod = function (elId, params) {
        var el = this._elements[elId];
        if (el) {
            el.modSelf();
            if (params) {
                if (params.parent || params._storage || params.__startClip) {
                    var target = {};
                    for (var name in params) {
                        if (name == &#x27;parent&#x27; || name == &#x27;_storage&#x27; || name == &#x27;__startClip&#x27;) {
                            continue;
                        }
                        if (params.hasOwnProperty(name)) {
                            target[name] = params[name];
                        }
                    }
                    util.merge(el, target, true);
                } else {
                    util.merge(el, params, true);
                }
            }
        }
        return this;
    };
    Storage.prototype.drift = function (shapeId, dx, dy) {
        var shape = this._elements[shapeId];
        if (shape) {
            shape.needTransform = true;
            if (shape.draggable === &#x27;horizontal&#x27;) {
                dy = 0;
            } else if (shape.draggable === &#x27;vertical&#x27;) {
                dx = 0;
            }
            if (!shape.ondrift || shape.ondrift &amp;&amp; !shape.ondrift(dx, dy)) {
                shape.drift(dx, dy);
            }
        }
        return this;
    };
    Storage.prototype.addHover = function (shape) {
        shape.updateNeedTransform();
        this._hoverElements.push(shape);
        return this;
    };
    Storage.prototype.delHover = function () {
        this._hoverElements = [];
        return this;
    };
    Storage.prototype.hasHoverShape = function () {
        return this._hoverElements.length &gt; 0;
    };
    Storage.prototype.addRoot = function (el) {
        if (el instanceof Group) {
            el.addChildrenToStorage(this);
        }
        this.addToMap(el);
        this._roots.push(el);
    };
    Storage.prototype.delRoot = function (elId) {
        if (typeof elId == &#x27;undefined&#x27;) {
            for (var i = 0; i &lt; this._roots.length; i++) {
                var root = this._roots[i];
                if (root instanceof Group) {
                    root.delChildrenFromStorage(this);
                }
            }
            this._elements = {};
            this._hoverElements = [];
            this._roots = [];
            this._shapeList = [];
            this._shapeListOffset = 0;
            return;
        }
        if (elId instanceof Array) {
            for (var i = 0, l = elId.length; i &lt; l; i++) {
                this.delRoot(elId[i]);
            }
            return;
        }
        var el;
        if (typeof elId == &#x27;string&#x27;) {
            el = this._elements[elId];
        } else {
            el = elId;
        }
        var idx = util.indexOf(this._roots, el);
        if (idx &gt;= 0) {
            this.delFromMap(el.id);
            this._roots.splice(idx, 1);
            if (el instanceof Group) {
                el.delChildrenFromStorage(this);
            }
        }
    };
    Storage.prototype.addToMap = function (el) {
        if (el instanceof Group) {
            el._storage = this;
        }
        el.modSelf();
        this._elements[el.id] = el;
        return this;
    };
    Storage.prototype.get = function (elId) {
        return this._elements[elId];
    };
    Storage.prototype.delFromMap = function (elId) {
        var el = this._elements[elId];
        if (el) {
            delete this._elements[elId];
            if (el instanceof Group) {
                el._storage = null;
            }
        }
        return this;
    };
    Storage.prototype.dispose = function () {
        this._elements = this._renderList = this._roots = this._hoverElements = null;
    };
    return Storage;
});define(&#x27;zrender/animation/Animation&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Clip&#x27;,
    &#x27;../tool/color&#x27;,
    &#x27;../tool/util&#x27;,
    &#x27;../tool/event&#x27;
], function (require) {
    &#x27;use strict&#x27;;
    var Clip = require(&#x27;./Clip&#x27;);
    var color = require(&#x27;../tool/color&#x27;);
    var util = require(&#x27;../tool/util&#x27;);
    var Dispatcher = require(&#x27;../tool/event&#x27;).Dispatcher;
    var requestAnimationFrame = window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (func) {
        setTimeout(func, 16);
    };
    var arraySlice = Array.prototype.slice;
    var Animation = function (options) {
        options = options || {};
        this.stage = options.stage || {};
        this.onframe = options.onframe || function () {
        };
        this._clips = [];
        this._running = false;
        this._time = 0;
        Dispatcher.call(this);
    };
    Animation.prototype = {
        add: function (clip) {
            this._clips.push(clip);
        },
        remove: function (clip) {
            var idx = util.indexOf(this._clips, clip);
            if (idx &gt;= 0) {
                this._clips.splice(idx, 1);
            }
        },
        _update: function () {
            var time = new Date().getTime();
            var delta = time - this._time;
            var clips = this._clips;
            var len = clips.length;
            var deferredEvents = [];
            var deferredClips = [];
            for (var i = 0; i &lt; len; i++) {
                var clip = clips[i];
                var e = clip.step(time);
                if (e) {
                    deferredEvents.push(e);
                    deferredClips.push(clip);
                }
            }
            if (this.stage.update) {
                this.stage.update();
            }
            for (var i = 0; i &lt; len;) {
                if (clips[i]._needsRemove) {
                    clips[i] = clips[len - 1];
                    clips.pop();
                    len--;
                } else {
                    i++;
                }
            }
            len = deferredEvents.length;
            for (var i = 0; i &lt; len; i++) {
                deferredClips[i].fire(deferredEvents[i]);
            }
            this._time = time;
            this.onframe(delta);
            this.dispatch(&#x27;frame&#x27;, delta);
        },
        start: function () {
            var self = this;
            this._running = true;
            function step() {
                if (self._running) {
                    self._update();
                    requestAnimationFrame(step);
                }
            }
            this._time = new Date().getTime();
            requestAnimationFrame(step);
        },
        stop: function () {
            this._running = false;
        },
        clear: function () {
            this._clips = [];
        },
        animate: function (target, options) {
            options = options || {};
            var deferred = new Animator(target, options.loop, options.getter, options.setter);
            deferred.animation = this;
            return deferred;
        },
        constructor: Animation
    };
    util.merge(Animation.prototype, Dispatcher.prototype, true);
    function _defaultGetter(target, key) {
        return target[key];
    }
    function _defaultSetter(target, key, value) {
        target[key] = value;
    }
    function _interpolateNumber(p0, p1, percent) {
        return (p1 - p0) * percent + p0;
    }
    function _interpolateArray(p0, p1, percent, out, arrDim) {
        var len = p0.length;
        if (arrDim == 1) {
            for (var i = 0; i &lt; len; i++) {
                out[i] = _interpolateNumber(p0[i], p1[i], percent);
            }
        } else {
            var len2 = p0[0].length;
            for (var i = 0; i &lt; len; i++) {
                for (var j = 0; j &lt; len2; j++) {
                    out[i][j] = _interpolateNumber(p0[i][j], p1[i][j], percent);
                }
            }
        }
    }
    function _isArrayLike(data) {
        switch (typeof data) {
        case &#x27;undefined&#x27;:
        case &#x27;string&#x27;:
            return false;
        }
        return typeof data.length !== &#x27;undefined&#x27;;
    }
    function _catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
        var len = p0.length;
        if (arrDim == 1) {
            for (var i = 0; i &lt; len; i++) {
                out[i] = _catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
            }
        } else {
            var len2 = p0[0].length;
            for (var i = 0; i &lt; len; i++) {
                for (var j = 0; j &lt; len2; j++) {
                    out[i][j] = _catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
                }
            }
        }
    }
    function _catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    function _cloneValue(value) {
        if (_isArrayLike(value)) {
            var len = value.length;
            if (_isArrayLike(value[0])) {
                var ret = [];
                for (var i = 0; i &lt; len; i++) {
                    ret.push(arraySlice.call(value[i]));
                }
                return ret;
            } else {
                return arraySlice.call(value);
            }
        } else {
            return value;
        }
    }
    function rgba2String(rgba) {
        rgba[0] = Math.floor(rgba[0]);
        rgba[1] = Math.floor(rgba[1]);
        rgba[2] = Math.floor(rgba[2]);
        return &#x27;rgba(&#x27; + rgba.join(&#x27;,&#x27;) + &#x27;)&#x27;;
    }
    var Animator = function (target, loop, getter, setter) {
        this._tracks = {};
        this._target = target;
        this._loop = loop || false;
        this._getter = getter || _defaultGetter;
        this._setter = setter || _defaultSetter;
        this._clipCount = 0;
        this._delay = 0;
        this._doneList = [];
        this._onframeList = [];
        this._clipList = [];
    };
    Animator.prototype = {
        when: function (time, props) {
            for (var propName in props) {
                if (!this._tracks[propName]) {
                    this._tracks[propName] = [];
                    if (time !== 0) {
                        this._tracks[propName].push({
                            time: 0,
                            value: _cloneValue(this._getter(this._target, propName))
                        });
                    }
                }
                this._tracks[propName].push({
                    time: parseInt(time, 10),
                    value: props[propName]
                });
            }
            return this;
        },
        during: function (callback) {
            this._onframeList.push(callback);
            return this;
        },
        start: function (easing) {
            var self = this;
            var setter = this._setter;
            var getter = this._getter;
            var useSpline = easing === &#x27;spline&#x27;;
            var ondestroy = function () {
                self._clipCount--;
                if (self._clipCount === 0) {
                    self._tracks = {};
                    var len = self._doneList.length;
                    for (var i = 0; i &lt; len; i++) {
                        self._doneList[i].call(self);
                    }
                }
            };
            var createTrackClip = function (keyframes, propName) {
                var trackLen = keyframes.length;
                if (!trackLen) {
                    return;
                }
                var firstVal = keyframes[0].value;
                var isValueArray = _isArrayLike(firstVal);
                var isValueColor = false;
                var arrDim = isValueArray &amp;&amp; _isArrayLike(firstVal[0]) ? 2 : 1;
                keyframes.sort(function (a, b) {
                    return a.time - b.time;
                });
                var trackMaxTime;
                if (trackLen) {
                    trackMaxTime = keyframes[trackLen - 1].time;
                } else {
                    return;
                }
                var kfPercents = [];
                var kfValues = [];
                for (var i = 0; i &lt; trackLen; i++) {
                    kfPercents.push(keyframes[i].time / trackMaxTime);
                    var value = keyframes[i].value;
                    if (typeof value == &#x27;string&#x27;) {
                        value = color.toArray(value);
                        if (value.length === 0) {
                            value[0] = value[1] = value[2] = 0;
                            value[3] = 1;
                        }
                        isValueColor = true;
                    }
                    kfValues.push(value);
                }
                var cacheKey = 0;
                var cachePercent = 0;
                var start;
                var i;
                var w;
                var p0;
                var p1;
                var p2;
                var p3;
                if (isValueColor) {
                    var rgba = [
                        0,
                        0,
                        0,
                        0
                    ];
                }
                var onframe = function (target, percent) {
                    if (percent &lt; cachePercent) {
                        start = Math.min(cacheKey + 1, trackLen - 1);
                        for (i = start; i &gt;= 0; i--) {
                            if (kfPercents[i] &lt;= percent) {
                                break;
                            }
                        }
                        i = Math.min(i, trackLen - 2);
                    } else {
                        for (i = cacheKey; i &lt; trackLen; i++) {
                            if (kfPercents[i] &gt; percent) {
                                break;
                            }
                        }
                        i = Math.min(i - 1, trackLen - 2);
                    }
                    cacheKey = i;
                    cachePercent = percent;
                    var range = kfPercents[i + 1] - kfPercents[i];
                    if (range === 0) {
                        return;
                    } else {
                        w = (percent - kfPercents[i]) / range;
                    }
                    if (useSpline) {
                        p1 = kfValues[i];
                        p0 = kfValues[i === 0 ? i : i - 1];
                        p2 = kfValues[i &gt; trackLen - 2 ? trackLen - 1 : i + 1];
                        p3 = kfValues[i &gt; trackLen - 3 ? trackLen - 1 : i + 2];
                        if (isValueArray) {
                            _catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
                        } else {
                            var value;
                            if (isValueColor) {
                                value = _catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
                                value = rgba2String(rgba);
                            } else {
                                value = _catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
                            }
                            setter(target, propName, value);
                        }
                    } else {
                        if (isValueArray) {
                            _interpolateArray(kfValues[i], kfValues[i + 1], w, getter(target, propName), arrDim);
                        } else {
                            var value;
                            if (isValueColor) {
                                _interpolateArray(kfValues[i], kfValues[i + 1], w, rgba, 1);
                                value = rgba2String(rgba);
                            } else {
                                value = _interpolateNumber(kfValues[i], kfValues[i + 1], w);
                            }
                            setter(target, propName, value);
                        }
                    }
                    for (i = 0; i &lt; self._onframeList.length; i++) {
                        self._onframeList[i](target, percent);
                    }
                };
                var clip = new Clip({
                    target: self._target,
                    life: trackMaxTime,
                    loop: self._loop,
                    delay: self._delay,
                    onframe: onframe,
                    ondestroy: ondestroy
                });
                if (easing &amp;&amp; easing !== &#x27;spline&#x27;) {
                    clip.easing = easing;
                }
                self._clipList.push(clip);
                self._clipCount++;
                self.animation.add(clip);
            };
            for (var propName in this._tracks) {
                createTrackClip(this._tracks[propName], propName);
            }
            return this;
        },
        stop: function () {
            for (var i = 0; i &lt; this._clipList.length; i++) {
                var clip = this._clipList[i];
                this.animation.remove(clip);
            }
            this._clipList = [];
        },
        delay: function (time) {
            this._delay = time;
            return this;
        },
        done: function (cb) {
            if (cb) {
                this._doneList.push(cb);
            }
            return this;
        }
    };
    return Animation;
});define(&#x27;zrender/tool/vector&#x27;, [], function () {
    var ArrayCtor = typeof Float32Array === &#x27;undefined&#x27; ? Array : Float32Array;
    var vector = {
        create: function (x, y) {
            var out = new ArrayCtor(2);
            out[0] = x || 0;
            out[1] = y || 0;
            return out;
        },
        copy: function (out, v) {
            out[0] = v[0];
            out[1] = v[1];
            return out;
        },
        set: function (out, a, b) {
            out[0] = a;
            out[1] = b;
            return out;
        },
        add: function (out, v1, v2) {
            out[0] = v1[0] + v2[0];
            out[1] = v1[1] + v2[1];
            return out;
        },
        scaleAndAdd: function (out, v1, v2, a) {
            out[0] = v1[0] + v2[0] * a;
            out[1] = v1[1] + v2[1] * a;
            return out;
        },
        sub: function (out, v1, v2) {
            out[0] = v1[0] - v2[0];
            out[1] = v1[1] - v2[1];
            return out;
        },
        len: function (v) {
            return Math.sqrt(this.lenSquare(v));
        },
        lenSquare: function (v) {
            return v[0] * v[0] + v[1] * v[1];
        },
        mul: function (out, v1, v2) {
            out[0] = v1[0] * v2[0];
            out[1] = v1[1] * v2[1];
            return out;
        },
        div: function (out, v1, v2) {
            out[0] = v1[0] / v2[0];
            out[1] = v1[1] / v2[1];
            return out;
        },
        dot: function (v1, v2) {
            return v1[0] * v2[0] + v1[1] * v2[1];
        },
        scale: function (out, v, s) {
            out[0] = v[0] * s;
            out[1] = v[1] * s;
            return out;
        },
        normalize: function (out, v) {
            var d = vector.len(v);
            if (d === 0) {
                out[0] = 0;
                out[1] = 0;
            } else {
                out[0] = v[0] / d;
                out[1] = v[1] / d;
            }
            return out;
        },
        distance: function (v1, v2) {
            return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
        },
        distanceSquare: function (v1, v2) {
            return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
        },
        negate: function (out, v) {
            out[0] = -v[0];
            out[1] = -v[1];
            return out;
        },
        lerp: function (out, v1, v2, t) {
            out[0] = v1[0] + t * (v2[0] - v1[0]);
            out[1] = v1[1] + t * (v2[1] - v1[1]);
            return out;
        },
        applyTransform: function (out, v, m) {
            var x = v[0];
            var y = v[1];
            out[0] = m[0] * x + m[2] * y + m[4];
            out[1] = m[1] * x + m[3] * y + m[5];
            return out;
        },
        min: function (out, v1, v2) {
            out[0] = Math.min(v1[0], v2[0]);
            out[1] = Math.min(v1[1], v2[1]);
            return out;
        },
        max: function (out, v1, v2) {
            out[0] = Math.max(v1[0], v2[0]);
            out[1] = Math.max(v1[1], v2[1]);
            return out;
        }
    };
    vector.length = vector.len;
    vector.lengthSquare = vector.lenSquare;
    vector.dist = vector.distance;
    vector.distSquare = vector.distanceSquare;
    return vector;
});define(&#x27;zrender/tool/matrix&#x27;, [], function () {
    var ArrayCtor = typeof Float32Array === &#x27;undefined&#x27; ? Array : Float32Array;
    var matrix = {
        create: function () {
            var out = new ArrayCtor(6);
            matrix.identity(out);
            return out;
        },
        identity: function (out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            out[4] = 0;
            out[5] = 0;
            return out;
        },
        copy: function (out, m) {
            out[0] = m[0];
            out[1] = m[1];
            out[2] = m[2];
            out[3] = m[3];
            out[4] = m[4];
            out[5] = m[5];
            return out;
        },
        mul: function (out, m1, m2) {
            out[0] = m1[0] * m2[0] + m1[2] * m2[1];
            out[1] = m1[1] * m2[0] + m1[3] * m2[1];
            out[2] = m1[0] * m2[2] + m1[2] * m2[3];
            out[3] = m1[1] * m2[2] + m1[3] * m2[3];
            out[4] = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
            out[5] = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
            return out;
        },
        translate: function (out, a, v) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4] + v[0];
            out[5] = a[5] + v[1];
            return out;
        },
        rotate: function (out, a, rad) {
            var aa = a[0];
            var ac = a[2];
            var atx = a[4];
            var ab = a[1];
            var ad = a[3];
            var aty = a[5];
            var st = Math.sin(rad);
            var ct = Math.cos(rad);
            out[0] = aa * ct + ab * st;
            out[1] = -aa * st + ab * ct;
            out[2] = ac * ct + ad * st;
            out[3] = -ac * st + ct * ad;
            out[4] = ct * atx + st * aty;
            out[5] = ct * aty - st * atx;
            return out;
        },
        scale: function (out, a, v) {
            var vx = v[0];
            var vy = v[1];
            out[0] = a[0] * vx;
            out[1] = a[1] * vy;
            out[2] = a[2] * vx;
            out[3] = a[3] * vy;
            out[4] = a[4] * vx;
            out[5] = a[5] * vy;
            return out;
        },
        invert: function (out, a) {
            var aa = a[0];
            var ac = a[2];
            var atx = a[4];
            var ab = a[1];
            var ad = a[3];
            var aty = a[5];
            var det = aa * ad - ab * ac;
            if (!det) {
                return null;
            }
            det = 1 / det;
            out[0] = ad * det;
            out[1] = -ab * det;
            out[2] = -ac * det;
            out[3] = aa * det;
            out[4] = (ac * aty - ad * atx) * det;
            out[5] = (ab * atx - aa * aty) * det;
            return out;
        },
        mulVector: function (out, a, v) {
            var aa = a[0];
            var ac = a[2];
            var atx = a[4];
            var ab = a[1];
            var ad = a[3];
            var aty = a[5];
            out[0] = v[0] * aa + v[1] * ac + atx;
            out[1] = v[0] * ab + v[1] * ad + aty;
            return out;
        }
    };
    return matrix;
});define(&#x27;zrender/loadingEffect/Base&#x27;, [
    &#x27;require&#x27;,
    &#x27;../tool/util&#x27;,
    &#x27;../shape/Text&#x27;,
    &#x27;../shape/Rectangle&#x27;
], function (require) {
    var util = require(&#x27;../tool/util&#x27;);
    var TextShape = require(&#x27;../shape/Text&#x27;);
    var RectangleShape = require(&#x27;../shape/Rectangle&#x27;);
    var DEFAULT_TEXT = &#x27;Loading...&#x27;;
    var DEFAULT_TEXT_FONT = &#x27;normal 16px Arial&#x27;;
    function Base(options) {
        this.setOptions(options);
    }
    Base.prototype.createTextShape = function (textStyle) {
        return new TextShape({
            highlightStyle: util.merge({
                x: this.canvasWidth / 2,
                y: this.canvasHeight / 2,
                text: DEFAULT_TEXT,
                textAlign: &#x27;center&#x27;,
                textBaseline: &#x27;middle&#x27;,
                textFont: DEFAULT_TEXT_FONT,
                color: &#x27;#333&#x27;,
                brushType: &#x27;fill&#x27;
            }, textStyle, true)
        });
    };
    Base.prototype.createBackgroundShape = function (color) {
        return new RectangleShape({
            highlightStyle: {
                x: 0,
                y: 0,
                width: this.canvasWidth,
                height: this.canvasHeight,
                brushType: &#x27;fill&#x27;,
                color: color
            }
        });
    };
    Base.prototype.start = function (painter) {
        this.canvasWidth = painter._width;
        this.canvasHeight = painter._height;
        function addShapeHandle(param) {
            painter.storage.addHover(param);
        }
        function refreshHandle() {
            painter.refreshHover();
        }
        this.loadingTimer = this._start(addShapeHandle, refreshHandle);
    };
    Base.prototype._start = function () {
        return setInterval(function () {
        }, 10000);
    };
    Base.prototype.stop = function () {
        clearInterval(this.loadingTimer);
    };
    Base.prototype.setOptions = function (options) {
        this.options = options || {};
    };
    Base.prototype.adjust = function (value, region) {
        if (value &lt;= region[0]) {
            value = region[0];
        } else if (value &gt;= region[1]) {
            value = region[1];
        }
        return value;
    };
    Base.prototype.getLocation = function (loc, totalWidth, totalHeight) {
        var x = loc.x != null ? loc.x : &#x27;center&#x27;;
        switch (x) {
        case &#x27;center&#x27;:
            x = Math.floor((this.canvasWidth - totalWidth) / 2);
            break;
        case &#x27;left&#x27;:
            x = 0;
            break;
        case &#x27;right&#x27;:
            x = this.canvasWidth - totalWidth;
            break;
        }
        var y = loc.y != null ? loc.y : &#x27;center&#x27;;
        switch (y) {
        case &#x27;center&#x27;:
            y = Math.floor((this.canvasHeight - totalHeight) / 2);
            break;
        case &#x27;top&#x27;:
            y = 0;
            break;
        case &#x27;bottom&#x27;:
            y = this.canvasHeight - totalHeight;
            break;
        }
        return {
            x: x,
            y: y,
            width: totalWidth,
            height: totalHeight
        };
    };
    return Base;
});define(&#x27;zrender/mixin/Transformable&#x27;, [
    &#x27;require&#x27;,
    &#x27;../tool/matrix&#x27;,
    &#x27;../tool/vector&#x27;
], function (require) {
    &#x27;use strict&#x27;;
    var matrix = require(&#x27;../tool/matrix&#x27;);
    var vector = require(&#x27;../tool/vector&#x27;);
    var origin = [
        0,
        0
    ];
    var EPSILON = 0.00005;
    function isAroundZero(val) {
        return val &gt; -EPSILON &amp;&amp; val &lt; EPSILON;
    }
    function isNotAroundZero(val) {
        return val &gt; EPSILON || val &lt; -EPSILON;
    }
    var Transformable = function () {
        if (!this.position) {
            this.position = [
                0,
                0
            ];
        }
        if (typeof this.rotation == &#x27;undefined&#x27;) {
            this.rotation = [
                0,
                0,
                0
            ];
        }
        if (!this.scale) {
            this.scale = [
                1,
                1,
                0,
                0
            ];
        }
        this.needLocalTransform = false;
        this.needTransform = false;
    };
    Transformable.prototype = {
        constructor: Transformable,
        updateNeedTransform: function () {
            this.needLocalTransform = isNotAroundZero(this.rotation[0]) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
        },
        updateTransform: function () {
            this.updateNeedTransform();
            if (this.parent) {
                this.needTransform = this.needLocalTransform || this.parent.needTransform;
            } else {
                this.needTransform = this.needLocalTransform;
            }
            if (!this.needTransform) {
                return;
            }
            var m = this.transform || matrix.create();
            matrix.identity(m);
            if (this.needLocalTransform) {
                if (isNotAroundZero(this.scale[0]) || isNotAroundZero(this.scale[1])) {
                    origin[0] = -this.scale[2] || 0;
                    origin[1] = -this.scale[3] || 0;
                    var haveOrigin = isNotAroundZero(origin[0]) || isNotAroundZero(origin[1]);
                    if (haveOrigin) {
                        matrix.translate(m, m, origin);
                    }
                    matrix.scale(m, m, this.scale);
                    if (haveOrigin) {
                        origin[0] = -origin[0];
                        origin[1] = -origin[1];
                        matrix.translate(m, m, origin);
                    }
                }
                if (this.rotation instanceof Array) {
                    if (this.rotation[0] !== 0) {
                        origin[0] = -this.rotation[1] || 0;
                        origin[1] = -this.rotation[2] || 0;
                        var haveOrigin = isNotAroundZero(origin[0]) || isNotAroundZero(origin[1]);
                        if (haveOrigin) {
                            matrix.translate(m, m, origin);
                        }
                        matrix.rotate(m, m, this.rotation[0]);
                        if (haveOrigin) {
                            origin[0] = -origin[0];
                            origin[1] = -origin[1];
                            matrix.translate(m, m, origin);
                        }
                    }
                } else {
                    if (this.rotation !== 0) {
                        matrix.rotate(m, m, this.rotation);
                    }
                }
                if (isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1])) {
                    matrix.translate(m, m, this.position);
                }
            }
            this.transform = m;
            if (this.parent &amp;&amp; this.parent.needTransform) {
                if (this.needLocalTransform) {
                    matrix.mul(this.transform, this.parent.transform, this.transform);
                } else {
                    matrix.copy(this.transform, this.parent.transform);
                }
            }
        },
        setTransform: function (ctx) {
            if (this.needTransform) {
                var m = this.transform;
                ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
            }
        },
        lookAt: function () {
            var v = vector.create();
            return function (target) {
                if (!this.transform) {
                    this.transform = matrix.create();
                }
                var m = this.transform;
                vector.sub(v, target, this.position);
                if (isAroundZero(v[0]) &amp;&amp; isAroundZero(v[1])) {
                    return;
                }
                vector.normalize(v, v);
                m[2] = v[0] * this.scale[1];
                m[3] = v[1] * this.scale[1];
                m[0] = v[1] * this.scale[0];
                m[1] = -v[0] * this.scale[0];
                m[4] = this.position[0];
                m[5] = this.position[1];
                this.decomposeTransform();
            };
        }(),
        decomposeTransform: function () {
            if (!this.transform) {
                return;
            }
            var m = this.transform;
            var sx = m[0] * m[0] + m[1] * m[1];
            var position = this.position;
            var scale = this.scale;
            var rotation = this.rotation;
            if (isNotAroundZero(sx - 1)) {
                sx = Math.sqrt(sx);
            }
            var sy = m[2] * m[2] + m[3] * m[3];
            if (isNotAroundZero(sy - 1)) {
                sy = Math.sqrt(sy);
            }
            position[0] = m[4];
            position[1] = m[5];
            scale[0] = sx;
            scale[1] = sy;
            scale[2] = scale[3] = 0;
            rotation[0] = Math.atan2(-m[1] / sy, m[0] / sx);
            rotation[1] = rotation[2] = 0;
        }
    };
    return Transformable;
});define(&#x27;zrender/shape/Text&#x27;, [
    &#x27;require&#x27;,
    &#x27;../tool/area&#x27;,
    &#x27;./Base&#x27;,
    &#x27;../tool/util&#x27;
], function (require) {
    var area = require(&#x27;../tool/area&#x27;);
    var Base = require(&#x27;./Base&#x27;);
    var Text = function (options) {
        Base.call(this, options);
    };
    Text.prototype = {
        type: &#x27;text&#x27;,
        brush: function (ctx, isHighlight) {
            var style = this.style;
            if (isHighlight) {
                style = this.getHighlightStyle(style, this.highlightStyle || {});
            }
            if (typeof style.text == &#x27;undefined&#x27; || style.text === false) {
                return;
            }
            ctx.save();
            this.doClip(ctx);
            this.setContext(ctx, style);
            this.setTransform(ctx);
            if (style.textFont) {
                ctx.font = style.textFont;
            }
            ctx.textAlign = style.textAlign || &#x27;start&#x27;;
            ctx.textBaseline = style.textBaseline || &#x27;middle&#x27;;
            var text = (style.text + &#x27;&#x27;).split(&#x27;\n&#x27;);
            var lineHeight = area.getTextHeight(&#x27;国&#x27;, style.textFont);
            var rect = this.getRect(style);
            var x = style.x;
            var y;
            if (style.textBaseline == &#x27;top&#x27;) {
                y = rect.y;
            } else if (style.textBaseline == &#x27;bottom&#x27;) {
                y = rect.y + lineHeight;
            } else {
                y = rect.y + lineHeight / 2;
            }
            for (var i = 0, l = text.length; i &lt; l; i++) {
                if (style.maxWidth) {
                    switch (style.brushType) {
                    case &#x27;fill&#x27;:
                        ctx.fillText(text[i], x, y, style.maxWidth);
                        break;
                    case &#x27;stroke&#x27;:
                        ctx.strokeText(text[i], x, y, style.maxWidth);
                        break;
                    case &#x27;both&#x27;:
                        ctx.fillText(text[i], x, y, style.maxWidth);
                        ctx.strokeText(text[i], x, y, style.maxWidth);
                        break;
                    default:
                        ctx.fillText(text[i], x, y, style.maxWidth);
                    }
                } else {
                    switch (style.brushType) {
                    case &#x27;fill&#x27;:
                        ctx.fillText(text[i], x, y);
                        break;
                    case &#x27;stroke&#x27;:
                        ctx.strokeText(text[i], x, y);
                        break;
                    case &#x27;both&#x27;:
                        ctx.fillText(text[i], x, y);
                        ctx.strokeText(text[i], x, y);
                        break;
                    default:
                        ctx.fillText(text[i], x, y);
                    }
                }
                y += lineHeight;
            }
            ctx.restore();
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var width = area.getTextWidth(style.text, style.textFont);
            var height = area.getTextHeight(style.text, style.textFont);
            var textX = style.x;
            if (style.textAlign == &#x27;end&#x27; || style.textAlign == &#x27;right&#x27;) {
                textX -= width;
            } else if (style.textAlign == &#x27;center&#x27;) {
                textX -= width / 2;
            }
            var textY;
            if (style.textBaseline == &#x27;top&#x27;) {
                textY = style.y;
            } else if (style.textBaseline == &#x27;bottom&#x27;) {
                textY = style.y - height;
            } else {
                textY = style.y - height / 2;
            }
            style.__rect = {
                x: textX,
                y: textY,
                width: width,
                height: height
            };
            return style.__rect;
        }
    };
    require(&#x27;../tool/util&#x27;).inherits(Text, Base);
    return Text;
});define(&#x27;zrender/shape/Rectangle&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Base&#x27;,
    &#x27;../tool/util&#x27;
], function (require) {
    var Base = require(&#x27;./Base&#x27;);
    var Rectangle = function (options) {
        Base.call(this, options);
    };
    Rectangle.prototype = {
        type: &#x27;rectangle&#x27;,
        _buildRadiusPath: function (ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            var r = style.radius;
            var r1;
            var r2;
            var r3;
            var r4;
            if (typeof r === &#x27;number&#x27;) {
                r1 = r2 = r3 = r4 = r;
            } else if (r instanceof Array) {
                if (r.length === 1) {
                    r1 = r2 = r3 = r4 = r[0];
                } else if (r.length === 2) {
                    r1 = r3 = r[0];
                    r2 = r4 = r[1];
                } else if (r.length === 3) {
                    r1 = r[0];
                    r2 = r4 = r[1];
                    r3 = r[2];
                } else {
                    r1 = r[0];
                    r2 = r[1];
                    r3 = r[2];
                    r4 = r[3];
                }
            } else {
                r1 = r2 = r3 = r4 = 0;
            }
            var total;
            if (r1 + r2 &gt; width) {
                total = r1 + r2;
                r1 *= width / total;
                r2 *= width / total;
            }
            if (r3 + r4 &gt; width) {
                total = r3 + r4;
                r3 *= width / total;
                r4 *= width / total;
            }
            if (r2 + r3 &gt; height) {
                total = r2 + r3;
                r2 *= height / total;
                r3 *= height / total;
            }
            if (r1 + r4 &gt; height) {
                total = r1 + r4;
                r1 *= height / total;
                r4 *= height / total;
            }
            ctx.moveTo(x + r1, y);
            ctx.lineTo(x + width - r2, y);
            r2 !== 0 &amp;&amp; ctx.quadraticCurveTo(x + width, y, x + width, y + r2);
            ctx.lineTo(x + width, y + height - r3);
            r3 !== 0 &amp;&amp; ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);
            ctx.lineTo(x + r4, y + height);
            r4 !== 0 &amp;&amp; ctx.quadraticCurveTo(x, y + height, x, y + height - r4);
            ctx.lineTo(x, y + r1);
            r1 !== 0 &amp;&amp; ctx.quadraticCurveTo(x, y, x + r1, y);
        },
        buildPath: function (ctx, style) {
            if (!style.radius) {
                ctx.moveTo(style.x, style.y);
                ctx.lineTo(style.x + style.width, style.y);
                ctx.lineTo(style.x + style.width, style.y + style.height);
                ctx.lineTo(style.x, style.y + style.height);
                ctx.lineTo(style.x, style.y);
            } else {
                this._buildRadiusPath(ctx, style);
            }
            ctx.closePath();
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var lineWidth;
            if (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;fill&#x27;) {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(style.x - lineWidth / 2),
                y: Math.round(style.y - lineWidth / 2),
                width: style.width + lineWidth,
                height: style.height + lineWidth
            };
            return style.__rect;
        }
    };
    require(&#x27;../tool/util&#x27;).inherits(Rectangle, Base);
    return Rectangle;
});define(&#x27;zrender/tool/area&#x27;, [
    &#x27;require&#x27;,
    &#x27;./util&#x27;,
    &#x27;./curve&#x27;
], function (require) {
    &#x27;use strict&#x27;;
    var util = require(&#x27;./util&#x27;);
    var curve = require(&#x27;./curve&#x27;);
    var _ctx;
    var _textWidthCache = {};
    var _textHeightCache = {};
    var _textWidthCacheCounter = 0;
    var _textHeightCacheCounter = 0;
    var TEXT_CACHE_MAX = 5000;
    var PI2 = Math.PI * 2;
    function normalizeRadian(angle) {
        angle %= PI2;
        if (angle &lt; 0) {
            angle += PI2;
        }
        return angle;
    }
    function isInside(shape, area, x, y) {
        if (!area || !shape) {
            return false;
        }
        var zoneType = shape.type;
        _ctx = _ctx || util.getContext();
        var _mathReturn = _mathMethod(shape, area, x, y);
        if (typeof _mathReturn != &#x27;undefined&#x27;) {
            return _mathReturn;
        }
        if (shape.buildPath &amp;&amp; _ctx.isPointInPath) {
            return _buildPathMethod(shape, _ctx, area, x, y);
        }
        switch (zoneType) {
        case &#x27;ellipse&#x27;:
            return true;
        case &#x27;trochoid&#x27;:
            var _r = area.location == &#x27;out&#x27; ? area.r1 + area.r2 + area.d : area.r1 - area.r2 + area.d;
            return isInsideCircle(area, x, y, _r);
        case &#x27;rose&#x27;:
            return isInsideCircle(area, x, y, area.maxr);
        default:
            return false;
        }
    }
    function _mathMethod(shape, area, x, y) {
        var zoneType = shape.type;
        switch (zoneType) {
        case &#x27;bezier-curve&#x27;:
            if (typeof area.cpX2 === &#x27;undefined&#x27;) {
                return isInsideQuadraticStroke(area.xStart, area.yStart, area.cpX1, area.cpY1, area.xEnd, area.yEnd, area.lineWidth, x, y);
            }
            return isInsideCubicStroke(area.xStart, area.yStart, area.cpX1, area.cpY1, area.cpX2, area.cpY2, area.xEnd, area.yEnd, area.lineWidth, x, y);
        case &#x27;line&#x27;:
            return isInsideLine(area.xStart, area.yStart, area.xEnd, area.yEnd, area.lineWidth, x, y);
        case &#x27;broken-line&#x27;:
            return isInsideBrokenLine(area.pointList, area.lineWidth, x, y);
        case &#x27;ring&#x27;:
            return isInsideRing(area.x, area.y, area.r0, area.r, x, y);
        case &#x27;circle&#x27;:
            return isInsideCircle(area.x, area.y, area.r, x, y);
        case &#x27;sector&#x27;:
            var startAngle = area.startAngle * Math.PI / 180;
            var endAngle = area.endAngle * Math.PI / 180;
            if (!area.clockWise) {
                startAngle = -startAngle;
                endAngle = -endAngle;
            }
            return isInsideSector(area.x, area.y, area.r0, area.r, startAngle, endAngle, !area.clockWise, x, y);
        case &#x27;path&#x27;:
            return isInsidePath(area.pathArray, Math.max(area.lineWidth, 5), area.brushType, x, y);
        case &#x27;polygon&#x27;:
        case &#x27;star&#x27;:
        case &#x27;isogon&#x27;:
            return isInsidePolygon(area.pointList, x, y);
        case &#x27;text&#x27;:
            var rect = area.__rect || shape.getRect(area);
            return isInsideRect(rect.x, rect.y, rect.width, rect.height, x, y);
        case &#x27;rectangle&#x27;:
        case &#x27;image&#x27;:
            return isInsideRect(area.x, area.y, area.width, area.height, x, y);
        }
    }
    function _buildPathMethod(shape, context, area, x, y) {
        context.beginPath();
        shape.buildPath(context, area);
        context.closePath();
        return context.isPointInPath(x, y);
    }
    function isOutside(shape, area, x, y) {
        return !isInside(shape, area, x, y);
    }
    function isInsideLine(x0, y0, x1, y1, lineWidth, x, y) {
        if (lineWidth === 0) {
            return false;
        }
        var _l = Math.max(lineWidth, 5);
        var _a = 0;
        var _b = x0;
        if (y &gt; y0 + _l &amp;&amp; y &gt; y1 + _l || y &lt; y0 - _l &amp;&amp; y &lt; y1 - _l || x &gt; x0 + _l &amp;&amp; x &gt; x1 + _l || x &lt; x0 - _l &amp;&amp; x &lt; x1 - _l) {
            return false;
        }
        if (x0 !== x1) {
            _a = (y0 - y1) / (x0 - x1);
            _b = (x0 * y1 - x1 * y0) / (x0 - x1);
        } else {
            return Math.abs(x - x0) &lt;= _l / 2;
        }
        var tmp = _a * x - y + _b;
        var _s = tmp * tmp / (_a * _a + 1);
        return _s &lt;= _l / 2 * _l / 2;
    }
    function isInsideCubicStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
        if (lineWidth === 0) {
            return false;
        }
        var _l = Math.max(lineWidth, 5);
        if (y &gt; y0 + _l &amp;&amp; y &gt; y1 + _l &amp;&amp; y &gt; y2 + _l &amp;&amp; y &gt; y3 + _l || y &lt; y0 - _l &amp;&amp; y &lt; y1 - _l &amp;&amp; y &lt; y2 - _l &amp;&amp; y &lt; y3 - _l || x &gt; x0 + _l &amp;&amp; x &gt; x1 + _l &amp;&amp; x &gt; x2 + _l &amp;&amp; x &gt; x3 + _l || x &lt; x0 - _l &amp;&amp; x &lt; x1 - _l &amp;&amp; x &lt; x2 - _l &amp;&amp; x &lt; x3 - _l) {
            return false;
        }
        var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
        return d &lt;= _l / 2;
    }
    function isInsideQuadraticStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
        if (lineWidth === 0) {
            return false;
        }
        var _l = Math.max(lineWidth, 5);
        if (y &gt; y0 + _l &amp;&amp; y &gt; y1 + _l &amp;&amp; y &gt; y2 + _l || y &lt; y0 - _l &amp;&amp; y &lt; y1 - _l &amp;&amp; y &lt; y2 - _l || x &gt; x0 + _l &amp;&amp; x &gt; x1 + _l &amp;&amp; x &gt; x2 + _l || x &lt; x0 - _l &amp;&amp; x &lt; x1 - _l &amp;&amp; x &lt; x2 - _l) {
            return false;
        }
        var d = curve.quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
        return d &lt;= _l / 2;
    }
    function isInsideArcStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
        if (lineWidth === 0) {
            return false;
        }
        var _l = Math.max(lineWidth, 5);
        x -= cx;
        y -= cy;
        var d = Math.sqrt(x * x + y * y);
        if (d - _l &gt; r || d + _l &lt; r) {
            return false;
        }
        if (Math.abs(startAngle - endAngle) &gt;= PI2) {
            return true;
        }
        if (anticlockwise) {
            var tmp = startAngle;
            startAngle = normalizeRadian(endAngle);
            endAngle = normalizeRadian(tmp);
        } else {
            startAngle = normalizeRadian(startAngle);
            endAngle = normalizeRadian(endAngle);
        }
        if (startAngle &gt; endAngle) {
            endAngle += PI2;
        }
        var angle = Math.atan2(y, x);
        if (angle &lt; 0) {
            angle += PI2;
        }
        return angle &gt;= startAngle &amp;&amp; angle &lt;= endAngle || angle + PI2 &gt;= startAngle &amp;&amp; angle + PI2 &lt;= endAngle;
    }
    function isInsideBrokenLine(points, lineWidth, x, y) {
        var lineWidth = Math.max(lineWidth, 10);
        for (var i = 0, l = points.length - 1; i &lt; l; i++) {
            var x0 = points[i][0];
            var y0 = points[i][1];
            var x1 = points[i + 1][0];
            var y1 = points[i + 1][1];
            if (isInsideLine(x0, y0, x1, y1, lineWidth, x, y)) {
                return true;
            }
        }
        return false;
    }
    function isInsideRing(cx, cy, r0, r, x, y) {
        var d = (x - cx) * (x - cx) + (y - cy) * (y - cy);
        return d &lt; r * r &amp;&amp; d &gt; r0 * r0;
    }
    function isInsideRect(x0, y0, width, height, x, y) {
        return x &gt;= x0 &amp;&amp; x &lt;= x0 + width &amp;&amp; y &gt;= y0 &amp;&amp; y &lt;= y0 + height;
    }
    function isInsideCircle(x0, y0, r, x, y) {
        return (x - x0) * (x - x0) + (y - y0) * (y - y0) &lt; r * r;
    }
    function isInsideSector(cx, cy, r0, r, startAngle, endAngle, anticlockwise, x, y) {
        return isInsideArcStroke(cx, cy, (r0 + r) / 2, startAngle, endAngle, anticlockwise, r - r0, x, y);
    }
    function isInsidePolygon(points, x, y) {
        var N = points.length;
        var w = 0;
        for (var i = 0, j = N - 1; i &lt; N; i++) {
            var x0 = points[j][0];
            var y0 = points[j][1];
            var x1 = points[i][0];
            var y1 = points[i][1];
            w += windingLine(x0, y0, x1, y1, x, y);
            j = i;
        }
        return w !== 0;
    }
    function windingLine(x0, y0, x1, y1, x, y) {
        if (y &gt; y0 &amp;&amp; y &gt; y1 || y &lt; y0 &amp;&amp; y &lt; y1) {
            return 0;
        }
        if (y1 == y0) {
            return 0;
        }
        var dir = y1 &lt; y0 ? 1 : -1;
        var t = (y - y0) / (y1 - y0);
        var x_ = t * (x1 - x0) + x0;
        return x_ &gt; x ? dir : 0;
    }
    var roots = [
        -1,
        -1,
        -1
    ];
    var extrema = [
        -1,
        -1
    ];
    function swapExtrema() {
        var tmp = extrema[0];
        extrema[0] = extrema[1];
        extrema[1] = tmp;
    }
    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
        if (y &gt; y0 &amp;&amp; y &gt; y1 &amp;&amp; y &gt; y2 &amp;&amp; y &gt; y3 || y &lt; y0 &amp;&amp; y &lt; y1 &amp;&amp; y &lt; y2 &amp;&amp; y &lt; y3) {
            return 0;
        }
        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
        if (nRoots === 0) {
            return 0;
        } else {
            var w = 0;
            var nExtrema = -1;
            var y0_, y1_;
            for (var i = 0; i &lt; nRoots; i++) {
                var t = roots[i];
                var x_ = curve.cubicAt(x0, x1, x2, x3, t);
                if (x_ &lt; x) {
                    continue;
                }
                if (nExtrema &lt; 0) {
                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
                    if (extrema[1] &lt; extrema[0] &amp;&amp; nExtrema &gt; 1) {
                        swapExtrema();
                    }
                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
                    if (nExtrema &gt; 1) {
                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
                    }
                }
                if (nExtrema == 2) {
                    if (t &lt; extrema[0]) {
                        w += y0_ &lt; y0 ? 1 : -1;
                    } else if (t &lt; extrema[1]) {
                        w += y1_ &lt; y0_ ? 1 : -1;
                    } else {
                        w += y3 &lt; y1_ ? 1 : -1;
                    }
                } else {
                    if (t &lt; extrema[0]) {
                        w += y0_ &lt; y0 ? 1 : -1;
                    } else {
                        w += y3 &lt; y0_ ? 1 : -1;
                    }
                }
            }
            return w;
        }
    }
    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
        if (y &gt; y0 &amp;&amp; y &gt; y1 &amp;&amp; y &gt; y2 || y &lt; y0 &amp;&amp; y &lt; y1 &amp;&amp; y &lt; y2) {
            return 0;
        }
        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
        if (nRoots === 0) {
            return 0;
        } else {
            var t = curve.quadraticExtremum(y0, y1, y2);
            if (t &gt;= 0 &amp;&amp; t &lt;= 1) {
                var w = 0;
                var y_ = curve.quadraticAt(y0, y1, y2, t);
                for (var i = 0; i &lt; nRoots; i++) {
                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
                    if (x_ &gt; x) {
                        continue;
                    }
                    if (roots[i] &lt; t) {
                        w += y_ &lt; y0 ? 1 : -1;
                    } else {
                        w += y2 &lt; y_ ? 1 : -1;
                    }
                }
                return w;
            } else {
                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
                if (x_ &gt; x) {
                    return 0;
                }
                return y2 &lt; y0 ? 1 : -1;
            }
        }
    }
    function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
        y -= cy;
        if (y &gt; r || y &lt; -r) {
            return 0;
        }
        var tmp = Math.sqrt(r * r - y * y);
        roots[0] = -tmp;
        roots[1] = tmp;
        if (Math.abs(startAngle - endAngle) &gt;= PI2) {
            startAngle = 0;
            endAngle = PI2;
            var dir = anticlockwise ? 1 : -1;
            if (x &gt;= roots[0] + cx &amp;&amp; x &lt;= roots[1] + cx) {
                return dir;
            } else {
                return 0;
            }
        }
        if (anticlockwise) {
            var tmp = startAngle;
            startAngle = normalizeRadian(endAngle);
            endAngle = normalizeRadian(tmp);
        } else {
            startAngle = normalizeRadian(startAngle);
            endAngle = normalizeRadian(endAngle);
        }
        if (startAngle &gt; endAngle) {
            endAngle += PI2;
        }
        var w = 0;
        for (var i = 0; i &lt; 2; i++) {
            var x_ = roots[i];
            if (x_ + cx &gt; x) {
                var angle = Math.atan2(y, x_);
                var dir = anticlockwise ? 1 : -1;
                if (angle &lt; 0) {
                    angle = PI2 + angle;
                }
                if (angle &gt;= startAngle &amp;&amp; angle &lt;= endAngle || angle + PI2 &gt;= startAngle &amp;&amp; angle + PI2 &lt;= endAngle) {
                    if (angle &gt; Math.PI / 2 &amp;&amp; angle &lt; Math.PI * 1.5) {
                        dir = -dir;
                    }
                    w += dir;
                }
            }
        }
        return w;
    }
    function isInsidePath(pathArray, lineWidth, brushType, x, y) {
        var w = 0;
        var xi = 0;
        var yi = 0;
        var x0 = 0;
        var y0 = 0;
        var beginSubpath = true;
        var firstCmd = true;
        brushType = brushType || &#x27;fill&#x27;;
        var hasStroke = brushType === &#x27;stroke&#x27; || brushType === &#x27;both&#x27;;
        var hasFill = brushType === &#x27;fill&#x27; || brushType === &#x27;both&#x27;;
        for (var i = 0; i &lt; pathArray.length; i++) {
            var seg = pathArray[i];
            var p = seg.points;
            if (beginSubpath || seg.command === &#x27;M&#x27;) {
                if (i &gt; 0) {
                    if (hasFill) {
                        w += windingLine(xi, yi, x0, y0, x, y);
                    }
                    if (w !== 0) {
                        return true;
                    }
                }
                x0 = p[p.length - 2];
                y0 = p[p.length - 1];
                beginSubpath = false;
                if (firstCmd &amp;&amp; seg.command !== &#x27;A&#x27;) {
                    firstCmd = false;
                    xi = x0;
                    yi = y0;
                }
            }
            switch (seg.command) {
            case &#x27;M&#x27;:
                xi = p[0];
                yi = p[1];
                break;
            case &#x27;L&#x27;:
                if (hasStroke) {
                    if (isInsideLine(xi, yi, p[0], p[1], lineWidth, x, y)) {
                        return true;
                    }
                }
                if (hasFill) {
                    w += windingLine(xi, yi, p[0], p[1], x, y);
                }
                xi = p[0];
                yi = p[1];
                break;
            case &#x27;C&#x27;:
                if (hasStroke) {
                    if (isInsideCubicStroke(xi, yi, p[0], p[1], p[2], p[3], p[4], p[5], lineWidth, x, y)) {
                        return true;
                    }
                }
                if (hasFill) {
                    w += windingCubic(xi, yi, p[0], p[1], p[2], p[3], p[4], p[5], x, y);
                }
                xi = p[4];
                yi = p[5];
                break;
            case &#x27;Q&#x27;:
                if (hasStroke) {
                    if (isInsideQuadraticStroke(xi, yi, p[0], p[1], p[2], p[3], lineWidth, x, y)) {
                        return true;
                    }
                }
                if (hasFill) {
                    w += windingQuadratic(xi, yi, p[0], p[1], p[2], p[3], x, y);
                }
                xi = p[2];
                yi = p[3];
                break;
            case &#x27;A&#x27;:
                var cx = p[0];
                var cy = p[1];
                var rx = p[2];
                var ry = p[3];
                var theta = p[4];
                var dTheta = p[5];
                var x1 = Math.cos(theta) * rx + cx;
                var y1 = Math.sin(theta) * ry + cy;
                if (!firstCmd) {
                    w += windingLine(xi, yi, x1, y1);
                } else {
                    firstCmd = false;
                    x0 = x1;
                    y0 = y1;
                }
                var _x = (x - cx) * ry / rx + cx;
                if (hasStroke) {
                    if (isInsideArcStroke(cx, cy, ry, theta, theta + dTheta, 1 - p[7], lineWidth, _x, y)) {
                        return true;
                    }
                }
                if (hasFill) {
                    w += windingArc(cx, cy, ry, theta, theta + dTheta, 1 - p[7], _x, y);
                }
                xi = Math.cos(theta + dTheta) * rx + cx;
                yi = Math.sin(theta + dTheta) * ry + cy;
                break;
            case &#x27;z&#x27;:
                if (hasStroke) {
                    if (isInsideLine(xi, yi, x0, y0, lineWidth, x, y)) {
                        return true;
                    }
                }
                beginSubpath = true;
                break;
            }
        }
        if (hasFill) {
            w += windingLine(xi, yi, x0, y0, x, y);
        }
        return w !== 0;
    }
    function getTextWidth(text, textFont) {
        var key = text + &#x27;:&#x27; + textFont;
        if (_textWidthCache[key]) {
            return _textWidthCache[key];
        }
        _ctx = _ctx || util.getContext();
        _ctx.save();
        if (textFont) {
            _ctx.font = textFont;
        }
        text = (text + &#x27;&#x27;).split(&#x27;\n&#x27;);
        var width = 0;
        for (var i = 0, l = text.length; i &lt; l; i++) {
            width = Math.max(_ctx.measureText(text[i]).width, width);
        }
        _ctx.restore();
        _textWidthCache[key] = width;
        if (++_textWidthCacheCounter &gt; TEXT_CACHE_MAX) {
            _textWidthCacheCounter = 0;
            _textWidthCache = {};
        }
        return width;
    }
    function getTextHeight(text, textFont) {
        var key = text + &#x27;:&#x27; + textFont;
        if (_textHeightCache[key]) {
            return _textHeightCache[key];
        }
        _ctx = _ctx || util.getContext();
        _ctx.save();
        if (textFont) {
            _ctx.font = textFont;
        }
        text = (text + &#x27;&#x27;).split(&#x27;\n&#x27;);
        var height = (_ctx.measureText(&#x27;国&#x27;).width + 2) * text.length;
        _ctx.restore();
        _textHeightCache[key] = height;
        if (++_textHeightCacheCounter &gt; TEXT_CACHE_MAX) {
            _textHeightCacheCounter = 0;
            _textHeightCache = {};
        }
        return height;
    }
    return {
        isInside: isInside,
        isOutside: isOutside,
        getTextWidth: getTextWidth,
        getTextHeight: getTextHeight,
        isInsidePath: isInsidePath,
        isInsidePolygon: isInsidePolygon,
        isInsideSector: isInsideSector,
        isInsideCircle: isInsideCircle,
        isInsideLine: isInsideLine,
        isInsideRect: isInsideRect,
        isInsideBrokenLine: isInsideBrokenLine,
        isInsideCubicStroke: isInsideCubicStroke,
        isInsideQuadraticStroke: isInsideQuadraticStroke
    };
});define(&#x27;zrender/shape/Base&#x27;, [
    &#x27;require&#x27;,
    &#x27;../tool/matrix&#x27;,
    &#x27;../tool/guid&#x27;,
    &#x27;../tool/util&#x27;,
    &#x27;../tool/log&#x27;,
    &#x27;../mixin/Transformable&#x27;,
    &#x27;../mixin/Eventful&#x27;,
    &#x27;../tool/area&#x27;,
    &#x27;../tool/color&#x27;
], function (require) {
    var vmlCanvasManager = window[&#x27;G_vmlCanvasManager&#x27;];
    var matrix = require(&#x27;../tool/matrix&#x27;);
    var guid = require(&#x27;../tool/guid&#x27;);
    var util = require(&#x27;../tool/util&#x27;);
    var log = require(&#x27;../tool/log&#x27;);
    var Transformable = require(&#x27;../mixin/Transformable&#x27;);
    var Eventful = require(&#x27;../mixin/Eventful&#x27;);
    function _fillText(ctx, text, x, y, textFont, textAlign, textBaseline) {
        if (textFont) {
            ctx.font = textFont;
        }
        ctx.textAlign = textAlign;
        ctx.textBaseline = textBaseline;
        var rect = _getTextRect(text, x, y, textFont, textAlign, textBaseline);
        text = (text + &#x27;&#x27;).split(&#x27;\n&#x27;);
        var lineHeight = require(&#x27;../tool/area&#x27;).getTextHeight(&#x27;国&#x27;, textFont);
        switch (textBaseline) {
        case &#x27;top&#x27;:
            y = rect.y;
            break;
        case &#x27;bottom&#x27;:
            y = rect.y + lineHeight;
            break;
        default:
            y = rect.y + lineHeight / 2;
        }
        for (var i = 0, l = text.length; i &lt; l; i++) {
            ctx.fillText(text[i], x, y);
            y += lineHeight;
        }
    }
    function _getTextRect(text, x, y, textFont, textAlign, textBaseline) {
        var area = require(&#x27;../tool/area&#x27;);
        var width = area.getTextWidth(text, textFont);
        var lineHeight = area.getTextHeight(&#x27;国&#x27;, textFont);
        text = (text + &#x27;&#x27;).split(&#x27;\n&#x27;);
        switch (textAlign) {
        case &#x27;end&#x27;:
        case &#x27;right&#x27;:
            x -= width;
            break;
        case &#x27;center&#x27;:
            x -= width / 2;
            break;
        }
        switch (textBaseline) {
        case &#x27;top&#x27;:
            break;
        case &#x27;bottom&#x27;:
            y -= lineHeight * text.length;
            break;
        default:
            y -= lineHeight * text.length / 2;
        }
        return {
            x: x,
            y: y,
            width: width,
            height: lineHeight * text.length
        };
    }
    var Base = function (options) {
        options = options || {};
        this.id = options.id || guid();
        for (var key in options) {
            this[key] = options[key];
        }
        this.style = this.style || {};
        this.highlightStyle = this.highlightStyle || null;
        this.parent = null;
        this.__dirty = true;
        this.__clipShapes = [];
        Transformable.call(this);
        Eventful.call(this);
    };
    Base.prototype.invisible = false;
    Base.prototype.ignore = false;
    Base.prototype.zlevel = 0;
    Base.prototype.draggable = false;
    Base.prototype.clickable = false;
    Base.prototype.hoverable = true;
    Base.prototype.z = 0;
    Base.prototype.brush = function (ctx, isHighlight) {
        var style = this.beforeBrush(ctx, isHighlight);
        ctx.beginPath();
        this.buildPath(ctx, style);
        switch (style.brushType) {
        case &#x27;both&#x27;:
            ctx.fill();
        case &#x27;stroke&#x27;:
            style.lineWidth &gt; 0 &amp;&amp; ctx.stroke();
            break;
        default:
            ctx.fill();
        }
        this.drawText(ctx, style, this.style);
        this.afterBrush(ctx);
    };
    Base.prototype.beforeBrush = function (ctx, isHighlight) {
        var style = this.style;
        if (this.brushTypeOnly) {
            style.brushType = this.brushTypeOnly;
        }
        if (isHighlight) {
            style = this.getHighlightStyle(style, this.highlightStyle || {}, this.brushTypeOnly);
        }
        if (this.brushTypeOnly == &#x27;stroke&#x27;) {
            style.strokeColor = style.strokeColor || style.color;
        }
        ctx.save();
        this.doClip(ctx);
        this.setContext(ctx, style);
        this.setTransform(ctx);
        return style;
    };
    Base.prototype.afterBrush = function (ctx) {
        ctx.restore();
    };
    var STYLE_CTX_MAP = [
        [
            &#x27;color&#x27;,
            &#x27;fillStyle&#x27;
        ],
        [
            &#x27;strokeColor&#x27;,
            &#x27;strokeStyle&#x27;
        ],
        [
            &#x27;opacity&#x27;,
            &#x27;globalAlpha&#x27;
        ],
        [
            &#x27;lineCap&#x27;,
            &#x27;lineCap&#x27;
        ],
        [
            &#x27;lineJoin&#x27;,
            &#x27;lineJoin&#x27;
        ],
        [
            &#x27;miterLimit&#x27;,
            &#x27;miterLimit&#x27;
        ],
        [
            &#x27;lineWidth&#x27;,
            &#x27;lineWidth&#x27;
        ],
        [
            &#x27;shadowBlur&#x27;,
            &#x27;shadowBlur&#x27;
        ],
        [
            &#x27;shadowColor&#x27;,
            &#x27;shadowColor&#x27;
        ],
        [
            &#x27;shadowOffsetX&#x27;,
            &#x27;shadowOffsetX&#x27;
        ],
        [
            &#x27;shadowOffsetY&#x27;,
            &#x27;shadowOffsetY&#x27;
        ]
    ];
    Base.prototype.setContext = function (ctx, style) {
        for (var i = 0, len = STYLE_CTX_MAP.length; i &lt; len; i++) {
            var styleProp = STYLE_CTX_MAP[i][0];
            var styleValue = style[styleProp];
            var ctxProp = STYLE_CTX_MAP[i][1];
            if (typeof styleValue != &#x27;undefined&#x27;) {
                ctx[ctxProp] = styleValue;
            }
        }
    };
    var clipShapeInvTransform = matrix.create();
    Base.prototype.doClip = function (ctx) {
        if (this.__clipShapes &amp;&amp; !vmlCanvasManager) {
            for (var i = 0; i &lt; this.__clipShapes.length; i++) {
                var clipShape = this.__clipShapes[i];
                if (clipShape.needTransform) {
                    var m = clipShape.transform;
                    matrix.invert(clipShapeInvTransform, m);
                    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                }
                ctx.beginPath();
                clipShape.buildPath(ctx, clipShape.style);
                ctx.clip();
                if (clipShape.needTransform) {
                    var m = clipShapeInvTransform;
                    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                }
            }
        }
    };
    Base.prototype.getHighlightStyle = function (style, highlightStyle, brushTypeOnly) {
        var newStyle = {};
        for (var k in style) {
            newStyle[k] = style[k];
        }
        var color = require(&#x27;../tool/color&#x27;);
        var highlightColor = color.getHighlightColor();
        if (style.brushType != &#x27;stroke&#x27;) {
            newStyle.strokeColor = highlightColor;
            newStyle.lineWidth = (style.lineWidth || 1) + this.getHighlightZoom();
            newStyle.brushType = &#x27;both&#x27;;
        } else {
            if (brushTypeOnly != &#x27;stroke&#x27;) {
                newStyle.strokeColor = highlightColor;
                newStyle.lineWidth = (style.lineWidth || 1) + this.getHighlightZoom();
            } else {
                newStyle.strokeColor = highlightStyle.strokeColor || color.mix(style.strokeColor, color.toRGB(highlightColor));
            }
        }
        for (var k in highlightStyle) {
            if (typeof highlightStyle[k] != &#x27;undefined&#x27;) {
                newStyle[k] = highlightStyle[k];
            }
        }
        return newStyle;
    };
    Base.prototype.getHighlightZoom = function () {
        return this.type != &#x27;text&#x27; ? 6 : 2;
    };
    Base.prototype.drift = function (dx, dy) {
        this.position[0] += dx;
        this.position[1] += dy;
    };
    Base.prototype.getTansform = function () {
        var invTransform = [];
        return function (x, y) {
            var originPos = [
                x,
                y
            ];
            if (this.needTransform &amp;&amp; this.transform) {
                matrix.invert(invTransform, this.transform);
                matrix.mulVector(originPos, invTransform, [
                    x,
                    y,
                    1
                ]);
                if (x == originPos[0] &amp;&amp; y == originPos[1]) {
                    this.updateNeedTransform();
                }
            }
            return originPos;
        };
    }();
    Base.prototype.buildPath = function (ctx, style) {
        log(&#x27;buildPath not implemented in &#x27; + this.type);
    };
    Base.prototype.getRect = function (style) {
        log(&#x27;getRect not implemented in &#x27; + this.type);
    };
    Base.prototype.isCover = function (x, y) {
        var originPos = this.getTansform(x, y);
        x = originPos[0];
        y = originPos[1];
        var rect = this.style.__rect;
        if (!rect) {
            rect = this.style.__rect = this.getRect(this.style);
        }
        if (x &gt;= rect.x &amp;&amp; x &lt;= rect.x + rect.width &amp;&amp; y &gt;= rect.y &amp;&amp; y &lt;= rect.y + rect.height) {
            return require(&#x27;../tool/area&#x27;).isInside(this, this.style, x, y);
        }
        return false;
    };
    Base.prototype.drawText = function (ctx, style, normalStyle) {
        if (typeof style.text == &#x27;undefined&#x27; || style.text === false) {
            return;
        }
        var textColor = style.textColor || style.color || style.strokeColor;
        ctx.fillStyle = textColor;
        var dd = 10;
        var al;
        var bl;
        var tx;
        var ty;
        var textPosition = style.textPosition || this.textPosition || &#x27;top&#x27;;
        switch (textPosition) {
        case &#x27;inside&#x27;:
        case &#x27;top&#x27;:
        case &#x27;bottom&#x27;:
        case &#x27;left&#x27;:
        case &#x27;right&#x27;:
            if (this.getRect) {
                var rect = (normalStyle || style).__rect || this.getRect(normalStyle || style);
                switch (textPosition) {
                case &#x27;inside&#x27;:
                    tx = rect.x + rect.width / 2;
                    ty = rect.y + rect.height / 2;
                    al = &#x27;center&#x27;;
                    bl = &#x27;middle&#x27;;
                    if (style.brushType != &#x27;stroke&#x27; &amp;&amp; textColor == style.color) {
                        ctx.fillStyle = &#x27;#fff&#x27;;
                    }
                    break;
                case &#x27;left&#x27;:
                    tx = rect.x - dd;
                    ty = rect.y + rect.height / 2;
                    al = &#x27;end&#x27;;
                    bl = &#x27;middle&#x27;;
                    break;
                case &#x27;right&#x27;:
                    tx = rect.x + rect.width + dd;
                    ty = rect.y + rect.height / 2;
                    al = &#x27;start&#x27;;
                    bl = &#x27;middle&#x27;;
                    break;
                case &#x27;top&#x27;:
                    tx = rect.x + rect.width / 2;
                    ty = rect.y - dd;
                    al = &#x27;center&#x27;;
                    bl = &#x27;bottom&#x27;;
                    break;
                case &#x27;bottom&#x27;:
                    tx = rect.x + rect.width / 2;
                    ty = rect.y + rect.height + dd;
                    al = &#x27;center&#x27;;
                    bl = &#x27;top&#x27;;
                    break;
                }
            }
            break;
        case &#x27;start&#x27;:
        case &#x27;end&#x27;:
            var xStart;
            var xEnd;
            var yStart;
            var yEnd;
            if (typeof style.pointList != &#x27;undefined&#x27;) {
                var pointList = style.pointList;
                if (pointList.length &lt; 2) {
                    return;
                }
                var length = pointList.length;
                switch (textPosition) {
                case &#x27;start&#x27;:
                    xStart = pointList[0][0];
                    xEnd = pointList[1][0];
                    yStart = pointList[0][1];
                    yEnd = pointList[1][1];
                    break;
                case &#x27;end&#x27;:
                    xStart = pointList[length - 2][0];
                    xEnd = pointList[length - 1][0];
                    yStart = pointList[length - 2][1];
                    yEnd = pointList[length - 1][1];
                    break;
                }
            } else {
                xStart = style.xStart || 0;
                xEnd = style.xEnd || 0;
                yStart = style.yStart || 0;
                yEnd = style.yEnd || 0;
            }
            switch (textPosition) {
            case &#x27;start&#x27;:
                al = xStart &lt; xEnd ? &#x27;end&#x27; : &#x27;start&#x27;;
                bl = yStart &lt; yEnd ? &#x27;bottom&#x27; : &#x27;top&#x27;;
                tx = xStart;
                ty = yStart;
                break;
            case &#x27;end&#x27;:
                al = xStart &lt; xEnd ? &#x27;start&#x27; : &#x27;end&#x27;;
                bl = yStart &lt; yEnd ? &#x27;top&#x27; : &#x27;bottom&#x27;;
                tx = xEnd;
                ty = yEnd;
                break;
            }
            dd -= 4;
            if (xStart != xEnd) {
                tx -= al == &#x27;end&#x27; ? dd : -dd;
            } else {
                al = &#x27;center&#x27;;
            }
            if (yStart != yEnd) {
                ty -= bl == &#x27;bottom&#x27; ? dd : -dd;
            } else {
                bl = &#x27;middle&#x27;;
            }
            break;
        case &#x27;specific&#x27;:
            tx = style.textX || 0;
            ty = style.textY || 0;
            al = &#x27;start&#x27;;
            bl = &#x27;middle&#x27;;
            break;
        }
        if (tx != null &amp;&amp; ty != null) {
            _fillText(ctx, style.text, tx, ty, style.textFont, style.textAlign || al, style.textBaseline || bl);
        }
    };
    Base.prototype.modSelf = function () {
        this.__dirty = true;
        if (this.style) {
            this.style.__rect = null;
        }
        if (this.highlightStyle) {
            this.highlightStyle.__rect = null;
        }
    };
    Base.prototype.isSilent = function () {
        return !(this.hoverable || this.draggable || this.clickable || this.onmousemove || this.onmouseover || this.onmouseout || this.onmousedown || this.onmouseup || this.onclick || this.ondragenter || this.ondragover || this.ondragleave || this.ondrop);
    };
    util.merge(Base.prototype, Transformable.prototype, true);
    util.merge(Base.prototype, Eventful.prototype, true);
    return Base;
});define(&#x27;zrender/tool/curve&#x27;, [
    &#x27;require&#x27;,
    &#x27;./vector&#x27;
], function (require) {
    var vector = require(&#x27;./vector&#x27;);
    &#x27;use strict&#x27;;
    var EPSILON = 0.0001;
    var THREE_SQRT = Math.sqrt(3);
    var ONE_THIRD = 1 / 3;
    var _v0 = vector.create();
    var _v1 = vector.create();
    var _v2 = vector.create();
    function isAroundZero(val) {
        return val &gt; -EPSILON &amp;&amp; val &lt; EPSILON;
    }
    function isNotAroundZero(val) {
        return val &gt; EPSILON || val &lt; -EPSILON;
    }
    function cubicAt(p0, p1, p2, p3, t) {
        var onet = 1 - t;
        return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
    }
    function cubicDerivativeAt(p0, p1, p2, p3, t) {
        var onet = 1 - t;
        return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
    }
    function cubicRootAt(p0, p1, p2, p3, val, roots) {
        var a = p3 + 3 * (p1 - p2) - p0;
        var b = 3 * (p2 - p1 * 2 + p0);
        var c = 3 * (p1 - p0);
        var d = p0 - val;
        var A = b * b - 3 * a * c;
        var B = b * c - 9 * a * d;
        var C = c * c - 3 * b * d;
        var n = 0;
        if (isAroundZero(A) &amp;&amp; isAroundZero(B)) {
            if (isAroundZero(b)) {
                roots[0] = 0;
            } else {
                var t1 = -c / b;
                if (t1 &gt;= 0 &amp;&amp; t1 &lt;= 1) {
                    roots[n++] = t1;
                }
            }
        } else {
            var disc = B * B - 4 * A * C;
            if (isAroundZero(disc)) {
                var K = B / A;
                var t1 = -b / a + K;
                var t2 = -K / 2;
                if (t1 &gt;= 0 &amp;&amp; t1 &lt;= 1) {
                    roots[n++] = t1;
                }
                if (t2 &gt;= 0 &amp;&amp; t2 &lt;= 1) {
                    roots[n++] = t2;
                }
            } else if (disc &gt; 0) {
                var discSqrt = Math.sqrt(disc);
                var Y1 = A * b + 1.5 * a * (-B + discSqrt);
                var Y2 = A * b + 1.5 * a * (-B - discSqrt);
                if (Y1 &lt; 0) {
                    Y1 = -Math.pow(-Y1, ONE_THIRD);
                } else {
                    Y1 = Math.pow(Y1, ONE_THIRD);
                }
                if (Y2 &lt; 0) {
                    Y2 = -Math.pow(-Y2, ONE_THIRD);
                } else {
                    Y2 = Math.pow(Y2, ONE_THIRD);
                }
                var t1 = (-b - (Y1 + Y2)) / (3 * a);
                if (t1 &gt;= 0 &amp;&amp; t1 &lt;= 1) {
                    roots[n++] = t1;
                }
            } else {
                var T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A));
                var theta = Math.acos(T) / 3;
                var ASqrt = Math.sqrt(A);
                var tmp = Math.cos(theta);
                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
                if (t1 &gt;= 0 &amp;&amp; t1 &lt;= 1) {
                    roots[n++] = t1;
                }
                if (t2 &gt;= 0 &amp;&amp; t2 &lt;= 1) {
                    roots[n++] = t2;
                }
                if (t3 &gt;= 0 &amp;&amp; t3 &lt;= 1) {
                    roots[n++] = t3;
                }
            }
        }
        return n;
    }
    function cubicExtrema(p0, p1, p2, p3, extrema) {
        var b = 6 * p2 - 12 * p1 + 6 * p0;
        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
        var c = 3 * p1 - 3 * p0;
        var n = 0;
        if (isAroundZero(a)) {
            if (isNotAroundZero(b)) {
                var t1 = -c / b;
                if (t1 &gt;= 0 &amp;&amp; t1 &lt;= 1) {
                    extrema[n++] = t1;
                }
            }
        } else {
            var disc = b * b - 4 * a * c;
            if (isAroundZero(disc)) {
                extrema[0] = -b / (2 * a);
            } else if (disc &gt; 0) {
                var discSqrt = Math.sqrt(disc);
                var t1 = (-b + discSqrt) / (2 * a);
                var t2 = (-b - discSqrt) / (2 * a);
                if (t1 &gt;= 0 &amp;&amp; t1 &lt;= 1) {
                    extrema[n++] = t1;
                }
                if (t2 &gt;= 0 &amp;&amp; t2 &lt;= 1) {
                    extrema[n++] = t2;
                }
            }
        }
        return n;
    }
    function cubicSubdivide(p0, p1, p2, p3, t, out) {
        var p01 = (p1 - p0) * t + p0;
        var p12 = (p2 - p1) * t + p1;
        var p23 = (p3 - p2) * t + p2;
        var p012 = (p12 - p01) * t + p01;
        var p123 = (p23 - p12) * t + p12;
        var p0123 = (p123 - p012) * t + p012;
        out[0] = p0;
        out[1] = p01;
        out[2] = p012;
        out[3] = p0123;
        out[4] = p0123;
        out[5] = p123;
        out[6] = p23;
        out[7] = p3;
    }
    function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
        var t;
        var interval = 0.005;
        var d = Infinity;
        _v0[0] = x;
        _v0[1] = y;
        for (var _t = 0; _t &lt; 1; _t += 0.05) {
            _v1[0] = cubicAt(x0, x1, x2, x3, _t);
            _v1[1] = cubicAt(y0, y1, y2, y3, _t);
            var d1 = vector.distSquare(_v0, _v1);
            if (d1 &lt; d) {
                t = _t;
                d = d1;
            }
        }
        d = Infinity;
        for (var i = 0; i &lt; 32; i++) {
            if (interval &lt; EPSILON) {
                break;
            }
            var prev = t - interval;
            var next = t + interval;
            _v1[0] = cubicAt(x0, x1, x2, x3, prev);
            _v1[1] = cubicAt(y0, y1, y2, y3, prev);
            var d1 = vector.distSquare(_v1, _v0);
            if (prev &gt;= 0 &amp;&amp; d1 &lt; d) {
                t = prev;
                d = d1;
            } else {
                _v2[0] = cubicAt(x0, x1, x2, x3, next);
                _v2[1] = cubicAt(y0, y1, y2, y3, next);
                var d2 = vector.distSquare(_v2, _v0);
                if (next &lt;= 1 &amp;&amp; d2 &lt; d) {
                    t = next;
                    d = d2;
                } else {
                    interval *= 0.5;
                }
            }
        }
        if (out) {
            out[0] = cubicAt(x0, x1, x2, x3, t);
            out[1] = cubicAt(y0, y1, y2, y3, t);
        }
        return Math.sqrt(d);
    }
    function quadraticAt(p0, p1, p2, t) {
        var onet = 1 - t;
        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
    }
    function quadraticDerivativeAt(p0, p1, p2, t) {
        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
    }
    function quadraticRootAt(p0, p1, p2, val, roots) {
        var a = p0 - 2 * p1 + p2;
        var b = 2 * (p1 - p0);
        var c = p0 - val;
        var n = 0;
        if (isAroundZero(a)) {
            if (isNotAroundZero(b)) {
                var t1 = -c / b;
                if (t1 &gt;= 0 &amp;&amp; t1 &lt;= 1) {
                    roots[n++] = t1;
                }
            }
        } else {
            var disc = b * b - 4 * a * c;
            if (isAroundZero(disc)) {
                var t1 = -b / (2 * a);
                if (t1 &gt;= 0 &amp;&amp; t1 &lt;= 1) {
                    roots[n++] = t1;
                }
            } else if (disc &gt; 0) {
                var discSqrt = Math.sqrt(disc);
                var t1 = (-b + discSqrt) / (2 * a);
                var t2 = (-b - discSqrt) / (2 * a);
                if (t1 &gt;= 0 &amp;&amp; t1 &lt;= 1) {
                    roots[n++] = t1;
                }
                if (t2 &gt;= 0 &amp;&amp; t2 &lt;= 1) {
                    roots[n++] = t2;
                }
            }
        }
        return n;
    }
    function quadraticExtremum(p0, p1, p2) {
        var divider = p0 + p2 - 2 * p1;
        if (divider === 0) {
            return 0.5;
        } else {
            return (p0 - p1) / divider;
        }
    }
    function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
        var t;
        var interval = 0.005;
        var d = Infinity;
        _v0[0] = x;
        _v0[1] = y;
        for (var _t = 0; _t &lt; 1; _t += 0.05) {
            _v1[0] = quadraticAt(x0, x1, x2, _t);
            _v1[1] = quadraticAt(y0, y1, y2, _t);
            var d1 = vector.distSquare(_v0, _v1);
            if (d1 &lt; d) {
                t = _t;
                d = d1;
            }
        }
        d = Infinity;
        for (var i = 0; i &lt; 32; i++) {
            if (interval &lt; EPSILON) {
                break;
            }
            var prev = t - interval;
            var next = t + interval;
            _v1[0] = quadraticAt(x0, x1, x2, prev);
            _v1[1] = quadraticAt(y0, y1, y2, prev);
            var d1 = vector.distSquare(_v1, _v0);
            if (prev &gt;= 0 &amp;&amp; d1 &lt; d) {
                t = prev;
                d = d1;
            } else {
                _v2[0] = quadraticAt(x0, x1, x2, next);
                _v2[1] = quadraticAt(y0, y1, y2, next);
                var d2 = vector.distSquare(_v2, _v0);
                if (next &lt;= 1 &amp;&amp; d2 &lt; d) {
                    t = next;
                    d = d2;
                } else {
                    interval *= 0.5;
                }
            }
        }
        if (out) {
            out[0] = quadraticAt(x0, x1, x2, t);
            out[1] = quadraticAt(y0, y1, y2, t);
        }
        return Math.sqrt(d);
    }
    return {
        cubicAt: cubicAt,
        cubicDerivativeAt: cubicDerivativeAt,
        cubicRootAt: cubicRootAt,
        cubicExtrema: cubicExtrema,
        cubicSubdivide: cubicSubdivide,
        cubicProjectPoint: cubicProjectPoint,
        quadraticAt: quadraticAt,
        quadraticDerivativeAt: quadraticDerivativeAt,
        quadraticRootAt: quadraticRootAt,
        quadraticExtremum: quadraticExtremum,
        quadraticProjectPoint: quadraticProjectPoint
    };
});define(&#x27;zrender/Group&#x27;, [
    &#x27;require&#x27;,
    &#x27;./tool/guid&#x27;,
    &#x27;./tool/util&#x27;,
    &#x27;./mixin/Transformable&#x27;,
    &#x27;./mixin/Eventful&#x27;
], function (require) {
    var guid = require(&#x27;./tool/guid&#x27;);
    var util = require(&#x27;./tool/util&#x27;);
    var Transformable = require(&#x27;./mixin/Transformable&#x27;);
    var Eventful = require(&#x27;./mixin/Eventful&#x27;);
    var Group = function (options) {
        options = options || {};
        this.id = options.id || guid();
        for (var key in options) {
            this[key] = options[key];
        }
        this.type = &#x27;group&#x27;;
        this.clipShape = null;
        this._children = [];
        this._storage = null;
        this.__dirty = true;
        Transformable.call(this);
        Eventful.call(this);
    };
    Group.prototype.ignore = false;
    Group.prototype.children = function () {
        return this._children.slice();
    };
    Group.prototype.childAt = function (idx) {
        return this._children[idx];
    };
    Group.prototype.addChild = function (child) {
        if (child == this) {
            return;
        }
        if (child.parent == this) {
            return;
        }
        if (child.parent) {
            child.parent.removeChild(child);
        }
        this._children.push(child);
        child.parent = this;
        if (this._storage &amp;&amp; this._storage !== child._storage) {
            this._storage.addToMap(child);
            if (child instanceof Group) {
                child.addChildrenToStorage(this._storage);
            }
        }
    };
    Group.prototype.removeChild = function (child) {
        var idx = util.indexOf(this._children, child);
        this._children.splice(idx, 1);
        child.parent = null;
        if (this._storage) {
            this._storage.delFromMap(child.id);
            if (child instanceof Group) {
                child.delChildrenFromStorage(this._storage);
            }
        }
    };
    Group.prototype.eachChild = function (cb, context) {
        var haveContext = !!context;
        for (var i = 0; i &lt; this._children.length; i++) {
            var child = this._children[i];
            if (haveContext) {
                cb.call(context, child);
            } else {
                cb(child);
            }
        }
    };
    Group.prototype.traverse = function (cb, context) {
        var haveContext = !!context;
        for (var i = 0; i &lt; this._children.length; i++) {
            var child = this._children[i];
            if (haveContext) {
                cb.call(context, child);
            } else {
                cb(child);
            }
            if (child.type === &#x27;group&#x27;) {
                child.traverse(cb, context);
            }
        }
    };
    Group.prototype.addChildrenToStorage = function (storage) {
        for (var i = 0; i &lt; this._children.length; i++) {
            var child = this._children[i];
            storage.addToMap(child);
            if (child.type === &#x27;group&#x27;) {
                child.addChildrenToStorage(storage);
            }
        }
    };
    Group.prototype.delChildrenFromStorage = function (storage) {
        for (var i = 0; i &lt; this._children.length; i++) {
            var child = this._children[i];
            storage.delFromMap(child.id);
            if (child.type === &#x27;group&#x27;) {
                child.delChildrenFromStorage(storage);
            }
        }
    };
    Group.prototype.modSelf = function () {
        this.__dirty = true;
    };
    util.merge(Group.prototype, Transformable.prototype, true);
    util.merge(Group.prototype, Eventful.prototype, true);
    return Group;
});define(&#x27;zrender/animation/Clip&#x27;, [
    &#x27;require&#x27;,
    &#x27;./easing&#x27;
], function (require) {
    var Easing = require(&#x27;./easing&#x27;);
    function Clip(options) {
        this._targetPool = options.target || {};
        if (!(this._targetPool instanceof Array)) {
            this._targetPool = [this._targetPool];
        }
        this._life = options.life || 1000;
        this._delay = options.delay || 0;
        this._startTime = new Date().getTime() + this._delay;
        this._endTime = this._startTime + this._life * 1000;
        this.loop = typeof options.loop == &#x27;undefined&#x27; ? false : options.loop;
        this.gap = options.gap || 0;
        this.easing = options.easing || &#x27;Linear&#x27;;
        this.onframe = options.onframe;
        this.ondestroy = options.ondestroy;
        this.onrestart = options.onrestart;
    }
    Clip.prototype = {
        step: function (time) {
            var percent = (time - this._startTime) / this._life;
            if (percent &lt; 0) {
                return;
            }
            percent = Math.min(percent, 1);
            var easingFunc = typeof this.easing == &#x27;string&#x27; ? Easing[this.easing] : this.easing;
            var schedule = typeof easingFunc === &#x27;function&#x27; ? easingFunc(percent) : percent;
            this.fire(&#x27;frame&#x27;, schedule);
            if (percent == 1) {
                if (this.loop) {
                    this.restart();
                    return &#x27;restart&#x27;;
                }
                this._needsRemove = true;
                return &#x27;destroy&#x27;;
            }
            return null;
        },
        restart: function () {
            var time = new Date().getTime();
            var remainder = (time - this._startTime) % this._life;
            this._startTime = new Date().getTime() - remainder + this.gap;
            this._needsRemove = false;
        },
        fire: function (eventType, arg) {
            for (var i = 0, len = this._targetPool.length; i &lt; len; i++) {
                if (this[&#x27;on&#x27; + eventType]) {
                    this[&#x27;on&#x27; + eventType](this._targetPool[i], arg);
                }
            }
        },
        constructor: Clip
    };
    return Clip;
});define(&#x27;zrender/animation/easing&#x27;, [], function () {
    var easing = {
        Linear: function (k) {
            return k;
        },
        QuadraticIn: function (k) {
            return k * k;
        },
        QuadraticOut: function (k) {
            return k * (2 - k);
        },
        QuadraticInOut: function (k) {
            if ((k *= 2) &lt; 1) {
                return 0.5 * k * k;
            }
            return -0.5 * (--k * (k - 2) - 1);
        },
        CubicIn: function (k) {
            return k * k * k;
        },
        CubicOut: function (k) {
            return --k * k * k + 1;
        },
        CubicInOut: function (k) {
            if ((k *= 2) &lt; 1) {
                return 0.5 * k * k * k;
            }
            return 0.5 * ((k -= 2) * k * k + 2);
        },
        QuarticIn: function (k) {
            return k * k * k * k;
        },
        QuarticOut: function (k) {
            return 1 - --k * k * k * k;
        },
        QuarticInOut: function (k) {
            if ((k *= 2) &lt; 1) {
                return 0.5 * k * k * k * k;
            }
            return -0.5 * ((k -= 2) * k * k * k - 2);
        },
        QuinticIn: function (k) {
            return k * k * k * k * k;
        },
        QuinticOut: function (k) {
            return --k * k * k * k * k + 1;
        },
        QuinticInOut: function (k) {
            if ((k *= 2) &lt; 1) {
                return 0.5 * k * k * k * k * k;
            }
            return 0.5 * ((k -= 2) * k * k * k * k + 2);
        },
        SinusoidalIn: function (k) {
            return 1 - Math.cos(k * Math.PI / 2);
        },
        SinusoidalOut: function (k) {
            return Math.sin(k * Math.PI / 2);
        },
        SinusoidalInOut: function (k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
        },
        ExponentialIn: function (k) {
            return k === 0 ? 0 : Math.pow(1024, k - 1);
        },
        ExponentialOut: function (k) {
            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
        },
        ExponentialInOut: function (k) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if ((k *= 2) &lt; 1) {
                return 0.5 * Math.pow(1024, k - 1);
            }
            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
        },
        CircularIn: function (k) {
            return 1 - Math.sqrt(1 - k * k);
        },
        CircularOut: function (k) {
            return Math.sqrt(1 - --k * k);
        },
        CircularInOut: function (k) {
            if ((k *= 2) &lt; 1) {
                return -0.5 * (Math.sqrt(1 - k * k) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        },
        ElasticIn: function (k) {
            var s;
            var a = 0.1;
            var p = 0.4;
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if (!a || a &lt; 1) {
                a = 1;
                s = p / 4;
            } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        },
        ElasticOut: function (k) {
            var s;
            var a = 0.1;
            var p = 0.4;
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if (!a || a &lt; 1) {
                a = 1;
                s = p / 4;
            } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
        },
        ElasticInOut: function (k) {
            var s;
            var a = 0.1;
            var p = 0.4;
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if (!a || a &lt; 1) {
                a = 1;
                s = p / 4;
            } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            if ((k *= 2) &lt; 1) {
                return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
            }
            return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
        },
        BackIn: function (k) {
            var s = 1.70158;
            return k * k * ((s + 1) * k - s);
        },
        BackOut: function (k) {
            var s = 1.70158;
            return --k * k * ((s + 1) * k + s) + 1;
        },
        BackInOut: function (k) {
            var s = 1.70158 * 1.525;
            if ((k *= 2) &lt; 1) {
                return 0.5 * (k * k * ((s + 1) * k - s));
            }
            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        },
        BounceIn: function (k) {
            return 1 - easing.BounceOut(1 - k);
        },
        BounceOut: function (k) {
            if (k &lt; 1 / 2.75) {
                return 7.5625 * k * k;
            } else if (k &lt; 2 / 2.75) {
                return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
            } else if (k &lt; 2.5 / 2.75) {
                return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
            } else {
                return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
            }
        },
        BounceInOut: function (k) {
            if (k &lt; 0.5) {
                return easing.BounceIn(k * 2) * 0.5;
            }
            return easing.BounceOut(k * 2 - 1) * 0.5 + 0.5;
        }
    };
    return easing;
});define(&#x27;echarts/component/base&#x27;, [
    &#x27;require&#x27;,
    &#x27;../config&#x27;,
    &#x27;../util/ecData&#x27;,
    &#x27;../util/ecQuery&#x27;,
    &#x27;../util/number&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;zrender/tool/env&#x27;
], function (require) {
    var ecConfig = require(&#x27;../config&#x27;);
    var ecData = require(&#x27;../util/ecData&#x27;);
    var ecQuery = require(&#x27;../util/ecQuery&#x27;);
    var number = require(&#x27;../util/number&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    function Base(ecTheme, messageCenter, zr, option, myChart) {
        this.ecTheme = ecTheme;
        this.messageCenter = messageCenter;
        this.zr = zr;
        this.option = option;
        this.series = option.series;
        this.myChart = myChart;
        this.component = myChart.component;
        this._zlevelBase = this.getZlevelBase();
        this.shapeList = [];
        this.effectList = [];
        var self = this;
        self._onlegendhoverlink = function (param) {
            if (self.legendHoverLink) {
                var targetName = param.target;
                var name;
                for (var i = self.shapeList.length - 1; i &gt;= 0; i--) {
                    name = self.type == ecConfig.CHART_TYPE_PIE || self.type == ecConfig.CHART_TYPE_FUNNEL ? ecData.get(self.shapeList[i], &#x27;name&#x27;) : (ecData.get(self.shapeList[i], &#x27;series&#x27;) || {}).name;
                    if (name == targetName &amp;&amp; !self.shapeList[i].invisible) {
                        self.zr.addHoverShape(self.shapeList[i]);
                    }
                }
            }
        };
        messageCenter &amp;&amp; messageCenter.bind(ecConfig.EVENT.LEGEND_HOVERLINK, this._onlegendhoverlink);
    }
    Base.prototype = {
        canvasSupported: require(&#x27;zrender/tool/env&#x27;).canvasSupported,
        getZlevelBase: function (contentType) {
            contentType = contentType || this.type + &#x27;&#x27;;
            switch (contentType) {
            case ecConfig.COMPONENT_TYPE_GRID:
            case ecConfig.COMPONENT_TYPE_AXIS_CATEGORY:
            case ecConfig.COMPONENT_TYPE_AXIS_VALUE:
            case ecConfig.COMPONENT_TYPE_POLAR:
                return 0;
            case ecConfig.CHART_TYPE_LINE:
            case ecConfig.CHART_TYPE_BAR:
            case ecConfig.CHART_TYPE_SCATTER:
            case ecConfig.CHART_TYPE_PIE:
            case ecConfig.CHART_TYPE_RADAR:
            case ecConfig.CHART_TYPE_MAP:
            case ecConfig.CHART_TYPE_K:
            case ecConfig.CHART_TYPE_CHORD:
            case ecConfig.CHART_TYPE_GUAGE:
            case ecConfig.CHART_TYPE_FUNNEL:
            case ecConfig.CHART_TYPE_EVENTRIVER:
                return 2;
            case ecConfig.COMPONENT_TYPE_LEGEND:
            case ecConfig.COMPONENT_TYPE_DATARANGE:
            case ecConfig.COMPONENT_TYPE_DATAZOOM:
            case ecConfig.COMPONENT_TYPE_TIMELINE:
            case ecConfig.COMPONENT_TYPE_ROAMCONTROLLER:
                return 4;
            case ecConfig.CHART_TYPE_ISLAND:
                return 5;
            case ecConfig.COMPONENT_TYPE_TOOLBOX:
            case ecConfig.COMPONENT_TYPE_TITLE:
                return 6;
            case ecConfig.COMPONENT_TYPE_TOOLTIP:
                return 8;
            default:
                return 0;
            }
        },
        reformOption: function (opt) {
            return zrUtil.merge(opt || {}, zrUtil.clone(this.ecTheme[this.type] || {}));
        },
        reformCssArray: function (p) {
            if (p instanceof Array) {
                switch (p.length + &#x27;&#x27;) {
                case &#x27;4&#x27;:
                    return p;
                case &#x27;3&#x27;:
                    return [
                        p[0],
                        p[1],
                        p[2],
                        p[1]
                    ];
                case &#x27;2&#x27;:
                    return [
                        p[0],
                        p[1],
                        p[0],
                        p[1]
                    ];
                case &#x27;1&#x27;:
                    return [
                        p[0],
                        p[0],
                        p[0],
                        p[0]
                    ];
                case &#x27;0&#x27;:
                    return [
                        0,
                        0,
                        0,
                        0
                    ];
                }
            } else {
                return [
                    p,
                    p,
                    p,
                    p
                ];
            }
        },
        getShapeById: function (id) {
            for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                if (this.shapeList[i].id === id) {
                    return this.shapeList[i];
                }
            }
            return null;
        },
        getFont: function (textStyle) {
            var finalTextStyle = zrUtil.merge(zrUtil.clone(textStyle) || {}, this.ecTheme.textStyle);
            return finalTextStyle.fontStyle + &#x27; &#x27; + finalTextStyle.fontWeight + &#x27; &#x27; + finalTextStyle.fontSize + &#x27;px &#x27; + finalTextStyle.fontFamily;
        },
        getItemStyleColor: function (itemColor, seriesIndex, dataIndex, data) {
            return typeof itemColor === &#x27;function&#x27; ? itemColor.call(this.myChart, {
                seriesIndex: seriesIndex,
                series: this.series[seriesIndex],
                dataIndex: dataIndex,
                data: data
            }) : itemColor;
        },
        subPixelOptimize: function (position, lineWidth) {
            if (lineWidth % 2 === 1) {
                position = Math.floor(position) + 0.5;
            } else {
                position = Math.round(position);
            }
            return position;
        },
        resize: function () {
            this.refresh &amp;&amp; this.refresh();
            this.clearEffectShape &amp;&amp; this.clearEffectShape(true);
            var self = this;
            setTimeout(function () {
                self.animationEffect &amp;&amp; self.animationEffect();
            }, 200);
        },
        clear: function () {
            this.clearEffectShape &amp;&amp; this.clearEffectShape();
            this.zr &amp;&amp; this.zr.delShape(this.shapeList);
            this.shapeList = [];
        },
        dispose: function () {
            this.onbeforDispose &amp;&amp; this.onbeforDispose();
            this.clear();
            this.shapeList = null;
            this.effectList = null;
            this.messageCenter &amp;&amp; this.messageCenter.unbind(ecConfig.EVENT.LEGEND_HOVERLINK, this._onlegendhoverlink);
            this.onafterDispose &amp;&amp; this.onafterDispose();
        },
        query: ecQuery.query,
        deepQuery: ecQuery.deepQuery,
        deepMerge: ecQuery.deepMerge,
        parsePercent: number.parsePercent,
        parseCenter: number.parseCenter,
        parseRadius: number.parseRadius,
        numAddCommas: number.addCommas
    };
    return Base;
});define(&#x27;echarts/chart/base&#x27;, [
    &#x27;require&#x27;,
    &#x27;zrender/shape/Image&#x27;,
    &#x27;../util/shape/Icon&#x27;,
    &#x27;../util/shape/MarkLine&#x27;,
    &#x27;../util/shape/Symbol&#x27;,
    &#x27;../config&#x27;,
    &#x27;../util/ecData&#x27;,
    &#x27;../util/ecAnimation&#x27;,
    &#x27;../util/ecEffect&#x27;,
    &#x27;../util/accMath&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;zrender/tool/area&#x27;
], function (require) {
    var ImageShape = require(&#x27;zrender/shape/Image&#x27;);
    var IconShape = require(&#x27;../util/shape/Icon&#x27;);
    var MarkLineShape = require(&#x27;../util/shape/MarkLine&#x27;);
    var SymbolShape = require(&#x27;../util/shape/Symbol&#x27;);
    var ecConfig = require(&#x27;../config&#x27;);
    var ecData = require(&#x27;../util/ecData&#x27;);
    var ecAnimation = require(&#x27;../util/ecAnimation&#x27;);
    var ecEffect = require(&#x27;../util/ecEffect&#x27;);
    var accMath = require(&#x27;../util/accMath&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    var zrArea = require(&#x27;zrender/tool/area&#x27;);
    function Base() {
        var self = this;
        this.selectedMap = {};
        this.lastShapeList = [];
        this.shapeHandler = {
            onclick: function () {
                self.isClick = true;
            },
            ondragover: function (param) {
                var calculableShape = param.target;
                calculableShape.highlightStyle = calculableShape.highlightStyle || {};
                var highlightStyle = calculableShape.highlightStyle;
                var brushType = highlightStyle.brushTyep;
                var strokeColor = highlightStyle.strokeColor;
                var lineWidth = highlightStyle.lineWidth;
                highlightStyle.brushType = &#x27;stroke&#x27;;
                highlightStyle.strokeColor = self.ecTheme.calculableColor;
                highlightStyle.lineWidth = calculableShape.type === &#x27;icon&#x27; ? 30 : 10;
                self.zr.addHoverShape(calculableShape);
                setTimeout(function () {
                    if (calculableShape.highlightStyle) {
                        calculableShape.highlightStyle.brushType = brushType;
                        calculableShape.highlightStyle.strokeColor = strokeColor;
                        calculableShape.highlightStyle.lineWidth = lineWidth;
                    }
                }, 20);
            },
            ondrop: function (param) {
                if (ecData.get(param.dragged, &#x27;data&#x27;) != null) {
                    self.isDrop = true;
                }
            },
            ondragend: function () {
                self.isDragend = true;
            }
        };
    }
    Base.prototype = {
        setCalculable: function (shape) {
            shape.dragEnableTime = this.ecTheme.DRAG_ENABLE_TIME;
            shape.ondragover = this.shapeHandler.ondragover;
            shape.ondragend = this.shapeHandler.ondragend;
            shape.ondrop = this.shapeHandler.ondrop;
            return shape;
        },
        ondrop: function (param, status) {
            if (!this.isDrop || !param.target || status.dragIn) {
                return;
            }
            var target = param.target;
            var dragged = param.dragged;
            var seriesIndex = ecData.get(target, &#x27;seriesIndex&#x27;);
            var dataIndex = ecData.get(target, &#x27;dataIndex&#x27;);
            var series = this.series;
            var data;
            var legend = this.component.legend;
            if (dataIndex === -1) {
                if (ecData.get(dragged, &#x27;seriesIndex&#x27;) == seriesIndex) {
                    status.dragOut = status.dragIn = status.needRefresh = true;
                    this.isDrop = false;
                    return;
                }
                data = {
                    value: ecData.get(dragged, &#x27;value&#x27;),
                    name: ecData.get(dragged, &#x27;name&#x27;)
                };
                if (this.type === ecConfig.CHART_TYPE_PIE &amp;&amp; data.value &lt; 0) {
                    data.value = 0;
                }
                var hasFind = false;
                var sData = series[seriesIndex].data;
                for (var i = 0, l = sData.length; i &lt; l; i++) {
                    if (sData[i].name === data.name &amp;&amp; sData[i].value === &#x27;-&#x27;) {
                        series[seriesIndex].data[i].value = data.value;
                        hasFind = true;
                    }
                }
                !hasFind &amp;&amp; series[seriesIndex].data.push(data);
                legend &amp;&amp; legend.add(data.name, dragged.style.color || dragged.style.strokeColor);
            } else {
                data = this.option.series[seriesIndex].data[dataIndex] || &#x27;-&#x27;;
                if (data.value != null) {
                    if (data.value != &#x27;-&#x27;) {
                        this.option.series[seriesIndex].data[dataIndex].value = accMath.accAdd(this.option.series[seriesIndex].data[dataIndex].value, ecData.get(dragged, &#x27;value&#x27;));
                    } else {
                        this.option.series[seriesIndex].data[dataIndex].value = ecData.get(dragged, &#x27;value&#x27;);
                    }
                    if (this.type === ecConfig.CHART_TYPE_FUNNEL || this.type === ecConfig.CHART_TYPE_PIE) {
                        legend &amp;&amp; legend.getRelatedAmount(data.name) === 1 &amp;&amp; this.component.legend.del(data.name);
                        data.name += this.option.nameConnector + ecData.get(dragged, &#x27;name&#x27;);
                        legend &amp;&amp; legend.add(data.name, dragged.style.color || dragged.style.strokeColor);
                    }
                } else {
                    if (data != &#x27;-&#x27;) {
                        this.option.series[seriesIndex].data[dataIndex] = accMath.accAdd(this.option.series[seriesIndex].data[dataIndex], ecData.get(dragged, &#x27;value&#x27;));
                    } else {
                        this.option.series[seriesIndex].data[dataIndex] = ecData.get(dragged, &#x27;value&#x27;);
                    }
                }
            }
            status.dragIn = status.dragIn || true;
            this.isDrop = false;
            var self = this;
            setTimeout(function () {
                self.zr.trigger(&#x27;mousemove&#x27;, param.event);
            }, 300);
            return;
        },
        ondragend: function (param, status) {
            if (!this.isDragend || !param.target || status.dragOut) {
                return;
            }
            var target = param.target;
            var seriesIndex = ecData.get(target, &#x27;seriesIndex&#x27;);
            var dataIndex = ecData.get(target, &#x27;dataIndex&#x27;);
            var series = this.series;
            if (series[seriesIndex].data[dataIndex].value != null) {
                series[seriesIndex].data[dataIndex].value = &#x27;-&#x27;;
                var name = series[seriesIndex].data[dataIndex].name;
                if (this.component.legend &amp;&amp; this.component.legend.getRelatedAmount(name) === 0) {
                    this.component.legend.del(name);
                }
            } else {
                series[seriesIndex].data[dataIndex] = &#x27;-&#x27;;
            }
            status.dragOut = true;
            status.needRefresh = true;
            this.isDragend = false;
            return;
        },
        onlegendSelected: function (param, status) {
            var legendSelected = param.selected;
            for (var itemName in this.selectedMap) {
                if (this.selectedMap[itemName] != legendSelected[itemName]) {
                    status.needRefresh = true;
                }
                this.selectedMap[itemName] = legendSelected[itemName];
            }
            return;
        },
        _bulidPosition: function () {
            this._symbol = this.option.symbolList;
            this._sIndex2ShapeMap = {};
            this._sIndex2ColorMap = {};
            this.selectedMap = {};
            this.xMarkMap = {};
            var series = this.series;
            var _position2sIndexMap = {
                top: [],
                bottom: [],
                left: [],
                right: [],
                other: []
            };
            var xAxisIndex;
            var yAxisIndex;
            var xAxis;
            var yAxis;
            for (var i = 0, l = series.length; i &lt; l; i++) {
                if (series[i].type === this.type) {
                    series[i] = this.reformOption(series[i]);
                    this.legendHoverLink = series[i].legendHoverLink || this.legendHoverLink;
                    xAxisIndex = series[i].xAxisIndex;
                    yAxisIndex = series[i].yAxisIndex;
                    xAxis = this.component.xAxis.getAxis(xAxisIndex);
                    yAxis = this.component.yAxis.getAxis(yAxisIndex);
                    if (xAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {
                        _position2sIndexMap[xAxis.getPosition()].push(i);
                    } else if (yAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {
                        _position2sIndexMap[yAxis.getPosition()].push(i);
                    } else {
                        _position2sIndexMap.other.push(i);
                    }
                }
            }
            for (var position in _position2sIndexMap) {
                if (_position2sIndexMap[position].length &gt; 0) {
                    this._buildSinglePosition(position, _position2sIndexMap[position]);
                }
            }
            this.addShapeList();
        },
        _buildSinglePosition: function (position, seriesArray) {
            var mapData = this._mapData(seriesArray);
            var locationMap = mapData.locationMap;
            var maxDataLength = mapData.maxDataLength;
            if (maxDataLength === 0 || locationMap.length === 0) {
                return;
            }
            switch (position) {
            case &#x27;bottom&#x27;:
            case &#x27;top&#x27;:
                this._buildHorizontal(seriesArray, maxDataLength, locationMap, this.xMarkMap);
                break;
            case &#x27;left&#x27;:
            case &#x27;right&#x27;:
                this._buildVertical(seriesArray, maxDataLength, locationMap, this.xMarkMap);
                break;
            case &#x27;other&#x27;:
                this._buildOther(seriesArray, maxDataLength, locationMap, this.xMarkMap);
                break;
            }
            for (var i = 0, l = seriesArray.length; i &lt; l; i++) {
                this.buildMark(seriesArray[i]);
            }
        },
        _mapData: function (seriesArray) {
            var series = this.series;
            var serie;
            var dataIndex = 0;
            var stackMap = {};
            var magicStackKey = &#x27;__kener__stack__&#x27;;
            var stackKey;
            var serieName;
            var legend = this.component.legend;
            var locationMap = [];
            var maxDataLength = 0;
            var iconShape;
            for (var i = 0, l = seriesArray.length; i &lt; l; i++) {
                serie = series[seriesArray[i]];
                serieName = serie.name;
                this._sIndex2ShapeMap[seriesArray[i]] = this._sIndex2ShapeMap[seriesArray[i]] || this.query(serie, &#x27;symbol&#x27;) || this._symbol[i % this._symbol.length];
                if (legend) {
                    this.selectedMap[serieName] = legend.isSelected(serieName);
                    this._sIndex2ColorMap[seriesArray[i]] = legend.getColor(serieName);
                    iconShape = legend.getItemShape(serieName);
                    if (iconShape) {
                        if (this.type == ecConfig.CHART_TYPE_LINE) {
                            iconShape.style.iconType = &#x27;legendLineIcon&#x27;;
                            iconShape.style.symbol = this._sIndex2ShapeMap[seriesArray[i]];
                        } else if (serie.itemStyle.normal.barBorderWidth &gt; 0) {
                            iconShape.style.x += 1;
                            iconShape.style.y += 1;
                            iconShape.style.width -= 2;
                            iconShape.style.height -= 2;
                            iconShape.style.strokeColor = iconShape.highlightStyle.strokeColor = serie.itemStyle.normal.barBorderColor;
                            iconShape.highlightStyle.lineWidth = 3;
                            iconShape.style.brushType = &#x27;both&#x27;;
                        }
                        legend.setItemShape(serieName, iconShape);
                    }
                } else {
                    this.selectedMap[serieName] = true;
                    this._sIndex2ColorMap[seriesArray[i]] = this.zr.getColor(seriesArray[i]);
                }
                if (this.selectedMap[serieName]) {
                    stackKey = serie.stack || magicStackKey + seriesArray[i];
                    if (stackMap[stackKey] == null) {
                        stackMap[stackKey] = dataIndex;
                        locationMap[dataIndex] = [seriesArray[i]];
                        dataIndex++;
                    } else {
                        locationMap[stackMap[stackKey]].push(seriesArray[i]);
                    }
                }
                maxDataLength = Math.max(maxDataLength, serie.data.length);
            }
            return {
                locationMap: locationMap,
                maxDataLength: maxDataLength
            };
        },
        _calculMarkMapXY: function (xMarkMap, locationMap, xy) {
            var series = this.series;
            for (var j = 0, k = locationMap.length; j &lt; k; j++) {
                for (var m = 0, n = locationMap[j].length; m &lt; n; m++) {
                    var seriesIndex = locationMap[j][m];
                    var valueIndex = xy == &#x27;xy&#x27; ? 0 : &#x27;&#x27;;
                    if (xy.indexOf(&#x27;x&#x27;) != &#x27;-1&#x27;) {
                        if (xMarkMap[seriesIndex][&#x27;counter&#x27; + valueIndex] &gt; 0) {
                            xMarkMap[seriesIndex][&#x27;average&#x27; + valueIndex] = (xMarkMap[seriesIndex][&#x27;sum&#x27; + valueIndex] / xMarkMap[seriesIndex][&#x27;counter&#x27; + valueIndex]).toFixed(2) - 0;
                        }
                        var x = this.component.xAxis.getAxis(series[seriesIndex].xAxisIndex || 0).getCoord(xMarkMap[seriesIndex][&#x27;average&#x27; + valueIndex]);
                        xMarkMap[seriesIndex][&#x27;averageLine&#x27; + valueIndex] = [
                            [
                                x,
                                this.component.grid.getYend()
                            ],
                            [
                                x,
                                this.component.grid.getY()
                            ]
                        ];
                        xMarkMap[seriesIndex][&#x27;minLine&#x27; + valueIndex] = [
                            [
                                xMarkMap[seriesIndex][&#x27;minX&#x27; + valueIndex],
                                this.component.grid.getYend()
                            ],
                            [
                                xMarkMap[seriesIndex][&#x27;minX&#x27; + valueIndex],
                                this.component.grid.getY()
                            ]
                        ];
                        xMarkMap[seriesIndex][&#x27;maxLine&#x27; + valueIndex] = [
                            [
                                xMarkMap[seriesIndex][&#x27;maxX&#x27; + valueIndex],
                                this.component.grid.getYend()
                            ],
                            [
                                xMarkMap[seriesIndex][&#x27;maxX&#x27; + valueIndex],
                                this.component.grid.getY()
                            ]
                        ];
                        xMarkMap[seriesIndex].isHorizontal = false;
                    }
                    valueIndex = xy == &#x27;xy&#x27; ? 1 : &#x27;&#x27;;
                    if (xy.indexOf(&#x27;y&#x27;) != &#x27;-1&#x27;) {
                        if (xMarkMap[seriesIndex][&#x27;counter&#x27; + valueIndex] &gt; 0) {
                            xMarkMap[seriesIndex][&#x27;average&#x27; + valueIndex] = (xMarkMap[seriesIndex][&#x27;sum&#x27; + valueIndex] / xMarkMap[seriesIndex][&#x27;counter&#x27; + valueIndex]).toFixed(2) - 0;
                        }
                        var y = this.component.yAxis.getAxis(series[seriesIndex].yAxisIndex || 0).getCoord(xMarkMap[seriesIndex][&#x27;average&#x27; + valueIndex]);
                        xMarkMap[seriesIndex][&#x27;averageLine&#x27; + valueIndex] = [
                            [
                                this.component.grid.getX(),
                                y
                            ],
                            [
                                this.component.grid.getXend(),
                                y
                            ]
                        ];
                        xMarkMap[seriesIndex][&#x27;minLine&#x27; + valueIndex] = [
                            [
                                this.component.grid.getX(),
                                xMarkMap[seriesIndex][&#x27;minY&#x27; + valueIndex]
                            ],
                            [
                                this.component.grid.getXend(),
                                xMarkMap[seriesIndex][&#x27;minY&#x27; + valueIndex]
                            ]
                        ];
                        xMarkMap[seriesIndex][&#x27;maxLine&#x27; + valueIndex] = [
                            [
                                this.component.grid.getX(),
                                xMarkMap[seriesIndex][&#x27;maxY&#x27; + valueIndex]
                            ],
                            [
                                this.component.grid.getXend(),
                                xMarkMap[seriesIndex][&#x27;maxY&#x27; + valueIndex]
                            ]
                        ];
                        xMarkMap[seriesIndex].isHorizontal = true;
                    }
                }
            }
        },
        addLabel: function (tarShape, serie, data, name, orient) {
            var queryTarget = [
                data,
                serie
            ];
            var nLabel = this.deepMerge(queryTarget, &#x27;itemStyle.normal.label&#x27;);
            var eLabel = this.deepMerge(queryTarget, &#x27;itemStyle.emphasis.label&#x27;);
            var nTextStyle = nLabel.textStyle || {};
            var eTextStyle = eLabel.textStyle || {};
            if (nLabel.show) {
                tarShape.style.text = this._getLabelText(serie, data, name, &#x27;normal&#x27;);
                tarShape.style.textPosition = nLabel.position == null ? orient === &#x27;horizontal&#x27; ? &#x27;right&#x27; : &#x27;top&#x27; : nLabel.position;
                tarShape.style.textColor = nTextStyle.color;
                tarShape.style.textFont = this.getFont(nTextStyle);
            }
            if (eLabel.show) {
                tarShape.highlightStyle.text = this._getLabelText(serie, data, name, &#x27;emphasis&#x27;);
                tarShape.highlightStyle.textPosition = nLabel.show ? tarShape.style.textPosition : eLabel.position == null ? orient === &#x27;horizontal&#x27; ? &#x27;right&#x27; : &#x27;top&#x27; : eLabel.position;
                tarShape.highlightStyle.textColor = eTextStyle.color;
                tarShape.highlightStyle.textFont = this.getFont(eTextStyle);
            }
            return tarShape;
        },
        _getLabelText: function (serie, data, name, status) {
            var formatter = this.deepQuery([
                data,
                serie
            ], &#x27;itemStyle.&#x27; + status + &#x27;.label.formatter&#x27;);
            if (!formatter &amp;&amp; status === &#x27;emphasis&#x27;) {
                formatter = this.deepQuery([
                    data,
                    serie
                ], &#x27;itemStyle.normal.label.formatter&#x27;);
            }
            var value = data != null ? data.value != null ? data.value : data : &#x27;-&#x27;;
            if (formatter) {
                if (typeof formatter === &#x27;function&#x27;) {
                    return formatter.call(this.myChart, serie.name, name, value);
                } else if (typeof formatter === &#x27;string&#x27;) {
                    formatter = formatter.replace(&#x27;{a}&#x27;, &#x27;{a0}&#x27;).replace(&#x27;{b}&#x27;, &#x27;{b0}&#x27;).replace(&#x27;{c}&#x27;, &#x27;{c0}&#x27;);
                    formatter = formatter.replace(&#x27;{a0}&#x27;, serie.name).replace(&#x27;{b0}&#x27;, name).replace(&#x27;{c0}&#x27;, this.numAddCommas(value));
                    return formatter;
                }
            } else {
                return this.numAddCommas(value);
            }
        },
        buildMark: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (this.selectedMap[serie.name]) {
                serie.markPoint &amp;&amp; this._buildMarkPoint(seriesIndex);
                serie.markLine &amp;&amp; this._buildMarkLine(seriesIndex);
            }
        },
        _buildMarkPoint: function (seriesIndex) {
            var attachStyle = (this.markAttachStyle || {})[seriesIndex];
            var serie = this.series[seriesIndex];
            var _zlevelBase = this.getZlevelBase();
            var mpData;
            var pos;
            var markPoint = zrUtil.clone(serie.markPoint);
            for (var i = 0, l = markPoint.data.length; i &lt; l; i++) {
                mpData = markPoint.data[i];
                pos = this.getMarkCoord(seriesIndex, mpData);
                markPoint.data[i].x = mpData.x != null ? mpData.x : pos[0];
                markPoint.data[i].y = mpData.y != null ? mpData.y : pos[1];
                if (mpData.type &amp;&amp; (mpData.type === &#x27;max&#x27; || mpData.type === &#x27;min&#x27;)) {
                    markPoint.data[i].value = pos[3];
                    markPoint.data[i].name = mpData.name || mpData.type;
                    markPoint.data[i].symbolSize = markPoint.data[i].symbolSize || zrArea.getTextWidth(pos[3], this.getFont()) / 2 + 5;
                }
            }
            var shapeList = this._markPoint(seriesIndex, markPoint);
            for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                shapeList[i].zlevel = _zlevelBase + 1;
                for (var key in attachStyle) {
                    shapeList[i][key] = zrUtil.clone(attachStyle[key]);
                }
                this.shapeList.push(shapeList[i]);
            }
            if (this.type === ecConfig.CHART_TYPE_FORCE || this.type === ecConfig.CHART_TYPE_CHORD) {
                for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                    this.zr.addShape(shapeList[i]);
                }
            }
        },
        _buildMarkLine: function (seriesIndex) {
            var attachStyle = (this.markAttachStyle || {})[seriesIndex];
            var serie = this.series[seriesIndex];
            var _zlevelBase = this.getZlevelBase();
            var mlData;
            var pos;
            var markLine = zrUtil.clone(serie.markLine);
            for (var i = 0, l = markLine.data.length; i &lt; l; i++) {
                mlData = markLine.data[i];
                if (mlData.type &amp;&amp; (mlData.type === &#x27;max&#x27; || mlData.type === &#x27;min&#x27; || mlData.type === &#x27;average&#x27;)) {
                    pos = this.getMarkCoord(seriesIndex, mlData);
                    markLine.data[i] = [
                        zrUtil.clone(mlData),
                        {}
                    ];
                    markLine.data[i][0].name = mlData.name || mlData.type;
                    markLine.data[i][0].value = pos[3];
                    pos = pos[2];
                    mlData = [
                        {},
                        {}
                    ];
                } else {
                    pos = [
                        this.getMarkCoord(seriesIndex, mlData[0]),
                        this.getMarkCoord(seriesIndex, mlData[1])
                    ];
                }
                if (pos == null || pos[0] == null || pos[1] == null) {
                    continue;
                }
                markLine.data[i][0].x = mlData[0].x != null ? mlData[0].x : pos[0][0];
                markLine.data[i][0].y = mlData[0].y != null ? mlData[0].y : pos[0][1];
                markLine.data[i][1].x = mlData[1].x != null ? mlData[1].x : pos[1][0];
                markLine.data[i][1].y = mlData[1].y != null ? mlData[1].y : pos[1][1];
            }
            var shapeList = this._markLine(seriesIndex, markLine);
            for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                shapeList[i].zlevel = _zlevelBase + 1;
                for (var key in attachStyle) {
                    shapeList[i][key] = zrUtil.clone(attachStyle[key]);
                }
                this.shapeList.push(shapeList[i]);
            }
            if (this.type === ecConfig.CHART_TYPE_FORCE || this.type === ecConfig.CHART_TYPE_CHORD) {
                for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                    this.zr.addShape(shapeList[i]);
                }
            }
        },
        _markPoint: function (seriesIndex, mpOption) {
            var serie = this.series[seriesIndex];
            var component = this.component;
            zrUtil.merge(mpOption, this.ecTheme.markPoint);
            mpOption.name = serie.name;
            var pList = [];
            var data = mpOption.data;
            var itemShape;
            var dataRange = component.dataRange;
            var legend = component.legend;
            var color;
            var value;
            var queryTarget;
            var nColor;
            var eColor;
            var effect;
            var zrWidth = this.zr.getWidth();
            var zrHeight = this.zr.getHeight();
            if (!mpOption.large) {
                for (var i = 0, l = data.length; i &lt; l; i++) {
                    if (data[i].x == null || data[i].y == null) {
                        continue;
                    }
                    value = data[i] != null &amp;&amp; data[i].value != null ? data[i].value : &#x27;&#x27;;
                    if (legend) {
                        color = legend.getColor(serie.name);
                    }
                    if (dataRange) {
                        color = isNaN(value) ? color : dataRange.getColor(value);
                        queryTarget = [
                            data[i],
                            mpOption
                        ];
                        nColor = this.deepQuery(queryTarget, &#x27;itemStyle.normal.color&#x27;) || color;
                        eColor = this.deepQuery(queryTarget, &#x27;itemStyle.emphasis.color&#x27;) || nColor;
                        if (nColor == null &amp;&amp; eColor == null) {
                            continue;
                        }
                    }
                    color = color == null ? this.zr.getColor(seriesIndex) : color;
                    data[i].tooltip = data[i].tooltip || mpOption.tooltip || { trigger: &#x27;item&#x27; };
                    data[i].name = data[i].name != null ? data[i].name : &#x27;&#x27;;
                    data[i].value = value;
                    itemShape = this.getSymbolShape(mpOption, seriesIndex, data[i], i, data[i].name, this.parsePercent(data[i].x, zrWidth), this.parsePercent(data[i].y, zrHeight), &#x27;pin&#x27;, color, &#x27;rgba(0,0,0,0)&#x27;, &#x27;horizontal&#x27;);
                    itemShape._mark = &#x27;point&#x27;;
                    effect = this.deepMerge([
                        data[i],
                        mpOption
                    ], &#x27;effect&#x27;);
                    if (effect.show) {
                        itemShape.effect = effect;
                    }
                    if (serie.type === ecConfig.CHART_TYPE_MAP) {
                        itemShape._geo = this.getMarkGeo(data[i]);
                    }
                    ecData.pack(itemShape, serie, seriesIndex, data[i], i, data[i].name, value);
                    pList.push(itemShape);
                }
            } else {
                itemShape = this.getLargeMarkPoingShape(seriesIndex, mpOption);
                itemShape._mark = &#x27;largePoint&#x27;;
                itemShape &amp;&amp; pList.push(itemShape);
            }
            return pList;
        },
        _markLine: function (seriesIndex, mlOption) {
            var serie = this.series[seriesIndex];
            var component = this.component;
            zrUtil.merge(mlOption, this.ecTheme.markLine);
            mlOption.symbol = mlOption.symbol instanceof Array ? mlOption.symbol.length &gt; 1 ? mlOption.symbol : [
                mlOption.symbol[0],
                mlOption.symbol[0]
            ] : [
                mlOption.symbol,
                mlOption.symbol
            ];
            mlOption.symbolSize = mlOption.symbolSize instanceof Array ? mlOption.symbolSize.length &gt; 1 ? mlOption.symbolSize : [
                mlOption.symbolSize[0],
                mlOption.symbolSize[0]
            ] : [
                mlOption.symbolSize,
                mlOption.symbolSize
            ];
            mlOption.symbolRotate = mlOption.symbolRotate instanceof Array ? mlOption.symbolRotate.length &gt; 1 ? mlOption.symbolRotate : [
                mlOption.symbolRotate[0],
                mlOption.symbolRotate[0]
            ] : [
                mlOption.symbolRotate,
                mlOption.symbolRotate
            ];
            mlOption.name = serie.name;
            var pList = [];
            var data = mlOption.data;
            var itemShape;
            var dataRange = component.dataRange;
            var legend = component.legend;
            var color;
            var value;
            var queryTarget;
            var nColor;
            var eColor;
            var effect;
            var zrWidth = this.zr.getWidth();
            var zrHeight = this.zr.getHeight();
            var mergeData;
            for (var i = 0, l = data.length; i &lt; l; i++) {
                if (data[i][0].x == null || data[i][0].y == null || data[i][1].x == null || data[i][1].y == null) {
                    continue;
                }
                color = legend ? legend.getColor(serie.name) : this.zr.getColor(seriesIndex);
                mergeData = this.deepMerge(data[i]);
                value = mergeData != null &amp;&amp; mergeData.value != null ? mergeData.value : &#x27;&#x27;;
                if (dataRange) {
                    color = isNaN(value) ? color : dataRange.getColor(value);
                    queryTarget = [
                        mergeData,
                        mlOption
                    ];
                    nColor = this.deepQuery(queryTarget, &#x27;itemStyle.normal.color&#x27;) || color;
                    eColor = this.deepQuery(queryTarget, &#x27;itemStyle.emphasis.color&#x27;) || nColor;
                    if (nColor == null &amp;&amp; eColor == null) {
                        continue;
                    }
                }
                data[i][0].tooltip = mergeData.tooltip || { trigger: &#x27;item&#x27; };
                data[i][0].name = data[i][0].name != null ? data[i][0].name : &#x27;&#x27;;
                data[i][1].name = data[i][1].name != null ? data[i][1].name : &#x27;&#x27;;
                data[i][0].value = data[i][0].value != null ? data[i][0].value : &#x27;&#x27;;
                itemShape = this.getLineMarkShape(mlOption, seriesIndex, data[i], i, this.parsePercent(data[i][0].x, zrWidth), this.parsePercent(data[i][0].y, zrHeight), this.parsePercent(data[i][1].x, zrWidth), this.parsePercent(data[i][1].y, zrHeight), color);
                itemShape._mark = &#x27;line&#x27;;
                effect = this.deepMerge([
                    mergeData,
                    mlOption
                ], &#x27;effect&#x27;);
                if (effect.show) {
                    itemShape.effect = effect;
                }
                if (serie.type === ecConfig.CHART_TYPE_MAP) {
                    itemShape._geo = [
                        this.getMarkGeo(data[i][0]),
                        this.getMarkGeo(data[i][1])
                    ];
                }
                ecData.pack(itemShape, serie, seriesIndex, data[i][0], i, data[i][0].name + (data[i][1].name !== &#x27;&#x27; ? &#x27; &gt; &#x27; + data[i][1].name : &#x27;&#x27;), value);
                pList.push(itemShape);
            }
            return pList;
        },
        getMarkCoord: function () {
            return [
                0,
                0
            ];
        },
        getSymbolShape: function (serie, seriesIndex, data, dataIndex, name, x, y, symbol, color, emptyColor, orient) {
            var queryTarget = [
                data,
                serie
            ];
            var value = data != null ? data.value != null ? data.value : data : &#x27;-&#x27;;
            symbol = this.deepQuery(queryTarget, &#x27;symbol&#x27;) || symbol;
            var symbolSize = this.deepQuery(queryTarget, &#x27;symbolSize&#x27;);
            symbolSize = typeof symbolSize === &#x27;function&#x27; ? symbolSize(value) : symbolSize;
            var symbolRotate = this.deepQuery(queryTarget, &#x27;symbolRotate&#x27;);
            var normal = this.deepMerge(queryTarget, &#x27;itemStyle.normal&#x27;);
            var emphasis = this.deepMerge(queryTarget, &#x27;itemStyle.emphasis&#x27;);
            var nBorderWidth = normal.borderWidth != null ? normal.borderWidth : normal.lineStyle &amp;&amp; normal.lineStyle.width;
            if (nBorderWidth == null) {
                nBorderWidth = symbol.match(&#x27;empty&#x27;) ? 2 : 0;
            }
            var eBorderWidth = emphasis.borderWidth != null ? emphasis.borderWidth : emphasis.lineStyle &amp;&amp; emphasis.lineStyle.width;
            if (eBorderWidth == null) {
                eBorderWidth = nBorderWidth + 2;
            }
            var itemShape = new IconShape({
                style: {
                    iconType: symbol.replace(&#x27;empty&#x27;, &#x27;&#x27;).toLowerCase(),
                    x: x - symbolSize,
                    y: y - symbolSize,
                    width: symbolSize * 2,
                    height: symbolSize * 2,
                    brushType: &#x27;both&#x27;,
                    color: symbol.match(&#x27;empty&#x27;) ? emptyColor : this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data) || color,
                    strokeColor: normal.borderColor || this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data) || color,
                    lineWidth: nBorderWidth
                },
                highlightStyle: {
                    color: symbol.match(&#x27;empty&#x27;) ? emptyColor : this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data),
                    strokeColor: emphasis.borderColor || normal.borderColor || this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data) || color,
                    lineWidth: eBorderWidth
                },
                clickable: this.deepQuery(queryTarget, &#x27;clickable&#x27;)
            });
            if (symbol.match(&#x27;image&#x27;)) {
                itemShape.style.image = symbol.replace(new RegExp(&#x27;^image:\\/\\/&#x27;), &#x27;&#x27;);
                itemShape = new ImageShape({
                    style: itemShape.style,
                    highlightStyle: itemShape.highlightStyle,
                    clickable: this.deepQuery(queryTarget, &#x27;clickable&#x27;)
                });
            }
            if (symbolRotate != null) {
                itemShape.rotation = [
                    symbolRotate * Math.PI / 180,
                    x,
                    y
                ];
            }
            if (symbol.match(&#x27;star&#x27;)) {
                itemShape.style.iconType = &#x27;star&#x27;;
                itemShape.style.n = symbol.replace(&#x27;empty&#x27;, &#x27;&#x27;).replace(&#x27;star&#x27;, &#x27;&#x27;) - 0 || 5;
            }
            if (symbol === &#x27;none&#x27;) {
                itemShape.invisible = true;
                itemShape.hoverable = false;
            }
            itemShape = this.addLabel(itemShape, serie, data, name, orient);
            if (symbol.match(&#x27;empty&#x27;)) {
                if (itemShape.style.textColor == null) {
                    itemShape.style.textColor = itemShape.style.strokeColor;
                }
                if (itemShape.highlightStyle.textColor == null) {
                    itemShape.highlightStyle.textColor = itemShape.highlightStyle.strokeColor;
                }
            }
            ecData.pack(itemShape, serie, seriesIndex, data, dataIndex, name);
            itemShape._x = x;
            itemShape._y = y;
            itemShape._dataIndex = dataIndex;
            itemShape._seriesIndex = seriesIndex;
            return itemShape;
        },
        getLineMarkShape: function (mlOption, seriesIndex, data, dataIndex, xStart, yStart, xEnd, yEnd, color) {
            var value0 = data[0] != null ? data[0].value != null ? data[0].value : data[0] : &#x27;-&#x27;;
            var value1 = data[1] != null ? data[1].value != null ? data[1].value : data[1] : &#x27;-&#x27;;
            var symbol = [
                this.query(data[0], &#x27;symbol&#x27;) || mlOption.symbol[0],
                this.query(data[1], &#x27;symbol&#x27;) || mlOption.symbol[1]
            ];
            var symbolSize = [
                this.query(data[0], &#x27;symbolSize&#x27;) || mlOption.symbolSize[0],
                this.query(data[1], &#x27;symbolSize&#x27;) || mlOption.symbolSize[1]
            ];
            symbolSize[0] = typeof symbolSize[0] === &#x27;function&#x27; ? symbolSize[0](value0) : symbolSize[0];
            symbolSize[1] = typeof symbolSize[1] === &#x27;function&#x27; ? symbolSize[1](value1) : symbolSize[1];
            var symbolRotate = [
                this.query(data[0], &#x27;symbolRotate&#x27;) || mlOption.symbolRotate[0],
                this.query(data[1], &#x27;symbolRotate&#x27;) || mlOption.symbolRotate[1]
            ];
            var queryTarget = [
                data[0],
                mlOption
            ];
            var normal = this.deepMerge(queryTarget, &#x27;itemStyle.normal&#x27;);
            normal.color = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data);
            var emphasis = this.deepMerge(queryTarget, &#x27;itemStyle.emphasis&#x27;);
            emphasis.color = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data);
            var nlineStyle = normal.lineStyle;
            var elineStyle = emphasis.lineStyle;
            var nBorderWidth = nlineStyle.width;
            if (nBorderWidth == null) {
                nBorderWidth = normal.borderWidth;
            }
            var eBorderWidth = elineStyle.width;
            if (eBorderWidth == null) {
                eBorderWidth = emphasis.borderWidth != null ? emphasis.borderWidth : nBorderWidth + 2;
            }
            var itemShape = new MarkLineShape({
                style: {
                    smooth: mlOption.smooth ? &#x27;spline&#x27; : false,
                    symbol: symbol,
                    symbolSize: symbolSize,
                    symbolRotate: symbolRotate,
                    xStart: xStart,
                    yStart: yStart,
                    xEnd: xEnd,
                    yEnd: yEnd,
                    brushType: &#x27;both&#x27;,
                    lineType: nlineStyle.type,
                    shadowColor: nlineStyle.shadowColor || nlineStyle.color || normal.borderColor || normal.color || color,
                    shadowBlur: nlineStyle.shadowBlur,
                    shadowOffsetX: nlineStyle.shadowOffsetX,
                    shadowOffsetY: nlineStyle.shadowOffsetY,
                    color: normal.color || color,
                    strokeColor: nlineStyle.color || normal.borderColor || normal.color || color,
                    lineWidth: nBorderWidth,
                    symbolBorderColor: normal.borderColor || normal.color || color,
                    symbolBorder: normal.borderWidth
                },
                highlightStyle: {
                    shadowColor: elineStyle.shadowColor,
                    shadowBlur: elineStyle.shadowBlur,
                    shadowOffsetX: elineStyle.shadowOffsetX,
                    shadowOffsetY: elineStyle.shadowOffsetY,
                    color: emphasis.color || normal.color || color,
                    strokeColor: elineStyle.color || nlineStyle.color || emphasis.borderColor || normal.borderColor || emphasis.color || normal.color || color,
                    lineWidth: eBorderWidth,
                    symbolBorderColor: emphasis.borderColor || normal.borderColor || emphasis.color || normal.color || color,
                    symbolBorder: emphasis.borderWidth == null ? normal.borderWidth + 2 : emphasis.borderWidth
                },
                clickable: this.deepQuery(queryTarget, &#x27;clickable&#x27;)
            });
            itemShape = this.addLabel(itemShape, mlOption, data[0], data[0].name + &#x27; : &#x27; + data[1].name);
            itemShape._x = xEnd;
            itemShape._y = yEnd;
            return itemShape;
        },
        getLargeMarkPoingShape: function (seriesIndex, mpOption) {
            var serie = this.series[seriesIndex];
            var component = this.component;
            var data = mpOption.data;
            var itemShape;
            var dataRange = component.dataRange;
            var legend = component.legend;
            var color;
            var value;
            var queryTarget = [
                data[0],
                mpOption
            ];
            var nColor;
            var eColor;
            var effect;
            if (legend) {
                color = legend.getColor(serie.name);
            }
            if (dataRange) {
                value = data[0] != null ? data[0].value != null ? data[0].value : data[0] : &#x27;-&#x27;;
                color = isNaN(value) ? color : dataRange.getColor(value);
                nColor = this.deepQuery(queryTarget, &#x27;itemStyle.normal.color&#x27;) || color;
                eColor = this.deepQuery(queryTarget, &#x27;itemStyle.emphasis.color&#x27;) || nColor;
                if (nColor == null &amp;&amp; eColor == null) {
                    return;
                }
            }
            color = this.deepMerge(queryTarget, &#x27;itemStyle.normal&#x27;).color || color;
            var symbol = this.deepQuery(queryTarget, &#x27;symbol&#x27;) || &#x27;circle&#x27;;
            symbol = symbol.replace(&#x27;empty&#x27;, &#x27;&#x27;).replace(/\d/g, &#x27;&#x27;);
            effect = this.deepMerge([
                data[0],
                mpOption
            ], &#x27;effect&#x27;);
            var devicePixelRatio = window.devicePixelRatio || 1;
            itemShape = new SymbolShape({
                style: {
                    pointList: data,
                    color: color,
                    strokeColor: color,
                    shadowColor: effect.shadowColor || color,
                    shadowBlur: (effect.shadowBlur != null ? effect.shadowBlur : 8) * devicePixelRatio,
                    size: this.deepQuery(queryTarget, &#x27;symbolSize&#x27;),
                    iconType: symbol,
                    brushType: &#x27;fill&#x27;,
                    lineWidth: 1
                },
                draggable: false,
                hoverable: false
            });
            if (effect.show) {
                itemShape.effect = effect;
            }
            return itemShape;
        },
        backupShapeList: function () {
            if (this.shapeList &amp;&amp; this.shapeList.length &gt; 0) {
                this.lastShapeList = this.shapeList;
                this.shapeList = [];
            } else {
                this.lastShapeList = [];
            }
        },
        addShapeList: function () {
            var maxLenth = this.option.animationThreshold / (this.canvasSupported ? 2 : 4);
            var lastShapeList = this.lastShapeList;
            var shapeList = this.shapeList;
            var duration = lastShapeList.length &gt; 0 ? 500 : this.query(this.option, &#x27;animationDuration&#x27;);
            var easing = this.query(this.option, &#x27;animationEasing&#x27;);
            var delay;
            var key;
            var oldMap = {};
            var newMap = {};
            if (this.option.animation &amp;&amp; !this.option.renderAsImage &amp;&amp; shapeList.length &lt; maxLenth &amp;&amp; !this.motionlessOnce) {
                for (var i = 0, l = lastShapeList.length; i &lt; l; i++) {
                    key = this._getAnimationKey(lastShapeList[i]);
                    if (key.match(&#x27;undefined&#x27;)) {
                        this.zr.delShape(lastShapeList[i].id);
                    } else {
                        key += lastShapeList[i].type;
                        oldMap[key] = lastShapeList[i];
                    }
                }
                for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                    key = this._getAnimationKey(shapeList[i]);
                    if (key.match(&#x27;undefined&#x27;)) {
                        this.zr.addShape(shapeList[i]);
                    } else {
                        key += shapeList[i].type;
                        newMap[key] = shapeList[i];
                    }
                }
                for (key in oldMap) {
                    if (!newMap[key]) {
                        this.zr.delShape(oldMap[key].id);
                    }
                }
                for (key in newMap) {
                    if (oldMap[key]) {
                        this.zr.delShape(oldMap[key].id);
                        this._animateMod(oldMap[key], newMap[key], duration, easing);
                    } else {
                        delay = (this.type == ecConfig.CHART_TYPE_LINE || this.type == ecConfig.CHART_TYPE_RADAR) &amp;&amp; key.indexOf(&#x27;icon&#x27;) !== 0 ? duration / 2 : 0;
                        this._animateMod(false, newMap[key], duration, easing, delay);
                    }
                }
                this.zr.refresh();
                this.animationEffect();
            } else {
                this.motionlessOnce = false;
                this.zr.delShape(lastShapeList);
                for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                    this.zr.addShape(shapeList[i]);
                }
            }
        },
        _getAnimationKey: function (shape) {
            if (this.type != ecConfig.CHART_TYPE_MAP) {
                return ecData.get(shape, &#x27;seriesIndex&#x27;) + &#x27;_&#x27; + ecData.get(shape, &#x27;dataIndex&#x27;) + (shape._mark ? shape._mark : &#x27;&#x27;) + (this.type === ecConfig.CHART_TYPE_RADAR ? ecData.get(shape, &#x27;special&#x27;) : &#x27;&#x27;);
            } else {
                return ecData.get(shape, &#x27;seriesIndex&#x27;) + &#x27;_&#x27; + ecData.get(shape, &#x27;dataIndex&#x27;) + (shape._mark ? shape._mark : &#x27;undefined&#x27;);
            }
        },
        _animateMod: function (oldShape, newShape, duration, easing, delay) {
            switch (newShape.type) {
            case &#x27;broken-line&#x27;:
            case &#x27;half-smooth-polygon&#x27;:
                ecAnimation.pointList(this.zr, oldShape, newShape, duration, easing);
                break;
            case &#x27;rectangle&#x27;:
                ecAnimation.rectangle(this.zr, oldShape, newShape, duration, easing);
                break;
            case &#x27;icon&#x27;:
                ecAnimation.icon(this.zr, oldShape, newShape, duration, easing, delay);
                break;
            case &#x27;candle&#x27;:
                if (duration &gt; 500) {
                    ecAnimation.candle(this.zr, oldShape, newShape, duration, easing);
                } else {
                    this.zr.addShape(newShape);
                }
                break;
            case &#x27;ring&#x27;:
            case &#x27;sector&#x27;:
            case &#x27;circle&#x27;:
                if (duration &gt; 500) {
                    ecAnimation.ring(this.zr, oldShape, newShape, duration + (ecData.get(newShape, &#x27;dataIndex&#x27;) || 0) % 20 * 100, easing);
                } else if (newShape.type === &#x27;sector&#x27;) {
                    ecAnimation.sector(this.zr, oldShape, newShape, duration, easing);
                } else {
                    this.zr.addShape(newShape);
                }
                break;
            case &#x27;text&#x27;:
                ecAnimation.text(this.zr, oldShape, newShape, duration, easing);
                break;
            case &#x27;polygon&#x27;:
                if (duration &gt; 500) {
                    ecAnimation.polygon(this.zr, oldShape, newShape, duration, easing);
                } else {
                    ecAnimation.pointList(this.zr, oldShape, newShape, duration, easing);
                }
                break;
            case &#x27;ribbon&#x27;:
                ecAnimation.ribbon(this.zr, oldShape, newShape, duration, easing);
                break;
            case &#x27;gauge-pointer&#x27;:
                ecAnimation.gaugePointer(this.zr, oldShape, newShape, duration, easing);
                break;
            case &#x27;mark-line&#x27;:
                ecAnimation.markline(this.zr, oldShape, newShape, duration, easing);
                break;
            case &#x27;bezier-curve&#x27;:
            case &#x27;line&#x27;:
                ecAnimation.line(this.zr, oldShape, newShape, duration, easing);
                break;
            default:
                this.zr.addShape(newShape);
                break;
            }
        },
        animationMark: function (duration, easing, addShapeList) {
            var shapeList = addShapeList || this.shapeList;
            for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                if (!shapeList[i]._mark) {
                    continue;
                }
                this._animateMod(false, shapeList[i], duration, easing);
            }
            this.animationEffect(addShapeList);
        },
        animationEffect: function (addShapeList) {
            !addShapeList &amp;&amp; this.clearEffectShape();
            var shapeList = addShapeList || this.shapeList;
            if (shapeList == null) {
                return;
            }
            var zlevel = ecConfig.EFFECT_ZLEVEL;
            if (this.canvasSupported) {
                this.zr.modLayer(zlevel, {
                    motionBlur: true,
                    lastFrameAlpha: 0.95
                });
            }
            var shape;
            for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                shape = shapeList[i];
                if (!(shape._mark &amp;&amp; shape.effect &amp;&amp; shape.effect.show &amp;&amp; ecEffect[shape._mark])) {
                    continue;
                }
                ecEffect[shape._mark](this.zr, this.effectList, shape, zlevel);
                this.effectList[this.effectList.length - 1]._mark = shape._mark;
            }
        },
        clearEffectShape: function (clearMotionBlur) {
            if (this.zr &amp;&amp; this.effectList &amp;&amp; this.effectList.length &gt; 0) {
                clearMotionBlur &amp;&amp; this.zr.modLayer(ecConfig.EFFECT_ZLEVEL, { motionBlur: false });
                this.zr.delShape(this.effectList);
            }
            this.effectList = [];
        },
        addMark: function (seriesIndex, markData, markType) {
            var serie = this.series[seriesIndex];
            if (this.selectedMap[serie.name]) {
                var duration = 500;
                var easing = this.query(this.option, &#x27;animationEasing&#x27;);
                var oriMarkData = serie[markType].data;
                var lastLength = this.shapeList.length;
                serie[markType].data = markData.data;
                this[&#x27;_build&#x27; + markType.replace(&#x27;m&#x27;, &#x27;M&#x27;)](seriesIndex);
                if (this.option.animation &amp;&amp; !this.option.renderAsImage) {
                    this.animationMark(duration, easing, this.shapeList.slice(lastLength));
                } else {
                    for (var i = lastLength, l = this.shapeList.length; i &lt; l; i++) {
                        this.zr.addShape(this.shapeList[i]);
                    }
                    this.zr.refresh();
                }
                serie[markType].data = oriMarkData;
            }
        },
        delMark: function (seriesIndex, markName, markType) {
            markType = markType.replace(&#x27;mark&#x27;, &#x27;&#x27;).replace(&#x27;large&#x27;, &#x27;&#x27;).toLowerCase();
            var serie = this.series[seriesIndex];
            if (this.selectedMap[serie.name]) {
                var needRefresh = false;
                var shapeList = [
                    this.shapeList,
                    this.effectList
                ];
                var len = 2;
                while (len--) {
                    for (var i = 0, l = shapeList[len].length; i &lt; l; i++) {
                        if (shapeList[len][i]._mark == markType &amp;&amp; ecData.get(shapeList[len][i], &#x27;seriesIndex&#x27;) == seriesIndex &amp;&amp; ecData.get(shapeList[len][i], &#x27;name&#x27;) == markName) {
                            this.zr.delShape(shapeList[len][i].id);
                            shapeList[len].splice(i, 1);
                            needRefresh = true;
                            break;
                        }
                    }
                }
                needRefresh &amp;&amp; this.zr.refresh();
            }
        }
    };
    return Base;
});define(&#x27;zrender/shape/Circle&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Base&#x27;,
    &#x27;../tool/util&#x27;
], function (require) {
    &#x27;use strict&#x27;;
    var Base = require(&#x27;./Base&#x27;);
    var Circle = function (options) {
        Base.call(this, options);
    };
    Circle.prototype = {
        type: &#x27;circle&#x27;,
        buildPath: function (ctx, style) {
            ctx.arc(style.x, style.y, style.r, 0, Math.PI * 2, true);
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var lineWidth;
            if (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;fill&#x27;) {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(style.x - style.r - lineWidth / 2),
                y: Math.round(style.y - style.r - lineWidth / 2),
                width: style.r * 2 + lineWidth,
                height: style.r * 2 + lineWidth
            };
            return style.__rect;
        }
    };
    require(&#x27;../tool/util&#x27;).inherits(Circle, Base);
    return Circle;
});define(&#x27;echarts/util/accMath&#x27;, [], function () {
    function accDiv(arg1, arg2) {
        var s1 = arg1.toString();
        var s2 = arg2.toString();
        var m = 0;
        try {
            m = s2.split(&#x27;.&#x27;)[1].length;
        } catch (e) {
        }
        try {
            m -= s1.split(&#x27;.&#x27;)[1].length;
        } catch (e) {
        }
        return (s1.replace(&#x27;.&#x27;, &#x27;&#x27;) - 0) / (s2.replace(&#x27;.&#x27;, &#x27;&#x27;) - 0) * Math.pow(10, m);
    }
    function accMul(arg1, arg2) {
        var s1 = arg1.toString();
        var s2 = arg2.toString();
        var m = 0;
        try {
            m += s1.split(&#x27;.&#x27;)[1].length;
        } catch (e) {
        }
        try {
            m += s2.split(&#x27;.&#x27;)[1].length;
        } catch (e) {
        }
        return (s1.replace(&#x27;.&#x27;, &#x27;&#x27;) - 0) * (s2.replace(&#x27;.&#x27;, &#x27;&#x27;) - 0) / Math.pow(10, m);
    }
    function accAdd(arg1, arg2) {
        var r1 = 0;
        var r2 = 0;
        try {
            r1 = arg1.toString().split(&#x27;.&#x27;)[1].length;
        } catch (e) {
        }
        try {
            r2 = arg2.toString().split(&#x27;.&#x27;)[1].length;
        } catch (e) {
        }
        var m = Math.pow(10, Math.max(r1, r2));
        return (Math.round(arg1 * m) + Math.round(arg2 * m)) / m;
    }
    function accSub(arg1, arg2) {
        return accAdd(arg1, -arg2);
    }
    return {
        accDiv: accDiv,
        accMul: accMul,
        accAdd: accAdd,
        accSub: accSub
    };
});define(&#x27;echarts/util/ecQuery&#x27;, [
    &#x27;require&#x27;,
    &#x27;zrender/tool/util&#x27;
], function (require) {
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    function query(optionTarget, optionLocation) {
        if (typeof optionTarget == &#x27;undefined&#x27;) {
            return;
        }
        if (!optionLocation) {
            return optionTarget;
        }
        optionLocation = optionLocation.split(&#x27;.&#x27;);
        var length = optionLocation.length;
        var curIdx = 0;
        while (curIdx &lt; length) {
            optionTarget = optionTarget[optionLocation[curIdx]];
            if (typeof optionTarget == &#x27;undefined&#x27;) {
                return;
            }
            curIdx++;
        }
        return optionTarget;
    }
    function deepQuery(ctrList, optionLocation) {
        var finalOption;
        for (var i = 0, l = ctrList.length; i &lt; l; i++) {
            finalOption = query(ctrList[i], optionLocation);
            if (typeof finalOption != &#x27;undefined&#x27;) {
                return finalOption;
            }
        }
    }
    function deepMerge(ctrList, optionLocation) {
        var finalOption;
        var len = ctrList.length;
        while (len--) {
            var tempOption = query(ctrList[len], optionLocation);
            if (typeof tempOption != &#x27;undefined&#x27;) {
                if (typeof finalOption == &#x27;undefined&#x27;) {
                    finalOption = zrUtil.clone(tempOption);
                } else {
                    zrUtil.merge(finalOption, tempOption, true);
                }
            }
        }
        return finalOption;
    }
    return {
        query: query,
        deepQuery: deepQuery,
        deepMerge: deepMerge
    };
});define(&#x27;echarts/util/number&#x27;, [], function () {
    function _trim(str) {
        return str.replace(/^\s+/, &#x27;&#x27;).replace(/\s+$/, &#x27;&#x27;);
    }
    function parsePercent(value, maxValue) {
        if (typeof value === &#x27;string&#x27;) {
            if (_trim(value).match(/%$/)) {
                return parseFloat(value) / 100 * maxValue;
            }
            return parseFloat(value);
        }
        return value;
    }
    function parseCenter(zr, center) {
        return [
            parsePercent(center[0], zr.getWidth()),
            parsePercent(center[1], zr.getHeight())
        ];
    }
    function parseRadius(zr, radius) {
        if (!(radius instanceof Array)) {
            radius = [
                0,
                radius
            ];
        }
        var zrSize = Math.min(zr.getWidth(), zr.getHeight()) / 2;
        return [
            parsePercent(radius[0], zrSize),
            parsePercent(radius[1], zrSize)
        ];
    }
    function addCommas(x) {
        if (isNaN(x)) {
            return &#x27;-&#x27;;
        }
        x = (x + &#x27;&#x27;).split(&#x27;.&#x27;);
        return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, &#x27;$1,&#x27;) + (x.length &gt; 1 ? &#x27;.&#x27; + x[1] : &#x27;&#x27;);
    }
    return {
        parsePercent: parsePercent,
        parseCenter: parseCenter,
        parseRadius: parseRadius,
        addCommas: addCommas
    };
});define(&#x27;echarts/util/shape/Icon&#x27;, [
    &#x27;require&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;zrender/shape/Star&#x27;,
    &#x27;zrender/shape/Heart&#x27;,
    &#x27;zrender/shape/Droplet&#x27;,
    &#x27;zrender/shape/Image&#x27;,
    &#x27;zrender/shape/Base&#x27;
], function (require) {
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    function _iconMark(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x, y + style.height);
        ctx.lineTo(x + 5 * dx, y + 14 * dy);
        ctx.lineTo(x + style.width, y + 3 * dy);
        ctx.lineTo(x + 13 * dx, y);
        ctx.lineTo(x + 2 * dx, y + 11 * dy);
        ctx.lineTo(x, y + style.height);
        ctx.moveTo(x + 6 * dx, y + 10 * dy);
        ctx.lineTo(x + 14 * dx, y + 2 * dy);
        ctx.moveTo(x + 10 * dx, y + 13 * dy);
        ctx.lineTo(x + style.width, y + 13 * dy);
        ctx.moveTo(x + 13 * dx, y + 10 * dy);
        ctx.lineTo(x + 13 * dx, y + style.height);
    }
    function _iconMarkUndo(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x, y + style.height);
        ctx.lineTo(x + 5 * dx, y + 14 * dy);
        ctx.lineTo(x + style.width, y + 3 * dy);
        ctx.lineTo(x + 13 * dx, y);
        ctx.lineTo(x + 2 * dx, y + 11 * dy);
        ctx.lineTo(x, y + style.height);
        ctx.moveTo(x + 6 * dx, y + 10 * dy);
        ctx.lineTo(x + 14 * dx, y + 2 * dy);
        ctx.moveTo(x + 10 * dx, y + 13 * dy);
        ctx.lineTo(x + style.width, y + 13 * dy);
    }
    function _iconMarkClear(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x + 4 * dx, y + 15 * dy);
        ctx.lineTo(x + 9 * dx, y + 13 * dy);
        ctx.lineTo(x + 14 * dx, y + 8 * dy);
        ctx.lineTo(x + 11 * dx, y + 5 * dy);
        ctx.lineTo(x + 6 * dx, y + 10 * dy);
        ctx.lineTo(x + 4 * dx, y + 15 * dy);
        ctx.moveTo(x + 5 * dx, y);
        ctx.lineTo(x + 11 * dx, y);
        ctx.moveTo(x + 5 * dx, y + dy);
        ctx.lineTo(x + 11 * dx, y + dy);
        ctx.moveTo(x, y + 2 * dy);
        ctx.lineTo(x + style.width, y + 2 * dy);
        ctx.moveTo(x, y + 5 * dy);
        ctx.lineTo(x + 3 * dx, y + style.height);
        ctx.lineTo(x + 13 * dx, y + style.height);
        ctx.lineTo(x + style.width, y + 5 * dy);
    }
    function _iconDataZoom(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x, y + 3 * dy);
        ctx.lineTo(x + 6 * dx, y + 3 * dy);
        ctx.moveTo(x + 3 * dx, y);
        ctx.lineTo(x + 3 * dx, y + 6 * dy);
        ctx.moveTo(x + 3 * dx, y + 8 * dy);
        ctx.lineTo(x + 3 * dx, y + style.height);
        ctx.lineTo(x + style.width, y + style.height);
        ctx.lineTo(x + style.width, y + 3 * dy);
        ctx.lineTo(x + 8 * dx, y + 3 * dy);
    }
    function _iconDataZoomReset(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x + 6 * dx, y);
        ctx.lineTo(x + 2 * dx, y + 3 * dy);
        ctx.lineTo(x + 6 * dx, y + 6 * dy);
        ctx.moveTo(x + 2 * dx, y + 3 * dy);
        ctx.lineTo(x + 14 * dx, y + 3 * dy);
        ctx.lineTo(x + 14 * dx, y + 11 * dy);
        ctx.moveTo(x + 2 * dx, y + 5 * dy);
        ctx.lineTo(x + 2 * dx, y + 13 * dy);
        ctx.lineTo(x + 14 * dx, y + 13 * dy);
        ctx.moveTo(x + 10 * dx, y + 10 * dy);
        ctx.lineTo(x + 14 * dx, y + 13 * dy);
        ctx.lineTo(x + 10 * dx, y + style.height);
    }
    function _iconRestore(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        var r = style.width / 2;
        ctx.lineWidth = 1.5;
        ctx.arc(x + r, y + r, r - dx, 0, Math.PI * 2 / 3);
        ctx.moveTo(x + 3 * dx, y + style.height);
        ctx.lineTo(x + 0 * dx, y + 12 * dy);
        ctx.lineTo(x + 5 * dx, y + 11 * dy);
        ctx.moveTo(x, y + 8 * dy);
        ctx.arc(x + r, y + r, r - dx, Math.PI, Math.PI * 5 / 3);
        ctx.moveTo(x + 13 * dx, y);
        ctx.lineTo(x + style.width, y + 4 * dy);
        ctx.lineTo(x + 11 * dx, y + 5 * dy);
    }
    function _iconLineChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + style.height);
        ctx.lineTo(x + style.width, y + style.height);
        ctx.moveTo(x + 2 * dx, y + 14 * dy);
        ctx.lineTo(x + 7 * dx, y + 6 * dy);
        ctx.lineTo(x + 11 * dx, y + 11 * dy);
        ctx.lineTo(x + 15 * dx, y + 2 * dy);
    }
    function _iconBarChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + style.height);
        ctx.lineTo(x + style.width, y + style.height);
        ctx.moveTo(x + 3 * dx, y + 14 * dy);
        ctx.lineTo(x + 3 * dx, y + 6 * dy);
        ctx.lineTo(x + 4 * dx, y + 6 * dy);
        ctx.lineTo(x + 4 * dx, y + 14 * dy);
        ctx.moveTo(x + 7 * dx, y + 14 * dy);
        ctx.lineTo(x + 7 * dx, y + 2 * dy);
        ctx.lineTo(x + 8 * dx, y + 2 * dy);
        ctx.lineTo(x + 8 * dx, y + 14 * dy);
        ctx.moveTo(x + 11 * dx, y + 14 * dy);
        ctx.lineTo(x + 11 * dx, y + 9 * dy);
        ctx.lineTo(x + 12 * dx, y + 9 * dy);
        ctx.lineTo(x + 12 * dx, y + 14 * dy);
    }
    function _iconPieChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width - 2;
        var height = style.height - 2;
        var r = Math.min(width, height) / 2;
        y += 2;
        ctx.moveTo(x + r + 3, y + r - 3);
        ctx.arc(x + r + 3, y + r - 3, r - 1, 0, -Math.PI / 2, true);
        ctx.lineTo(x + r + 3, y + r - 3);
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + r, y + r);
        ctx.arc(x + r, y + r, r, -Math.PI / 2, Math.PI * 2, true);
        ctx.lineTo(x + r, y + r);
        ctx.lineWidth = 1.5;
    }
    function _iconFunnelChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        y -= dy;
        ctx.moveTo(x + 1 * dx, y + 2 * dy);
        ctx.lineTo(x + 15 * dx, y + 2 * dy);
        ctx.lineTo(x + 14 * dx, y + 3 * dy);
        ctx.lineTo(x + 2 * dx, y + 3 * dy);
        ctx.moveTo(x + 3 * dx, y + 6 * dy);
        ctx.lineTo(x + 13 * dx, y + 6 * dy);
        ctx.lineTo(x + 12 * dx, y + 7 * dy);
        ctx.lineTo(x + 4 * dx, y + 7 * dy);
        ctx.moveTo(x + 5 * dx, y + 10 * dy);
        ctx.lineTo(x + 11 * dx, y + 10 * dy);
        ctx.lineTo(x + 10 * dx, y + 11 * dy);
        ctx.lineTo(x + 6 * dx, y + 11 * dy);
        ctx.moveTo(x + 7 * dx, y + 14 * dy);
        ctx.lineTo(x + 9 * dx, y + 14 * dy);
        ctx.lineTo(x + 8 * dx, y + 15 * dy);
        ctx.lineTo(x + 7 * dx, y + 15 * dy);
    }
    function _iconForceChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width;
        var height = style.height;
        var dx = width / 16;
        var dy = height / 16;
        var r = Math.min(dx, dy) * 2;
        ctx.moveTo(x + dx + r, y + dy + r);
        ctx.arc(x + dx, y + dy, r, Math.PI / 4, Math.PI * 3);
        ctx.lineTo(x + 7 * dx - r, y + 6 * dy - r);
        ctx.arc(x + 7 * dx, y + 6 * dy, r, Math.PI / 4 * 5, Math.PI * 4);
        ctx.arc(x + 7 * dx, y + 6 * dy, r / 2, Math.PI / 4 * 5, Math.PI * 4);
        ctx.moveTo(x + 7 * dx - r / 2, y + 6 * dy + r);
        ctx.lineTo(x + dx + r, y + 14 * dy - r);
        ctx.arc(x + dx, y + 14 * dy, r, -Math.PI / 4, Math.PI * 2);
        ctx.moveTo(x + 7 * dx + r / 2, y + 6 * dy);
        ctx.lineTo(x + 14 * dx - r, y + 10 * dy - r / 2);
        ctx.moveTo(x + 16 * dx, y + 10 * dy);
        ctx.arc(x + 14 * dx, y + 10 * dy, r, 0, Math.PI * 3);
        ctx.lineWidth = 1.5;
    }
    function _iconChordChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width;
        var height = style.height;
        var r = Math.min(width, height) / 2;
        ctx.moveTo(x + width, y + height / 2);
        ctx.arc(x + r, y + r, r, 0, Math.PI * 2);
        ctx.arc(x + r, y, r, Math.PI / 4, Math.PI / 5 * 4);
        ctx.arc(x, y + r, r, -Math.PI / 3, Math.PI / 3);
        ctx.arc(x + width, y + height, r, Math.PI, Math.PI / 2 * 3);
        ctx.lineWidth = 1.5;
    }
    function _iconStackChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width;
        var height = style.height;
        var dy = Math.round(height / 3);
        var len = 3;
        while (len--) {
            ctx.rect(x, y + dy * len + 2, width, 2);
        }
    }
    function _iconTiledChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width;
        var height = style.height;
        var dx = Math.round(width / 3);
        var len = 3;
        while (len--) {
            ctx.rect(x + dx * len, y, 2, height);
        }
    }
    function _iconDataView(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        ctx.moveTo(x + dx, y);
        ctx.lineTo(x + dx, y + style.height);
        ctx.lineTo(x + 15 * dx, y + style.height);
        ctx.lineTo(x + 15 * dx, y);
        ctx.lineTo(x + dx, y);
        ctx.moveTo(x + 3 * dx, y + 3 * dx);
        ctx.lineTo(x + 13 * dx, y + 3 * dx);
        ctx.moveTo(x + 3 * dx, y + 6 * dx);
        ctx.lineTo(x + 13 * dx, y + 6 * dx);
        ctx.moveTo(x + 3 * dx, y + 9 * dx);
        ctx.lineTo(x + 13 * dx, y + 9 * dx);
        ctx.moveTo(x + 3 * dx, y + 12 * dx);
        ctx.lineTo(x + 9 * dx, y + 12 * dx);
    }
    function _iconSave(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + style.height);
        ctx.lineTo(x + style.width, y + style.height);
        ctx.lineTo(x + style.width, y);
        ctx.lineTo(x, y);
        ctx.moveTo(x + 4 * dx, y);
        ctx.lineTo(x + 4 * dx, y + 8 * dy);
        ctx.lineTo(x + 12 * dx, y + 8 * dy);
        ctx.lineTo(x + 12 * dx, y);
        ctx.moveTo(x + 6 * dx, y + 11 * dy);
        ctx.lineTo(x + 6 * dx, y + 13 * dy);
        ctx.lineTo(x + 10 * dx, y + 13 * dy);
        ctx.lineTo(x + 10 * dx, y + 11 * dy);
        ctx.lineTo(x + 6 * dx, y + 11 * dy);
    }
    function _iconCross(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width;
        var height = style.height;
        ctx.moveTo(x, y + height / 2);
        ctx.lineTo(x + width, y + height / 2);
        ctx.moveTo(x + width / 2, y);
        ctx.lineTo(x + width / 2, y + height);
    }
    function _iconCircle(ctx, style) {
        var width = style.width / 2;
        var height = style.height / 2;
        var r = Math.min(width, height);
        ctx.moveTo(style.x + width + r, style.y + height);
        ctx.arc(style.x + width, style.y + height, r, 0, Math.PI * 2);
        ctx.closePath();
    }
    function _iconRectangle(ctx, style) {
        ctx.rect(style.x, style.y, style.width, style.height);
        ctx.closePath();
    }
    function _iconTriangle(ctx, style) {
        var width = style.width / 2;
        var height = style.height / 2;
        var x = style.x + width;
        var y = style.y + height;
        var symbolSize = Math.min(width, height);
        ctx.moveTo(x, y - symbolSize);
        ctx.lineTo(x + symbolSize, y + symbolSize);
        ctx.lineTo(x - symbolSize, y + symbolSize);
        ctx.lineTo(x, y - symbolSize);
        ctx.closePath();
    }
    function _iconDiamond(ctx, style) {
        var width = style.width / 2;
        var height = style.height / 2;
        var x = style.x + width;
        var y = style.y + height;
        var symbolSize = Math.min(width, height);
        ctx.moveTo(x, y - symbolSize);
        ctx.lineTo(x + symbolSize, y);
        ctx.lineTo(x, y + symbolSize);
        ctx.lineTo(x - symbolSize, y);
        ctx.lineTo(x, y - symbolSize);
        ctx.closePath();
    }
    function _iconArrow(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        ctx.moveTo(x + 8 * dx, y);
        ctx.lineTo(x + dx, y + style.height);
        ctx.lineTo(x + 8 * dx, y + style.height / 4 * 3);
        ctx.lineTo(x + 15 * dx, y + style.height);
        ctx.lineTo(x + 8 * dx, y);
        ctx.closePath();
    }
    function _iconStar(ctx, style) {
        var StarShape = require(&#x27;zrender/shape/Star&#x27;);
        var width = style.width / 2;
        var height = style.height / 2;
        StarShape.prototype.buildPath(ctx, {
            x: style.x + width,
            y: style.y + height,
            r: Math.min(width, height),
            n: style.n || 5
        });
    }
    function _iconHeart(ctx, style) {
        var HeartShape = require(&#x27;zrender/shape/Heart&#x27;);
        HeartShape.prototype.buildPath(ctx, {
            x: style.x + style.width / 2,
            y: style.y + style.height * 0.2,
            a: style.width / 2,
            b: style.height * 0.8
        });
    }
    function _iconDroplet(ctx, style) {
        var DropletShape = require(&#x27;zrender/shape/Droplet&#x27;);
        DropletShape.prototype.buildPath(ctx, {
            x: style.x + style.width * 0.5,
            y: style.y + style.height * 0.5,
            a: style.width * 0.5,
            b: style.height * 0.8
        });
    }
    function _iconPin(ctx, style) {
        var x = style.x;
        var y = style.y - style.height / 2 * 1.5;
        var width = style.width / 2;
        var height = style.height / 2;
        var r = Math.min(width, height);
        ctx.arc(x + width, y + height, r, Math.PI / 5 * 4, Math.PI / 5);
        ctx.lineTo(x + width, y + height + r * 1.5);
        ctx.closePath();
    }
    function _iconImage(ctx, style, refreshNextFrame) {
        var ImageShape = require(&#x27;zrender/shape/Image&#x27;);
        this._imageShape = this._imageShape || new ImageShape({ style: {} });
        for (var name in style) {
            this._imageShape.style[name] = style[name];
        }
        this._imageShape.brush(ctx, false, refreshNextFrame);
    }
    var Base = require(&#x27;zrender/shape/Base&#x27;);
    function Icon(options) {
        Base.call(this, options);
    }
    Icon.prototype = {
        type: &#x27;icon&#x27;,
        iconLibrary: {
            mark: _iconMark,
            markUndo: _iconMarkUndo,
            markClear: _iconMarkClear,
            dataZoom: _iconDataZoom,
            dataZoomReset: _iconDataZoomReset,
            restore: _iconRestore,
            lineChart: _iconLineChart,
            barChart: _iconBarChart,
            pieChart: _iconPieChart,
            funnelChart: _iconFunnelChart,
            forceChart: _iconForceChart,
            chordChart: _iconChordChart,
            stackChart: _iconStackChart,
            tiledChart: _iconTiledChart,
            dataView: _iconDataView,
            saveAsImage: _iconSave,
            cross: _iconCross,
            circle: _iconCircle,
            rectangle: _iconRectangle,
            triangle: _iconTriangle,
            diamond: _iconDiamond,
            arrow: _iconArrow,
            star: _iconStar,
            heart: _iconHeart,
            droplet: _iconDroplet,
            pin: _iconPin,
            image: _iconImage
        },
        brush: function (ctx, isHighlight, refreshNextFrame) {
            var style = isHighlight ? this.highlightStyle : this.style;
            style = style || {};
            var iconType = style.iconType || this.style.iconType;
            if (iconType === &#x27;image&#x27;) {
                var ImageShape = require(&#x27;zrender/shape/Image&#x27;);
                ImageShape.prototype.brush.call(this, ctx, isHighlight, refreshNextFrame);
            } else {
                var style = this.beforeBrush(ctx, isHighlight);
                ctx.beginPath();
                this.buildPath(ctx, style, refreshNextFrame);
                switch (style.brushType) {
                case &#x27;both&#x27;:
                    ctx.fill();
                case &#x27;stroke&#x27;:
                    style.lineWidth &gt; 0 &amp;&amp; ctx.stroke();
                    break;
                default:
                    ctx.fill();
                }
                this.drawText(ctx, style, this.style);
                this.afterBrush(ctx);
            }
        },
        buildPath: function (ctx, style, refreshNextFrame) {
            if (this.iconLibrary[style.iconType]) {
                this.iconLibrary[style.iconType].call(this, ctx, style, refreshNextFrame);
            } else {
                ctx.moveTo(style.x, style.y);
                ctx.lineTo(style.x + style.width, style.y);
                ctx.lineTo(style.x + style.width, style.y + style.height);
                ctx.lineTo(style.x, style.y + style.height);
                ctx.lineTo(style.x, style.y);
                ctx.closePath();
            }
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            style.__rect = {
                x: Math.round(style.x),
                y: Math.round(style.y - (style.iconType == &#x27;pin&#x27; ? style.height / 2 * 1.5 : 0)),
                width: style.width,
                height: style.height
            };
            return style.__rect;
        },
        isCover: function (x, y) {
            var originPos = this.getTansform(x, y);
            x = originPos[0];
            y = originPos[1];
            var rect = this.style.__rect;
            if (!rect) {
                rect = this.style.__rect = this.getRect(this.style);
            }
            var delta = rect.height &lt; 8 || rect.width &lt; 8 ? 4 : 0;
            if (x &gt;= rect.x - delta &amp;&amp; x &lt;= rect.x + rect.width + delta &amp;&amp; y &gt;= rect.y - delta &amp;&amp; y &lt;= rect.y + rect.height + delta) {
                return true;
            } else {
                return false;
            }
        }
    };
    zrUtil.inherits(Icon, Base);
    return Icon;
});define(&#x27;echarts/util/shape/MarkLine&#x27;, [
    &#x27;require&#x27;,
    &#x27;zrender/shape/Base&#x27;,
    &#x27;./Icon&#x27;,
    &#x27;zrender/shape/Line&#x27;,
    &#x27;zrender/shape/BrokenLine&#x27;,
    &#x27;zrender/tool/matrix&#x27;,
    &#x27;zrender/tool/area&#x27;,
    &#x27;zrender/shape/util/dashedLineTo&#x27;,
    &#x27;zrender/shape/util/smoothSpline&#x27;,
    &#x27;zrender/tool/util&#x27;
], function (require) {
    var Base = require(&#x27;zrender/shape/Base&#x27;);
    var IconShape = require(&#x27;./Icon&#x27;);
    var LineShape = require(&#x27;zrender/shape/Line&#x27;);
    var lineInstance = new LineShape({});
    var BrokenLineShape = require(&#x27;zrender/shape/BrokenLine&#x27;);
    var brokenLineInstance = new BrokenLineShape({});
    var matrix = require(&#x27;zrender/tool/matrix&#x27;);
    var area = require(&#x27;zrender/tool/area&#x27;);
    var dashedLineTo = require(&#x27;zrender/shape/util/dashedLineTo&#x27;);
    var smoothSpline = require(&#x27;zrender/shape/util/smoothSpline&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    function MarkLine(options) {
        Base.call(this, options);
    }
    MarkLine.prototype = {
        type: &#x27;mark-line&#x27;,
        brush: function (ctx, isHighlight) {
            var style = this.style;
            if (isHighlight) {
                style = this.getHighlightStyle(style, this.highlightStyle || {});
            }
            ctx.save();
            this.setContext(ctx, style);
            this.setTransform(ctx);
            ctx.save();
            ctx.beginPath();
            this.buildLinePath(ctx, style, this.style.lineWidth || 1);
            ctx.stroke();
            ctx.restore();
            this.brushSymbol(ctx, style, 0);
            this.brushSymbol(ctx, style, 1);
            this.drawText(ctx, style, this.style);
            ctx.restore();
        },
        buildLinePath: function (ctx, style, lineWidth) {
            var pointList = style.pointList || this.getPointList(style);
            style.pointList = pointList;
            var len = Math.min(style.pointList.length, Math.round(style.pointListLength || style.pointList.length));
            if (!style.lineType || style.lineType == &#x27;solid&#x27;) {
                ctx.moveTo(pointList[0][0], pointList[0][1]);
                for (var i = 1; i &lt; len; i++) {
                    ctx.lineTo(pointList[i][0], pointList[i][1]);
                }
            } else if (style.lineType == &#x27;dashed&#x27; || style.lineType == &#x27;dotted&#x27;) {
                if (style.smooth !== &#x27;spline&#x27;) {
                    var dashLength = lineWidth * (style.lineType == &#x27;dashed&#x27; ? 5 : 1);
                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    for (var i = 1; i &lt; len; i++) {
                        dashedLineTo(ctx, pointList[i - 1][0], pointList[i - 1][1], pointList[i][0], pointList[i][1], dashLength);
                    }
                } else {
                    for (var i = 1; i &lt; len; i += 2) {
                        ctx.moveTo(pointList[i - 1][0], pointList[i - 1][1]);
                        ctx.lineTo(pointList[i][0], pointList[i][1]);
                    }
                }
            }
        },
        brushSymbol: function (ctx, style, idx) {
            if (style.symbol[idx] == &#x27;none&#x27;) {
                return;
            }
            ctx.save();
            ctx.beginPath();
            ctx.lineWidth = style.symbolBorder;
            ctx.strokeStyle = style.symbolBorderColor;
            style.iconType = style.symbol[idx].replace(&#x27;empty&#x27;, &#x27;&#x27;).toLowerCase();
            if (style.symbol[idx].match(&#x27;empty&#x27;)) {
                ctx.fillStyle = &#x27;#fff&#x27;;
            }
            var len = Math.min(style.pointList.length, Math.round(style.pointListLength || style.pointList.length));
            var x = idx === 0 ? style.pointList[0][0] : style.pointList[len - 1][0];
            var y = idx === 0 ? style.pointList[0][1] : style.pointList[len - 1][1];
            var rotate = typeof style.symbolRotate[idx] != &#x27;undefined&#x27; ? style.symbolRotate[idx] - 0 : 0;
            var transform;
            if (rotate !== 0) {
                transform = matrix.create();
                matrix.identity(transform);
                if (x || y) {
                    matrix.translate(transform, transform, [
                        -x,
                        -y
                    ]);
                }
                matrix.rotate(transform, transform, rotate * Math.PI / 180);
                if (x || y) {
                    matrix.translate(transform, transform, [
                        x,
                        y
                    ]);
                }
                ctx.transform.apply(ctx, transform);
            }
            if (style.iconType == &#x27;arrow&#x27; &amp;&amp; rotate === 0) {
                this.buildArrawPath(ctx, style, idx);
            } else {
                var symbolSize = style.symbolSize[idx];
                style.x = x - symbolSize;
                style.y = y - symbolSize, style.width = symbolSize * 2;
                style.height = symbolSize * 2;
                IconShape.prototype.buildPath(ctx, style);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        },
        buildArrawPath: function (ctx, style, idx) {
            var len = Math.min(style.pointList.length, Math.round(style.pointListLength || style.pointList.length));
            var symbolSize = style.symbolSize[idx] * 2;
            var xStart = style.pointList[0][0];
            var xEnd = style.pointList[len - 1][0];
            var yStart = style.pointList[0][1];
            var yEnd = style.pointList[len - 1][1];
            var delta = 0;
            if (style.smooth === &#x27;spline&#x27;) {
                delta = 0.2;
            }
            var rotate = Math.atan(Math.abs((yEnd - yStart) / (xStart - xEnd)));
            if (idx === 0) {
                if (xEnd &gt; xStart) {
                    if (yEnd &gt; yStart) {
                        rotate = Math.PI * 2 - rotate + delta;
                    } else {
                        rotate += delta;
                    }
                } else {
                    if (yEnd &gt; yStart) {
                        rotate += Math.PI - delta;
                    } else {
                        rotate = Math.PI - rotate - delta;
                    }
                }
            } else {
                if (xStart &gt; xEnd) {
                    if (yStart &gt; yEnd) {
                        rotate = Math.PI * 2 - rotate + delta;
                    } else {
                        rotate += delta;
                    }
                } else {
                    if (yStart &gt; yEnd) {
                        rotate += Math.PI - delta;
                    } else {
                        rotate = Math.PI - rotate - delta;
                    }
                }
            }
            var halfRotate = Math.PI / 8;
            var x = idx === 0 ? xStart : xEnd;
            var y = idx === 0 ? yStart : yEnd;
            var point = [
                [
                    x + symbolSize * Math.cos(rotate - halfRotate),
                    y - symbolSize * Math.sin(rotate - halfRotate)
                ],
                [
                    x + symbolSize * 0.6 * Math.cos(rotate),
                    y - symbolSize * 0.6 * Math.sin(rotate)
                ],
                [
                    x + symbolSize * Math.cos(rotate + halfRotate),
                    y - symbolSize * Math.sin(rotate + halfRotate)
                ]
            ];
            ctx.moveTo(x, y);
            for (var i = 0, l = point.length; i &lt; l; i++) {
                ctx.lineTo(point[i][0], point[i][1]);
            }
            ctx.lineTo(x, y);
        },
        getPointList: function (style) {
            var pointList = [
                [
                    style.xStart,
                    style.yStart
                ],
                [
                    style.xEnd,
                    style.yEnd
                ]
            ];
            if (style.smooth === &#x27;spline&#x27;) {
                var lastPointX = pointList[1][0];
                var lastPointY = pointList[1][1];
                pointList[3] = [
                    lastPointX,
                    lastPointY
                ];
                pointList[1] = this.getOffetPoint(pointList[0], pointList[3]);
                pointList[2] = this.getOffetPoint(pointList[3], pointList[0]);
                pointList = smoothSpline(pointList, false);
                pointList[pointList.length - 1] = [
                    lastPointX,
                    lastPointY
                ];
            }
            return pointList;
        },
        getOffetPoint: function (sp, ep) {
            var distance = Math.sqrt(Math.round((sp[0] - ep[0]) * (sp[0] - ep[0]) + (sp[1] - ep[1]) * (sp[1] - ep[1]))) / 3;
            var mp = [
                sp[0],
                sp[1]
            ];
            var angle;
            var deltaAngle = 0.2;
            if (sp[0] != ep[0] &amp;&amp; sp[1] != ep[1]) {
                var k = (ep[1] - sp[1]) / (ep[0] - sp[0]);
                angle = Math.atan(k);
            } else if (sp[0] == ep[0]) {
                angle = (sp[1] &lt;= ep[1] ? 1 : -1) * Math.PI / 2;
            } else {
                angle = 0;
            }
            var dX;
            var dY;
            if (sp[0] &lt;= ep[0]) {
                angle -= deltaAngle;
                dX = Math.round(Math.cos(angle) * distance);
                dY = Math.round(Math.sin(angle) * distance);
                mp[0] += dX;
                mp[1] += dY;
            } else {
                angle += deltaAngle;
                dX = Math.round(Math.cos(angle) * distance);
                dY = Math.round(Math.sin(angle) * distance);
                mp[0] -= dX;
                mp[1] -= dY;
            }
            return mp;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var lineWidth = style.lineWidth || 1;
            style.__rect = {
                x: Math.min(style.xStart, style.xEnd) - lineWidth,
                y: Math.min(style.yStart, style.yEnd) - lineWidth,
                width: Math.abs(style.xStart - style.xEnd) + lineWidth,
                height: Math.abs(style.yStart - style.yEnd) + lineWidth
            };
            return style.__rect;
        },
        isCover: function (x, y) {
            var originPos = this.getTansform(x, y);
            x = originPos[0];
            y = originPos[1];
            var rect = this.style.__rect;
            if (!rect) {
                rect = this.style.__rect = this.getRect(this.style);
            }
            if (x &gt;= rect.x &amp;&amp; x &lt;= rect.x + rect.width &amp;&amp; y &gt;= rect.y &amp;&amp; y &lt;= rect.y + rect.height) {
                return this.style.smooth !== &#x27;spline&#x27; ? area.isInside(lineInstance, this.style, x, y) : area.isInside(brokenLineInstance, this.style, x, y);
            }
            return false;
        }
    };
    zrUtil.inherits(MarkLine, Base);
    return MarkLine;
});define(&#x27;echarts/util/shape/Symbol&#x27;, [
    &#x27;require&#x27;,
    &#x27;zrender/shape/Base&#x27;,
    &#x27;zrender/shape/Polygon&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;./normalIsCover&#x27;
], function (require) {
    var Base = require(&#x27;zrender/shape/Base&#x27;);
    var PolygonShape = require(&#x27;zrender/shape/Polygon&#x27;);
    var polygonInstance = new PolygonShape({});
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    function Symbol(options) {
        Base.call(this, options);
    }
    Symbol.prototype = {
        type: &#x27;symbol&#x27;,
        buildPath: function (ctx, style) {
            var pointList = style.pointList;
            var len = pointList.length;
            if (len === 0) {
                return;
            }
            var subSize = 10000;
            var subSetLength = Math.ceil(len / subSize);
            var sub;
            var subLen;
            var isArray = pointList[0] instanceof Array;
            var size = style.size ? style.size : 2;
            var curSize = size;
            var halfSize = size / 2;
            var PI2 = Math.PI * 2;
            var percent;
            var x;
            var y;
            for (var j = 0; j &lt; subSetLength; j++) {
                ctx.beginPath();
                sub = j * subSize;
                subLen = sub + subSize;
                subLen = subLen &gt; len ? len : subLen;
                for (var i = sub; i &lt; subLen; i++) {
                    if (style.random) {
                        percent = style[&#x27;randomMap&#x27; + i % 20] / 100;
                        curSize = size * percent * percent;
                        halfSize = curSize / 2;
                    }
                    if (isArray) {
                        x = pointList[i][0];
                        y = pointList[i][1];
                    } else {
                        x = pointList[i].x;
                        y = pointList[i].y;
                    }
                    if (curSize &lt; 3) {
                        ctx.rect(x - halfSize, y - halfSize, curSize, curSize);
                    } else {
                        switch (style.iconType) {
                        case &#x27;circle&#x27;:
                            ctx.moveTo(x, y);
                            ctx.arc(x, y, halfSize, 0, PI2, true);
                            break;
                        case &#x27;diamond&#x27;:
                            ctx.moveTo(x, y - halfSize);
                            ctx.lineTo(x + halfSize / 3, y - halfSize / 3);
                            ctx.lineTo(x + halfSize, y);
                            ctx.lineTo(x + halfSize / 3, y + halfSize / 3);
                            ctx.lineTo(x, y + halfSize);
                            ctx.lineTo(x - halfSize / 3, y + halfSize / 3);
                            ctx.lineTo(x - halfSize, y);
                            ctx.lineTo(x - halfSize / 3, y - halfSize / 3);
                            ctx.lineTo(x, y - halfSize);
                            break;
                        default:
                            ctx.rect(x - halfSize, y - halfSize, curSize, curSize);
                        }
                    }
                }
                ctx.closePath();
                if (j &lt; subSetLength - 1) {
                    switch (style.brushType) {
                    case &#x27;both&#x27;:
                        ctx.fill();
                        style.lineWidth &gt; 0 &amp;&amp; ctx.stroke();
                        break;
                    case &#x27;stroke&#x27;:
                        style.lineWidth &gt; 0 &amp;&amp; ctx.stroke();
                        break;
                    default:
                        ctx.fill();
                    }
                }
            }
        },
        getRect: function (style) {
            return style.__rect || polygonInstance.getRect(style);
        },
        isCover: require(&#x27;./normalIsCover&#x27;)
    };
    zrUtil.inherits(Symbol, Base);
    return Symbol;
});define(&#x27;echarts/util/ecAnimation&#x27;, [
    &#x27;require&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;zrender/shape/Polygon&#x27;
], function (require) {
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    function pointList(zr, oldShape, newShape, duration, easing) {
        var newPointList = newShape.style.pointList;
        var newPointListLen = newPointList.length;
        var oldPointList;
        if (!oldShape) {
            oldPointList = [];
            if (newShape._orient != &#x27;vertical&#x27;) {
                var y = newPointList[0][1];
                for (var i = 0; i &lt; newPointListLen; i++) {
                    oldPointList[i] = [
                        newPointList[i][0],
                        y
                    ];
                }
            } else {
                var x = newPointList[0][0];
                for (var i = 0; i &lt; newPointListLen; i++) {
                    oldPointList[i] = [
                        x,
                        newPointList[i][1]
                    ];
                }
            }
            if (newShape.type == &#x27;half-smooth-polygon&#x27;) {
                oldPointList[newPointListLen - 1] = zrUtil.clone(newPointList[newPointListLen - 1]);
                oldPointList[newPointListLen - 2] = zrUtil.clone(newPointList[newPointListLen - 2]);
            }
            oldShape = { style: { pointList: oldPointList } };
        }
        oldPointList = oldShape.style.pointList;
        var oldPointListLen = oldPointList.length;
        if (oldPointListLen == newPointListLen) {
            newShape.style.pointList = oldPointList;
        } else if (oldPointListLen &lt; newPointListLen) {
            newShape.style.pointList = oldPointList.concat(newPointList.slice(oldPointListLen));
        } else {
            newShape.style.pointList = oldPointList.slice(0, newPointListLen);
        }
        zr.addShape(newShape);
        zr.animate(newShape.id, &#x27;style&#x27;).when(duration, { pointList: newPointList }).start(easing);
    }
    function cloneStyle(target, source) {
        var len = arguments.length;
        for (var i = 2; i &lt; len; i++) {
            var prop = arguments[i];
            target.style[prop] = source.style[prop];
        }
    }
    function rectangle(zr, oldShape, newShape, duration, easing) {
        var newShapeStyle = newShape.style;
        if (!oldShape) {
            oldShape = {
                position: newShape.position,
                style: {
                    x: newShapeStyle.x,
                    y: newShape._orient == &#x27;vertical&#x27; ? newShapeStyle.y + newShapeStyle.height : newShapeStyle.y,
                    width: newShape._orient == &#x27;vertical&#x27; ? newShapeStyle.width : 0,
                    height: newShape._orient != &#x27;vertical&#x27; ? newShapeStyle.height : 0
                }
            };
        }
        var newX = newShapeStyle.x;
        var newY = newShapeStyle.y;
        var newWidth = newShapeStyle.width;
        var newHeight = newShapeStyle.height;
        var newPosition = [
            newShape.position[0],
            newShape.position[1]
        ];
        cloneStyle(newShape, oldShape, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;width&#x27;, &#x27;height&#x27;);
        newShape.position = oldShape.position;
        zr.addShape(newShape);
        if (newPosition[0] != oldShape.position[0] || newPosition[1] != oldShape.position[1]) {
            zr.animate(newShape.id, &#x27;&#x27;).when(duration, { position: newPosition }).start(easing);
        }
        zr.animate(newShape.id, &#x27;style&#x27;).when(duration, {
            x: newX,
            y: newY,
            width: newWidth,
            height: newHeight
        }).start(easing);
    }
    function candle(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {
            var y = newShape.style.y;
            oldShape = {
                style: {
                    y: [
                        y[0],
                        y[0],
                        y[0],
                        y[0]
                    ]
                }
            };
        }
        var newY = newShape.style.y;
        newShape.style.y = oldShape.style.y;
        zr.addShape(newShape);
        zr.animate(newShape.id, &#x27;style&#x27;).when(duration, { y: newY }).start(easing);
    }
    function ring(zr, oldShape, newShape, duration, easing) {
        var x = newShape.style.x;
        var y = newShape.style.y;
        var r0 = newShape.style.r0;
        var r = newShape.style.r;
        if (newShape._animationAdd != &#x27;r&#x27;) {
            newShape.style.r0 = 0;
            newShape.style.r = 0;
            newShape.rotation = [
                Math.PI * 2,
                x,
                y
            ];
            zr.addShape(newShape);
            zr.animate(newShape.id, &#x27;style&#x27;).when(duration, {
                r0: r0,
                r: r
            }).start(easing);
            zr.animate(newShape.id, &#x27;&#x27;).when(Math.round(duration / 3 * 2), {
                rotation: [
                    0,
                    x,
                    y
                ]
            }).start(easing);
        } else {
            newShape.style.r0 = newShape.style.r;
            zr.addShape(newShape);
            zr.animate(newShape.id, &#x27;style&#x27;).when(duration, { r0: r0 }).start(easing);
        }
    }
    function sector(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {
            if (newShape._animationAdd != &#x27;r&#x27;) {
                oldShape = {
                    style: {
                        startAngle: newShape.style.startAngle,
                        endAngle: newShape.style.startAngle
                    }
                };
            } else {
                oldShape = { style: { r0: newShape.style.r } };
            }
        }
        var startAngle = newShape.style.startAngle;
        var endAngle = newShape.style.endAngle;
        cloneStyle(newShape, oldShape, &#x27;startAngle&#x27;, &#x27;endAngle&#x27;);
        zr.addShape(newShape);
        zr.animate(newShape.id, &#x27;style&#x27;).when(duration, {
            startAngle: startAngle,
            endAngle: endAngle
        }).start(easing);
    }
    function text(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {
            oldShape = {
                style: {
                    x: newShape.style.textAlign == &#x27;left&#x27; ? newShape.style.x + 100 : newShape.style.x - 100,
                    y: newShape.style.y
                }
            };
        }
        var x = newShape.style.x;
        var y = newShape.style.y;
        cloneStyle(newShape, oldShape, &#x27;x&#x27;, &#x27;y&#x27;);
        zr.addShape(newShape);
        zr.animate(newShape.id, &#x27;style&#x27;).when(duration, {
            x: x,
            y: y
        }).start(easing);
    }
    function polygon(zr, oldShape, newShape, duration, easing) {
        var rect = require(&#x27;zrender/shape/Polygon&#x27;).prototype.getRect(newShape.style);
        var x = rect.x + rect.width / 2;
        var y = rect.y + rect.height / 2;
        newShape.scale = [
            0.1,
            0.1,
            x,
            y
        ];
        zr.addShape(newShape);
        zr.animate(newShape.id, &#x27;&#x27;).when(duration, {
            scale: [
                1,
                1,
                x,
                y
            ]
        }).start(easing);
    }
    function ribbon(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {
            oldShape = {
                style: {
                    source0: 0,
                    source1: newShape.style.source1 &gt; 0 ? 360 : -360,
                    target0: 0,
                    target1: newShape.style.target1 &gt; 0 ? 360 : -360
                }
            };
        }
        var source0 = newShape.style.source0;
        var source1 = newShape.style.source1;
        var target0 = newShape.style.target0;
        var target1 = newShape.style.target1;
        if (oldShape.style) {
            cloneStyle(newShape, oldShape, &#x27;source0&#x27;, &#x27;source1&#x27;, &#x27;target0&#x27;, &#x27;target1&#x27;);
        }
        zr.addShape(newShape);
        zr.animate(newShape.id, &#x27;style&#x27;).when(duration, {
            source0: source0,
            source1: source1,
            target0: target0,
            target1: target1
        }).start(easing);
    }
    function gaugePointer(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {
            oldShape = { style: { angle: newShape.style.startAngle } };
        }
        var angle = newShape.style.angle;
        newShape.style.angle = oldShape.style.angle;
        zr.addShape(newShape);
        zr.animate(newShape.id, &#x27;style&#x27;).when(duration, { angle: angle }).start(easing);
    }
    function icon(zr, oldShape, newShape, duration, easing, delay) {
        newShape.style._x = newShape.style.x;
        newShape.style._y = newShape.style.y;
        newShape.style._width = newShape.style.width;
        newShape.style._height = newShape.style.height;
        if (!oldShape) {
            var x = newShape._x || 0;
            var y = newShape._y || 0;
            newShape.scale = [
                0.01,
                0.01,
                x,
                y
            ];
            zr.addShape(newShape);
            zr.animate(newShape.id, &#x27;&#x27;).delay(delay).when(duration, {
                scale: [
                    1,
                    1,
                    x,
                    y
                ]
            }).start(easing || &#x27;QuinticOut&#x27;);
        } else {
            rectangle(zr, oldShape, newShape, duration, easing);
        }
    }
    function line(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {
            oldShape = {
                style: {
                    xStart: newShape.style.xStart,
                    yStart: newShape.style.yStart,
                    xEnd: newShape.style.xStart,
                    yEnd: newShape.style.yStart
                }
            };
        }
        var xStart = newShape.style.xStart;
        var xEnd = newShape.style.xEnd;
        var yStart = newShape.style.yStart;
        var yEnd = newShape.style.yEnd;
        cloneStyle(newShape, oldShape, &#x27;xStart&#x27;, &#x27;xEnd&#x27;, &#x27;yStart&#x27;, &#x27;yEnd&#x27;);
        zr.addShape(newShape);
        zr.animate(newShape.id, &#x27;style&#x27;).when(duration, {
            xStart: xStart,
            xEnd: xEnd,
            yStart: yStart,
            yEnd: yEnd
        }).start(easing);
    }
    function markline(zr, oldShape, newShape, duration, easing) {
        if (!newShape.style.smooth) {
            newShape.style.pointList = !oldShape ? [
                [
                    newShape.style.xStart,
                    newShape.style.yStart
                ],
                [
                    newShape.style.xStart,
                    newShape.style.yStart
                ]
            ] : oldShape.style.pointList;
            zr.addShape(newShape);
            zr.animate(newShape.id, &#x27;style&#x27;).when(duration, {
                pointList: [
                    [
                        newShape.style.xStart,
                        newShape.style.yStart
                    ],
                    [
                        newShape._x || 0,
                        newShape._y || 0
                    ]
                ]
            }).start(easing || &#x27;QuinticOut&#x27;);
        } else {
            if (!oldShape) {
                newShape.style.pointListLength = 1;
                zr.addShape(newShape);
                newShape.style.pointList = newShape.style.pointList || newShape.getPointList(newShape.style);
                zr.animate(newShape.id, &#x27;style&#x27;).when(duration, { pointListLength: newShape.style.pointList.length }).start(easing || &#x27;QuinticOut&#x27;);
            } else {
                zr.addShape(newShape);
            }
        }
    }
    return {
        pointList: pointList,
        rectangle: rectangle,
        candle: candle,
        ring: ring,
        sector: sector,
        text: text,
        polygon: polygon,
        ribbon: ribbon,
        gaugePointer: gaugePointer,
        icon: icon,
        line: line,
        markline: markline
    };
});define(&#x27;echarts/util/ecEffect&#x27;, [
    &#x27;require&#x27;,
    &#x27;../util/ecData&#x27;,
    &#x27;zrender/shape/Circle&#x27;,
    &#x27;zrender/shape/Image&#x27;,
    &#x27;../util/shape/Icon&#x27;,
    &#x27;../util/shape/Symbol&#x27;,
    &#x27;zrender/tool/env&#x27;
], function (require) {
    var ecData = require(&#x27;../util/ecData&#x27;);
    var CircleShape = require(&#x27;zrender/shape/Circle&#x27;);
    var ImageShape = require(&#x27;zrender/shape/Image&#x27;);
    var IconShape = require(&#x27;../util/shape/Icon&#x27;);
    var SymbolShape = require(&#x27;../util/shape/Symbol&#x27;);
    var canvasSupported = require(&#x27;zrender/tool/env&#x27;).canvasSupported;
    function point(zr, effectList, shape, zlevel) {
        var effect = shape.effect;
        var color = effect.color || shape.style.strokeColor || shape.style.color;
        var shadowColor = effect.shadowColor || color;
        var size = effect.scaleSize;
        var shadowBlur = typeof effect.shadowBlur != &#x27;undefined&#x27; ? effect.shadowBlur : size;
        var effectShape = new IconShape({
            zlevel: zlevel,
            style: {
                brushType: &#x27;stroke&#x27;,
                iconType: shape.style.iconType != &#x27;pin&#x27; &amp;&amp; shape.style.iconType != &#x27;droplet&#x27; ? shape.style.iconType : &#x27;circle&#x27;,
                x: shadowBlur + 1,
                y: shadowBlur + 1,
                n: shape.style.n,
                width: shape.style._width * size,
                height: shape.style._height * size,
                lineWidth: 1,
                strokeColor: color,
                shadowColor: shadowColor,
                shadowBlur: shadowBlur
            },
            draggable: false,
            hoverable: false
        });
        if (canvasSupported) {
            effectShape.style.image = zr.shapeToImage(effectShape, effectShape.style.width + shadowBlur * 2 + 2, effectShape.style.height + shadowBlur * 2 + 2).style.image;
            effectShape = new ImageShape({
                zlevel: effectShape.zlevel,
                style: effectShape.style,
                draggable: false,
                hoverable: false
            });
        }
        ecData.clone(shape, effectShape);
        effectShape.position = shape.position;
        effectList.push(effectShape);
        zr.addShape(effectShape);
        var devicePixelRatio = window.devicePixelRatio || 1;
        var offset = (effectShape.style.width / devicePixelRatio - shape.style._width) / 2;
        effectShape.style.x = shape.style._x - offset;
        effectShape.style.y = shape.style._y - offset;
        var duration = (effect.period + Math.random() * 10) * 100;
        zr.modShape(shape.id, { invisible: true });
        var centerX = effectShape.style.x + effectShape.style.width / 2 / devicePixelRatio;
        var centerY = effectShape.style.y + effectShape.style.height / 2 / devicePixelRatio;
        zr.modShape(effectShape.id, {
            scale: [
                0.1,
                0.1,
                centerX,
                centerY
            ]
        });
        zr.animate(effectShape.id, &#x27;&#x27;, effect.loop).when(duration, {
            scale: [
                1,
                1,
                centerX,
                centerY
            ]
        }).done(function () {
            shape.effect.show = false;
            zr.delShape(effectShape.id);
        }).start();
    }
    function largePoint(zr, effectList, shape, zlevel) {
        var effect = shape.effect;
        var color = effect.color || shape.style.strokeColor || shape.style.color;
        var size = effect.scaleSize;
        var shadowColor = effect.shadowColor || color;
        var shadowBlur = typeof effect.shadowBlur != &#x27;undefined&#x27; ? effect.shadowBlur : size * 2;
        var devicePixelRatio = window.devicePixelRatio || 1;
        var effectShape = new SymbolShape({
            zlevel: zlevel,
            position: shape.position,
            scale: shape.scale,
            style: {
                pointList: shape.style.pointList,
                iconType: shape.style.iconType,
                color: color,
                strokeColor: color,
                shadowColor: shadowColor,
                shadowBlur: shadowBlur * devicePixelRatio,
                random: true,
                brushType: &#x27;fill&#x27;,
                lineWidth: 1,
                size: shape.style.size
            },
            draggable: false,
            hoverable: false
        });
        effectList.push(effectShape);
        zr.addShape(effectShape);
        zr.modShape(shape.id, { invisible: true });
        var duration = Math.round(effect.period * 100);
        var clip1 = {};
        var clip2 = {};
        for (var i = 0; i &lt; 20; i++) {
            effectShape.style[&#x27;randomMap&#x27; + i] = 0;
            clip1 = {};
            clip1[&#x27;randomMap&#x27; + i] = 100;
            clip2 = {};
            clip2[&#x27;randomMap&#x27; + i] = 0;
            effectShape.style[&#x27;randomMap&#x27; + i] = Math.random() * 100;
            zr.animate(effectShape.id, &#x27;style&#x27;, true).when(duration, clip1).when(duration * 2, clip2).when(duration * 3, clip1).when(duration * 4, clip1).delay(Math.random() * duration * i).start();
        }
    }
    function line(zr, effectList, shape, zlevel) {
        var effect = shape.effect;
        var color = effect.color || shape.style.strokeColor || shape.style.color;
        var shadowColor = effect.shadowColor || shape.style.strokeColor || color;
        var size = shape.style.lineWidth * effect.scaleSize;
        var shadowBlur = typeof effect.shadowBlur != &#x27;undefined&#x27; ? effect.shadowBlur : size;
        var effectShape = new CircleShape({
            zlevel: zlevel,
            style: {
                x: shadowBlur,
                y: shadowBlur,
                r: size,
                color: color,
                shadowColor: shadowColor,
                shadowBlur: shadowBlur
            },
            draggable: false,
            hoverable: false
        });
        var offset;
        if (canvasSupported) {
            effectShape.style.image = zr.shapeToImage(effectShape, (size + shadowBlur) * 2, (size + shadowBlur) * 2).style.image;
            effectShape = new ImageShape({
                zlevel: effectShape.zlevel,
                style: effectShape.style,
                draggable: false,
                hoverable: false
            });
            offset = shadowBlur;
        } else {
            offset = 0;
        }
        ecData.clone(shape, effectShape);
        effectShape.position = shape.position;
        effectList.push(effectShape);
        zr.addShape(effectShape);
        effectShape.style.x = shape.style.xStart - offset;
        effectShape.style.y = shape.style.yStart - offset;
        var distance = (shape.style.xStart - shape.style.xEnd) * (shape.style.xStart - shape.style.xEnd) + (shape.style.yStart - shape.style.yEnd) * (shape.style.yStart - shape.style.yEnd);
        var duration = Math.round(Math.sqrt(Math.round(distance * effect.period * effect.period)));
        if (!shape.style.smooth) {
            zr.animate(effectShape.id, &#x27;style&#x27;, effect.loop).when(duration, {
                x: shape._x - offset,
                y: shape._y - offset
            }).done(function () {
                shape.effect.show = false;
                zr.delShape(effectShape.id);
            }).start();
        } else {
            var pointList = shape.style.pointList || shape.getPointList(shape.style);
            var len = pointList.length;
            duration = Math.round(duration / len);
            var deferred = zr.animate(effectShape.id, &#x27;style&#x27;, effect.loop);
            var step = Math.ceil(len / 8);
            for (var j = 0; j &lt; len - step; j += step) {
                deferred.when(duration * (j + 1), {
                    x: pointList[j][0] - offset,
                    y: pointList[j][1] - offset
                });
            }
            deferred.when(duration * len, {
                x: pointList[len - 1][0] - offset,
                y: pointList[len - 1][1] - offset
            });
            deferred.done(function () {
                shape.effect.show = false;
                zr.delShape(effectShape.id);
            });
            deferred.start(&#x27;spline&#x27;);
        }
    }
    return {
        point: point,
        largePoint: largePoint,
        line: line
    };
});define(&#x27;zrender/shape/Star&#x27;, [
    &#x27;require&#x27;,
    &#x27;../tool/math&#x27;,
    &#x27;./Base&#x27;,
    &#x27;../tool/util&#x27;
], function (require) {
    var math = require(&#x27;../tool/math&#x27;);
    var sin = math.sin;
    var cos = math.cos;
    var PI = Math.PI;
    var Base = require(&#x27;./Base&#x27;);
    var Star = function (options) {
        Base.call(this, options);
    };
    Star.prototype = {
        type: &#x27;star&#x27;,
        buildPath: function (ctx, style) {
            var n = style.n;
            if (!n || n &lt; 2) {
                return;
            }
            var x = style.x;
            var y = style.y;
            var r = style.r;
            var r0 = style.r0;
            if (r0 == null) {
                r0 = n &gt; 4 ? r * cos(2 * PI / n) / cos(PI / n) : r / 3;
            }
            var dStep = PI / n;
            var deg = -PI / 2;
            var xStart = x + r * cos(deg);
            var yStart = y + r * sin(deg);
            deg += dStep;
            var pointList = style.pointList = [];
            pointList.push([
                xStart,
                yStart
            ]);
            for (var i = 0, end = n * 2 - 1, ri; i &lt; end; i++) {
                ri = i % 2 === 0 ? r0 : r;
                pointList.push([
                    x + ri * cos(deg),
                    y + ri * sin(deg)
                ]);
                deg += dStep;
            }
            pointList.push([
                xStart,
                yStart
            ]);
            ctx.moveTo(pointList[0][0], pointList[0][1]);
            for (var i = 0; i &lt; pointList.length; i++) {
                ctx.lineTo(pointList[i][0], pointList[i][1]);
            }
            ctx.closePath();
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var lineWidth;
            if (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;fill&#x27;) {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(style.x - style.r - lineWidth / 2),
                y: Math.round(style.y - style.r - lineWidth / 2),
                width: style.r * 2 + lineWidth,
                height: style.r * 2 + lineWidth
            };
            return style.__rect;
        }
    };
    require(&#x27;../tool/util&#x27;).inherits(Star, Base);
    return Star;
});define(&#x27;zrender/shape/Heart&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Base&#x27;,
    &#x27;./util/PathProxy&#x27;,
    &#x27;zrender/tool/area&#x27;,
    &#x27;../tool/util&#x27;
], function (require) {
    &#x27;use strict&#x27;;
    var Base = require(&#x27;./Base&#x27;);
    var PathProxy = require(&#x27;./util/PathProxy&#x27;);
    var area = require(&#x27;zrender/tool/area&#x27;);
    var Heart = function (options) {
        Base.call(this, options);
        this._pathProxy = new PathProxy();
    };
    Heart.prototype = {
        type: &#x27;heart&#x27;,
        buildPath: function (ctx, style) {
            var path = this._pathProxy || new PathProxy();
            path.begin(ctx);
            path.moveTo(style.x, style.y);
            path.bezierCurveTo(style.x + style.a / 2, style.y - style.b * 2 / 3, style.x + style.a * 2, style.y + style.b / 3, style.x, style.y + style.b);
            path.bezierCurveTo(style.x - style.a * 2, style.y + style.b / 3, style.x - style.a / 2, style.y - style.b * 2 / 3, style.x, style.y);
            path.closePath();
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            if (!this._pathProxy.isEmpty()) {
                this.buildPath(null, style);
            }
            return this._pathProxy.fastBoundingRect();
        },
        isCover: function (x, y) {
            var originPos = this.getTansform(x, y);
            x = originPos[0];
            y = originPos[1];
            var rect = this.getRect(this.style);
            if (x &gt;= rect.x &amp;&amp; x &lt;= rect.x + rect.width &amp;&amp; y &gt;= rect.y &amp;&amp; y &lt;= rect.y + rect.height) {
                return area.isInsidePath(this._pathProxy.pathCommands, this.style.lineWidth, this.style.brushType, x, y);
            }
        }
    };
    require(&#x27;../tool/util&#x27;).inherits(Heart, Base);
    return Heart;
});define(&#x27;zrender/shape/Droplet&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Base&#x27;,
    &#x27;./util/PathProxy&#x27;,
    &#x27;zrender/tool/area&#x27;,
    &#x27;../tool/util&#x27;
], function (require) {
    &#x27;use strict&#x27;;
    var Base = require(&#x27;./Base&#x27;);
    var PathProxy = require(&#x27;./util/PathProxy&#x27;);
    var area = require(&#x27;zrender/tool/area&#x27;);
    var Droplet = function (options) {
        Base.call(this, options);
        this._pathProxy = new PathProxy();
    };
    Droplet.prototype = {
        type: &#x27;droplet&#x27;,
        buildPath: function (ctx, style) {
            var path = this._pathProxy || new PathProxy();
            path.begin(ctx);
            path.moveTo(style.x, style.y + style.a);
            path.bezierCurveTo(style.x + style.a, style.y + style.a, style.x + style.a * 3 / 2, style.y - style.a / 3, style.x, style.y - style.b);
            path.bezierCurveTo(style.x - style.a * 3 / 2, style.y - style.a / 3, style.x - style.a, style.y + style.a, style.x, style.y + style.a);
            path.closePath();
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            if (!this._pathProxy.isEmpty()) {
                this.buildPath(null, style);
            }
            return this._pathProxy.fastBoundingRect();
        },
        isCover: function (x, y) {
            var originPos = this.getTansform(x, y);
            x = originPos[0];
            y = originPos[1];
            var rect = this.getRect(this.style);
            if (x &gt;= rect.x &amp;&amp; x &lt;= rect.x + rect.width &amp;&amp; y &gt;= rect.y &amp;&amp; y &lt;= rect.y + rect.height) {
                return area.isInsidePath(this._pathProxy.pathCommands, this.style.lineWidth, this.style.brushType, x, y);
            }
        }
    };
    require(&#x27;../tool/util&#x27;).inherits(Droplet, Base);
    return Droplet;
});define(&#x27;zrender/tool/math&#x27;, [], function () {
    var _radians = Math.PI / 180;
    function sin(angle, isDegrees) {
        return Math.sin(isDegrees ? angle * _radians : angle);
    }
    function cos(angle, isDegrees) {
        return Math.cos(isDegrees ? angle * _radians : angle);
    }
    function degreeToRadian(angle) {
        return angle * _radians;
    }
    function radianToDegree(angle) {
        return angle / _radians;
    }
    return {
        sin: sin,
        cos: cos,
        degreeToRadian: degreeToRadian,
        radianToDegree: radianToDegree
    };
});define(&#x27;zrender/shape/util/PathProxy&#x27;, [
    &#x27;require&#x27;,
    &#x27;../../tool/vector&#x27;
], function (require) {
    var vector = require(&#x27;../../tool/vector&#x27;);
    var PathSegment = function (command, points) {
        this.command = command;
        this.points = points || null;
    };
    var PathProxy = function () {
        this.pathCommands = [];
        this._ctx = null;
        this._min = [];
        this._max = [];
    };
    PathProxy.prototype.fastBoundingRect = function () {
        var min = this._min;
        var max = this._max;
        min[0] = min[1] = Infinity;
        max[0] = max[1] = -Infinity;
        for (var i = 0; i &lt; this.pathCommands.length; i++) {
            var seg = this.pathCommands[i];
            var p = seg.points;
            switch (seg.command) {
            case &#x27;M&#x27;:
                vector.min(min, min, p);
                vector.max(max, max, p);
                break;
            case &#x27;L&#x27;:
                vector.min(min, min, p);
                vector.max(max, max, p);
                break;
            case &#x27;C&#x27;:
                for (var j = 0; j &lt; 6; j += 2) {
                    min[0] = Math.min(min[0], min[0], p[j]);
                    min[1] = Math.min(min[1], min[1], p[j + 1]);
                    max[0] = Math.max(max[0], max[0], p[j]);
                    max[1] = Math.max(max[1], max[1], p[j + 1]);
                }
                break;
            case &#x27;Q&#x27;:
                for (var j = 0; j &lt; 4; j += 2) {
                    min[0] = Math.min(min[0], min[0], p[j]);
                    min[1] = Math.min(min[1], min[1], p[j + 1]);
                    max[0] = Math.max(max[0], max[0], p[j]);
                    max[1] = Math.max(max[1], max[1], p[j + 1]);
                }
                break;
            case &#x27;A&#x27;:
                var cx = p[0];
                var cy = p[1];
                var rx = p[2];
                var ry = p[3];
                min[0] = Math.min(min[0], min[0], cx - rx);
                min[1] = Math.min(min[1], min[1], cy - ry);
                max[0] = Math.max(max[0], max[0], cx + rx);
                max[1] = Math.max(max[1], max[1], cy + ry);
                break;
            }
        }
        return {
            x: min[0],
            y: min[1],
            width: max[0] - min[0],
            height: max[1] - min[1]
        };
    };
    PathProxy.prototype.begin = function (ctx) {
        this._ctx = ctx || null;
        this.pathCommands.length = 0;
        return this;
    };
    PathProxy.prototype.moveTo = function (x, y) {
        this.pathCommands.push(new PathSegment(&#x27;M&#x27;, [
            x,
            y
        ]));
        if (this._ctx) {
            this._ctx.moveTo(x, y);
        }
        return this;
    };
    PathProxy.prototype.lineTo = function (x, y) {
        this.pathCommands.push(new PathSegment(&#x27;L&#x27;, [
            x,
            y
        ]));
        if (this._ctx) {
            this._ctx.lineTo(x, y);
        }
        return this;
    };
    PathProxy.prototype.bezierCurveTo = function (x1, y1, x2, y2, x3, y3) {
        this.pathCommands.push(new PathSegment(&#x27;C&#x27;, [
            x1,
            y1,
            x2,
            y2,
            x3,
            y3
        ]));
        if (this._ctx) {
            this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
        }
        return this;
    };
    PathProxy.prototype.quadraticCurveTo = function (x1, y1, x2, y2) {
        this.pathCommands.push(new PathSegment(&#x27;Q&#x27;, [
            x1,
            y1,
            x2,
            y2
        ]));
        if (this._ctx) {
            this._ctx.quadraticCurveTo(x1, y1, x2, y2);
        }
        return this;
    };
    PathProxy.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {
        this.pathCommands.push(new PathSegment(&#x27;A&#x27;, [
            cx,
            cy,
            r,
            r,
            startAngle,
            endAngle - startAngle,
            0,
            anticlockwise ? 0 : 1
        ]));
        if (this._ctx) {
            this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
        }
        return this;
    };
    PathProxy.prototype.arcTo = function (x1, y1, x2, y2, radius) {
        if (this._ctx) {
            this._ctx.arcTo(x1, y1, x2, y2, radius);
        }
        return this;
    };
    PathProxy.prototype.rect = function (x, y, w, h) {
        if (this._ctx) {
            this._ctx.rect(x, y, w, h);
        }
        return this;
    };
    PathProxy.prototype.closePath = function () {
        this.pathCommands.push(new PathSegment(&#x27;z&#x27;));
        if (this._ctx) {
            this._ctx.closePath();
        }
        return this;
    };
    PathProxy.prototype.isEmpty = function () {
        return this.pathCommands.length === 0;
    };
    PathProxy.PathSegment = PathSegment;
    return PathProxy;
});define(&#x27;zrender/shape/Line&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Base&#x27;,
    &#x27;./util/dashedLineTo&#x27;,
    &#x27;../tool/util&#x27;
], function (require) {
    var Base = require(&#x27;./Base&#x27;);
    var dashedLineTo = require(&#x27;./util/dashedLineTo&#x27;);
    var Line = function (options) {
        this.brushTypeOnly = &#x27;stroke&#x27;;
        this.textPosition = &#x27;end&#x27;;
        Base.call(this, options);
    };
    Line.prototype = {
        type: &#x27;line&#x27;,
        buildPath: function (ctx, style) {
            if (!style.lineType || style.lineType == &#x27;solid&#x27;) {
                ctx.moveTo(style.xStart, style.yStart);
                ctx.lineTo(style.xEnd, style.yEnd);
            } else if (style.lineType == &#x27;dashed&#x27; || style.lineType == &#x27;dotted&#x27;) {
                var dashLength = (style.lineWidth || 1) * (style.lineType == &#x27;dashed&#x27; ? 5 : 1);
                dashedLineTo(ctx, style.xStart, style.yStart, style.xEnd, style.yEnd, dashLength);
            }
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var lineWidth = style.lineWidth || 1;
            style.__rect = {
                x: Math.min(style.xStart, style.xEnd) - lineWidth,
                y: Math.min(style.yStart, style.yEnd) - lineWidth,
                width: Math.abs(style.xStart - style.xEnd) + lineWidth,
                height: Math.abs(style.yStart - style.yEnd) + lineWidth
            };
            return style.__rect;
        }
    };
    require(&#x27;../tool/util&#x27;).inherits(Line, Base);
    return Line;
});define(&#x27;zrender/shape/BrokenLine&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Base&#x27;,
    &#x27;./util/smoothSpline&#x27;,
    &#x27;./util/smoothBezier&#x27;,
    &#x27;./util/dashedLineTo&#x27;,
    &#x27;./Polygon&#x27;,
    &#x27;../tool/util&#x27;
], function (require) {
    var Base = require(&#x27;./Base&#x27;);
    var smoothSpline = require(&#x27;./util/smoothSpline&#x27;);
    var smoothBezier = require(&#x27;./util/smoothBezier&#x27;);
    var dashedLineTo = require(&#x27;./util/dashedLineTo&#x27;);
    var BrokenLine = function (options) {
        this.brushTypeOnly = &#x27;stroke&#x27;;
        this.textPosition = &#x27;end&#x27;;
        Base.call(this, options);
    };
    BrokenLine.prototype = {
        type: &#x27;broken-line&#x27;,
        buildPath: function (ctx, style) {
            var pointList = style.pointList;
            if (pointList.length &lt; 2) {
                return;
            }
            var len = Math.min(style.pointList.length, Math.round(style.pointListLength || style.pointList.length));
            if (style.smooth &amp;&amp; style.smooth !== &#x27;spline&#x27;) {
                var controlPoints = smoothBezier(pointList, style.smooth, false, style.smoothConstraint);
                ctx.moveTo(pointList[0][0], pointList[0][1]);
                var cp1;
                var cp2;
                var p;
                for (var i = 0; i &lt; len - 1; i++) {
                    cp1 = controlPoints[i * 2];
                    cp2 = controlPoints[i * 2 + 1];
                    p = pointList[i + 1];
                    ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
                }
            } else {
                if (style.smooth === &#x27;spline&#x27;) {
                    pointList = smoothSpline(pointList);
                    len = pointList.length;
                }
                if (!style.lineType || style.lineType == &#x27;solid&#x27;) {
                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    for (var i = 1; i &lt; len; i++) {
                        ctx.lineTo(pointList[i][0], pointList[i][1]);
                    }
                } else if (style.lineType == &#x27;dashed&#x27; || style.lineType == &#x27;dotted&#x27;) {
                    var dashLength = (style.lineWidth || 1) * (style.lineType == &#x27;dashed&#x27; ? 5 : 1);
                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    for (var i = 1; i &lt; len; i++) {
                        dashedLineTo(ctx, pointList[i - 1][0], pointList[i - 1][1], pointList[i][0], pointList[i][1], dashLength);
                    }
                }
            }
            return;
        },
        getRect: function (style) {
            return require(&#x27;./Polygon&#x27;).prototype.getRect(style);
        }
    };
    require(&#x27;../tool/util&#x27;).inherits(BrokenLine, Base);
    return BrokenLine;
});define(&#x27;zrender/shape/util/dashedLineTo&#x27;, [], function () {
    var dashPattern = [
        5,
        5
    ];
    return function (ctx, x1, y1, x2, y2, dashLength) {
        if (ctx.setLineDash) {
            dashPattern[0] = dashPattern[1] = dashLength;
            ctx.setLineDash(dashPattern);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            return;
        }
        dashLength = typeof dashLength != &#x27;number&#x27; ? 5 : dashLength;
        var dx = x2 - x1;
        var dy = y2 - y1;
        var numDashes = Math.floor(Math.sqrt(dx * dx + dy * dy) / dashLength);
        dx = dx / numDashes;
        dy = dy / numDashes;
        var flag = true;
        for (var i = 0; i &lt; numDashes; ++i) {
            if (flag) {
                ctx.moveTo(x1, y1);
            } else {
                ctx.lineTo(x1, y1);
            }
            flag = !flag;
            x1 += dx;
            y1 += dy;
        }
        ctx.lineTo(x2, y2);
    };
});define(&#x27;zrender/shape/util/smoothSpline&#x27;, [
    &#x27;require&#x27;,
    &#x27;../../tool/vector&#x27;
], function (require) {
    var vector = require(&#x27;../../tool/vector&#x27;);
    function interpolate(p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    return function (points, isLoop, constraint) {
        var len = points.length;
        var ret = [];
        var distance = 0;
        for (var i = 1; i &lt; len; i++) {
            distance += vector.distance(points[i - 1], points[i]);
        }
        var segs = distance / 5;
        segs = segs &lt; len ? len : segs;
        for (var i = 0; i &lt; segs; i++) {
            var pos = i / (segs - 1) * (isLoop ? len : len - 1);
            var idx = Math.floor(pos);
            var w = pos - idx;
            var p0;
            var p1 = points[idx % len];
            var p2;
            var p3;
            if (!isLoop) {
                p0 = points[idx === 0 ? idx : idx - 1];
                p2 = points[idx &gt; len - 2 ? len - 1 : idx + 1];
                p3 = points[idx &gt; len - 3 ? len - 1 : idx + 2];
            } else {
                p0 = points[(idx - 1 + len) % len];
                p2 = points[(idx + 1) % len];
                p3 = points[(idx + 2) % len];
            }
            var w2 = w * w;
            var w3 = w * w2;
            ret.push([
                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
            ]);
        }
        return ret;
    };
});define(&#x27;zrender/shape/util/smoothBezier&#x27;, [
    &#x27;require&#x27;,
    &#x27;../../tool/vector&#x27;
], function (require) {
    var vector = require(&#x27;../../tool/vector&#x27;);
    return function (points, smooth, isLoop, constraint) {
        var cps = [];
        var v = [];
        var v1 = [];
        var v2 = [];
        var prevPoint;
        var nextPoint;
        var hasConstraint = !!constraint;
        var min, max;
        if (hasConstraint) {
            min = [
                Infinity,
                Infinity
            ];
            max = [
                -Infinity,
                -Infinity
            ];
            for (var i = 0, len = points.length; i &lt; len; i++) {
                vector.min(min, min, points[i]);
                vector.max(max, max, points[i]);
            }
            vector.min(min, min, constraint[0]);
            vector.max(max, max, constraint[1]);
        }
        for (var i = 0, len = points.length; i &lt; len; i++) {
            var point = points[i];
            var prevPoint;
            var nextPoint;
            if (isLoop) {
                prevPoint = points[i ? i - 1 : len - 1];
                nextPoint = points[(i + 1) % len];
            } else {
                if (i === 0 || i === len - 1) {
                    cps.push(points[i]);
                    continue;
                } else {
                    prevPoint = points[i - 1];
                    nextPoint = points[i + 1];
                }
            }
            vector.sub(v, nextPoint, prevPoint);
            vector.scale(v, v, smooth);
            var d0 = vector.distance(point, prevPoint);
            var d1 = vector.distance(point, nextPoint);
            var sum = d0 + d1;
            if (sum !== 0) {
                d0 /= sum;
                d1 /= sum;
            }
            vector.scale(v1, v, -d0);
            vector.scale(v2, v, d1);
            var cp0 = vector.add([], point, v1);
            var cp1 = vector.add([], point, v2);
            if (hasConstraint) {
                vector.max(cp0, cp0, min);
                vector.min(cp0, cp0, max);
                vector.max(cp1, cp1, min);
                vector.min(cp1, cp1, max);
            }
            cps.push(cp0);
            cps.push(cp1);
        }
        if (isLoop) {
            cps.push(cps.shift());
        }
        return cps;
    };
});define(&#x27;zrender/shape/Polygon&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Base&#x27;,
    &#x27;./util/smoothSpline&#x27;,
    &#x27;./util/smoothBezier&#x27;,
    &#x27;./util/dashedLineTo&#x27;,
    &#x27;../tool/util&#x27;
], function (require) {
    var Base = require(&#x27;./Base&#x27;);
    var smoothSpline = require(&#x27;./util/smoothSpline&#x27;);
    var smoothBezier = require(&#x27;./util/smoothBezier&#x27;);
    var dashedLineTo = require(&#x27;./util/dashedLineTo&#x27;);
    var Polygon = function (options) {
        Base.call(this, options);
    };
    Polygon.prototype = {
        type: &#x27;polygon&#x27;,
        brush: function (ctx, isHighlight) {
            var style = this.style;
            if (isHighlight) {
                style = this.getHighlightStyle(style, this.highlightStyle || {});
            }
            ctx.save();
            this.setContext(ctx, style);
            this.setTransform(ctx);
            var hasPath = false;
            if (style.brushType == &#x27;fill&#x27; || style.brushType == &#x27;both&#x27; || typeof style.brushType == &#x27;undefined&#x27;) {
                ctx.beginPath();
                if (style.lineType == &#x27;dashed&#x27; || style.lineType == &#x27;dotted&#x27;) {
                    this.buildPath(ctx, {
                        lineType: &#x27;solid&#x27;,
                        lineWidth: style.lineWidth,
                        pointList: style.pointList
                    });
                    hasPath = false;
                } else {
                    this.buildPath(ctx, style);
                    hasPath = true;
                }
                ctx.closePath();
                ctx.fill();
            }
            if (style.lineWidth &gt; 0 &amp;&amp; (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;both&#x27;)) {
                if (!hasPath) {
                    ctx.beginPath();
                    this.buildPath(ctx, style);
                }
                ctx.stroke();
            }
            this.drawText(ctx, style, this.style);
            ctx.restore();
            return;
        },
        buildPath: function (ctx, style) {
            var pointList = style.pointList;
            if (pointList.length &lt; 2) {
                return;
            }
            if (style.smooth &amp;&amp; style.smooth !== &#x27;spline&#x27;) {
                var controlPoints = smoothBezier(pointList, style.smooth, true, style.smoothConstraint);
                ctx.moveTo(pointList[0][0], pointList[0][1]);
                var cp1;
                var cp2;
                var p;
                var len = pointList.length;
                for (var i = 0; i &lt; len; i++) {
                    cp1 = controlPoints[i * 2];
                    cp2 = controlPoints[i * 2 + 1];
                    p = pointList[(i + 1) % len];
                    ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
                }
            } else {
                if (style.smooth === &#x27;spline&#x27;) {
                    pointList = smoothSpline(pointList, true);
                }
                if (!style.lineType || style.lineType == &#x27;solid&#x27;) {
                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    for (var i = 1, l = pointList.length; i &lt; l; i++) {
                        ctx.lineTo(pointList[i][0], pointList[i][1]);
                    }
                    ctx.lineTo(pointList[0][0], pointList[0][1]);
                } else if (style.lineType == &#x27;dashed&#x27; || style.lineType == &#x27;dotted&#x27;) {
                    var dashLength = style._dashLength || (style.lineWidth || 1) * (style.lineType == &#x27;dashed&#x27; ? 5 : 1);
                    style._dashLength = dashLength;
                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    for (var i = 1, l = pointList.length; i &lt; l; i++) {
                        dashedLineTo(ctx, pointList[i - 1][0], pointList[i - 1][1], pointList[i][0], pointList[i][1], dashLength);
                    }
                    dashedLineTo(ctx, pointList[pointList.length - 1][0], pointList[pointList.length - 1][1], pointList[0][0], pointList[0][1], dashLength);
                }
            }
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var minX = Number.MAX_VALUE;
            var maxX = Number.MIN_VALUE;
            var minY = Number.MAX_VALUE;
            var maxY = Number.MIN_VALUE;
            var pointList = style.pointList;
            for (var i = 0, l = pointList.length; i &lt; l; i++) {
                if (pointList[i][0] &lt; minX) {
                    minX = pointList[i][0];
                }
                if (pointList[i][0] &gt; maxX) {
                    maxX = pointList[i][0];
                }
                if (pointList[i][1] &lt; minY) {
                    minY = pointList[i][1];
                }
                if (pointList[i][1] &gt; maxY) {
                    maxY = pointList[i][1];
                }
            }
            var lineWidth;
            if (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;fill&#x27;) {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(minX - lineWidth / 2),
                y: Math.round(minY - lineWidth / 2),
                width: maxX - minX + lineWidth,
                height: maxY - minY + lineWidth
            };
            return style.__rect;
        }
    };
    require(&#x27;../tool/util&#x27;).inherits(Polygon, Base);
    return Polygon;
});define(&#x27;echarts/util/shape/normalIsCover&#x27;, [], function () {
    return function (x, y) {
        var originPos = this.getTansform(x, y);
        x = originPos[0];
        y = originPos[1];
        var rect = this.style.__rect;
        if (!rect) {
            rect = this.style.__rect = this.getRect(this.style);
        }
        return x &gt;= rect.x &amp;&amp; x &lt;= rect.x + rect.width &amp;&amp; y &gt;= rect.y &amp;&amp; y &lt;= rect.y + rect.height;
    };
});define(&#x27;echarts/component/dataView&#x27;, [
    &#x27;require&#x27;,
    &#x27;./base&#x27;,
    &#x27;../config&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;../component&#x27;
], function (require) {
    var Base = require(&#x27;./base&#x27;);
    var ecConfig = require(&#x27;../config&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    function DataView(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.dom = myChart.dom;
        this._tDom = document.createElement(&#x27;div&#x27;);
        this._textArea = document.createElement(&#x27;textArea&#x27;);
        this._buttonRefresh = document.createElement(&#x27;button&#x27;);
        this._buttonClose = document.createElement(&#x27;button&#x27;);
        this._hasShow = false;
        this._zrHeight = zr.getHeight();
        this._zrWidth = zr.getWidth();
        this._tDom.className = &#x27;echarts-dataview&#x27;, this.hide();
        this.dom.firstChild.appendChild(this._tDom);
        if (window.addEventListener) {
            this._tDom.addEventListener(&#x27;click&#x27;, this._stop);
            this._tDom.addEventListener(&#x27;mousewheel&#x27;, this._stop);
            this._tDom.addEventListener(&#x27;mousemove&#x27;, this._stop);
            this._tDom.addEventListener(&#x27;mousedown&#x27;, this._stop);
            this._tDom.addEventListener(&#x27;mouseup&#x27;, this._stop);
            this._tDom.addEventListener(&#x27;touchstart&#x27;, this._stop);
            this._tDom.addEventListener(&#x27;touchmove&#x27;, this._stop);
            this._tDom.addEventListener(&#x27;touchend&#x27;, this._stop);
        } else {
            this._tDom.attachEvent(&#x27;onclick&#x27;, this._stop);
            this._tDom.attachEvent(&#x27;onmousewheel&#x27;, this._stop);
            this._tDom.attachEvent(&#x27;onmousemove&#x27;, this._stop);
            this._tDom.attachEvent(&#x27;onmousedown&#x27;, this._stop);
            this._tDom.attachEvent(&#x27;onmouseup&#x27;, this._stop);
        }
    }
    DataView.prototype = {
        type: ecConfig.COMPONENT_TYPE_DATAVIEW,
        _lang: [
            &#x27;Data View&#x27;,
            &#x27;close&#x27;,
            &#x27;refresh&#x27;
        ],
        _gCssText: &#x27;position:absolute;&#x27; + &#x27;display:block;&#x27; + &#x27;overflow:hidden;&#x27; + &#x27;transition:height 0.8s,background-color 1s;&#x27; + &#x27;-moz-transition:height 0.8s,background-color 1s;&#x27; + &#x27;-webkit-transition:height 0.8s,background-color 1s;&#x27; + &#x27;-o-transition:height 0.8s,background-color 1s;&#x27; + &#x27;z-index:1;&#x27; + &#x27;left:0;&#x27; + &#x27;top:0;&#x27;,
        hide: function () {
            this._sizeCssText = &#x27;width:&#x27; + this._zrWidth + &#x27;px;&#x27; + &#x27;height:&#x27; + 0 + &#x27;px;&#x27; + &#x27;background-color:#f0ffff;&#x27;;
            this._tDom.style.cssText = this._gCssText + this._sizeCssText;
        },
        show: function (newOption) {
            this._hasShow = true;
            var lang = this.query(this.option, &#x27;toolbox.feature.dataView.lang&#x27;) || this._lang;
            this.option = newOption;
            this._tDom.innerHTML = &#x27;&lt;p style=&quot;padding:8px 0;margin:0 0 10px 0;&#x27; + &#x27;border-bottom:1px solid #eee&quot;&gt;&#x27; + (lang[0] || this._lang[0]) + &#x27;&lt;/p&gt;&#x27;;
            this._textArea.style.cssText = &#x27;display:block;margin:0 0 8px 0;padding:4px 6px;overflow:auto;&#x27; + &#x27;width:&#x27; + (this._zrWidth - 15) + &#x27;px;&#x27; + &#x27;height:&#x27; + (this._zrHeight - 100) + &#x27;px;&#x27;;
            var customContent = this.query(this.option, &#x27;toolbox.feature.dataView.optionToContent&#x27;);
            if (typeof customContent != &#x27;function&#x27;) {
                this._textArea.value = this._optionToContent();
            } else {
                this._textArea.value = customContent(this.option);
            }
            this._tDom.appendChild(this._textArea);
            this._buttonClose.style.cssText = &#x27;float:right;padding:1px 6px;&#x27;;
            this._buttonClose.innerHTML = lang[1] || this._lang[1];
            var self = this;
            this._buttonClose.onclick = function () {
                self.hide();
            };
            this._tDom.appendChild(this._buttonClose);
            if (this.query(this.option, &#x27;toolbox.feature.dataView.readOnly&#x27;) === false) {
                this._buttonRefresh.style.cssText = &#x27;float:right;margin-right:10px;padding:1px 6px;&#x27;;
                this._buttonRefresh.innerHTML = lang[2] || this._lang[2];
                this._buttonRefresh.onclick = function () {
                    self._save();
                };
                this._tDom.appendChild(this._buttonRefresh);
                this._textArea.readOnly = false;
                this._textArea.style.cursor = &#x27;default&#x27;;
            } else {
                this._textArea.readOnly = true;
                this._textArea.style.cursor = &#x27;text&#x27;;
            }
            this._sizeCssText = &#x27;width:&#x27; + this._zrWidth + &#x27;px;&#x27; + &#x27;height:&#x27; + this._zrHeight + &#x27;px;&#x27; + &#x27;background-color:#fff;&#x27;;
            this._tDom.style.cssText = this._gCssText + this._sizeCssText;
        },
        _optionToContent: function () {
            var i;
            var j;
            var k;
            var len;
            var data;
            var valueList;
            var axisList = [];
            var content = &#x27;&#x27;;
            if (this.option.xAxis) {
                if (this.option.xAxis instanceof Array) {
                    axisList = this.option.xAxis;
                } else {
                    axisList = [this.option.xAxis];
                }
                for (i = 0, len = axisList.length; i &lt; len; i++) {
                    if ((axisList[i].type || &#x27;category&#x27;) == &#x27;category&#x27;) {
                        valueList = [];
                        for (j = 0, k = axisList[i].data.length; j &lt; k; j++) {
                            data = axisList[i].data[j];
                            valueList.push(typeof data.value != &#x27;undefined&#x27; ? data.value : data);
                        }
                        content += valueList.join(&#x27;, &#x27;) + &#x27;\n\n&#x27;;
                    }
                }
            }
            if (this.option.yAxis) {
                if (this.option.yAxis instanceof Array) {
                    axisList = this.option.yAxis;
                } else {
                    axisList = [this.option.yAxis];
                }
                for (i = 0, len = axisList.length; i &lt; len; i++) {
                    if (axisList[i].type == &#x27;category&#x27;) {
                        valueList = [];
                        for (j = 0, k = axisList[i].data.length; j &lt; k; j++) {
                            data = axisList[i].data[j];
                            valueList.push(typeof data.value != &#x27;undefined&#x27; ? data.value : data);
                        }
                        content += valueList.join(&#x27;, &#x27;) + &#x27;\n\n&#x27;;
                    }
                }
            }
            var series = this.option.series;
            var itemName;
            for (i = 0, len = series.length; i &lt; len; i++) {
                valueList = [];
                for (j = 0, k = series[i].data.length; j &lt; k; j++) {
                    data = series[i].data[j];
                    if (series[i].type == ecConfig.CHART_TYPE_PIE || series[i].type == ecConfig.CHART_TYPE_MAP) {
                        itemName = (data.name || &#x27;-&#x27;) + &#x27;:&#x27;;
                    } else {
                        itemName = &#x27;&#x27;;
                    }
                    if (series[i].type == ecConfig.CHART_TYPE_SCATTER) {
                        data = typeof data.value != &#x27;undefined&#x27; ? data.value : data;
                        data = data.join(&#x27;, &#x27;);
                    }
                    valueList.push(itemName + (typeof data.value != &#x27;undefined&#x27; ? data.value : data));
                }
                content += (series[i].name || &#x27;-&#x27;) + &#x27; : \n&#x27;;
                content += valueList.join(series[i].type == ecConfig.CHART_TYPE_SCATTER ? &#x27;\n&#x27; : &#x27;, &#x27;);
                content += &#x27;\n\n&#x27;;
            }
            return content;
        },
        _save: function () {
            var text = this._textArea.value;
            var customContent = this.query(this.option, &#x27;toolbox.feature.dataView.contentToOption&#x27;);
            if (typeof customContent != &#x27;function&#x27;) {
                text = text.split(&#x27;\n&#x27;);
                var content = [];
                for (var i = 0, l = text.length; i &lt; l; i++) {
                    text[i] = this._trim(text[i]);
                    if (text[i] !== &#x27;&#x27;) {
                        content.push(text[i]);
                    }
                }
                this._contentToOption(content);
            } else {
                customContent(text, this.option);
            }
            this.hide();
            var self = this;
            setTimeout(function () {
                self.messageCenter &amp;&amp; self.messageCenter.dispatch(ecConfig.EVENT.DATA_VIEW_CHANGED, null, { option: self.option }, self.myChart);
            }, self.canvasSupported ? 800 : 100);
        },
        _contentToOption: function (content) {
            var i;
            var j;
            var k;
            var len;
            var data;
            var axisList = [];
            var contentIdx = 0;
            var contentValueList;
            var value;
            if (this.option.xAxis) {
                if (this.option.xAxis instanceof Array) {
                    axisList = this.option.xAxis;
                } else {
                    axisList = [this.option.xAxis];
                }
                for (i = 0, len = axisList.length; i &lt; len; i++) {
                    if ((axisList[i].type || &#x27;category&#x27;) == &#x27;category&#x27;) {
                        contentValueList = content[contentIdx].split(&#x27;,&#x27;);
                        for (j = 0, k = axisList[i].data.length; j &lt; k; j++) {
                            value = this._trim(contentValueList[j] || &#x27;&#x27;);
                            data = axisList[i].data[j];
                            if (typeof axisList[i].data[j].value != &#x27;undefined&#x27;) {
                                axisList[i].data[j].value = value;
                            } else {
                                axisList[i].data[j] = value;
                            }
                        }
                        contentIdx++;
                    }
                }
            }
            if (this.option.yAxis) {
                if (this.option.yAxis instanceof Array) {
                    axisList = this.option.yAxis;
                } else {
                    axisList = [this.option.yAxis];
                }
                for (i = 0, len = axisList.length; i &lt; len; i++) {
                    if (axisList[i].type == &#x27;category&#x27;) {
                        contentValueList = content[contentIdx].split(&#x27;,&#x27;);
                        for (j = 0, k = axisList[i].data.length; j &lt; k; j++) {
                            value = this._trim(contentValueList[j] || &#x27;&#x27;);
                            data = axisList[i].data[j];
                            if (typeof axisList[i].data[j].value != &#x27;undefined&#x27;) {
                                axisList[i].data[j].value = value;
                            } else {
                                axisList[i].data[j] = value;
                            }
                        }
                        contentIdx++;
                    }
                }
            }
            var series = this.option.series;
            for (i = 0, len = series.length; i &lt; len; i++) {
                contentIdx++;
                if (series[i].type == ecConfig.CHART_TYPE_SCATTER) {
                    for (var j = 0, k = series[i].data.length; j &lt; k; j++) {
                        contentValueList = content[contentIdx];
                        value = contentValueList.replace(&#x27; &#x27;, &#x27;&#x27;).split(&#x27;,&#x27;);
                        if (typeof series[i].data[j].value != &#x27;undefined&#x27;) {
                            series[i].data[j].value = value;
                        } else {
                            series[i].data[j] = value;
                        }
                        contentIdx++;
                    }
                } else {
                    contentValueList = content[contentIdx].split(&#x27;,&#x27;);
                    for (var j = 0, k = series[i].data.length; j &lt; k; j++) {
                        value = (contentValueList[j] || &#x27;&#x27;).replace(/.*:/, &#x27;&#x27;);
                        value = this._trim(value);
                        value = value != &#x27;-&#x27; &amp;&amp; value !== &#x27;&#x27; ? value - 0 : &#x27;-&#x27;;
                        if (typeof series[i].data[j].value != &#x27;undefined&#x27;) {
                            series[i].data[j].value = value;
                        } else {
                            series[i].data[j] = value;
                        }
                    }
                    contentIdx++;
                }
            }
        },
        _trim: function (str) {
            var trimer = new RegExp(&#x27;(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+$)&#x27;, &#x27;g&#x27;);
            return str.replace(trimer, &#x27;&#x27;);
        },
        _stop: function (e) {
            e = e || window.event;
            if (e.stopPropagation) {
                e.stopPropagation();
            } else {
                e.cancelBubble = true;
            }
        },
        resize: function () {
            this._zrHeight = this.zr.getHeight();
            this._zrWidth = this.zr.getWidth();
            if (this._tDom.offsetHeight &gt; 10) {
                this._sizeCssText = &#x27;width:&#x27; + this._zrWidth + &#x27;px;&#x27; + &#x27;height:&#x27; + this._zrHeight + &#x27;px;&#x27; + &#x27;background-color:#fff;&#x27;;
                this._tDom.style.cssText = this._gCssText + this._sizeCssText;
                this._textArea.style.cssText = &#x27;display:block;margin:0 0 8px 0;&#x27; + &#x27;padding:4px 6px;overflow:auto;&#x27; + &#x27;width:&#x27; + (this._zrWidth - 15) + &#x27;px;&#x27; + &#x27;height:&#x27; + (this._zrHeight - 100) + &#x27;px;&#x27;;
            }
        },
        dispose: function () {
            if (window.removeEventListener) {
                this._tDom.removeEventListener(&#x27;click&#x27;, this._stop);
                this._tDom.removeEventListener(&#x27;mousewheel&#x27;, this._stop);
                this._tDom.removeEventListener(&#x27;mousemove&#x27;, this._stop);
                this._tDom.removeEventListener(&#x27;mousedown&#x27;, this._stop);
                this._tDom.removeEventListener(&#x27;mouseup&#x27;, this._stop);
                this._tDom.removeEventListener(&#x27;touchstart&#x27;, this._stop);
                this._tDom.removeEventListener(&#x27;touchmove&#x27;, this._stop);
                this._tDom.removeEventListener(&#x27;touchend&#x27;, this._stop);
            } else {
                this._tDom.detachEvent(&#x27;onclick&#x27;, this._stop);
                this._tDom.detachEvent(&#x27;onmousewheel&#x27;, this._stop);
                this._tDom.detachEvent(&#x27;onmousemove&#x27;, this._stop);
                this._tDom.detachEvent(&#x27;onmousedown&#x27;, this._stop);
                this._tDom.detachEvent(&#x27;onmouseup&#x27;, this._stop);
            }
            this._buttonRefresh.onclick = null;
            this._buttonClose.onclick = null;
            if (this._hasShow) {
                this._tDom.removeChild(this._textArea);
                this._tDom.removeChild(this._buttonRefresh);
                this._tDom.removeChild(this._buttonClose);
            }
            this._textArea = null;
            this._buttonRefresh = null;
            this._buttonClose = null;
            this.dom.firstChild.removeChild(this._tDom);
            this._tDom = null;
        }
    };
    zrUtil.inherits(DataView, Base);
    require(&#x27;../component&#x27;).define(&#x27;dataView&#x27;, DataView);
    return DataView;
});define(&#x27;echarts/util/shape/Cross&#x27;, [
    &#x27;require&#x27;,
    &#x27;zrender/shape/Base&#x27;,
    &#x27;zrender/shape/Line&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;./normalIsCover&#x27;
], function (require) {
    var Base = require(&#x27;zrender/shape/Base&#x27;);
    var LineShape = require(&#x27;zrender/shape/Line&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    function Cross(options) {
        Base.call(this, options);
    }
    Cross.prototype = {
        type: &#x27;cross&#x27;,
        buildPath: function (ctx, style) {
            var rect = style.rect;
            style.xStart = rect.x;
            style.xEnd = rect.x + rect.width;
            style.yStart = style.yEnd = style.y;
            LineShape.prototype.buildPath(ctx, style);
            style.xStart = style.xEnd = style.x;
            style.yStart = rect.y;
            style.yEnd = rect.y + rect.height;
            LineShape.prototype.buildPath(ctx, style);
        },
        getRect: function (style) {
            return style.rect;
        },
        isCover: require(&#x27;./normalIsCover&#x27;)
    };
    zrUtil.inherits(Cross, Base);
    return Cross;
});define(&#x27;zrender/shape/Sector&#x27;, [
    &#x27;require&#x27;,
    &#x27;../tool/math&#x27;,
    &#x27;../tool/computeBoundingBox&#x27;,
    &#x27;../tool/vector&#x27;,
    &#x27;./Base&#x27;,
    &#x27;../tool/util&#x27;
], function (require) {
    var math = require(&#x27;../tool/math&#x27;);
    var computeBoundingBox = require(&#x27;../tool/computeBoundingBox&#x27;);
    var vec2 = require(&#x27;../tool/vector&#x27;);
    var Base = require(&#x27;./Base&#x27;);
    var min0 = vec2.create();
    var min1 = vec2.create();
    var max0 = vec2.create();
    var max1 = vec2.create();
    var Sector = function (options) {
        Base.call(this, options);
    };
    Sector.prototype = {
        type: &#x27;sector&#x27;,
        buildPath: function (ctx, style) {
            var x = style.x;
            var y = style.y;
            var r0 = style.r0 || 0;
            var r = style.r;
            var startAngle = style.startAngle;
            var endAngle = style.endAngle;
            var clockWise = style.clockWise || false;
            startAngle = math.degreeToRadian(startAngle);
            endAngle = math.degreeToRadian(endAngle);
            if (!clockWise) {
                startAngle = -startAngle;
                endAngle = -endAngle;
            }
            var unitX = math.cos(startAngle);
            var unitY = math.sin(startAngle);
            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
            ctx.lineTo(unitX * r + x, unitY * r + y);
            ctx.arc(x, y, r, startAngle, endAngle, !clockWise);
            ctx.lineTo(math.cos(endAngle) * r0 + x, math.sin(endAngle) * r0 + y);
            if (r0 !== 0) {
                ctx.arc(x, y, r0, endAngle, startAngle, clockWise);
            }
            ctx.closePath();
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var x = style.x;
            var y = style.y;
            var r0 = style.r0 || 0;
            var r = style.r;
            var startAngle = math.degreeToRadian(style.startAngle);
            var endAngle = math.degreeToRadian(style.endAngle);
            var clockWise = style.clockWise;
            if (!clockWise) {
                startAngle = -startAngle;
                endAngle = -endAngle;
            }
            if (r0 &gt; 1) {
                computeBoundingBox.arc(x, y, r0, startAngle, endAngle, !clockWise, min0, max0);
            } else {
                min0[0] = max0[0] = x;
                min0[1] = max0[1] = y;
            }
            computeBoundingBox.arc(x, y, r, startAngle, endAngle, !clockWise, min1, max1);
            vec2.min(min0, min0, min1);
            vec2.max(max0, max0, max1);
            style.__rect = {
                x: min0[0],
                y: min0[1],
                width: max0[0] - min0[0],
                height: max0[1] - min0[1]
            };
            return style.__rect;
        }
    };
    require(&#x27;../tool/util&#x27;).inherits(Sector, Base);
    return Sector;
});define(&#x27;echarts/util/shape/Candle&#x27;, [
    &#x27;require&#x27;,
    &#x27;zrender/shape/Base&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;./normalIsCover&#x27;
], function (require) {
    var Base = require(&#x27;zrender/shape/Base&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    function Candle(options) {
        Base.call(this, options);
    }
    Candle.prototype = {
        type: &#x27;candle&#x27;,
        _numberOrder: function (a, b) {
            return b - a;
        },
        buildPath: function (ctx, style) {
            var yList = zrUtil.clone(style.y).sort(this._numberOrder);
            ctx.moveTo(style.x, yList[3]);
            ctx.lineTo(style.x, yList[2]);
            ctx.moveTo(style.x - style.width / 2, yList[2]);
            ctx.rect(style.x - style.width / 2, yList[2], style.width, yList[1] - yList[2]);
            ctx.moveTo(style.x, yList[1]);
            ctx.lineTo(style.x, yList[0]);
        },
        getRect: function (style) {
            if (!style.__rect) {
                var lineWidth = 0;
                if (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;fill&#x27;) {
                    lineWidth = style.lineWidth || 1;
                }
                var yList = zrUtil.clone(style.y).sort(this._numberOrder);
                style.__rect = {
                    x: Math.round(style.x - style.width / 2 - lineWidth / 2),
                    y: Math.round(yList[3] - lineWidth / 2),
                    width: style.width + lineWidth,
                    height: yList[0] - yList[3] + lineWidth
                };
            }
            return style.__rect;
        },
        isCover: require(&#x27;./normalIsCover&#x27;)
    };
    zrUtil.inherits(Candle, Base);
    return Candle;
});define(&#x27;zrender/tool/computeBoundingBox&#x27;, [
    &#x27;require&#x27;,
    &#x27;./vector&#x27;,
    &#x27;./curve&#x27;
], function (require) {
    var vec2 = require(&#x27;./vector&#x27;);
    var curve = require(&#x27;./curve&#x27;);
    function computeBoundingBox(points, min, max) {
        if (points.length === 0) {
            return;
        }
        var left = points[0][0];
        var right = points[0][0];
        var top = points[0][1];
        var bottom = points[0][1];
        for (var i = 1; i &lt; points.length; i++) {
            var p = points[i];
            if (p[0] &lt; left) {
                left = p[0];
            }
            if (p[0] &gt; right) {
                right = p[0];
            }
            if (p[1] &lt; top) {
                top = p[1];
            }
            if (p[1] &gt; bottom) {
                bottom = p[1];
            }
        }
        min[0] = left;
        min[1] = top;
        max[0] = right;
        max[1] = bottom;
    }
    function computeCubeBezierBoundingBox(p0, p1, p2, p3, min, max) {
        var xDim = [];
        curve.cubicExtrema(p0[0], p1[0], p2[0], p3[0], xDim);
        for (var i = 0; i &lt; xDim.length; i++) {
            xDim[i] = curve.cubicAt(p0[0], p1[0], p2[0], p3[0], xDim[i]);
        }
        var yDim = [];
        curve.cubicExtrema(p0[1], p1[1], p2[1], p3[1], yDim);
        for (var i = 0; i &lt; yDim.length; i++) {
            yDim[i] = curve.cubicAt(p0[1], p1[1], p2[1], p3[1], yDim[i]);
        }
        xDim.push(p0[0], p3[0]);
        yDim.push(p0[1], p3[1]);
        var left = Math.min.apply(null, xDim);
        var right = Math.max.apply(null, xDim);
        var top = Math.min.apply(null, yDim);
        var bottom = Math.max.apply(null, yDim);
        min[0] = left;
        min[1] = top;
        max[0] = right;
        max[1] = bottom;
    }
    function computeQuadraticBezierBoundingBox(p0, p1, p2, min, max) {
        var t1 = curve.quadraticExtremum(p0[0], p1[0], p2[0]);
        var t2 = curve.quadraticExtremum(p0[1], p1[1], p2[1]);
        t1 = Math.max(Math.min(t1, 1), 0);
        t2 = Math.max(Math.min(t2, 1), 0);
        var ct1 = 1 - t1;
        var ct2 = 1 - t2;
        var x1 = ct1 * ct1 * p0[0] + 2 * ct1 * t1 * p1[0] + t1 * t1 * p2[0];
        var y1 = ct1 * ct1 * p0[1] + 2 * ct1 * t1 * p1[1] + t1 * t1 * p2[1];
        var x2 = ct2 * ct2 * p0[0] + 2 * ct2 * t2 * p1[0] + t2 * t2 * p2[0];
        var y2 = ct2 * ct2 * p0[1] + 2 * ct2 * t2 * p1[1] + t2 * t2 * p2[1];
        min[0] = Math.min(p0[0], p2[0], x1, x2);
        min[1] = Math.min(p0[1], p2[1], y1, y2);
        max[0] = Math.max(p0[0], p2[0], x1, x2);
        max[1] = Math.max(p0[1], p2[1], y1, y2);
    }
    var start = vec2.create();
    var end = vec2.create();
    var extremity = vec2.create();
    var computeArcBoundingBox = function (x, y, r, startAngle, endAngle, anticlockwise, min, max) {
        start[0] = Math.cos(startAngle) * r + x;
        start[1] = Math.sin(startAngle) * r + y;
        end[0] = Math.cos(endAngle) * r + x;
        end[1] = Math.sin(endAngle) * r + y;
        vec2.min(min, start, end);
        vec2.max(max, start, end);
        startAngle = startAngle % (Math.PI * 2);
        if (startAngle &lt; 0) {
            startAngle = startAngle + Math.PI * 2;
        }
        endAngle = endAngle % (Math.PI * 2);
        if (endAngle &lt; 0) {
            endAngle = endAngle + Math.PI * 2;
        }
        if (startAngle &gt; endAngle &amp;&amp; !anticlockwise) {
            endAngle += Math.PI * 2;
        } else if (startAngle &lt; endAngle &amp;&amp; anticlockwise) {
            startAngle += Math.PI * 2;
        }
        if (anticlockwise) {
            var tmp = endAngle;
            endAngle = startAngle;
            startAngle = tmp;
        }
        for (var angle = 0; angle &lt; endAngle; angle += Math.PI / 2) {
            if (angle &gt; startAngle) {
                extremity[0] = Math.cos(angle) * r + x;
                extremity[1] = Math.sin(angle) * r + y;
                vec2.min(min, extremity, min);
                vec2.max(max, extremity, max);
            }
        }
    };
    computeBoundingBox.cubeBezier = computeCubeBezierBoundingBox;
    computeBoundingBox.quadraticBezier = computeQuadraticBezierBoundingBox;
    computeBoundingBox.arc = computeArcBoundingBox;
    return computeBoundingBox;
});define(&#x27;echarts/util/shape/Chain&#x27;, [
    &#x27;require&#x27;,
    &#x27;zrender/shape/Base&#x27;,
    &#x27;./Icon&#x27;,
    &#x27;zrender/shape/util/dashedLineTo&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;zrender/tool/matrix&#x27;
], function (require) {
    var Base = require(&#x27;zrender/shape/Base&#x27;);
    var IconShape = require(&#x27;./Icon&#x27;);
    var dashedLineTo = require(&#x27;zrender/shape/util/dashedLineTo&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    var matrix = require(&#x27;zrender/tool/matrix&#x27;);
    function Chain(options) {
        Base.call(this, options);
    }
    Chain.prototype = {
        type: &#x27;chain&#x27;,
        brush: function (ctx, isHighlight) {
            var style = this.style;
            if (isHighlight) {
                style = this.getHighlightStyle(style, this.highlightStyle || {});
            }
            ctx.save();
            this.setContext(ctx, style);
            this.setTransform(ctx);
            ctx.save();
            ctx.beginPath();
            this.buildLinePath(ctx, style);
            ctx.stroke();
            ctx.restore();
            this.brushSymbol(ctx, style);
            ctx.restore();
            return;
        },
        buildLinePath: function (ctx, style) {
            var x = style.x;
            var y = style.y + 5;
            var width = style.width;
            var height = style.height / 2 - 10;
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + height);
            ctx.moveTo(x + width, y);
            ctx.lineTo(x + width, y + height);
            ctx.moveTo(x, y + height / 2);
            if (!style.lineType || style.lineType == &#x27;solid&#x27;) {
                ctx.lineTo(x + width, y + height / 2);
            } else if (style.lineType == &#x27;dashed&#x27; || style.lineType == &#x27;dotted&#x27;) {
                var dashLength = (style.lineWidth || 1) * (style.lineType == &#x27;dashed&#x27; ? 5 : 1);
                dashedLineTo(ctx, x, y + height / 2, x + width, y + height / 2, dashLength);
            }
        },
        brushSymbol: function (ctx, style) {
            var y = style.y + style.height / 4;
            ctx.save();
            var chainPoint = style.chainPoint;
            var curPoint;
            for (var idx = 0, l = chainPoint.length; idx &lt; l; idx++) {
                curPoint = chainPoint[idx];
                if (curPoint.symbol != &#x27;none&#x27;) {
                    ctx.beginPath();
                    var symbolSize = curPoint.symbolSize;
                    IconShape.prototype.buildPath(ctx, {
                        iconType: curPoint.symbol,
                        x: curPoint.x - symbolSize,
                        y: y - symbolSize,
                        width: symbolSize * 2,
                        height: symbolSize * 2,
                        n: curPoint.n
                    });
                    ctx.fillStyle = curPoint.isEmpty ? &#x27;#fff&#x27; : style.strokeColor;
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
                if (curPoint.showLabel) {
                    ctx.font = curPoint.textFont;
                    ctx.fillStyle = curPoint.textColor;
                    ctx.textAlign = curPoint.textAlign;
                    ctx.textBaseline = curPoint.textBaseline;
                    if (curPoint.rotation) {
                        ctx.save();
                        this._updateTextTransform(ctx, curPoint.rotation);
                        ctx.fillText(curPoint.name, curPoint.textX, curPoint.textY);
                        ctx.restore();
                    } else {
                        ctx.fillText(curPoint.name, curPoint.textX, curPoint.textY);
                    }
                }
            }
            ctx.restore();
        },
        _updateTextTransform: function (ctx, rotation) {
            var _transform = matrix.create();
            matrix.identity(_transform);
            if (rotation[0] !== 0) {
                var originX = rotation[1] || 0;
                var originY = rotation[2] || 0;
                if (originX || originY) {
                    matrix.translate(_transform, _transform, [
                        -originX,
                        -originY
                    ]);
                }
                matrix.rotate(_transform, _transform, rotation[0]);
                if (originX || originY) {
                    matrix.translate(_transform, _transform, [
                        originX,
                        originY
                    ]);
                }
            }
            ctx.transform.apply(ctx, _transform);
        },
        isCover: function (x, y) {
            var rect = this.style;
            if (x &gt;= rect.x &amp;&amp; x &lt;= rect.x + rect.width &amp;&amp; y &gt;= rect.y &amp;&amp; y &lt;= rect.y + rect.height) {
                return true;
            } else {
                return false;
            }
        }
    };
    zrUtil.inherits(Chain, Base);
    return Chain;
});define(&#x27;zrender/shape/Ring&#x27;, [
    &#x27;require&#x27;,
    &#x27;./Base&#x27;,
    &#x27;../tool/util&#x27;
], function (require) {
    var Base = require(&#x27;./Base&#x27;);
    var Ring = function (options) {
        Base.call(this, options);
    };
    Ring.prototype = {
        type: &#x27;ring&#x27;,
        buildPath: function (ctx, style) {
            ctx.arc(style.x, style.y, style.r, 0, Math.PI * 2, false);
            ctx.moveTo(style.x + style.r0, style.y);
            ctx.arc(style.x, style.y, style.r0, 0, Math.PI * 2, true);
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var lineWidth;
            if (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;fill&#x27;) {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(style.x - style.r - lineWidth / 2),
                y: Math.round(style.y - style.r - lineWidth / 2),
                width: style.r * 2 + lineWidth,
                height: style.r * 2 + lineWidth
            };
            return style.__rect;
        }
    };
    require(&#x27;../tool/util&#x27;).inherits(Ring, Base);
    return Ring;
});define(&#x27;echarts/component/axis&#x27;, [
    &#x27;require&#x27;,
    &#x27;./base&#x27;,
    &#x27;zrender/shape/Line&#x27;,
    &#x27;../config&#x27;,
    &#x27;../util/ecData&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;zrender/tool/color&#x27;,
    &#x27;./categoryAxis&#x27;,
    &#x27;./valueAxis&#x27;,
    &#x27;../component&#x27;
], function (require) {
    var Base = require(&#x27;./base&#x27;);
    var LineShape = require(&#x27;zrender/shape/Line&#x27;);
    var ecConfig = require(&#x27;../config&#x27;);
    var ecData = require(&#x27;../util/ecData&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    var zrColor = require(&#x27;zrender/tool/color&#x27;);
    function Axis(ecTheme, messageCenter, zr, option, myChart, axisType) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.axisType = axisType;
        this._axisList = [];
        this.refresh(option);
    }
    Axis.prototype = {
        type: ecConfig.COMPONENT_TYPE_AXIS,
        axisBase: {
            _buildAxisLine: function () {
                var lineWidth = this.option.axisLine.lineStyle.width;
                var halfLineWidth = lineWidth / 2;
                var axShape = {
                    _axisShape: &#x27;axisLine&#x27;,
                    zlevel: this._zlevelBase + 1,
                    hoverable: false
                };
                switch (this.option.position) {
                case &#x27;left&#x27;:
                    axShape.style = {
                        xStart: this.grid.getX() - halfLineWidth,
                        yStart: this.grid.getYend(),
                        xEnd: this.grid.getX() - halfLineWidth,
                        yEnd: this.grid.getY(),
                        lineCap: &#x27;round&#x27;
                    };
                    break;
                case &#x27;right&#x27;:
                    axShape.style = {
                        xStart: this.grid.getXend() + halfLineWidth,
                        yStart: this.grid.getYend(),
                        xEnd: this.grid.getXend() + halfLineWidth,
                        yEnd: this.grid.getY(),
                        lineCap: &#x27;round&#x27;
                    };
                    break;
                case &#x27;bottom&#x27;:
                    axShape.style = {
                        xStart: this.grid.getX(),
                        yStart: this.grid.getYend() + halfLineWidth,
                        xEnd: this.grid.getXend(),
                        yEnd: this.grid.getYend() + halfLineWidth,
                        lineCap: &#x27;round&#x27;
                    };
                    break;
                case &#x27;top&#x27;:
                    axShape.style = {
                        xStart: this.grid.getX(),
                        yStart: this.grid.getY() - halfLineWidth,
                        xEnd: this.grid.getXend(),
                        yEnd: this.grid.getY() - halfLineWidth,
                        lineCap: &#x27;round&#x27;
                    };
                    break;
                }
                if (this.option.name !== &#x27;&#x27;) {
                    axShape.style.text = this.option.name;
                    axShape.style.textPosition = this.option.nameLocation;
                    axShape.style.textFont = this.getFont(this.option.nameTextStyle);
                    if (this.option.nameTextStyle.align) {
                        axShape.style.textAlign = this.option.nameTextStyle.align;
                    }
                    if (this.option.nameTextStyle.baseline) {
                        axShape.style.textBaseline = this.option.nameTextStyle.baseline;
                    }
                    if (this.option.nameTextStyle.color) {
                        axShape.style.textColor = this.option.nameTextStyle.color;
                    }
                }
                axShape.style.strokeColor = this.option.axisLine.lineStyle.color;
                axShape.style.lineWidth = lineWidth;
                if (this.isHorizontal()) {
                    axShape.style.yStart = axShape.style.yEnd = this.subPixelOptimize(axShape.style.yEnd, lineWidth);
                } else {
                    axShape.style.xStart = axShape.style.xEnd = this.subPixelOptimize(axShape.style.xEnd, lineWidth);
                }
                axShape.style.lineType = this.option.axisLine.lineStyle.type;
                axShape = new LineShape(axShape);
                this.shapeList.push(axShape);
            },
            _axisLabelClickable: function (clickable, axShape) {
                if (clickable) {
                    ecData.pack(axShape, undefined, -1, undefined, -1, axShape.style.text);
                    axShape.hoverable = true;
                    axShape.clickable = true;
                    axShape.highlightStyle = {
                        color: zrColor.lift(axShape.style.color, 1),
                        brushType: &#x27;fill&#x27;
                    };
                    return axShape;
                } else {
                    return axShape;
                }
            },
            refixAxisShape: function (zeroX, zeroY) {
                if (!this.option.axisLine.onZero) {
                    return;
                }
                var tickLength;
                if (this.isHorizontal() &amp;&amp; zeroY != null) {
                    for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                        if (this.shapeList[i]._axisShape === &#x27;axisLine&#x27;) {
                            this.shapeList[i].style.yStart = this.shapeList[i].style.yEnd = this.subPixelOptimize(zeroY, this.shapeList[i].stylelineWidth);
                            this.zr.modShape(this.shapeList[i].id);
                        } else if (this.shapeList[i]._axisShape === &#x27;axisTick&#x27;) {
                            tickLength = this.shapeList[i].style.yEnd - this.shapeList[i].style.yStart;
                            this.shapeList[i].style.yStart = zeroY - tickLength;
                            this.shapeList[i].style.yEnd = zeroY;
                            this.zr.modShape(this.shapeList[i].id);
                        }
                    }
                }
                if (!this.isHorizontal() &amp;&amp; zeroX != null) {
                    for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                        if (this.shapeList[i]._axisShape === &#x27;axisLine&#x27;) {
                            this.shapeList[i].style.xStart = this.shapeList[i].style.xEnd = this.subPixelOptimize(zeroX, this.shapeList[i].stylelineWidth);
                            this.zr.modShape(this.shapeList[i].id);
                        } else if (this.shapeList[i]._axisShape === &#x27;axisTick&#x27;) {
                            tickLength = this.shapeList[i].style.xEnd - this.shapeList[i].style.xStart;
                            this.shapeList[i].style.xStart = zeroX;
                            this.shapeList[i].style.xEnd = zeroX + tickLength;
                            this.zr.modShape(this.shapeList[i].id);
                        }
                    }
                }
            },
            getPosition: function () {
                return this.option.position;
            },
            isHorizontal: function () {
                return this.option.position === &#x27;bottom&#x27; || this.option.position === &#x27;top&#x27;;
            }
        },
        reformOption: function (opt) {
            if (!opt || opt instanceof Array &amp;&amp; opt.length === 0) {
                opt = [{ type: ecConfig.COMPONENT_TYPE_AXIS_VALUE }];
            } else if (!(opt instanceof Array)) {
                opt = [opt];
            }
            if (opt.length &gt; 2) {
                opt = [
                    opt[0],
                    opt[1]
                ];
            }
            if (this.axisType === &#x27;xAxis&#x27;) {
                if (!opt[0].position || opt[0].position != &#x27;bottom&#x27; &amp;&amp; opt[0].position != &#x27;top&#x27;) {
                    opt[0].position = &#x27;bottom&#x27;;
                }
                if (opt.length &gt; 1) {
                    opt[1].position = opt[0].position === &#x27;bottom&#x27; ? &#x27;top&#x27; : &#x27;bottom&#x27;;
                }
                for (var i = 0, l = opt.length; i &lt; l; i++) {
                    opt[i].type = opt[i].type || &#x27;category&#x27;;
                    opt[i].xAxisIndex = i;
                    opt[i].yAxisIndex = -1;
                }
            } else {
                if (!opt[0].position || opt[0].position != &#x27;left&#x27; &amp;&amp; opt[0].position != &#x27;right&#x27;) {
                    opt[0].position = &#x27;left&#x27;;
                }
                if (opt.length &gt; 1) {
                    opt[1].position = opt[0].position === &#x27;left&#x27; ? &#x27;right&#x27; : &#x27;left&#x27;;
                }
                for (var i = 0, l = opt.length; i &lt; l; i++) {
                    opt[i].type = opt[i].type || &#x27;value&#x27;;
                    opt[i].xAxisIndex = -1;
                    opt[i].yAxisIndex = i;
                }
            }
            return opt;
        },
        refresh: function (newOption) {
            var axisOption;
            if (newOption) {
                this.option = newOption;
                if (this.axisType === &#x27;xAxis&#x27;) {
                    this.option.xAxis = this.reformOption(newOption.xAxis);
                    axisOption = this.option.xAxis;
                } else {
                    this.option.yAxis = this.reformOption(newOption.yAxis);
                    axisOption = this.option.yAxis;
                }
                this.series = newOption.series;
            }
            var CategoryAxis = require(&#x27;./categoryAxis&#x27;);
            var ValueAxis = require(&#x27;./valueAxis&#x27;);
            var len = Math.max(axisOption &amp;&amp; axisOption.length || 0, this._axisList.length);
            for (var i = 0; i &lt; len; i++) {
                if (this._axisList[i] &amp;&amp; newOption &amp;&amp; (!axisOption[i] || this._axisList[i].type != axisOption[i].type)) {
                    this._axisList[i].dispose &amp;&amp; this._axisList[i].dispose();
                    this._axisList[i] = false;
                }
                if (this._axisList[i]) {
                    this._axisList[i].refresh &amp;&amp; this._axisList[i].refresh(axisOption ? axisOption[i] : false, this.series);
                } else if (axisOption &amp;&amp; axisOption[i]) {
                    this._axisList[i] = axisOption[i].type === &#x27;category&#x27; ? new CategoryAxis(this.ecTheme, this.messageCenter, this.zr, axisOption[i], this.myChart, this.axisBase) : new ValueAxis(this.ecTheme, this.messageCenter, this.zr, axisOption[i], this.myChart, this.axisBase, this.series);
                }
            }
        },
        getAxis: function (idx) {
            return this._axisList[idx];
        },
        clear: function () {
            for (var i = 0, l = this._axisList.length; i &lt; l; i++) {
                this._axisList[i].dispose &amp;&amp; this._axisList[i].dispose();
            }
            this._axisList = [];
        }
    };
    zrUtil.inherits(Axis, Base);
    require(&#x27;../component&#x27;).define(&#x27;axis&#x27;, Axis);
    return Axis;
});define(&#x27;echarts/component/grid&#x27;, [
    &#x27;require&#x27;,
    &#x27;./base&#x27;,
    &#x27;zrender/shape/Rectangle&#x27;,
    &#x27;../config&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;../component&#x27;
], function (require) {
    var Base = require(&#x27;./base&#x27;);
    var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
    var ecConfig = require(&#x27;../config&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    function Grid(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.refresh(option);
    }
    Grid.prototype = {
        type: ecConfig.COMPONENT_TYPE_GRID,
        getX: function () {
            return this._x;
        },
        getY: function () {
            return this._y;
        },
        getWidth: function () {
            return this._width;
        },
        getHeight: function () {
            return this._height;
        },
        getXend: function () {
            return this._x + this._width;
        },
        getYend: function () {
            return this._y + this._height;
        },
        getArea: function () {
            return {
                x: this._x,
                y: this._y,
                width: this._width,
                height: this._height
            };
        },
        getBbox: function () {
            return [
                [
                    this._x,
                    this._y
                ],
                [
                    this.getXend(),
                    this.getYend()
                ]
            ];
        },
        refixAxisShape: function (component) {
            var zeroX;
            var zeroY;
            var axisList = component.xAxis._axisList.concat(component.yAxis ? component.yAxis._axisList : []);
            var len = axisList.length;
            var axis;
            while (len--) {
                axis = axisList[len];
                if (axis.type == ecConfig.COMPONENT_TYPE_AXIS_VALUE &amp;&amp; axis._min &lt; 0 &amp;&amp; axis._max &gt;= 0) {
                    axis.isHorizontal() ? zeroX = axis.getCoord(0) : zeroY = axis.getCoord(0);
                }
            }
            if (typeof zeroX != &#x27;undefined&#x27; || typeof zeroY != &#x27;undefined&#x27;) {
                len = axisList.length;
                while (len--) {
                    axisList[len].refixAxisShape(zeroX, zeroY);
                }
            }
        },
        refresh: function (newOption) {
            if (newOption || this._zrWidth != this.zr.getWidth() || this._zrHeight != this.zr.getHeight()) {
                this.clear();
                this.option = newOption || this.option;
                this.option.grid = this.reformOption(this.option.grid);
                var gridOption = this.option.grid;
                this._zrWidth = this.zr.getWidth();
                this._zrHeight = this.zr.getHeight();
                this._x = this.parsePercent(gridOption.x, this._zrWidth);
                this._y = this.parsePercent(gridOption.y, this._zrHeight);
                var x2 = this.parsePercent(gridOption.x2, this._zrWidth);
                var y2 = this.parsePercent(gridOption.y2, this._zrHeight);
                if (typeof gridOption.width == &#x27;undefined&#x27;) {
                    this._width = this._zrWidth - this._x - x2;
                } else {
                    this._width = this.parsePercent(gridOption.width, this._zrWidth);
                }
                this._width = this._width &lt;= 0 ? 10 : this._width;
                if (typeof gridOption.height == &#x27;undefined&#x27;) {
                    this._height = this._zrHeight - this._y - y2;
                } else {
                    this._height = this.parsePercent(gridOption.height, this._zrHeight);
                }
                this._height = this._height &lt;= 0 ? 10 : this._height;
                this._x = this.subPixelOptimize(this._x, gridOption.borderWidth);
                this._y = this.subPixelOptimize(this._y, gridOption.borderWidth);
                this.shapeList.push(new RectangleShape({
                    zlevel: this._zlevelBase,
                    hoverable: false,
                    style: {
                        x: this._x,
                        y: this._y,
                        width: this._width,
                        height: this._height,
                        brushType: gridOption.borderWidth &gt; 0 ? &#x27;both&#x27; : &#x27;fill&#x27;,
                        color: gridOption.backgroundColor,
                        strokeColor: gridOption.borderColor,
                        lineWidth: gridOption.borderWidth
                    }
                }));
                this.zr.addShape(this.shapeList[0]);
            }
        }
    };
    zrUtil.inherits(Grid, Base);
    require(&#x27;../component&#x27;).define(&#x27;grid&#x27;, Grid);
    return Grid;
});define(&#x27;echarts/component/dataZoom&#x27;, [
    &#x27;require&#x27;,
    &#x27;./base&#x27;,
    &#x27;zrender/shape/Rectangle&#x27;,
    &#x27;zrender/shape/Polygon&#x27;,
    &#x27;../util/shape/Icon&#x27;,
    &#x27;../config&#x27;,
    &#x27;../util/date&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;../component&#x27;
], function (require) {
    var Base = require(&#x27;./base&#x27;);
    var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
    var PolygonShape = require(&#x27;zrender/shape/Polygon&#x27;);
    var IconShape = require(&#x27;../util/shape/Icon&#x27;);
    var ecConfig = require(&#x27;../config&#x27;);
    var ecDate = require(&#x27;../util/date&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    function DataZoom(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        var self = this;
        self._ondrift = function (dx, dy) {
            return self.__ondrift(this, dx, dy);
        };
        self._ondragend = function () {
            return self.__ondragend();
        };
        this._fillerSize = 28;
        this._handleSize = 8;
        this._isSilence = false;
        this._zoom = {};
        this.option.dataZoom = this.reformOption(this.option.dataZoom);
        this.zoomOption = this.option.dataZoom;
        if (!this.myChart.canvasSupported) {
            this.zoomOption.realtime = false;
        }
        this._location = this._getLocation();
        this._zoom = this._getZoom();
        this._backupData();
        if (this.option.dataZoom.show) {
            this._buildShape();
        }
        this._syncData();
    }
    DataZoom.prototype = {
        type: ecConfig.COMPONENT_TYPE_DATAZOOM,
        _buildShape: function () {
            this._buildBackground();
            this._buildFiller();
            this._buildHandle();
            this._buildFrame();
            for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
            this._syncFrameShape();
        },
        _getLocation: function () {
            var x;
            var y;
            var width;
            var height;
            var grid = this.component.grid;
            if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                width = this.zoomOption.width || grid.getWidth();
                height = this.zoomOption.height || this._fillerSize;
                x = this.zoomOption.x != null ? this.zoomOption.x : grid.getX();
                y = this.zoomOption.y != null ? this.zoomOption.y : this.zr.getHeight() - height - 2;
            } else {
                width = this.zoomOption.width || this._fillerSize;
                height = this.zoomOption.height || grid.getHeight();
                x = this.zoomOption.x != null ? this.zoomOption.x : 2;
                y = this.zoomOption.y != null ? this.zoomOption.y : grid.getY();
            }
            return {
                x: x,
                y: y,
                width: width,
                height: height
            };
        },
        _getZoom: function () {
            var series = this.option.series;
            var xAxis = this.option.xAxis;
            if (xAxis &amp;&amp; !(xAxis instanceof Array)) {
                xAxis = [xAxis];
                this.option.xAxis = xAxis;
            }
            var yAxis = this.option.yAxis;
            if (yAxis &amp;&amp; !(yAxis instanceof Array)) {
                yAxis = [yAxis];
                this.option.yAxis = yAxis;
            }
            var zoomSeriesIndex = [];
            var xAxisIndex;
            var yAxisIndex;
            var zOptIdx = this.zoomOption.xAxisIndex;
            if (xAxis &amp;&amp; zOptIdx == null) {
                xAxisIndex = [];
                for (var i = 0, l = xAxis.length; i &lt; l; i++) {
                    if (xAxis[i].type == &#x27;category&#x27; || xAxis[i].type == null) {
                        xAxisIndex.push(i);
                    }
                }
            } else {
                if (zOptIdx instanceof Array) {
                    xAxisIndex = zOptIdx;
                } else if (zOptIdx != null) {
                    xAxisIndex = [zOptIdx];
                } else {
                    xAxisIndex = [];
                }
            }
            zOptIdx = this.zoomOption.yAxisIndex;
            if (yAxis &amp;&amp; zOptIdx == null) {
                yAxisIndex = [];
                for (var i = 0, l = yAxis.length; i &lt; l; i++) {
                    if (yAxis[i].type == &#x27;category&#x27;) {
                        yAxisIndex.push(i);
                    }
                }
            } else {
                if (zOptIdx instanceof Array) {
                    yAxisIndex = zOptIdx;
                } else if (zOptIdx != null) {
                    yAxisIndex = [zOptIdx];
                } else {
                    yAxisIndex = [];
                }
            }
            var serie;
            for (var i = 0, l = series.length; i &lt; l; i++) {
                serie = series[i];
                if (serie.type != ecConfig.CHART_TYPE_LINE &amp;&amp; serie.type != ecConfig.CHART_TYPE_BAR &amp;&amp; serie.type != ecConfig.CHART_TYPE_SCATTER &amp;&amp; serie.type != ecConfig.CHART_TYPE_K) {
                    continue;
                }
                for (var j = 0, k = xAxisIndex.length; j &lt; k; j++) {
                    if (xAxisIndex[j] == (serie.xAxisIndex || 0)) {
                        zoomSeriesIndex.push(i);
                        break;
                    }
                }
                for (var j = 0, k = yAxisIndex.length; j &lt; k; j++) {
                    if (yAxisIndex[j] == (serie.yAxisIndex || 0)) {
                        zoomSeriesIndex.push(i);
                        break;
                    }
                }
                if (this.zoomOption.xAxisIndex == null &amp;&amp; this.zoomOption.yAxisIndex == null &amp;&amp; serie.data &amp;&amp; serie.data[0] &amp;&amp; serie.data[0] instanceof Array &amp;&amp; (serie.type == ecConfig.CHART_TYPE_SCATTER || serie.type == ecConfig.CHART_TYPE_LINE || serie.type == ecConfig.CHART_TYPE_BAR)) {
                    zoomSeriesIndex.push(i);
                }
            }
            var start = this._zoom.start != null ? this._zoom.start : this.zoomOption.start != null ? this.zoomOption.start : 0;
            var end = this._zoom.end != null ? this._zoom.end : this.zoomOption.end != null ? this.zoomOption.end : 100;
            if (start &gt; end) {
                start = start + end;
                end = start - end;
                start = start - end;
            }
            var size = Math.round((end - start) / 100 * (this.zoomOption.orient == &#x27;horizontal&#x27; ? this._location.width : this._location.height));
            return {
                start: start,
                end: end,
                start2: 0,
                end2: 100,
                size: size,
                xAxisIndex: xAxisIndex,
                yAxisIndex: yAxisIndex,
                seriesIndex: zoomSeriesIndex,
                scatterMap: this._zoom.scatterMap || {}
            };
        },
        _backupData: function () {
            this._originalData = {
                xAxis: {},
                yAxis: {},
                series: {}
            };
            var xAxis = this.option.xAxis;
            var xAxisIndex = this._zoom.xAxisIndex;
            for (var i = 0, l = xAxisIndex.length; i &lt; l; i++) {
                this._originalData.xAxis[xAxisIndex[i]] = xAxis[xAxisIndex[i]].data;
            }
            var yAxis = this.option.yAxis;
            var yAxisIndex = this._zoom.yAxisIndex;
            for (var i = 0, l = yAxisIndex.length; i &lt; l; i++) {
                this._originalData.yAxis[yAxisIndex[i]] = yAxis[yAxisIndex[i]].data;
            }
            var series = this.option.series;
            var seriesIndex = this._zoom.seriesIndex;
            var serie;
            for (var i = 0, l = seriesIndex.length; i &lt; l; i++) {
                serie = series[seriesIndex[i]];
                this._originalData.series[seriesIndex[i]] = serie.data;
                if (serie.data &amp;&amp; serie.data[0] &amp;&amp; serie.data[0] instanceof Array &amp;&amp; (serie.type == ecConfig.CHART_TYPE_SCATTER || serie.type == ecConfig.CHART_TYPE_LINE || serie.type == ecConfig.CHART_TYPE_BAR)) {
                    this._backupScale();
                    this._calculScatterMap(seriesIndex[i]);
                }
            }
        },
        _calculScatterMap: function (seriesIndex) {
            this._zoom.scatterMap = this._zoom.scatterMap || {};
            this._zoom.scatterMap[seriesIndex] = this._zoom.scatterMap[seriesIndex] || {};
            var componentLibrary = require(&#x27;../component&#x27;);
            var Axis = componentLibrary.get(&#x27;axis&#x27;);
            var axisOption = zrUtil.clone(this.option.xAxis);
            if (axisOption[0].type == &#x27;category&#x27;) {
                axisOption[0].type = &#x27;value&#x27;;
            }
            if (axisOption[1] &amp;&amp; axisOption[1].type == &#x27;category&#x27;) {
                axisOption[1].type = &#x27;value&#x27;;
            }
            var vAxis = new Axis(this.ecTheme, null, false, {
                xAxis: axisOption,
                series: this.option.series
            }, this, &#x27;xAxis&#x27;);
            var axisIndex = this.option.series[seriesIndex].xAxisIndex || 0;
            this._zoom.scatterMap[seriesIndex].x = vAxis.getAxis(axisIndex).getExtremum();
            vAxis.dispose();
            axisOption = zrUtil.clone(this.option.yAxis);
            if (axisOption[0].type == &#x27;category&#x27;) {
                axisOption[0].type = &#x27;value&#x27;;
            }
            if (axisOption[1] &amp;&amp; axisOption[1].type == &#x27;category&#x27;) {
                axisOption[1].type = &#x27;value&#x27;;
            }
            vAxis = new Axis(this.ecTheme, null, false, {
                yAxis: axisOption,
                series: this.option.series
            }, this, &#x27;yAxis&#x27;);
            axisIndex = this.option.series[seriesIndex].yAxisIndex || 0;
            this._zoom.scatterMap[seriesIndex].y = vAxis.getAxis(axisIndex).getExtremum();
            vAxis.dispose();
        },
        _buildBackground: function () {
            var width = this._location.width;
            var height = this._location.height;
            this.shapeList.push(new RectangleShape({
                zlevel: this._zlevelBase,
                hoverable: false,
                style: {
                    x: this._location.x,
                    y: this._location.y,
                    width: width,
                    height: height,
                    color: this.zoomOption.backgroundColor
                }
            }));
            var maxLength = 0;
            var xAxis = this._originalData.xAxis;
            var xAxisIndex = this._zoom.xAxisIndex;
            for (var i = 0, l = xAxisIndex.length; i &lt; l; i++) {
                maxLength = Math.max(maxLength, xAxis[xAxisIndex[i]].length);
            }
            var yAxis = this._originalData.yAxis;
            var yAxisIndex = this._zoom.yAxisIndex;
            for (var i = 0, l = yAxisIndex.length; i &lt; l; i++) {
                maxLength = Math.max(maxLength, yAxis[yAxisIndex[i]].length);
            }
            var seriesIndex = this._zoom.seriesIndex[0];
            var data = this._originalData.series[seriesIndex];
            var maxValue = Number.MIN_VALUE;
            var minValue = Number.MAX_VALUE;
            var value;
            for (var i = 0, l = data.length; i &lt; l; i++) {
                value = data[i] != null ? data[i].value != null ? data[i].value : data[i] : 0;
                if (this.option.series[seriesIndex].type == ecConfig.CHART_TYPE_K) {
                    value = value[1];
                }
                if (isNaN(value)) {
                    value = 0;
                }
                maxValue = Math.max(maxValue, value);
                minValue = Math.min(minValue, value);
            }
            var valueRange = maxValue - minValue;
            var pointList = [];
            var x = width / (maxLength - (maxLength &gt; 1 ? 1 : 0));
            var y = height / (maxLength - (maxLength &gt; 1 ? 1 : 0));
            var step = 1;
            if (this.zoomOption.orient == &#x27;horizontal&#x27; &amp;&amp; x &lt; 1) {
                step = Math.floor(maxLength * 3 / width);
            } else if (this.zoomOption.orient == &#x27;vertical&#x27; &amp;&amp; y &lt; 1) {
                step = Math.floor(maxLength * 3 / height);
            }
            for (var i = 0, l = maxLength; i &lt; l; i += step) {
                value = data[i] != null ? data[i].value != null ? data[i].value : data[i] : 0;
                if (this.option.series[seriesIndex].type == ecConfig.CHART_TYPE_K) {
                    value = value[1];
                }
                if (isNaN(value)) {
                    value = 0;
                }
                if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                    pointList.push([
                        this._location.x + x * i,
                        this._location.y + height - 1 - Math.round((value - minValue) / valueRange * (height - 10))
                    ]);
                } else {
                    pointList.push([
                        this._location.x + 1 + Math.round((value - minValue) / valueRange * (width - 10)),
                        this._location.y + y * i
                    ]);
                }
            }
            if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                pointList.push([
                    this._location.x + width,
                    this._location.y + height
                ]);
                pointList.push([
                    this._location.x,
                    this._location.y + height
                ]);
            } else {
                pointList.push([
                    this._location.x,
                    this._location.y + height
                ]);
                pointList.push([
                    this._location.x,
                    this._location.y
                ]);
            }
            this.shapeList.push(new PolygonShape({
                zlevel: this._zlevelBase,
                style: {
                    pointList: pointList,
                    color: this.zoomOption.dataBackgroundColor
                },
                hoverable: false
            }));
        },
        _buildFiller: function () {
            this._fillerShae = {
                zlevel: this._zlevelBase,
                draggable: true,
                ondrift: this._ondrift,
                ondragend: this._ondragend,
                _type: &#x27;filler&#x27;
            };
            if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                this._fillerShae.style = {
                    x: this._location.x + Math.round(this._zoom.start / 100 * this._location.width) + this._handleSize,
                    y: this._location.y,
                    width: this._zoom.size - this._handleSize * 2,
                    height: this._location.height,
                    color: this.zoomOption.fillerColor,
                    text: &#x27;:::&#x27;,
                    textPosition: &#x27;inside&#x27;
                };
            } else {
                this._fillerShae.style = {
                    x: this._location.x,
                    y: this._location.y + Math.round(this._zoom.start / 100 * this._location.height) + this._handleSize,
                    width: this._location.width,
                    height: this._zoom.size - this._handleSize * 2,
                    color: this.zoomOption.fillerColor,
                    text: &#x27;::&#x27;,
                    textPosition: &#x27;inside&#x27;
                };
            }
            this._fillerShae.highlightStyle = {
                brushType: &#x27;fill&#x27;,
                color: &#x27;rgba(0,0,0,0)&#x27;
            };
            this._fillerShae = new RectangleShape(this._fillerShae);
            this.shapeList.push(this._fillerShae);
        },
        _buildHandle: function () {
            this._startShape = {
                zlevel: this._zlevelBase,
                draggable: true,
                style: {
                    iconType: &#x27;rectangle&#x27;,
                    x: this._location.x,
                    y: this._location.y,
                    width: this._handleSize,
                    height: this._handleSize,
                    color: this.zoomOption.handleColor,
                    text: &#x27;=&#x27;,
                    textPosition: &#x27;inside&#x27;
                },
                highlightStyle: {
                    text: &#x27;&#x27;,
                    brushType: &#x27;fill&#x27;,
                    textPosition: &#x27;left&#x27;
                },
                ondrift: this._ondrift,
                ondragend: this._ondragend
            };
            if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                this._startShape.style.height = this._location.height;
                this._endShape = zrUtil.clone(this._startShape);
                this._startShape.style.x = this._fillerShae.style.x - this._handleSize, this._endShape.style.x = this._fillerShae.style.x + this._fillerShae.style.width;
                this._endShape.highlightStyle.textPosition = &#x27;right&#x27;;
            } else {
                this._startShape.style.width = this._location.width;
                this._endShape = zrUtil.clone(this._startShape);
                this._startShape.style.y = this._fillerShae.style.y - this._handleSize;
                this._startShape.highlightStyle.textPosition = &#x27;top&#x27;;
                this._endShape.style.y = this._fillerShae.style.y + this._fillerShae.style.height;
                this._endShape.highlightStyle.textPosition = &#x27;bottom&#x27;;
            }
            this._startShape = new IconShape(this._startShape);
            this._endShape = new IconShape(this._endShape);
            this.shapeList.push(this._startShape);
            this.shapeList.push(this._endShape);
        },
        _buildFrame: function () {
            var x = this.subPixelOptimize(this._location.x, 1);
            var y = this.subPixelOptimize(this._location.y, 1);
            this._startFrameShape = {
                zlevel: this._zlevelBase,
                hoverable: false,
                style: {
                    x: x,
                    y: y,
                    width: this._location.width - (x &gt; this._location.x ? 1 : 0),
                    height: this._location.height - (y &gt; this._location.y ? 1 : 0),
                    lineWidth: 1,
                    brushType: &#x27;stroke&#x27;,
                    strokeColor: this.zoomOption.handleColor
                }
            };
            this._endFrameShape = zrUtil.clone(this._startFrameShape);
            this._startFrameShape = new RectangleShape(this._startFrameShape);
            this._endFrameShape = new RectangleShape(this._endFrameShape);
            this.shapeList.push(this._startFrameShape);
            this.shapeList.push(this._endFrameShape);
            return;
        },
        _syncHandleShape: function () {
            if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                this._startShape.style.x = this._fillerShae.style.x - this._handleSize;
                this._endShape.style.x = this._fillerShae.style.x + this._fillerShae.style.width;
                this._zoom.start = Math.floor((this._startShape.style.x - this._location.x) / this._location.width * 100);
                this._zoom.end = Math.ceil((this._endShape.style.x + this._handleSize - this._location.x) / this._location.width * 100);
            } else {
                this._startShape.style.y = this._fillerShae.style.y - this._handleSize;
                this._endShape.style.y = this._fillerShae.style.y + this._fillerShae.style.height;
                this._zoom.start = Math.floor((this._startShape.style.y - this._location.y) / this._location.height * 100);
                this._zoom.end = Math.ceil((this._endShape.style.y + this._handleSize - this._location.y) / this._location.height * 100);
            }
            this.zr.modShape(this._startShape.id);
            this.zr.modShape(this._endShape.id);
            this._syncFrameShape();
            this.zr.refresh();
        },
        _syncFillerShape: function () {
            var a;
            var b;
            if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                a = this._startShape.style.x;
                b = this._endShape.style.x;
                this._fillerShae.style.x = Math.min(a, b) + this._handleSize;
                this._fillerShae.style.width = Math.abs(a - b) - this._handleSize;
                this._zoom.start = Math.floor((Math.min(a, b) - this._location.x) / this._location.width * 100);
                this._zoom.end = Math.ceil((Math.max(a, b) + this._handleSize - this._location.x) / this._location.width * 100);
            } else {
                a = this._startShape.style.y;
                b = this._endShape.style.y;
                this._fillerShae.style.y = Math.min(a, b) + this._handleSize;
                this._fillerShae.style.height = Math.abs(a - b) - this._handleSize;
                this._zoom.start = Math.floor((Math.min(a, b) - this._location.y) / this._location.height * 100);
                this._zoom.end = Math.ceil((Math.max(a, b) + this._handleSize - this._location.y) / this._location.height * 100);
            }
            this.zr.modShape(this._fillerShae.id);
            this._syncFrameShape();
            this.zr.refresh();
        },
        _syncFrameShape: function () {
            if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                this._startFrameShape.style.width = this._fillerShae.style.x - this._location.x;
                this._endFrameShape.style.x = this._fillerShae.style.x + this._fillerShae.style.width;
                this._endFrameShape.style.width = this._location.x + this._location.width - this._endFrameShape.style.x;
            } else {
                this._startFrameShape.style.height = this._fillerShae.style.y - this._location.y;
                this._endFrameShape.style.y = this._fillerShae.style.y + this._fillerShae.style.height;
                this._endFrameShape.style.height = this._location.y + this._location.height - this._endFrameShape.style.y;
            }
            this.zr.modShape(this._startFrameShape.id);
            this.zr.modShape(this._endFrameShape.id);
        },
        _syncShape: function () {
            if (!this.zoomOption.show) {
                return;
            }
            if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                this._startShape.style.x = this._location.x + this._zoom.start / 100 * this._location.width;
                this._endShape.style.x = this._location.x + this._zoom.end / 100 * this._location.width - this._handleSize;
                this._fillerShae.style.x = this._startShape.style.x + this._handleSize;
                this._fillerShae.style.width = this._endShape.style.x - this._startShape.style.x - this._handleSize;
            } else {
                this._startShape.style.y = this._location.y + this._zoom.start / 100 * this._location.height;
                this._endShape.style.y = this._location.y + this._zoom.end / 100 * this._location.height - this._handleSize;
                this._fillerShae.style.y = this._startShape.style.y + this._handleSize;
                this._fillerShae.style.height = this._endShape.style.y - this._startShape.style.y - this._handleSize;
            }
            this.zr.modShape(this._startShape.id);
            this.zr.modShape(this._endShape.id);
            this.zr.modShape(this._fillerShae.id);
            this._syncFrameShape();
            this.zr.refresh();
        },
        _syncData: function (dispatchNow) {
            var target;
            var start;
            var end;
            var length;
            var data;
            for (var key in this._originalData) {
                target = this._originalData[key];
                for (var idx in target) {
                    data = target[idx];
                    if (data == null) {
                        continue;
                    }
                    length = data.length;
                    start = Math.floor(this._zoom.start / 100 * length);
                    end = Math.ceil(this._zoom.end / 100 * length);
                    if (!(this.option[key][idx].data[0] instanceof Array) || this.option[key][idx].type == ecConfig.CHART_TYPE_K) {
                        this.option[key][idx].data = data.slice(start, end);
                    } else {
                        this._setScale();
                        this.option[key][idx].data = this._synScatterData(idx, data);
                    }
                }
            }
            if (!this._isSilence &amp;&amp; (this.zoomOption.realtime || dispatchNow)) {
                this.messageCenter.dispatch(ecConfig.EVENT.DATA_ZOOM, null, { zoom: this._zoom }, this.myChart);
            }
        },
        _synScatterData: function (seriesIndex, data) {
            if (this._zoom.start === 0 &amp;&amp; this._zoom.end == 100 &amp;&amp; this._zoom.start2 === 0 &amp;&amp; this._zoom.end2 == 100) {
                return data;
            }
            var newData = [];
            var scale = this._zoom.scatterMap[seriesIndex];
            var total;
            var xStart;
            var xEnd;
            var yStart;
            var yEnd;
            if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                total = scale.x.max - scale.x.min;
                xStart = this._zoom.start / 100 * total + scale.x.min;
                xEnd = this._zoom.end / 100 * total + scale.x.min;
                total = scale.y.max - scale.y.min;
                yStart = this._zoom.start2 / 100 * total + scale.y.min;
                yEnd = this._zoom.end2 / 100 * total + scale.y.min;
            } else {
                total = scale.x.max - scale.x.min;
                xStart = this._zoom.start2 / 100 * total + scale.x.min;
                xEnd = this._zoom.end2 / 100 * total + scale.x.min;
                total = scale.y.max - scale.y.min;
                yStart = this._zoom.start / 100 * total + scale.y.min;
                yEnd = this._zoom.end / 100 * total + scale.y.min;
            }
            var value;
            for (var i = 0, l = data.length; i &lt; l; i++) {
                value = data[i].value || data[i];
                if (value[0] &gt;= xStart &amp;&amp; value[0] &lt;= xEnd &amp;&amp; value[1] &gt;= yStart &amp;&amp; value[1] &lt;= yEnd) {
                    newData.push(data[i]);
                }
            }
            return newData;
        },
        _setScale: function () {
            var needScale = this._zoom.start !== 0 || this._zoom.end !== 100 || this._zoom.start2 !== 0 || this._zoom.end2 !== 100;
            var axis = {
                xAxis: this.option.xAxis,
                yAxis: this.option.yAxis
            };
            for (var key in axis) {
                for (var i = 0, l = axis[key].length; i &lt; l; i++) {
                    axis[key][i].scale = needScale || axis[key][i]._scale;
                }
            }
        },
        _backupScale: function () {
            var axis = {
                xAxis: this.option.xAxis,
                yAxis: this.option.yAxis
            };
            for (var key in axis) {
                for (var i = 0, l = axis[key].length; i &lt; l; i++) {
                    axis[key][i]._scale = axis[key][i].scale;
                }
            }
        },
        _getDetail: function () {
            var key = this.zoomOption.orient == &#x27;horizontal&#x27; ? &#x27;xAxis&#x27; : &#x27;yAxis&#x27;;
            var target = this._originalData[key];
            for (var idx in target) {
                var data = target[idx];
                if (data == null) {
                    continue;
                }
                var length = data.length;
                var start = Math.floor(this._zoom.start / 100 * length);
                var end = Math.ceil(this._zoom.end / 100 * length);
                end -= end &gt;= length ? 1 : 0;
                return {
                    start: data[start].value != null ? data[start].value : data[start],
                    end: data[end].value != null ? data[end].value : data[end]
                };
            }
            var seriesIndex = this._zoom.seriesIndex[0];
            var axisIndex = this.option.series[seriesIndex][key + &#x27;Index&#x27;] || 0;
            var axisType = this.option[key][axisIndex].type;
            var min = this._zoom.scatterMap[seriesIndex][key.charAt(0)].min;
            var max = this._zoom.scatterMap[seriesIndex][key.charAt(0)].max;
            var gap = max - min;
            if (axisType == &#x27;value&#x27;) {
                return {
                    start: min + gap * this._zoom.start / 100,
                    end: min + gap * this._zoom.end / 100
                };
            } else if (axisType == &#x27;time&#x27;) {
                max = min + gap * this._zoom.end / 100;
                min = min + gap * this._zoom.start / 100;
                var formatter = ecDate.getAutoFormatter(min, max).formatter;
                return {
                    start: ecDate.format(formatter, min),
                    end: ecDate.format(formatter, max)
                };
            }
            return {
                start: &#x27;&#x27;,
                end: &#x27;&#x27;
            };
        },
        __ondrift: function (shape, dx, dy) {
            if (this.zoomOption.zoomLock) {
                shape = this._fillerShae;
            }
            var detailSize = shape._type == &#x27;filler&#x27; ? this._handleSize : 0;
            if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                if (shape.style.x + dx - detailSize &lt;= this._location.x) {
                    shape.style.x = this._location.x + detailSize;
                } else if (shape.style.x + dx + shape.style.width + detailSize &gt;= this._location.x + this._location.width) {
                    shape.style.x = this._location.x + this._location.width - shape.style.width - detailSize;
                } else {
                    shape.style.x += dx;
                }
            } else {
                if (shape.style.y + dy - detailSize &lt;= this._location.y) {
                    shape.style.y = this._location.y + detailSize;
                } else if (shape.style.y + dy + shape.style.height + detailSize &gt;= this._location.y + this._location.height) {
                    shape.style.y = this._location.y + this._location.height - shape.style.height - detailSize;
                } else {
                    shape.style.y += dy;
                }
            }
            if (shape._type == &#x27;filler&#x27;) {
                this._syncHandleShape();
            } else {
                this._syncFillerShape();
            }
            if (this.zoomOption.realtime) {
                this._syncData();
            }
            if (this.zoomOption.showDetail) {
                var deltail = this._getDetail();
                this._startShape.style.text = this._startShape.highlightStyle.text = deltail.start;
                this._endShape.style.text = this._endShape.highlightStyle.text = deltail.end;
                this._startShape.style.textPosition = this._startShape.highlightStyle.textPosition;
                this._endShape.style.textPosition = this._endShape.highlightStyle.textPosition;
            }
            return true;
        },
        __ondragend: function () {
            if (this.zoomOption.showDetail) {
                this._startShape.style.text = this._endShape.style.text = &#x27;=&#x27;;
                this._startShape.style.textPosition = this._endShape.style.textPosition = &#x27;inside&#x27;;
                this.zr.modShape(this._startShape.id);
                this.zr.modShape(this._endShape.id);
                this.zr.refreshNextFrame();
            }
            this.isDragend = true;
        },
        ondragend: function (param, status) {
            if (!this.isDragend || !param.target) {
                return;
            }
            !this.zoomOption.realtime &amp;&amp; this._syncData();
            status.dragOut = true;
            status.dragIn = true;
            if (!this._isSilence &amp;&amp; !this.zoomOption.realtime) {
                this.messageCenter.dispatch(ecConfig.EVENT.DATA_ZOOM, null, { zoom: this._zoom }, this.myChart);
            }
            status.needRefresh = false;
            this.isDragend = false;
            return;
        },
        ondataZoom: function (param, status) {
            status.needRefresh = true;
            return;
        },
        absoluteZoom: function (param) {
            this._zoom.start = param.start;
            this._zoom.end = param.end;
            this._zoom.start2 = param.start2;
            this._zoom.end2 = param.end2;
            this._syncShape();
            this._syncData(true);
            return;
        },
        rectZoom: function (param) {
            if (!param) {
                this._zoom.start = this._zoom.start2 = 0;
                this._zoom.end = this._zoom.end2 = 100;
                this._syncShape();
                this._syncData(true);
                return this._zoom;
            }
            var gridArea = this.component.grid.getArea();
            var rect = {
                x: param.x,
                y: param.y,
                width: param.width,
                height: param.height
            };
            if (rect.width &lt; 0) {
                rect.x += rect.width;
                rect.width = -rect.width;
            }
            if (rect.height &lt; 0) {
                rect.y += rect.height;
                rect.height = -rect.height;
            }
            if (rect.x &gt; gridArea.x + gridArea.width || rect.y &gt; gridArea.y + gridArea.height) {
                return false;
            }
            if (rect.x &lt; gridArea.x) {
                rect.x = gridArea.x;
            }
            if (rect.x + rect.width &gt; gridArea.x + gridArea.width) {
                rect.width = gridArea.x + gridArea.width - rect.x;
            }
            if (rect.y + rect.height &gt; gridArea.y + gridArea.height) {
                rect.height = gridArea.y + gridArea.height - rect.y;
            }
            var total;
            var sdx = (rect.x - gridArea.x) / gridArea.width;
            var edx = 1 - (rect.x + rect.width - gridArea.x) / gridArea.width;
            var sdy = 1 - (rect.y + rect.height - gridArea.y) / gridArea.height;
            var edy = (rect.y - gridArea.y) / gridArea.height;
            if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                total = this._zoom.end - this._zoom.start;
                this._zoom.start += total * sdx;
                this._zoom.end -= total * edx;
                total = this._zoom.end2 - this._zoom.start2;
                this._zoom.start2 += total * sdy;
                this._zoom.end2 -= total * edy;
            } else {
                total = this._zoom.end - this._zoom.start;
                this._zoom.start += total * sdy;
                this._zoom.end -= total * edy;
                total = this._zoom.end2 - this._zoom.start2;
                this._zoom.start2 += total * sdx;
                this._zoom.end2 -= total * edx;
            }
            this._syncShape();
            this._syncData(true);
            return this._zoom;
        },
        syncBackupData: function (curOption) {
            var start;
            var target = this._originalData[&#x27;series&#x27;];
            var curSeries = curOption.series;
            var curData;
            for (var i = 0, l = curSeries.length; i &lt; l; i++) {
                curData = curSeries[i].data || curSeries[i].eventList;
                if (target[i]) {
                    start = Math.floor(this._zoom.start / 100 * target[i].length);
                } else {
                    start = 0;
                }
                for (var j = 0, k = curData.length; j &lt; k; j++) {
                    if (target[i]) {
                        target[i][j + start] = curData[j];
                    }
                }
            }
        },
        syncOption: function (magicOption) {
            this.silence(true);
            this.option = magicOption;
            this.option.dataZoom = this.reformOption(this.option.dataZoom);
            this.zoomOption = this.option.dataZoom;
            if (!this.myChart.canvasSupported) {
                this.zoomOption.realtime = false;
            }
            this.clear();
            this._location = this._getLocation();
            this._zoom = this._getZoom();
            this._backupData();
            if (this.option.dataZoom &amp;&amp; this.option.dataZoom.show) {
                this._buildShape();
            }
            this._syncData();
            this.silence(false);
        },
        silence: function (s) {
            this._isSilence = s;
        },
        getRealDataIndex: function (sIdx, dIdx) {
            if (!this._originalData || this._zoom.start === 0 &amp;&amp; this._zoom.end == 100) {
                return dIdx;
            }
            var sreies = this._originalData.series;
            if (sreies[sIdx]) {
                return Math.floor(this._zoom.start / 100 * sreies[sIdx].length) + dIdx;
            }
            return -1;
        },
        resize: function () {
            this.clear();
            this._location = this._getLocation();
            this._zoom = this._getZoom();
            if (this.option.dataZoom.show) {
                this._buildShape();
            }
        }
    };
    zrUtil.inherits(DataZoom, Base);
    require(&#x27;../component&#x27;).define(&#x27;dataZoom&#x27;, DataZoom);
    return DataZoom;
});define(&#x27;echarts/component/categoryAxis&#x27;, [
    &#x27;require&#x27;,
    &#x27;./base&#x27;,
    &#x27;zrender/shape/Text&#x27;,
    &#x27;zrender/shape/Line&#x27;,
    &#x27;zrender/shape/Rectangle&#x27;,
    &#x27;../config&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;zrender/tool/area&#x27;,
    &#x27;../component&#x27;
], function (require) {
    var Base = require(&#x27;./base&#x27;);
    var TextShape = require(&#x27;zrender/shape/Text&#x27;);
    var LineShape = require(&#x27;zrender/shape/Line&#x27;);
    var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
    var ecConfig = require(&#x27;../config&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    var zrArea = require(&#x27;zrender/tool/area&#x27;);
    function CategoryAxis(ecTheme, messageCenter, zr, option, myChart, axisBase) {
        if (option.data.length &lt; 1) {
            console.error(&#x27;option.data.length &lt; 1.&#x27;);
            return;
        }
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.grid = this.component.grid;
        for (var method in axisBase) {
            this[method] = axisBase[method];
        }
        this.refresh(option);
    }
    CategoryAxis.prototype = {
        type: ecConfig.COMPONENT_TYPE_AXIS_CATEGORY,
        _getReformedLabel: function (idx) {
            var data = typeof this.option.data[idx].value != &#x27;undefined&#x27; ? this.option.data[idx].value : this.option.data[idx];
            var formatter = this.option.data[idx].formatter || this.option.axisLabel.formatter;
            if (formatter) {
                if (typeof formatter == &#x27;function&#x27;) {
                    data = formatter.call(this.myChart, data);
                } else if (typeof formatter == &#x27;string&#x27;) {
                    data = formatter.replace(&#x27;{value}&#x27;, data);
                }
            }
            return data;
        },
        _getInterval: function () {
            var interval = this.option.axisLabel.interval;
            if (interval == &#x27;auto&#x27;) {
                var fontSize = this.option.axisLabel.textStyle.fontSize;
                var data = this.option.data;
                var dataLength = this.option.data.length;
                if (this.isHorizontal()) {
                    if (dataLength &gt; 3) {
                        var gap = this.getGap();
                        var isEnough = false;
                        var labelSpace;
                        var labelSize;
                        var step = Math.floor(0.5 / gap);
                        step = step &lt; 1 ? 1 : step;
                        interval = Math.floor(15 / gap);
                        while (!isEnough &amp;&amp; interval &lt; dataLength) {
                            interval += step;
                            isEnough = true;
                            labelSpace = Math.floor(gap * interval);
                            for (var i = Math.floor((dataLength - 1) / interval) * interval; i &gt;= 0; i -= interval) {
                                if (this.option.axisLabel.rotate !== 0) {
                                    labelSize = fontSize;
                                } else if (data[i].textStyle) {
                                    labelSize = zrArea.getTextWidth(this._getReformedLabel(i), this.getFont(zrUtil.merge(data[i].textStyle, this.option.axisLabel.textStyle)));
                                } else {
                                    var label = this._getReformedLabel(i) + &#x27;&#x27;;
                                    var wLen = (label.match(/\w/g) || &#x27;&#x27;).length;
                                    var oLen = label.length - wLen;
                                    labelSize = wLen * fontSize * 2 / 3 + oLen * fontSize;
                                }
                                if (labelSpace &lt; labelSize) {
                                    isEnough = false;
                                    break;
                                }
                            }
                        }
                    } else {
                        interval = 1;
                    }
                } else {
                    if (dataLength &gt; 3) {
                        var gap = this.getGap();
                        interval = Math.floor(11 / gap);
                        while (gap * interval - 6 &lt; fontSize &amp;&amp; interval &lt; dataLength) {
                            interval++;
                        }
                    } else {
                        interval = 1;
                    }
                }
            } else {
                interval = interval - 0 + 1;
            }
            return interval;
        },
        _buildShape: function () {
            this._interval = this._getInterval();
            if (!this.option.show) {
                return;
            }
            this.option.splitArea.show &amp;&amp; this._buildSplitArea();
            this.option.splitLine.show &amp;&amp; this._buildSplitLine();
            this.option.axisLine.show &amp;&amp; this._buildAxisLine();
            this.option.axisTick.show &amp;&amp; this._buildAxisTick();
            this.option.axisLabel.show &amp;&amp; this._buildAxisLabel();
            for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },
        _buildAxisTick: function () {
            var axShape;
            var dataLength = this.option.data.length;
            var tickOption = this.option.axisTick;
            var length = tickOption.length;
            var color = tickOption.lineStyle.color;
            var lineWidth = tickOption.lineStyle.width;
            var interval = tickOption.interval == &#x27;auto&#x27; ? this._interval : tickOption.interval - 0 + 1;
            var onGap = tickOption.onGap;
            var optGap = onGap ? this.getGap() / 2 : typeof onGap == &#x27;undefined&#x27; ? this.option.boundaryGap ? this.getGap() / 2 : 0 : 0;
            var startIndex = optGap &gt; 0 ? -interval : 0;
            if (this.isHorizontal()) {
                var yPosition = this.option.position == &#x27;bottom&#x27; ? tickOption.inside ? this.grid.getYend() - length - 1 : this.grid.getYend() + 1 : tickOption.inside ? this.grid.getY() + 1 : this.grid.getY() - length - 1;
                var x;
                for (var i = startIndex; i &lt; dataLength; i += interval) {
                    x = this.subPixelOptimize(this.getCoordByIndex(i) + (i &gt;= 0 ? optGap : 0), lineWidth);
                    axShape = {
                        _axisShape: &#x27;axisTick&#x27;,
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            xStart: x,
                            yStart: yPosition,
                            xEnd: x,
                            yEnd: yPosition + length,
                            strokeColor: color,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            } else {
                var xPosition = this.option.position == &#x27;left&#x27; ? tickOption.inside ? this.grid.getX() + 1 : this.grid.getX() - length - 1 : tickOption.inside ? this.grid.getXend() - length - 1 : this.grid.getXend() + 1;
                var y;
                for (var i = startIndex; i &lt; dataLength; i += interval) {
                    y = this.subPixelOptimize(this.getCoordByIndex(i) - (i &gt;= 0 ? optGap : 0), lineWidth);
                    axShape = {
                        _axisShape: &#x27;axisTick&#x27;,
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            xStart: xPosition,
                            yStart: y,
                            xEnd: xPosition + length,
                            yEnd: y,
                            strokeColor: color,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            }
        },
        _buildAxisLabel: function () {
            var axShape;
            var data = this.option.data;
            var dataLength = this.option.data.length;
            var rotate = this.option.axisLabel.rotate;
            var margin = this.option.axisLabel.margin;
            var clickable = this.option.axisLabel.clickable;
            var textStyle = this.option.axisLabel.textStyle;
            var dataTextStyle;
            if (this.isHorizontal()) {
                var yPosition;
                var baseLine;
                if (this.option.position == &#x27;bottom&#x27;) {
                    yPosition = this.grid.getYend() + margin;
                    baseLine = &#x27;top&#x27;;
                } else {
                    yPosition = this.grid.getY() - margin;
                    baseLine = &#x27;bottom&#x27;;
                }
                for (var i = 0; i &lt; dataLength; i += this._interval) {
                    if (this._getReformedLabel(i) === &#x27;&#x27;) {
                        continue;
                    }
                    dataTextStyle = zrUtil.merge(data[i].textStyle || {}, textStyle);
                    axShape = {
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            x: this.getCoordByIndex(i),
                            y: yPosition,
                            color: dataTextStyle.color,
                            text: this._getReformedLabel(i),
                            textFont: this.getFont(dataTextStyle),
                            textAlign: dataTextStyle.align || &#x27;center&#x27;,
                            textBaseline: dataTextStyle.baseline || baseLine
                        }
                    };
                    if (rotate) {
                        axShape.style.textAlign = rotate &gt; 0 ? this.option.position == &#x27;bottom&#x27; ? &#x27;right&#x27; : &#x27;left&#x27; : this.option.position == &#x27;bottom&#x27; ? &#x27;left&#x27; : &#x27;right&#x27;;
                        axShape.rotation = [
                            rotate * Math.PI / 180,
                            axShape.style.x,
                            axShape.style.y
                        ];
                    }
                    this.shapeList.push(new TextShape(this._axisLabelClickable(clickable, axShape)));
                }
            } else {
                var xPosition;
                var align;
                if (this.option.position == &#x27;left&#x27;) {
                    xPosition = this.grid.getX() - margin;
                    align = &#x27;right&#x27;;
                } else {
                    xPosition = this.grid.getXend() + margin;
                    align = &#x27;left&#x27;;
                }
                for (var i = 0; i &lt; dataLength; i += this._interval) {
                    if (this._getReformedLabel(i) === &#x27;&#x27;) {
                        continue;
                    }
                    dataTextStyle = zrUtil.merge(data[i].textStyle || {}, textStyle);
                    axShape = {
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            x: xPosition,
                            y: this.getCoordByIndex(i),
                            color: dataTextStyle.color,
                            text: this._getReformedLabel(i),
                            textFont: this.getFont(dataTextStyle),
                            textAlign: dataTextStyle.align || align,
                            textBaseline: dataTextStyle.baseline || i === 0 &amp;&amp; this.option.name !== &#x27;&#x27; ? &#x27;bottom&#x27; : i == dataLength - 1 &amp;&amp; this.option.name !== &#x27;&#x27; ? &#x27;top&#x27; : &#x27;middle&#x27;
                        }
                    };
                    if (rotate) {
                        axShape.rotation = [
                            rotate * Math.PI / 180,
                            axShape.style.x,
                            axShape.style.y
                        ];
                    }
                    this.shapeList.push(new TextShape(this._axisLabelClickable(clickable, axShape)));
                }
            }
        },
        _buildSplitLine: function () {
            var axShape;
            var dataLength = this.option.data.length;
            var sLineOption = this.option.splitLine;
            var lineType = sLineOption.lineStyle.type;
            var lineWidth = sLineOption.lineStyle.width;
            var color = sLineOption.lineStyle.color;
            color = color instanceof Array ? color : [color];
            var colorLength = color.length;
            var onGap = sLineOption.onGap;
            var optGap = onGap ? this.getGap() / 2 : typeof onGap == &#x27;undefined&#x27; ? this.option.boundaryGap ? this.getGap() / 2 : 0 : 0;
            dataLength -= onGap || typeof onGap == &#x27;undefined&#x27; &amp;&amp; this.option.boundaryGap ? 1 : 0;
            if (this.isHorizontal()) {
                var sy = this.grid.getY();
                var ey = this.grid.getYend();
                var x;
                for (var i = 0; i &lt; dataLength; i += this._interval) {
                    x = this.subPixelOptimize(this.getCoordByIndex(i) + optGap, lineWidth);
                    axShape = {
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            xStart: x,
                            yStart: sy,
                            xEnd: x,
                            yEnd: ey,
                            strokeColor: color[i / this._interval % colorLength],
                            lineType: lineType,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            } else {
                var sx = this.grid.getX();
                var ex = this.grid.getXend();
                var y;
                for (var i = 0; i &lt; dataLength; i += this._interval) {
                    y = this.subPixelOptimize(this.getCoordByIndex(i) - optGap, lineWidth);
                    axShape = {
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            xStart: sx,
                            yStart: y,
                            xEnd: ex,
                            yEnd: y,
                            strokeColor: color[i / this._interval % colorLength],
                            linetype: lineType,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            }
        },
        _buildSplitArea: function () {
            var axShape;
            var sAreaOption = this.option.splitArea;
            var color = sAreaOption.areaStyle.color;
            if (!(color instanceof Array)) {
                axShape = {
                    zlevel: this._zlevelBase,
                    hoverable: false,
                    style: {
                        x: this.grid.getX(),
                        y: this.grid.getY(),
                        width: this.grid.getWidth(),
                        height: this.grid.getHeight(),
                        color: color
                    }
                };
                this.shapeList.push(new RectangleShape(axShape));
            } else {
                var colorLength = color.length;
                var dataLength = this.option.data.length;
                var onGap = sAreaOption.onGap;
                var optGap = onGap ? this.getGap() / 2 : typeof onGap == &#x27;undefined&#x27; ? this.option.boundaryGap ? this.getGap() / 2 : 0 : 0;
                if (this.isHorizontal()) {
                    var y = this.grid.getY();
                    var height = this.grid.getHeight();
                    var lastX = this.grid.getX();
                    var curX;
                    for (var i = 0; i &lt;= dataLength; i += this._interval) {
                        curX = i &lt; dataLength ? this.getCoordByIndex(i) + optGap : this.grid.getXend();
                        axShape = {
                            zlevel: this._zlevelBase,
                            hoverable: false,
                            style: {
                                x: lastX,
                                y: y,
                                width: curX - lastX,
                                height: height,
                                color: color[i / this._interval % colorLength]
                            }
                        };
                        this.shapeList.push(new RectangleShape(axShape));
                        lastX = curX;
                    }
                } else {
                    var x = this.grid.getX();
                    var width = this.grid.getWidth();
                    var lastYend = this.grid.getYend();
                    var curY;
                    for (var i = 0; i &lt;= dataLength; i += this._interval) {
                        curY = i &lt; dataLength ? this.getCoordByIndex(i) - optGap : this.grid.getY();
                        axShape = {
                            zlevel: this._zlevelBase,
                            hoverable: false,
                            style: {
                                x: x,
                                y: curY,
                                width: width,
                                height: lastYend - curY,
                                color: color[i / this._interval % colorLength]
                            }
                        };
                        this.shapeList.push(new RectangleShape(axShape));
                        lastYend = curY;
                    }
                }
            }
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = this.reformOption(newOption);
                this.option.axisLabel.textStyle = zrUtil.merge(this.option.axisLabel.textStyle || {}, this.ecTheme.textStyle);
            }
            this.clear();
            this._buildShape();
        },
        getGap: function () {
            var dataLength = this.option.data.length;
            var total = this.isHorizontal() ? this.grid.getWidth() : this.grid.getHeight();
            if (this.option.boundaryGap) {
                return total / dataLength;
            } else {
                return total / (dataLength &gt; 1 ? dataLength - 1 : 1);
            }
        },
        getCoord: function (value) {
            var data = this.option.data;
            var dataLength = data.length;
            var gap = this.getGap();
            var position = this.option.boundaryGap ? gap / 2 : 0;
            for (var i = 0; i &lt; dataLength; i++) {
                if (data[i] == value || typeof data[i].value != &#x27;undefined&#x27; &amp;&amp; data[i].value == value) {
                    if (this.isHorizontal()) {
                        position = this.grid.getX() + position;
                    } else {
                        position = this.grid.getYend() - position;
                    }
                    return position;
                }
                position += gap;
            }
        },
        getCoordByIndex: function (dataIndex) {
            if (dataIndex &lt; 0) {
                if (this.isHorizontal()) {
                    return this.grid.getX();
                } else {
                    return this.grid.getYend();
                }
            } else if (dataIndex &gt; this.option.data.length - 1) {
                if (this.isHorizontal()) {
                    return this.grid.getXend();
                } else {
                    return this.grid.getY();
                }
            } else {
                var gap = this.getGap();
                var position = this.option.boundaryGap ? gap / 2 : 0;
                position += dataIndex * gap;
                if (this.isHorizontal()) {
                    position = this.grid.getX() + position;
                } else {
                    position = this.grid.getYend() - position;
                }
                return position;
            }
        },
        getNameByIndex: function (dataIndex) {
            var data = this.option.data[dataIndex];
            if (typeof data != &#x27;undefined&#x27; &amp;&amp; typeof data.value != &#x27;undefined&#x27;) {
                return data.value;
            } else {
                return data;
            }
        },
        getIndexByName: function (name) {
            var data = this.option.data;
            var dataLength = data.length;
            for (var i = 0; i &lt; dataLength; i++) {
                if (data[i] == name || typeof data[i].value != &#x27;undefined&#x27; &amp;&amp; data[i].value == name) {
                    return i;
                }
            }
            return -1;
        },
        getValueFromCoord: function () {
            return &#x27;&#x27;;
        },
        isMainAxis: function (dataIndex) {
            return dataIndex % this._interval === 0;
        }
    };
    zrUtil.inherits(CategoryAxis, Base);
    require(&#x27;../component&#x27;).define(&#x27;categoryAxis&#x27;, CategoryAxis);
    return CategoryAxis;
});define(&#x27;echarts/component/valueAxis&#x27;, [
    &#x27;require&#x27;,
    &#x27;./base&#x27;,
    &#x27;zrender/shape/Text&#x27;,
    &#x27;zrender/shape/Line&#x27;,
    &#x27;zrender/shape/Rectangle&#x27;,
    &#x27;../config&#x27;,
    &#x27;../util/date&#x27;,
    &#x27;zrender/tool/util&#x27;,
    &#x27;../util/smartSteps&#x27;,
    &#x27;../util/accMath&#x27;,
    &#x27;../component&#x27;
], function (require) {
    var Base = require(&#x27;./base&#x27;);
    var TextShape = require(&#x27;zrender/shape/Text&#x27;);
    var LineShape = require(&#x27;zrender/shape/Line&#x27;);
    var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
    var ecConfig = require(&#x27;../config&#x27;);
    var ecDate = require(&#x27;../util/date&#x27;);
    var zrUtil = require(&#x27;zrender/tool/util&#x27;);
    function ValueAxis(ecTheme, messageCenter, zr, option, myChart, axisBase, series) {
        if (!series || series.length === 0) {
            console.err(&#x27;option.series.length == 0.&#x27;);
            return;
        }
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.series = series;
        this.grid = this.component.grid;
        for (var method in axisBase) {
            this[method] = axisBase[method];
        }
        this.refresh(option, series);
    }
    ValueAxis.prototype = {
        type: ecConfig.COMPONENT_TYPE_AXIS_VALUE,
        _buildShape: function () {
            this._hasData = false;
            this._calculateValue();
            if (!this._hasData || !this.option.show) {
                return;
            }
            this.option.splitArea.show &amp;&amp; this._buildSplitArea();
            this.option.splitLine.show &amp;&amp; this._buildSplitLine();
            this.option.axisLine.show &amp;&amp; this._buildAxisLine();
            this.option.axisTick.show &amp;&amp; this._buildAxisTick();
            this.option.axisLabel.show &amp;&amp; this._buildAxisLabel();
            for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },
        _buildAxisTick: function () {
            var axShape;
            var data = this._valueList;
            var dataLength = this._valueList.length;
            var tickOption = this.option.axisTick;
            var length = tickOption.length;
            var color = tickOption.lineStyle.color;
            var lineWidth = tickOption.lineStyle.width;
            if (this.isHorizontal()) {
                var yPosition = this.option.position === &#x27;bottom&#x27; ? tickOption.inside ? this.grid.getYend() - length - 1 : this.grid.getYend() + 1 : tickOption.inside ? this.grid.getY() + 1 : this.grid.getY() - length - 1;
                var x;
                for (var i = 0; i &lt; dataLength; i++) {
                    x = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                    axShape = {
                        _axisShape: &#x27;axisTick&#x27;,
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            xStart: x,
                            yStart: yPosition,
                            xEnd: x,
                            yEnd: yPosition + length,
                            strokeColor: color,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            } else {
                var xPosition = this.option.position === &#x27;left&#x27; ? tickOption.inside ? this.grid.getX() + 1 : this.grid.getX() - length - 1 : tickOption.inside ? this.grid.getXend() - length - 1 : this.grid.getXend() + 1;
                var y;
                for (var i = 0; i &lt; dataLength; i++) {
                    y = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                    axShape = {
                        _axisShape: &#x27;axisTick&#x27;,
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            xStart: xPosition,
                            yStart: y,
                            xEnd: xPosition + length,
                            yEnd: y,
                            strokeColor: color,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            }
        },
        _buildAxisLabel: function () {
            var axShape;
            var data = this._valueList;
            var dataLength = this._valueList.length;
            var rotate = this.option.axisLabel.rotate;
            var margin = this.option.axisLabel.margin;
            var clickable = this.option.axisLabel.clickable;
            var textStyle = this.option.axisLabel.textStyle;
            if (this.isHorizontal()) {
                var yPosition;
                var baseLine;
                if (this.option.position === &#x27;bottom&#x27;) {
                    yPosition = this.grid.getYend() + margin;
                    baseLine = &#x27;top&#x27;;
                } else {
                    yPosition = this.grid.getY() - margin;
                    baseLine = &#x27;bottom&#x27;;
                }
                for (var i = 0; i &lt; dataLength; i++) {
                    axShape = {
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            x: this.getCoord(data[i]),
                            y: yPosition,
                            color: typeof textStyle.color === &#x27;function&#x27; ? textStyle.color(data[i]) : textStyle.color,
                            text: this._valueLabel[i],
                            textFont: this.getFont(textStyle),
                            textAlign: textStyle.align || &#x27;center&#x27;,
                            textBaseline: textStyle.baseline || baseLine
                        }
                    };
                    if (rotate) {
                        axShape.style.textAlign = rotate &gt; 0 ? this.option.position === &#x27;bottom&#x27; ? &#x27;right&#x27; : &#x27;left&#x27; : this.option.position === &#x27;bottom&#x27; ? &#x27;left&#x27; : &#x27;right&#x27;;
                        axShape.rotation = [
                            rotate * Math.PI / 180,
                            axShape.style.x,
                            axShape.style.y
                        ];
                    }
                    this.shapeList.push(new TextShape(this._axisLabelClickable(clickable, axShape)));
                }
            } else {
                var xPosition;
                var align;
                if (this.option.position === &#x27;left&#x27;) {
                    xPosition = this.grid.getX() - margin;
                    align = &#x27;right&#x27;;
                } else {
                    xPosition = this.grid.getXend() + margin;
                    align = &#x27;left&#x27;;
                }
                for (var i = 0; i &lt; dataLength; i++) {
                    axShape = {
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            x: xPosition,
                            y: this.getCoord(data[i]),
                            color: typeof textStyle.color === &#x27;function&#x27; ? textStyle.color(data[i]) : textStyle.color,
                            text: this._valueLabel[i],
                            textFont: this.getFont(textStyle),
                            textAlign: textStyle.align || align,
                            textBaseline: textStyle.baseline || i === 0 &amp;&amp; this.option.name !== &#x27;&#x27; ? &#x27;bottom&#x27; : i === dataLength - 1 &amp;&amp; this.option.name !== &#x27;&#x27; ? &#x27;top&#x27; : &#x27;middle&#x27;
                        }
                    };
                    if (rotate) {
                        axShape.rotation = [
                            rotate * Math.PI / 180,
                            axShape.style.x,
                            axShape.style.y
                        ];
                    }
                    this.shapeList.push(new TextShape(this._axisLabelClickable(clickable, axShape)));
                }
            }
        },
        _buildSplitLine: function () {
            var axShape;
            var data = this._valueList;
            var dataLength = this._valueList.length;
            var sLineOption = this.option.splitLine;
            var lineType = sLineOption.lineStyle.type;
            var lineWidth = sLineOption.lineStyle.width;
            var color = sLineOption.lineStyle.color;
            color = color instanceof Array ? color : [color];
            var colorLength = color.length;
            if (this.isHorizontal()) {
                var sy = this.grid.getY();
                var ey = this.grid.getYend();
                var x;
                for (var i = 0; i &lt; dataLength; i++) {
                    x = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                    axShape = {
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            xStart: x,
                            yStart: sy,
                            xEnd: x,
                            yEnd: ey,
                            strokeColor: color[i % colorLength],
                            lineType: lineType,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            } else {
                var sx = this.grid.getX();
                var ex = this.grid.getXend();
                var y;
                for (var i = 0; i &lt; dataLength; i++) {
                    y = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                    axShape = {
                        zlevel: this._zlevelBase,
                        hoverable: false,
                        style: {
                            xStart: sx,
                            yStart: y,
                            xEnd: ex,
                            yEnd: y,
                            strokeColor: color[i % colorLength],
                            lineType: lineType,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            }
        },
        _buildSplitArea: function () {
            var axShape;
            var color = this.option.splitArea.areaStyle.color;
            if (!(color instanceof Array)) {
                axShape = {
                    zlevel: this._zlevelBase,
                    hoverable: false,
                    style: {
                        x: this.grid.getX(),
                        y: this.grid.getY(),
                        width: this.grid.getWidth(),
                        height: this.grid.getHeight(),
                        color: color
                    }
                };
                this.shapeList.push(new RectangleShape(axShape));
            } else {
                var colorLength = color.length;
                var data = this._valueList;
                var dataLength = this._valueList.length;
                if (this.isHorizontal()) {
                    var y = this.grid.getY();
                    var height = this.grid.getHeight();
                    var lastX = this.grid.getX();
                    var curX;
                    for (var i = 0; i &lt;= dataLength; i++) {
                        curX = i &lt; dataLength ? this.getCoord(data[i]) : this.grid.getXend();
                        axShape = {
                            zlevel: this._zlevelBase,
                            hoverable: false,
                            style: {
                                x: lastX,
                                y: y,
                                width: curX - lastX,
                                height: height,
                                color: color[i % colorLength]
                            }
                        };
                        this.shapeList.push(new RectangleShape(axShape));
                        lastX = curX;
                    }
                } else {
                    var x = this.grid.getX();
                    var width = this.grid.getWidth();
                    var lastYend = this.grid.getYend();
                    var curY;
                    for (var i = 0; i &lt;= dataLength; i++) {
                        curY = i &lt; dataLength ? this.getCoord(data[i]) : this.grid.getY();
                        axShape = {
                            zlevel: this._zlevelBase,
                            hoverable: false,
                            style: {
                                x: x,
                                y: curY,
                                width: width,
                                height: lastYend - curY,
                                color: color[i % colorLength]
                            }
                        };
                        this.shapeList.push(new RectangleShape(axShape));
                        lastYend = curY;
                    }
                }
            }
        },
        _calculateValue: function () {
            if (isNaN(this.option.min - 0) || isNaN(this.option.max - 0)) {
                var data = {};
                var xIdx;
                var yIdx;
                var legend = this.component.legend;
                for (var i = 0, l = this.series.length; i &lt; l; i++) {
                    if (this.series[i].type != ecConfig.CHART_TYPE_LINE &amp;&amp; this.series[i].type != ecConfig.CHART_TYPE_BAR &amp;&amp; this.series[i].type != ecConfig.CHART_TYPE_SCATTER &amp;&amp; this.series[i].type != ecConfig.CHART_TYPE_K &amp;&amp; this.series[i].type != ecConfig.CHART_TYPE_EVENTRIVER) {
                        continue;
                    }
                    if (legend &amp;&amp; !legend.isSelected(this.series[i].name)) {
                        continue;
                    }
                    xIdx = this.series[i].xAxisIndex || 0;
                    yIdx = this.series[i].yAxisIndex || 0;
                    if (this.option.xAxisIndex != xIdx &amp;&amp; this.option.yAxisIndex != yIdx) {
                        continue;
                    }
                    this._calculSum(data, i);
                }
                var oriData;
                for (var i in data) {
                    oriData = data[i];
                    for (var j = 0, k = oriData.length; j &lt; k; j++) {
                        if (!isNaN(oriData[j])) {
                            this._hasData = true;
                            this._min = oriData[j];
                            this._max = oriData[j];
                            break;
                        }
                    }
                    if (this._hasData) {
                        break;
                    }
                }
                for (var i in data) {
                    oriData = data[i];
                    for (var j = 0, k = oriData.length; j &lt; k; j++) {
                        if (!isNaN(oriData[j])) {
                            this._min = Math.min(this._min, oriData[j]);
                            this._max = Math.max(this._max, oriData[j]);
                        }
                    }
                }
                var gap = Math.abs(this._max - this._min);
                this._min = isNaN(this.option.min - 0) ? this._min - Math.abs(gap * this.option.boundaryGap[0]) : this.option.min - 0;
                this._max = isNaN(this.option.max - 0) ? this._max + Math.abs(gap * this.option.boundaryGap[1]) : this.option.max - 0;
                if (this._min === this._max) {
                    if (this._max === 0) {
                        this._max = 1;
                    } else if (this._max &gt; 0) {
                        this._min = this._max / this.option.splitNumber != null ? this.option.splitNumber : 5;
                    } else {
                        this._max = this._max / this.option.splitNumber != null ? this.option.splitNumber : 5;
                    }
                }
                this.option.type != &#x27;time&#x27; ? this._reformValue(this.option.scale) : this._reformTimeValue();
            } else {
                this._hasData = true;
                this._min = this.option.min - 0;
                this._max = this.option.max - 0;
                this.option.type != &#x27;time&#x27; ? this._customerValue() : this._reformTimeValue();
            }
        },
        _calculSum: function (data, i) {
            var key = this.series[i].name || &#x27;kener&#x27;;
            var value;
            var oriData;
            if (!this.series[i].stack) {
                data[key] = data[key] || [];
                if (this.series[i].type != ecConfig.CHART_TYPE_EVENTRIVER) {
                    oriData = this.series[i].data;
                    for (var j = 0, k = oriData.length; j &lt; k; j++) {
                        value = oriData[j].value != null ? oriData[j].value : oriData[j];
                        if (this.series[i].type === ecConfig.CHART_TYPE_K) {
                            data[key].push(value[0]);
                            data[key].push(value[1]);
                            data[key].push(value[2]);
                            data[key].push(value[3]);
                        } else if (value instanceof Array) {
                            if (this.option.xAxisIndex != -1) {
                                data[key].push(this.option.type != &#x27;time&#x27; ? value[0] : ecDate.getNewDate(value[0]));
                            }
                            if (this.option.yAxisIndex != -1) {
                                data[key].push(this.option.type != &#x27;time&#x27; ? value[1] : ecDate.getNewDate(value[1]));
                            }
                        } else {
                            data[key].push(value);
                        }
                    }
                } else {
                    oriData = this.series[i].eventList;
                    for (var j = 0, k = oriData.length; j &lt; k; j++) {
                        var evolution = oriData[j].evolution;
                        for (var m = 0, n = evolution.length; m &lt; n; m++) {
                            data[key].push(ecDate.getNewDate(evolution[m].time));
                        }
                    }
                }
            } else {
                var keyP = &#x27;__Magic_Key_Positive__&#x27; + this.series[i].stack;
                var keyN = &#x27;__Magic_Key_Negative__&#x27; + this.series[i].stack;
                data[keyP] = data[keyP] || [];
                data[keyN] = data[keyN] || [];
                data[key] = data[key] || [];
                oriData = this.series[i].data;
                for (var j = 0, k = oriData.length; j &lt; k; j++) {
                    value = oriData[j].value != null ? oriData[j].value : oriData[j];
                    if (value === &#x27;-&#x27;) {
                        continue;
                    }
                    value = value - 0;
                    if (value &gt;= 0) {
                        if (data[keyP][j] != null) {
                            data[keyP][j] += value;
                        } else {
                            data[keyP][j] = value;
                        }
                    } else {
                        if (data[keyN][j] != null) {
                            data[keyN][j] += value;
                        } else {
                            data[keyN][j] = value;
                        }
                    }
                    if (this.option.scale) {
                        data[key].push(value);
                    }
                }
            }
        },
        _reformValue: function (scale) {
            var smartSteps = require(&#x27;../util/smartSteps&#x27;);
            var splitNumber = this.option.splitNumber;
            if (!scale &amp;&amp; this._min &gt;= 0 &amp;&amp; this._max &gt;= 0) {
                this._min = 0;
            }
            if (!scale &amp;&amp; this._min &lt;= 0 &amp;&amp; this._max &lt;= 0) {
                this._max = 0;
            }
            var stepOpt = smartSteps(this._min, this._max, splitNumber);
            splitNumber = splitNumber != null ? splitNumber : stepOpt.secs;
            this.option.splitNumber = splitNumber;
            this._min = stepOpt.min;
            this._max = stepOpt.max;
            this._valueList = stepOpt.pnts;
            this._reformLabelData();
        },
        _reformTimeValue: function () {
            var splitNumber = this.option.splitNumber != null ? this.option.splitNumber : 5;
            var curValue = ecDate.getAutoFormatter(this._min, this._max, splitNumber);
            var formatter = curValue.formatter;
            var gapValue = curValue.gapValue;
            this._valueList = [ecDate.getNewDate(this._min)];
            var startGap;
            switch (formatter) {
            case &#x27;week&#x27;:
                startGap = ecDate.nextMonday(this._min);
                break;
            case &#x27;month&#x27;:
                startGap = ecDate.nextNthOnMonth(this._min, 1);
                break;
            case &#x27;quarter&#x27;:
                startGap = ecDate.nextNthOnQuarterYear(this._min, 1);
                break;
            case &#x27;half-year&#x27;:
                startGap = ecDate.nextNthOnHalfYear(this._min, 1);
                break;
            case &#x27;year&#x27;:
                startGap = ecDate.nextNthOnYear(this._min, 1);
                break;
            default:
                if (gapValue &lt;= 3600000 * 2) {
                    startGap = (Math.floor(this._min / gapValue) + 1) * gapValue;
                } else {
                    startGap = ecDate.getNewDate(this._min - -gapValue);
                    startGap.setHours(Math.round(startGap.getHours() / 6) * 6);
                    startGap.setMinutes(0);
                    startGap.setSeconds(0);
                }
                break;
            }
            if (startGap - this._min &lt; gapValue / 2) {
                startGap -= -gapValue;
            }
            curValue = ecDate.getNewDate(startGap);
            splitNumber *= 1.5;
            while (splitNumber-- &gt;= 0) {
                if (formatter == &#x27;month&#x27; || formatter == &#x27;quarter&#x27; || formatter == &#x27;half-year&#x27; || formatter == &#x27;year&#x27;) {
                    curValue.setDate(1);
                }
                if (this._max - curValue &lt; gapValue / 2) {
                    break;
                }
                this._valueList.push(curValue);
                curValue = ecDate.getNewDate(curValue - -gapValue);
            }
            this._valueList.push(ecDate.getNewDate(this._max));
            this._reformLabelData(formatter);
        },
        _customerValue: function () {
            var accMath = require(&#x27;../util/accMath&#x27;);
            var splitNumber = this.option.splitNumber != null ? this.option.splitNumber : 5;
            var splitGap = (this._max - this._min) / splitNumber;
            this._valueList = [];
            for (var i = 0; i &lt;= splitNumber; i++) {
                this._valueList.push(accMath.accAdd(this._min, accMath.accMul(splitGap, i)));
            }
            this._reformLabelData();
        },
        _reformLabelData: function (timeFormatter) {
            this._valueLabel = [];
            var formatter = this.option.axisLabel.formatter;
            if (formatter) {
                for (var i = 0, l = this._valueList.length; i &lt; l; i++) {
                    if (typeof formatter === &#x27;function&#x27;) {
                        this._valueLabel.push(timeFormatter ? formatter.call(this.myChart, this._valueList[i], timeFormatter) : formatter.call(this.myChart, this._valueList[i]));
                    } else if (typeof formatter === &#x27;string&#x27;) {
                        this._valueLabel.push(timeFormatter ? ecDate.format(formatter, this._valueList[i]) : formatter.replace(&#x27;{value}&#x27;, this._valueList[i]));
                    }
                }
            } else if (timeFormatter) {
                for (var i = 0, l = this._valueList.length; i &lt; l; i++) {
                    this._valueLabel.push(ecDate.format(timeFormatter, this._valueList[i]));
                }
            } else {
                for (var i = 0, l = this._valueList.length; i &lt; l; i++) {
                    this._valueLabel.push(this.numAddCommas(this._valueList[i]));
                }
            }
        },
        getExtremum: function () {
            this._calculateValue();
            return {
                min: this._min,
                max: this._max
            };
        },
        refresh: function (newOption, newSeries) {
            if (newOption) {
                this.option = this.reformOption(newOption);
                this.option.axisLabel.textStyle = zrUtil.merge(this.option.axisLabel.textStyle || {}, this.ecTheme.textStyle);
                this.series = newSeries;
            }
            if (this.zr) {
                this.clear();
                this._buildShape();
            }
        },
        getCoord: function (value) {
            value = value &lt; this._min ? this._min : value;
            value = value &gt; this._max ? this._max : value;
            var result;
            if (!this.isHorizontal()) {
                result = this.grid.getYend() - (value - this._min) / (this._max - this._min) * this.grid.getHeight();
            } else {
                result = this.grid.getX() + (value - this._min) / (this._max - this._min) * this.grid.getWidth();
            }
            return result;
        },
        getCoordSize: function (value) {
            if (!this.isHorizontal()) {
                return Math.abs(value / (this._max - this._min) * this.grid.getHeight());
            } else {
                return Math.abs(value / (this._max - this._min) * this.grid.getWidth());
            }
        },
        getValueFromCoord: function (coord) {
            var result;
            if (!this.isHorizontal()) {
                coord = coord &lt; this.grid.getY() ? this.grid.getY() : coord;
                coord = coord &gt; this.grid.getYend() ? this.grid.getYend() : coord;
                result = this._max - (coord - this.grid.getY()) / this.grid.getHeight() * (this._max - this._min);
            } else {
                coord = coord &lt; this.grid.getX() ? this.grid.getX() : coord;
                coord = coord &gt; this.grid.getXend() ? this.grid.getXend() : coord;
                result = this._min + (coord - this.grid.getX()) / this.grid.getWidth() * (this._max - this._min);
            }
            return result.toFixed(2) - 0;
        },
        isMaindAxis: function (value) {
            for (var i = 0, l = this._valueList.length; i &lt; l; i++) {
                if (this._valueList[i] === value) {
                    return true;
                }
            }
            return false;
        }
    };
    zrUtil.inherits(ValueAxis, Base);
    require(&#x27;../component&#x27;).define(&#x27;valueAxis&#x27;, ValueAxis);
    return ValueAxis;
});define(&#x27;echarts/util/date&#x27;, [], function () {
    var _timeGap = [
        {
            formatter: &#x27;hh : mm : ss&#x27;,
            value: 1000
        },
        {
            formatter: &#x27;hh : mm : ss&#x27;,
            value: 1000 * 5
        },
        {
            formatter: &#x27;hh : mm : ss&#x27;,
            value: 1000 * 10
        },
        {
            formatter: &#x27;hh : mm : ss&#x27;,
            value: 1000 * 15
        },
        {
            formatter: &#x27;hh : mm : ss&#x27;,
            value: 1000 * 30
        },
        {
            formatter: &#x27;hh : mm\nMM - dd&#x27;,
            value: 60000
        },
        {
            formatter: &#x27;hh : mm\nMM - dd&#x27;,
            value: 60000 * 5
        },
        {
            formatter: &#x27;hh : mm\nMM - dd&#x27;,
            value: 60000 * 10
        },
        {
            formatter: &#x27;hh : mm\nMM - dd&#x27;,
            value: 60000 * 15
        },
        {
            formatter: &#x27;hh : mm\nMM - dd&#x27;,
            value: 60000 * 30
        },
        {
            formatter: &#x27;hh : mm\nMM - dd&#x27;,
            value: 3600000
        },
        {
            formatter: &#x27;hh : mm\nMM - dd&#x27;,
            value: 3600000 * 2
        },
        {
            formatter: &#x27;hh : mm\nMM - dd&#x27;,
            value: 3600000 * 6
        },
        {
            formatter: &#x27;hh : mm\nMM - dd&#x27;,
            value: 3600000 * 12
        },
        {
            formatter: &#x27;MM - dd\nyyyy&#x27;,
            value: 3600000 * 24
        },
        {
            formatter: &#x27;week&#x27;,
            value: 3600000 * 24 * 7
        },
        {
            formatter: &#x27;month&#x27;,
            value: 3600000 * 24 * 31
        },
        {
            formatter: &#x27;quarter&#x27;,
            value: 3600000 * 24 * 380 / 4
        },
        {
            formatter: &#x27;half-year&#x27;,
            value: 3600000 * 24 * 380 / 2
        },
        {
            formatter: &#x27;year&#x27;,
            value: 3600000 * 24 * 380
        }
    ];
    function getAutoFormatter(min, max, splitNumber) {
        splitNumber = splitNumber &gt; 1 ? splitNumber : 2;
        var curValue;
        var totalGap;
        var formatter;
        var gapValue;
        for (var i = 0, l = _timeGap.length; i &lt; l; i++) {
            curValue = _timeGap[i].value;
            totalGap = Math.ceil(max / curValue) * curValue - Math.floor(min / curValue) * curValue;
            if (Math.round(totalGap / curValue) &lt;= splitNumber * 1.2) {
                formatter = _timeGap[i].formatter;
                gapValue = _timeGap[i].value;
                break;
            }
        }
        if (formatter == null) {
            formatter = &#x27;year&#x27;;
            curValue = 3600000 * 24 * 367;
            totalGap = Math.ceil(max / curValue) * curValue - Math.floor(min / curValue) * curValue;
            gapValue = Math.round(totalGap / (splitNumber - 1) / curValue) * curValue;
        }
        return {
            formatter: formatter,
            gapValue: gapValue
        };
    }
    function s2d(v) {
        return v &lt; 10 ? &#x27;0&#x27; + v : v;
    }
    function format(formatter, value) {
        if (formatter == &#x27;week&#x27; || formatter == &#x27;month&#x27; || formatter == &#x27;quarter&#x27; || formatter == &#x27;half-year&#x27; || formatter == &#x27;year&#x27;) {
            formatter = &#x27;MM - dd\nyyyy&#x27;;
        }
        var date = getNewDate(value);
        var y = date.getFullYear();
        var M = date.getMonth() + 1;
        var d = date.getDate();
        var h = date.getHours();
        var m = date.getMinutes();
        var s = date.getSeconds();
        formatter = formatter.replace(&#x27;MM&#x27;, s2d(M));
        formatter = formatter.toLowerCase();
        formatter = formatter.replace(&#x27;yyyy&#x27;, y);
        formatter = formatter.replace(&#x27;yy&#x27;, y % 100);
        formatter = formatter.replace(&#x27;dd&#x27;, s2d(d));
        formatter = formatter.replace(&#x27;d&#x27;, d);
        formatter = formatter.replace(&#x27;hh&#x27;, s2d(h));
        formatter = formatter.replace(&#x27;h&#x27;, h);
        formatter = formatter.replace(&#x27;mm&#x27;, s2d(m));
        formatter = formatter.replace(&#x27;m&#x27;, m);
        formatter = formatter.replace(&#x27;ss&#x27;, s2d(s));
        formatter = formatter.replace(&#x27;s&#x27;, s);
        return formatter;
    }
    function nextMonday(value) {
        value = getNewDate(value);
        value.setDate(value.getDate() + 8 - value.getDay());
        return value;
    }
    function nextNthPerNmonth(value, nth, nmon) {
        value = getNewDate(value);
        value.setMonth(Math.ceil((value.getMonth() + 1) / nmon) * nmon);
        value.setDate(nth);
        return value;
    }
    function nextNthOnMonth(value, nth) {
        return nextNthPerNmonth(value, nth, 1);
    }
    function nextNthOnQuarterYear(value, nth) {
        return nextNthPerNmonth(value, nth, 3);
    }
    function nextNthOnHalfYear(value, nth) {
        return nextNthPerNmonth(value, nth, 6);
    }
    function nextNthOnYear(value, nth) {
        return nextNthPerNmonth(value, nth, 12);
    }
    function getNewDate(value) {
        return value instanceof Date ? value : new Date(typeof value == &#x27;string&#x27; ? value.replace(/-/g, &#x27;/&#x27;) : value);
    }
    return {
        getAutoFormatter: getAutoFormatter,
        getNewDate: getNewDate,
        format: format,
        nextMonday: nextMonday,
        nextNthPerNmonth: nextNthPerNmonth,
        nextNthOnMonth: nextNthOnMonth,
        nextNthOnQuarterYear: nextNthOnQuarterYear,
        nextNthOnHalfYear: nextNthOnHalfYear,
        nextNthOnYear: nextNthOnYear
    };
});define(&#x27;echarts/util/smartSteps&#x27;, [], function () {
    var mySteps = [
        10,
        25,
        50
    ];
    var mySections = [
        4,
        5,
        6
    ];
    var custOpts;
    var custSteps;
    var custSecs;
    var minLocked;
    var maxLocked;
    var MT = Math;
    var MATH_ROUND = MT.round;
    var MATH_FLOOR = MT.floor;
    var MATH_CEIL = MT.ceil;
    var MATH_ABS = MT.abs;
    function MATH_LOG(n) {
        return MT.log(MATH_ABS(n)) / MT.LN10;
    }
    function MATH_POW(n) {
        return MT.pow(10, n);
    }
    function MATH_ISINT(n) {
        return n === MATH_FLOOR(n);
    }
    function smartSteps(min, max, section, opts) {
        custOpts = opts || {};
        custSteps = custOpts.steps || mySteps;
        custSecs = custOpts.secs || mySections;
        section = MATH_ROUND(+section || 0) % 99;
        min = +min || 0;
        max = +max || 0;
        minLocked = maxLocked = 0;
        if (&#x27;min&#x27; in custOpts) {
            min = +custOpts.min || 0;
            minLocked = 1;
        }
        if (&#x27;max&#x27; in custOpts) {
            max = +custOpts.max || 0;
            maxLocked = 1;
        }
        if (min &gt; max) {
            max = [
                min,
                min = max
            ][0];
        }
        var span = max - min;
        if (minLocked &amp;&amp; maxLocked) {
            return bothLocked(min, max, section);
        }
        if (span &lt; (section || 5)) {
            if (MATH_ISINT(min) &amp;&amp; MATH_ISINT(max)) {
                return forInteger(min, max, section);
            } else if (span === 0) {
                return forSpan0(min, max, section);
            }
        }
        return coreCalc(min, max, section);
    }
    function makeResult(newMin, newMax, section, expon) {
        expon = expon || 0;
        var expStep = expNum((newMax - newMin) / section, -1);
        var expMin = expNum(newMin, -1, 1);
        var expMax = expNum(newMax, -1);
        var minExp = MT.min(expStep.e, expMin.e, expMax.e);
        expFixTo(expStep, {
            c: 0,
            e: minExp
        });
        expFixTo(expMin, expStep, 1);
        expFixTo(expMax, expStep);
        expon += minExp;
        newMin = expMin.c;
        newMax = expMax.c;
        var step = (newMax - newMin) / section;
        var zoom = MATH_POW(expon);
        var fixTo = 0;
        var points = [];
        for (var i = section + 1; i--;) {
            points[i] = (newMin + step * i) * zoom;
        }
        if (expon &lt; 0) {
            fixTo = decimals(zoom);
            step = +(step * zoom).toFixed(fixTo);
            newMin = +(newMin * zoom).toFixed(fixTo);
            newMax = +(newMax * zoom).toFixed(fixTo);
            for (var i = points.length; i--;) {
                points[i] = points[i].toFixed(fixTo);
                +points[i] === 0 &amp;&amp; (points[i] = &#x27;0&#x27;);
            }
        } else {
            newMin *= zoom;
            newMax *= zoom;
            step *= zoom;
        }
        custSecs = 0;
        custSteps = 0;
        custOpts = 0;
        return {
            min: newMin,
            max: newMax,
            secs: section,
            step: step,
            fix: fixTo,
            exp: expon,
            pnts: points
        };
    }
    function expNum(num, digit, byFloor) {
        digit = MATH_ROUND(digit % 10) || 2;
        if (digit &lt; 0) {
            if (MATH_ISINT(num)) {
                digit = (&#x27;&#x27; + MATH_ABS(num)).replace(/0+$/, &#x27;&#x27;).length || 1;
            } else {
                num = num.toFixed(15).replace(/0+$/, &#x27;&#x27;);
                digit = num.replace(&#x27;.&#x27;, &#x27;&#x27;).replace(/^[-0]+/, &#x27;&#x27;).length;
                num = +num;
            }
        }
        var expon = MATH_FLOOR(MATH_LOG(num)) - digit + 1;
        var cNum = +(num * MATH_POW(-expon)).toFixed(15) || 0;
        cNum = byFloor ? MATH_FLOOR(cNum) : MATH_CEIL(cNum);
        !cNum &amp;&amp; (expon = 0);
        if ((&#x27;&#x27; + MATH_ABS(cNum)).length &gt; digit) {
            expon += 1;
            cNum /= 10;
        }
        return {
            c: cNum,
            e: expon
        };
    }
    function expFixTo(expnum1, expnum2, byFloor) {
        var deltaExp = expnum2.e - expnum1.e;
        if (deltaExp) {
            expnum1.e += deltaExp;
            expnum1.c *= MATH_POW(-deltaExp);
            expnum1.c = byFloor ? MATH_FLOOR(expnum1.c) : MATH_CEIL(expnum1.c);
        }
    }
    function expFixMin(expnum1, expnum2, byFloor) {
        if (expnum1.e &lt; expnum2.e) {
            expFixTo(expnum2, expnum1, byFloor);
        } else {
            expFixTo(expnum1, expnum2, byFloor);
        }
    }
    function getCeil(num, rounds) {
        rounds = rounds || mySteps;
        num = expNum(num);
        var cNum = num.c;
        var i = 0;
        while (cNum &gt; rounds[i]) {
            i++;
        }
        if (!rounds[i]) {
            cNum /= 10;
            num.e += 1;
            i = 0;
            while (cNum &gt; rounds[i]) {
                i++;
            }
        }
        num.c = rounds[i];
        return num;
    }
    function coreCalc(min, max, section) {
        var step;
        var secs = section || +custSecs.slice(-1);
        var expStep = getCeil((max - min) / secs, custSteps);
        var expSpan = expNum(max - min);
        var expMin = expNum(min, -1, 1);
        var expMax = expNum(max, -1);
        expFixTo(expSpan, expStep);
        expFixTo(expMin, expStep, 1);
        expFixTo(expMax, expStep);
        if (!section) {
            secs = look4sections(expMin, expMax);
        } else {
            step = look4step(expMin, expMax, secs);
        }
        if (MATH_ISINT(min) &amp;&amp; MATH_ISINT(max) &amp;&amp; min * max &gt;= 0) {
            if (max - min &lt; secs) {
                return forInteger(min, max, secs);
            }
            secs = tryForInt(min, max, section, expMin, expMax, secs);
        }
        var arrMM = cross0(min, max, expMin.c, expMax.c);
        expMin.c = arrMM[0];
        expMax.c = arrMM[1];
        if (minLocked || maxLocked) {
            singleLocked(min, max, expMin, expMax);
        }
        return makeResult(expMin.c, expMax.c, secs, expMax.e);
    }
    function look4sections(expMin, expMax) {
        var section;
        var tmpStep, tmpMin, tmpMax;
        var reference = [];
        for (var i = custSecs.length; i--;) {
            section = custSecs[i];
            tmpStep = getCeil((expMax.c - expMin.c) / section, custSteps);
            tmpStep = tmpStep.c * MATH_POW(tmpStep.e);
            tmpMin = MATH_FLOOR(expMin.c / tmpStep) * tmpStep;
            tmpMax = MATH_CEIL(expMax.c / tmpStep) * tmpStep;
            reference[i] = {
                min: tmpMin,
                max: tmpMax,
                step: tmpStep,
                span: tmpMax - tmpMin
            };
        }
        reference.sort(function (a, b) {
            return a.span - b.span;
        });
        reference = reference[0];
        section = reference.span / reference.step;
        expMin.c = reference.min;
        expMax.c = reference.max;
        return section &lt; 3 ? section * 2 : section;
    }
    function look4step(expMin, expMax, secs) {
        var span;
        var tmpMax;
        var tmpMin = expMax.c;
        var tmpStep = (expMax.c - expMin.c) / secs - 1;
        while (tmpMin &gt; expMin.c) {
            tmpStep = getCeil(tmpStep + 1, custSteps);
            tmpStep = tmpStep.c * MATH_POW(tmpStep.e);
            span = tmpStep * secs;
            tmpMax = MATH_CEIL(expMax.c / tmpStep) * tmpStep;
            tmpMin = tmpMax - span;
        }
        var deltaMin = expMin.c - tmpMin;
        var deltaMax = tmpMax - expMax.c;
        var deltaDelta = deltaMin - deltaMax;
        if (deltaDelta &gt;= tmpStep * 2) {
            deltaDelta = MATH_FLOOR(deltaDelta / tmpStep) * tmpStep;
            tmpMin += deltaDelta;
            tmpMax += deltaDelta;
        }
        expMin.c = tmpMin;
        expMax.c = tmpMax;
        return tmpStep;
    }
    function tryForInt(min, max, section, expMin, expMax, secs) {
        var span = expMax.c - expMin.c;
        var step = span / secs * MATH_POW(expMax.e);
        if (!MATH_ISINT(step)) {
            step = MATH_FLOOR(step);
            span = step * secs;
            if (span &lt; max - min) {
                step += 1;
                span = step * secs;
                if (!section &amp;&amp; step * (secs - 1) &gt;= max - min) {
                    secs -= 1;
                    span = step * secs;
                }
            }
            if (span &gt;= max - min) {
                var delta = span - (max - min);
                expMin.c = MATH_ROUND(min - delta / 2);
                expMax.c = MATH_ROUND(max + delta / 2);
                expMin.e = 0;
                expMax.e = 0;
            }
        }
        return secs;
    }
    function forInteger(min, max, section) {
        section = section || 5;
        if (minLocked) {
            max = min + section;
        } else if (maxLocked) {
            min = max - section;
        } else {
            var delta = section - (max - min);
            var newMin = MATH_ROUND(min - delta / 2);
            var newMax = MATH_ROUND(max + delta / 2);
            var arrMM = cross0(min, max, newMin, newMax);
            min = arrMM[0];
            max = arrMM[1];
        }
        return makeResult(min, max, section);
    }
    function forSpan0(min, max, section) {
        section = section || 5;
        var delta = MT.min(MATH_ABS(max / section), section) / 2.1;
        if (minLocked) {
            max = min + delta;
        } else if (maxLocked) {
            min = max - delta;
        } else {
            min = min - delta;
            max = max + delta;
        }
        return coreCalc(min, max, section);
    }
    function cross0(min, max, newMin, newMax) {
        if (min &gt;= 0 &amp;&amp; newMin &lt; 0) {
            newMax -= newMin;
            newMin = 0;
        } else if (max &lt;= 0 &amp;&amp; newMax &gt; 0) {
            newMin -= newMax;
            newMax = 0;
        }
        return [
            newMin,
            newMax
        ];
    }
    function decimals(num) {
        num = (+num).toFixed(15).split(&#x27;.&#x27;);
        return num.pop().replace(/0+$/, &#x27;&#x27;).length;
    }
    function singleLocked(min, max, emin, emax) {
        if (minLocked) {
            var expMin = expNum(min, 4, 1);
            if (emin.e - expMin.e &gt; 6) {
                expMin = {
                    c: 0,
                    e: emin.e
                };
            }
            expFixMin(emin, expMin);
            expFixMin(emax, expMin);
            emax.c += expMin.c - emin.c;
            emin.c = expMin.c;
        } else if (maxLocked) {
            var expMax = expNum(max, 4);
            if (emax.e - expMax.e &gt; 6) {
                expMax = {
                    c: 0,
                    e: emax.e
                };
            }
            expFixMin(emin, expMax);
            expFixMin(emax, expMax);
            emin.c += expMax.c - emax.c;
            emax.c = expMax.c;
        }
    }
    function bothLocked(min, max, section) {
        var trySecs = section ? [section] : custSecs;
        var span = max - min;
        if (span === 0) {
            max = expNum(max, 3);
            section = trySecs[0];
            max.c = MATH_ROUND(max.c + section / 2);
            return makeResult(max.c - section, max.c, section, max.e);
        }
        if (MATH_ABS(max / span) &lt; 0.000001) {
            max = 0;
        }
        if (MATH_ABS(min / span) &lt; 0.000001) {
            min = 0;
        }
        var step, deltaSpan, score;
        var scoreS = [
            [
                5,
                10
            ],
            [
                10,
                2
            ],
            [
                50,
                10
            ],
            [
                100,
                2
            ]
        ];
        var reference = [];
        var debugLog = [];
        var expSpan = expNum(max - min, 3);
        var expMin = expNum(min, -1, 1);
        var expMax = expNum(max, -1);
        expFixTo(expMin, expSpan, 1);
        expFixTo(expMax, expSpan);
        span = expMax.c - expMin.c;
        expSpan.c = span;
        for (var i = trySecs.length; i--;) {
            section = trySecs[i];
            step = MATH_CEIL(span / section);
            deltaSpan = step * section - span;
            score = (deltaSpan + 3) * 3;
            score += (section - trySecs[0] + 2) * 2;
            if (section % 5 === 0) {
                score -= 10;
            }
            for (var j = scoreS.length; j--;) {
                if (step % scoreS[j][0] === 0) {
                    score /= scoreS[j][1];
                }
            }
            debugLog[i] = [
                section,
                step,
                deltaSpan,
                score
            ].join();
            reference[i] = {
                secs: section,
                step: step,
                delta: deltaSpan,
                score: score
            };
        }
        reference.sort(function (a, b) {
            return a.score - b.score;
        });
        reference = reference[0];
        expMin.c = MATH_ROUND(expMin.c - reference.delta / 2);
        expMax.c = MATH_ROUND(expMax.c + reference.delta / 2);
        return makeResult(expMin.c, expMax.c, reference.secs, expSpan.e);
    }
    return smartSteps;
});
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
