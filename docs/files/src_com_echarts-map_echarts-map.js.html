<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/com/echarts-map/echarts-map.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/: Animation.html">: Animation</a></li>
            
                <li><a href="../classes/Captcha.html">Captcha</a></li>
            
                <li><a href="../classes/Checkin.html">Checkin</a></li>
            
                <li><a href="../classes/Cookie.html">Cookie</a></li>
            
                <li><a href="../classes/countDown.html">countDown</a></li>
            
                <li><a href="../classes/GoTop.html">GoTop</a></li>
            
                <li><a href="../classes/limitText.html">limitText</a></li>
            
                <li><a href="../classes/loading.html">loading</a></li>
            
                <li><a href="../classes/Log.html">Log</a></li>
            
                <li><a href="../classes/numberstep.html">numberstep</a></li>
            
                <li><a href="../classes/NumFormat.html">NumFormat</a></li>
            
                <li><a href="../classes/NumSeparate.html">NumSeparate</a></li>
            
                <li><a href="../classes/pageCount.html">pageCount</a></li>
            
                <li><a href="../classes/popup.html">popup</a></li>
            
                <li><a href="../classes/Tabset.html">Tabset</a></li>
            
                <li><a href="../classes/templateMerge.html">templateMerge</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/com.html">com</a></li>
            
                <li><a href="../modules/lufax.html">lufax</a></li>
            
                <li><a href="../modules/lufax
author: fangxiao.html">lufax
author: fangxiao</a></li>
            
                <li><a href="../modules/ui.html">ui</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/com/echarts-map/echarts-map.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(_global){

    /**
     * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
     * Available via the MIT or new BSD license.
     * see: http://github.com/jrburke/almond for details
     */
//Going sloppy to avoid &#x27;use strict&#x27; string cost, but strict practices should
//be followed.
    /*jslint sloppy: true */
    /*global setTimeout: false */

    var requirejs, require, define;
    (function (undef) {
        var main, req, makeMap, handlers,
            defined = {},
            waiting = {},
            config = {},
            defining = {},
            hasOwn = Object.prototype.hasOwnProperty,
            aps = [].slice;

        function hasProp(obj, prop) {
            return hasOwn.call(obj, prop);
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @returns {String} normalized name
         */
        function normalize(name, baseName) {
            var nameParts, nameSegment, mapValue, foundMap,
                foundI, foundStarMap, starI, i, j, part,
                baseParts = baseName &amp;&amp; baseName.split(&quot;/&quot;),
                map = config.map,
                starMap = (map &amp;&amp; map[&#x27;*&#x27;]) || {};

            //Adjust any relative paths.
            if (name &amp;&amp; name.charAt(0) === &quot;.&quot;) {
                //If have a base name, try to normalize against it,
                //otherwise, assume it is a top-level require that will
                //be relative to baseUrl in the end.
                if (baseName) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that &quot;directory&quot; and not name of the baseName&#x27;s
                    //module. For instance, baseName of &quot;one/two/three&quot;, maps to
                    //&quot;one/two/three.js&quot;, but we want the directory, &quot;one/two&quot; for
                    //this normalization.
                    baseParts = baseParts.slice(0, baseParts.length - 1);

                    name = baseParts.concat(name.split(&quot;/&quot;));

                    //start trimDots
                    for (i = 0; i &lt; name.length; i += 1) {
                        part = name[i];
                        if (part === &quot;.&quot;) {
                            name.splice(i, 1);
                            i -= 1;
                        } else if (part === &quot;..&quot;) {
                            if (i === 1 &amp;&amp; (name[2] === &#x27;..&#x27; || name[0] === &#x27;..&#x27;)) {
                                //End of the line. Keep at least one non-dot
                                //path segment at the front so it can be mapped
                                //correctly to disk. Otherwise, there is likely
                                //no path mapping for a path starting with &#x27;..&#x27;.
                                //This can still fail, but catches the most reasonable
                                //uses of ..
                                break;
                            } else if (i &gt; 0) {
                                name.splice(i - 1, 2);
                                i -= 2;
                            }
                        }
                    }
                    //end trimDots

                    name = name.join(&quot;/&quot;);
                } else if (name.indexOf(&#x27;./&#x27;) === 0) {
                    // No baseName, so this is ID is resolved relative
                    // to baseUrl, pull off the leading dot.
                    name = name.substring(2);
                }
            }

            //Apply map config if available.
            if ((baseParts || starMap) &amp;&amp; map) {
                nameParts = name.split(&#x27;/&#x27;);

                for (i = nameParts.length; i &gt; 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join(&quot;/&quot;);

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j &gt; 0; j -= 1) {
                            mapValue = map[baseParts.slice(0, j).join(&#x27;/&#x27;)];

                            //baseName segment has  config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = mapValue[nameSegment];
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break;
                                }
                            }
                        }
                    }

                    if (foundMap) {
                        break;
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap &amp;&amp; starMap &amp;&amp; starMap[nameSegment]) {
                        foundStarMap = starMap[nameSegment];
                        starI = i;
                    }
                }

                if (!foundMap &amp;&amp; foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join(&#x27;/&#x27;);
                }
            }

            return name;
        }

        function makeRequire(relName, forceSync) {
            return function () {
                //A version of a require function that passes a moduleName
                //value for items that may need to
                //look up paths relative to the moduleName
                return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
            };
        }

        function makeNormalize(relName) {
            return function (name) {
                return normalize(name, relName);
            };
        }

        function makeLoad(depName) {
            return function (value) {
                defined[depName] = value;
            };
        }

        function callDep(name) {
            if (hasProp(waiting, name)) {
                var args = waiting[name];
                delete waiting[name];
                defining[name] = true;
                main.apply(undef, args);
            }

            if (!hasProp(defined, name) &amp;&amp; !hasProp(defining, name)) {
                throw new Error(&#x27;No &#x27; + name);
            }
            return defined[name];
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf(&#x27;!&#x27;) : -1;
            if (index &gt; -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Makes a name map, normalizing the name, and using a plugin
         * for normalization if necessary. Grabs a ref to plugin
         * too, as an optimization.
         */
        makeMap = function (name, relName) {
            var plugin,
                parts = splitPrefix(name),
                prefix = parts[0];

            name = parts[1];

            if (prefix) {
                prefix = normalize(prefix, relName);
                plugin = callDep(prefix);
            }

            //Normalize according
            if (prefix) {
                if (plugin &amp;&amp; plugin.normalize) {
                    name = plugin.normalize(name, makeNormalize(relName));
                } else {
                    name = normalize(name, relName);
                }
            } else {
                name = normalize(name, relName);
                parts = splitPrefix(name);
                prefix = parts[0];
                name = parts[1];
                if (prefix) {
                    plugin = callDep(prefix);
                }
            }

            //Using ridiculous property names for space reasons
            return {
                f: prefix ? prefix + &#x27;!&#x27; + name : name, //fullName
                n: name,
                pr: prefix,
                p: plugin
            };
        };

        function makeConfig(name) {
            return function () {
                return (config &amp;&amp; config.config &amp;&amp; config.config[name]) || {};
            };
        }

        handlers = {
            require: function (name) {
                return makeRequire(name);
            },
            exports: function (name) {
                var e = defined[name];
                if (typeof e !== &#x27;undefined&#x27;) {
                    return e;
                } else {
                    return (defined[name] = {});
                }
            },
            module: function (name) {
                return {
                    id: name,
                    uri: &#x27;&#x27;,
                    exports: defined[name],
                    config: makeConfig(name)
                };
            }
        };

        main = function (name, deps, callback, relName) {
            var cjsModule, depName, ret, map, i,
                args = [],
                usingExports;

            //Use name if no relName
            relName = relName || name;

            //Call the callback to define the module, if necessary.
            if (typeof callback === &#x27;function&#x27;) {

                //Pull out the defined dependencies and pass the ordered
                //values to the callback.
                //Default to [require, exports, module] if no deps
                deps = !deps.length &amp;&amp; callback.length ? [&#x27;require&#x27;, &#x27;exports&#x27;, &#x27;module&#x27;] : deps;
                for (i = 0; i &lt; deps.length; i += 1) {
                    map = makeMap(deps[i], relName);
                    depName = map.f;

                    //Fast path CommonJS standard dependencies.
                    if (depName === &quot;require&quot;) {
                        args[i] = handlers.require(name);
                    } else if (depName === &quot;exports&quot;) {
                        //CommonJS module spec 1.1
                        args[i] = handlers.exports(name);
                        usingExports = true;
                    } else if (depName === &quot;module&quot;) {
                        //CommonJS module spec 1.1
                        cjsModule = args[i] = handlers.module(name);
                    } else if (hasProp(defined, depName) ||
                        hasProp(waiting, depName) ||
                        hasProp(defining, depName)) {
                        args[i] = callDep(depName);
                    } else if (map.p) {
                        map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                        args[i] = defined[depName];
                    } else {
                        throw new Error(name + &#x27; missing &#x27; + depName);
                    }
                }

                ret = callback.apply(defined[name], args);

                if (name) {
                    //If setting exports via &quot;module&quot; is in play,
                    //favor that over return value and exports. After that,
                    //favor a non-undefined return value over exports use.
                    if (cjsModule &amp;&amp; cjsModule.exports !== undef &amp;&amp;
                        cjsModule.exports !== defined[name]) {
                        defined[name] = cjsModule.exports;
                    } else if (ret !== undef || !usingExports) {
                        //Use the return value from the function.
                        defined[name] = ret;
                    }
                }
            } else if (name) {
                //May just be an object definition for the module. Only
                //worry about defining if have a module name.
                defined[name] = callback;
            }
        };

        requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
            if (typeof deps === &quot;string&quot;) {
                if (handlers[deps]) {
                    //callback in this case is really relName
                    return handlers[deps](callback);
                }
                //Just return the module wanted. In this scenario, the
                //deps arg is the module name, and second arg (if passed)
                //is just the relName.
                //Normalize module name, if it contains . or ..
                return callDep(makeMap(deps, callback).f);
            } else if (!deps.splice) {
                //deps is a config object, not an array.
                config = deps;
                if (callback.splice) {
                    //callback is an array, which means it is a dependency list.
                    //Adjust args if there are dependencies
                    deps = callback;
                    callback = relName;
                    relName = null;
                } else {
                    deps = undef;
                }
            }

            //Support require([&#x27;a&#x27;])
            callback = callback || function () {};

            //If relName is a function, it is an errback handler,
            //so remove it.
            if (typeof relName === &#x27;function&#x27;) {
                relName = forceSync;
                forceSync = alt;
            }

            //Simulate async callback;
            if (forceSync) {
                main(undef, deps, callback, relName);
            } else {
                //Using a non-zero value because of concern for what old browsers
                //do, and latest browsers &quot;upgrade&quot; to 4 if lower value is used:
                //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
                //If want a value immediately, use require(&#x27;id&#x27;) instead -- something
                //that works in almond on the global level, but not guaranteed and
                //unlikely to work in other AMD implementations.
                setTimeout(function () {
                    main(undef, deps, callback, relName);
                }, 4);
            }

            return req;
        };

        /**
         * Just drops the config on the floor, but returns req in case
         * the config return value is used.
         */
        req.config = function (cfg) {
            config = cfg;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            return req;
        };

        define = function (name, deps, callback) {

            //This module may not have dependencies
            if (!deps.splice) {
                //deps is not an array, so probably means
                //an object literal or factory function for
                //the value. Adjust args.
                callback = deps;
                deps = [];
            }

            if (!hasProp(defined, name) &amp;&amp; !hasProp(waiting, name)) {
                waiting[name] = [name, deps, callback];
            }
        };

        define.amd = {
            jQuery: true
        };
    }());

    /**
     * echarts默认配置项
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/config&#x27;,[],function() {
        // 请原谅我这样写，这显然可以直接返回个对象，但那样的话outline就显示不出来了~~
        var config = {
            // 图表类型
            CHART_TYPE_MAP: &#x27;map&#x27;,

            // 组件类型
            COMPONENT_TYPE_TITLE: &#x27;title&#x27;,
            COMPONENT_TYPE_LEGEND: &#x27;legend&#x27;,
            COMPONENT_TYPE_DATARANGE: &#x27;dataRange&#x27;,
            COMPONENT_TYPE_DATAVIEW: &#x27;dataView&#x27;,
            COMPONENT_TYPE_DATAZOOM: &#x27;dataZoom&#x27;,
            COMPONENT_TYPE_TOOLBOX: &#x27;toolbox&#x27;,
            COMPONENT_TYPE_TOOLTIP: &#x27;tooltip&#x27;,
            COMPONENT_TYPE_GRID: &#x27;grid&#x27;,
            COMPONENT_TYPE_AXIS: &#x27;axis&#x27;,
            COMPONENT_TYPE_POLAR: &#x27;polar&#x27;,
            COMPONENT_TYPE_X_AXIS: &#x27;xAxis&#x27;,
            COMPONENT_TYPE_Y_AXIS: &#x27;yAxis&#x27;,
            COMPONENT_TYPE_AXIS_CATEGORY: &#x27;categoryAxis&#x27;,
            COMPONENT_TYPE_AXIS_VALUE: &#x27;valueAxis&#x27;,
            COMPONENT_TYPE_TIMELINE: &#x27;timeline&#x27;,

            // 全图默认背景
            backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,

            // 默认色板
            color: [&#x27;#ff7f50&#x27;,&#x27;#87cefa&#x27;,&#x27;#da70d6&#x27;,&#x27;#32cd32&#x27;,&#x27;#6495ed&#x27;,
                &#x27;#ff69b4&#x27;,&#x27;#ba55d3&#x27;,&#x27;#cd5c5c&#x27;,&#x27;#ffa500&#x27;,&#x27;#40e0d0&#x27;,
                &#x27;#1e90ff&#x27;,&#x27;#ff6347&#x27;,&#x27;#7b68ee&#x27;,&#x27;#00fa9a&#x27;,&#x27;#ffd700&#x27;,
                &#x27;#6699FF&#x27;,&#x27;#ff6666&#x27;,&#x27;#3cb371&#x27;,&#x27;#b8860b&#x27;,&#x27;#30e0e0&#x27;],

            // 图表标题
            title: {
                text: &#x27;&#x27;,
                //link: null,              // 超链接跳转
                //target: null,            // 仅支持self | blank
                subtext: &#x27;&#x27;,
                //sublink: null,           // 超链接跳转
                //subtarget: null,         // 仅支持self | blank
                x: &#x27;left&#x27;,                 // 水平安放位置，默认为左对齐，可选为：
                // &#x27;center&#x27; ¦ &#x27;left&#x27; ¦ &#x27;right&#x27;
                // ¦ {number}（x坐标，单位px）
                y: &#x27;top&#x27;,                  // 垂直安放位置，默认为全图顶端，可选为：
                // &#x27;top&#x27; ¦ &#x27;bottom&#x27; ¦ &#x27;center&#x27;
                // ¦ {number}（y坐标，单位px）
                //textAlign: null          // 水平对齐方式，默认根据x设置自动调整
                backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,
                borderColor: &#x27;#ccc&#x27;,       // 标题边框颜色
                borderWidth: 0,            // 标题边框线宽，单位px，默认为0（无边框）
                padding: 5,                // 标题内边距，单位px，默认各方向内边距为5，
                // 接受数组分别设定上右下左边距，同css
                itemGap: 5,               // 主副标题纵向间隔，单位px，默认为10，
                textStyle: {
                    fontSize: 18,
                    fontWeight: &#x27;bolder&#x27;,
                    color: &#x27;#333&#x27;          // 主标题文字颜色
                },
                subtextStyle: {
                    color: &#x27;#aaa&#x27;          // 副标题文字颜色
                }
            },

            // 图例
            legend: {
                orient: &#x27;horizontal&#x27;,      // 布局方式，默认为水平布局，可选为：
                // &#x27;horizontal&#x27; ¦ &#x27;vertical&#x27;
                x: &#x27;center&#x27;,               // 水平安放位置，默认为全图居中，可选为：
                // &#x27;center&#x27; ¦ &#x27;left&#x27; ¦ &#x27;right&#x27;
                // ¦ {number}（x坐标，单位px）
                y: &#x27;top&#x27;,                  // 垂直安放位置，默认为全图顶端，可选为：
                // &#x27;top&#x27; ¦ &#x27;bottom&#x27; ¦ &#x27;center&#x27;
                // ¦ {number}（y坐标，单位px）
                backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,
                borderColor: &#x27;#ccc&#x27;,       // 图例边框颜色
                borderWidth: 0,            // 图例边框线宽，单位px，默认为0（无边框）
                padding: 5,                // 图例内边距，单位px，默认各方向内边距为5，
                // 接受数组分别设定上右下左边距，同css
                itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，
                // 横向布局时为水平间隔，纵向布局时为纵向间隔
                itemWidth: 20,             // 图例图形宽度
                itemHeight: 14,            // 图例图形高度
                textStyle: {
                    color: &#x27;#333&#x27;          // 图例文字颜色
                },
                selectedMode: true        // 选择模式，默认开启图例开关
                // selected: null,         // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入
                // data: [],               // 图例内容（详见legend.data，数组中每一项代表一个item
            },

            // 值域
            dataRange: {
                orient: &#x27;vertical&#x27;,        // 布局方式，默认为垂直布局，可选为：
                // &#x27;horizontal&#x27; ¦ &#x27;vertical&#x27;
                x: &#x27;left&#x27;,                 // 水平安放位置，默认为全图左对齐，可选为：
                // &#x27;center&#x27; ¦ &#x27;left&#x27; ¦ &#x27;right&#x27;
                // ¦ {number}（x坐标，单位px）
                y: &#x27;bottom&#x27;,               // 垂直安放位置，默认为全图底部，可选为：
                // &#x27;top&#x27; ¦ &#x27;bottom&#x27; ¦ &#x27;center&#x27;
                // ¦ {number}（y坐标，单位px）
                backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,
                borderColor: &#x27;#ccc&#x27;,       // 值域边框颜色
                borderWidth: 0,            // 值域边框线宽，单位px，默认为0（无边框）
                padding: 5,                // 值域内边距，单位px，默认各方向内边距为5，
                // 接受数组分别设定上右下左边距，同css
                itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，
                // 横向布局时为水平间隔，纵向布局时为纵向间隔
                itemWidth: 20,             // 值域图形宽度，线性渐变水平布局宽度为该值 * 10
                itemHeight: 14,            // 值域图形高度，线性渐变垂直布局高度为该值 * 10
                // min: null,              // 最小值
                // max: null,              // 最大值
                precision: 0,              // 小数精度，默认为0，无小数点
                splitNumber: 5,            // 分割段数，默认为5，为0时为线性渐变
                calculable: false,         // 是否值域漫游，启用后无视splitNumber，线性渐变
                realtime: true,
                color:[&#x27;#006edd&#x27;,&#x27;#e0ffff&#x27;],//颜色 
                //formatter: null,
                //text:[&#x27;高&#x27;,&#x27;低&#x27;],           // 文本，默认为数值文本
                textStyle: {
                    color: &#x27;#333&#x27;          // 值域文字颜色
                }
            },

            toolbox: {
                show : false,
                orient: &#x27;horizontal&#x27;,      // 布局方式，默认为水平布局，可选为：
                // &#x27;horizontal&#x27; ¦ &#x27;vertical&#x27;
                x: &#x27;right&#x27;,                // 水平安放位置，默认为全图右对齐，可选为：
                // &#x27;center&#x27; ¦ &#x27;left&#x27; ¦ &#x27;right&#x27;
                // ¦ {number}（x坐标，单位px）
                y: &#x27;top&#x27;,                  // 垂直安放位置，默认为全图顶端，可选为：
                // &#x27;top&#x27; ¦ &#x27;bottom&#x27; ¦ &#x27;center&#x27;
                // ¦ {number}（y坐标，单位px）
                color : [&#x27;#1e90ff&#x27;,&#x27;#22bb22&#x27;,&#x27;#4b0082&#x27;,&#x27;#d2691e&#x27;],
                disableColor : &#x27;#ddd&#x27;,
                effectiveColor : &#x27;red&#x27;,
                backgroundColor: &#x27;rgba(0,0,0,0)&#x27;, // 工具箱背景颜色
                borderColor: &#x27;#ccc&#x27;,       // 工具箱边框颜色
                borderWidth: 0,            // 工具箱边框线宽，单位px，默认为0（无边框）
                padding: 5,                // 工具箱内边距，单位px，默认各方向内边距为5，
                // 接受数组分别设定上右下左边距，同css
                itemGap: 10,               // 各个item之间的间隔，单位px，默认为10，
                // 横向布局时为水平间隔，纵向布局时为纵向间隔
                itemSize: 16,             // 工具箱图形宽度
                showTitle : true,
                //textStyle : {},
                feature : {
                    mark : {
                        show : false,
                        title : {
                            mark : &#x27;辅助线开关&#x27;,
                            markUndo : &#x27;删除辅助线&#x27;,
                            markClear : &#x27;清空辅助线&#x27;
                        },
                        lineStyle : {
                            width : 1,
                            color : &#x27;#1e90ff&#x27;,
                            type : &#x27;dashed&#x27;
                        }
                    },
                    dataZoom : {
                        show : false,
                        title : {
                            dataZoom : &#x27;区域缩放&#x27;,
                            dataZoomReset : &#x27;区域缩放后退&#x27;
                        }
                    },
                    dataView : {
                        show : false,
                        title : &#x27;数据视图&#x27;,
                        readOnly: false,
                        lang : [&#x27;Data View&#x27;, &#x27;close&#x27;, &#x27;refresh&#x27;]
                    },
                    magicType: {
                        show : false,
                        title : {
                            line : &#x27;折线图切换&#x27;,
                            bar : &#x27;柱形图切换&#x27;,
                            stack : &#x27;堆积&#x27;,
                            tiled : &#x27;平铺&#x27;
                        },
                        type : [] // &#x27;line&#x27;, &#x27;bar&#x27;, &#x27;stack&#x27;, &#x27;tiled&#x27;
                    },
                    restore : {
                        show : false,
                        title : &#x27;还原&#x27;
                    },
                    saveAsImage : {
                        show : false,
                        title : &#x27;保存为图片&#x27;,
                        type : &#x27;png&#x27;,
                        lang : [&#x27;点击保存&#x27;]
                    }
                }
            },

            // 提示框
            tooltip: {
                show: true,
                showContent: true,         // tooltip主体内容
                trigger: &#x27;item&#x27;,           // 触发类型，默认数据触发，见下图，可选为：&#x27;item&#x27; ¦ &#x27;axis&#x27;
                // position : null         // 位置 {Array} | {Function}
                // formatter: null         // 内容格式器：{string}（Template） ¦ {Function}
                islandFormatter: &#x27;{a} &lt;br/&gt;{b} : {c}&#x27;,  // 数据孤岛内容格式器
                showDelay: 20,             // 显示延迟，添加显示延迟可以避免频繁切换，单位ms
                hideDelay: 100,            // 隐藏延迟，单位ms
                transitionDuration : 0.4,  // 动画变换时间，单位s
                backgroundColor: &#x27;rgba(0,0,0,0.7)&#x27;,     // 提示背景颜色，默认为透明度为0.7的黑色
                borderColor: &#x27;#333&#x27;,       // 提示边框颜色
                borderRadius: 4,           // 提示边框圆角，单位px，默认为4
                borderWidth: 0,            // 提示边框线宽，单位px，默认为0（无边框）
                padding: 5,                // 提示内边距，单位px，默认各方向内边距为5，
                // 接受数组分别设定上右下左边距，同css
                axisPointer : {            // 坐标轴指示器，坐标轴触发有效
                    type : &#x27;line&#x27;,         // 默认为直线，可选为：&#x27;line&#x27; | &#x27;shadow&#x27; | &#x27;cross&#x27;
                    lineStyle : {          // 直线指示器样式设置
                        color: &#x27;#48b&#x27;,
                        width: 2,
                        type: &#x27;solid&#x27;
                    },
                    crossStyle: {
                        color: &#x27;#1e90ff&#x27;,
                        width: 1,
                        type: &#x27;dashed&#x27;
                    },
                    shadowStyle : {                     // 阴影指示器样式设置
                        color: &#x27;rgba(150,150,150,0.3)&#x27;, // 阴影颜色
                        width: &#x27;auto&#x27;,                  // 阴影大小
                        type: &#x27;default&#x27;
                    }
                },
                textStyle: {
                    color: &#x27;#fff&#x27;
                }
            },

            // 区域缩放控制器
            dataZoom: {
                show: false,
                orient: &#x27;horizontal&#x27;,          // 布局方式，默认为水平布局，可选为：
                // &#x27;horizontal&#x27; ¦ &#x27;vertical&#x27;
                // x: {number},            // 水平安放位置，默认为根据grid参数适配，可选为：
                // {number}（x坐标，单位px）
                // y: {number},            // 垂直安放位置，默认为根据grid参数适配，可选为：
                // {number}（y坐标，单位px）
                // width: {number},        // 指定宽度，横向布局时默认为根据grid参数适配
                // height: {number},       // 指定高度，纵向布局时默认为根据grid参数适配
                backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,       // 背景颜色
                dataBackgroundColor: &#x27;#eee&#x27;,            // 数据背景颜色
                fillerColor: &#x27;rgba(144,197,237,0.2)&#x27;,   // 填充颜色
                handleColor: &#x27;rgba(70,130,180,0.8)&#x27;,    // 手柄颜色
                // xAxisIndex: [],         // 默认控制所有横向类目
                // yAxisIndex: [],         // 默认控制所有横向类目
                // start: 0,               // 默认为0
                // end: 100,               // 默认为全部 100%
                realtime: true
                // zoomLock: false         // 是否锁定选择区域大小
            },

            // 网格
            grid: {
                x: 80,
                y: 60,
                x2: 80,
                y2: 60,
                // width: {totalWidth} - x - x2,
                // height: {totalHeight} - y - y2,
                backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,
                borderWidth: 1,
                borderColor: &#x27;#ccc&#x27;
            },

            // 类目轴
            categoryAxis: {
                position: &#x27;bottom&#x27;,    // 位置
                name: &#x27;&#x27;,              // 坐标轴名字，默认为空
                nameLocation: &#x27;end&#x27;,   // 坐标轴名字位置，支持&#x27;start&#x27; | &#x27;end&#x27;
                nameTextStyle: {},     // 坐标轴文字样式，默认取全局样式
                boundaryGap: true,     // 类目起始和结束两端空白策略
                axisLine: {            // 坐标轴线
                    show: true,        // 默认显示，属性show控制显示与否
                    onZero: true,
                    lineStyle: {       // 属性lineStyle控制线条样式
                        color: &#x27;#48b&#x27;,
                        width: 2,
                        type: &#x27;solid&#x27;
                    }
                },
                axisTick: {            // 坐标轴小标记
                    show: true,        // 属性show控制显示与否，默认不显示
                    interval: &#x27;auto&#x27;,
                    inside : false,    // 控制小标记是否在grid里 
                    // onGap: null,
                    length :5,         // 属性length控制线长
                    lineStyle: {       // 属性lineStyle控制线条样式
                        color: &#x27;#333&#x27;,
                        width: 1
                    }
                },
                axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel
                    show: true,
                    interval: &#x27;auto&#x27;,
                    rotate: 0,
                    margin: 8,
                    // clickable: false,
                    // formatter: null,
                    textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                        color: &#x27;#333&#x27;
                    }
                },
                splitLine: {           // 分隔线
                    show: true,        // 默认显示，属性show控制显示与否
                    // onGap: null,
                    lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式
                        color: [&#x27;#ccc&#x27;],
                        width: 1,
                        type: &#x27;solid&#x27;
                    }
                },
                splitArea: {           // 分隔区域
                    show: false,       // 默认不显示，属性show控制显示与否
                    // onGap: null,
                    areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式
                        color: [&#x27;rgba(250,250,250,0.3)&#x27;,&#x27;rgba(200,200,200,0.3)&#x27;]
                    }
                }
            },

            // 数值型坐标轴默认参数
            valueAxis: {
                position: &#x27;left&#x27;,      // 位置
                name: &#x27;&#x27;,              // 坐标轴名字，默认为空
                nameLocation: &#x27;end&#x27;,   // 坐标轴名字位置，支持&#x27;start&#x27; | &#x27;end&#x27;
                nameTextStyle: {},     // 坐标轴文字样式，默认取全局样式
                boundaryGap: [0, 0],   // 数值起始和结束两端空白策略
                // min: null,          // 最小值
                // max: null,          // 最大值
                // scale: false,       // 脱离0值比例，放大聚焦到最终_min，_max区间
                precision: 0,          // 小数精度，默认为0，无小数点
                power: 100,            // 整数精度，默认为100，个位和百位为0
                splitNumber: 5,        // 分割段数，默认为5
                axisLine: {            // 坐标轴线
                    show: true,        // 默认显示，属性show控制显示与否
                    onZero: true,
                    lineStyle: {       // 属性lineStyle控制线条样式
                        color: &#x27;#48b&#x27;,
                        width: 2,
                        type: &#x27;solid&#x27;
                    }
                },
                axisTick: {            // 坐标轴小标记
                    show: false,       // 属性show控制显示与否，默认不显示
                    inside : false,    // 控制小标记是否在grid里 
                    length :5,         // 属性length控制线长
                    lineStyle: {       // 属性lineStyle控制线条样式
                        color: &#x27;#333&#x27;,
                        width: 1
                    }
                },
                axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel
                    show: true,
                    rotate: 0,
                    margin: 8,
                    // clickable: false,
                    // formatter: null,
                    textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                        color: &#x27;#333&#x27;
                    }
                },
                splitLine: {           // 分隔线
                    show: true,        // 默认显示，属性show控制显示与否
                    lineStyle: {       // 属性lineStyle（详见lineStyle）控制线条样式
                        color: [&#x27;#ccc&#x27;],
                        width: 1,
                        type: &#x27;solid&#x27;
                    }
                },
                splitArea: {           // 分隔区域
                    show: false,       // 默认不显示，属性show控制显示与否
                    areaStyle: {       // 属性areaStyle（详见areaStyle）控制区域样式
                        color: [&#x27;rgba(250,250,250,0.3)&#x27;,&#x27;rgba(200,200,200,0.3)&#x27;]
                    }
                }
            },

            polar : {
                center : [&#x27;50%&#x27;, &#x27;50%&#x27;],    // 默认全局居中
                radius : &#x27;75%&#x27;,
                startAngle : 90,
                splitNumber : 5,
                name : {
                    show: true,
                    // formatter: null,
                    textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                        color: &#x27;#333&#x27;
                    }
                },
                axisLine: {            // 坐标轴线
                    show: true,        // 默认显示，属性show控制显示与否
                    lineStyle: {       // 属性lineStyle控制线条样式
                        color: &#x27;#ccc&#x27;,
                        width: 1,
                        type: &#x27;solid&#x27;
                    }
                },
                axisLabel: {           // 坐标轴文本标签，详见axis.axisLabel
                    show: false,
                    // formatter: null,
                    textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                        color: &#x27;#333&#x27;
                    }
                },
                splitArea : {
                    show : true,
                    areaStyle : {
                        color: [&#x27;rgba(250,250,250,0.3)&#x27;,&#x27;rgba(200,200,200,0.3)&#x27;]
                    }
                },
                splitLine : {
                    show : true,
                    lineStyle : {
                        width : 1,
                        color : &#x27;#ccc&#x27;
                    }
                }
                //indicator : []
            },

            timeline : {
                show: true,
                type : &#x27;time&#x27;,  // 模式是时间类型，支持 number
                notMerge : false,
                realtime : true,
                x: 80,
                // y: {number},
                x2: 80,
                y2: 0,
                // width: {totalWidth} - x - x2,
                height: 50,
                backgroundColor: &#x27;rgba(0,0,0,0)&#x27;,   // 时间轴背景颜色
                borderColor : &#x27;#ccc&#x27;,               // 时间轴边框颜色
                borderWidth : 0,                    // 时间轴边框线宽，单位px，默认为0（无边框）
                padding : 5,                        // 时间轴内边距，单位px，默认各方向内边距为5，
                controlPosition : &#x27;left&#x27;,           // &#x27;right&#x27; | &#x27;none&#x27;
                autoPlay : false,
                loop : true,
                playInterval : 2000,                // 播放时间间隔，单位ms
                lineStyle : {
                    width : 1,
                    color : &#x27;#666&#x27;,
                    type : &#x27;dashed&#x27;
                },
                label: {                            // 文本标签
                    show: true,
                    interval: &#x27;auto&#x27;,
                    rotate: 0,
                    // formatter: null,
                    textStyle: {                    // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                        color: &#x27;#333&#x27;
                    }
                },
                checkpointStyle : {
                    symbol : &#x27;auto&#x27;,
                    symbolSize : &#x27;auto&#x27;,
                    color : &#x27;auto&#x27;,
                    borderColor : &#x27;auto&#x27;,
                    borderWidth : &#x27;auto&#x27;,
                    label: {                            // 文本标签
                        show: false,
                        textStyle: {                    // 其余属性默认使用全局文本样式，详见TEXTSTYLE
                            color: &#x27;auto&#x27;
                        }
                    }
                },
                controlStyle : {
                    normal : { color : &#x27;#333&#x27;},
                    emphasis : { color : &#x27;#1e90ff&#x27;}
                },
                symbol : &#x27;emptyDiamond&#x27;,
                symbolSize : 4,
                currentIndex : 0
                // data : []
            },

            map: {
                mapType: &#x27;china&#x27;,   // 各省的mapType暂时都用中文
                //mapLocation: {
                // x : &#x27;center&#x27; | &#x27;left&#x27; | &#x27;right&#x27; | &#x27;x%&#x27; | {number},
                // y : &#x27;center&#x27; | &#x27;top&#x27; | &#x27;bottom&#x27; | &#x27;x%&#x27; | {number}
                // width    // 自适应
                // height   // 自适应
                //},
                // mapValueCalculation: &#x27;sum&#x27;, // 数值合并方式，默认加和，可选为：
                // &#x27;sum&#x27; | &#x27;average&#x27; | &#x27;max&#x27; | &#x27;min&#x27; 
                mapValuePrecision : 0,         // 地图数值计算结果小数精度
                showLegendSymbol : true,       // 显示图例颜色标识（系列标识的小圆点），存在legend时生效
                // selectedMode: false,        // 选择模式，默认关闭，可选single，multiple
                hoverable: true,
                // roam : false,               // 是否开启缩放及漫游模式
                // scaleLimit : null,
                itemStyle: {
                    normal: {
                        // color: 各异,
                        borderColor: &#x27;rgba(0,0,0,0)&#x27;,
                        borderWidth: 1,
                        areaStyle: {
                            color: &#x27;#ccc&#x27;
                        },
                        label: {
                            show: false,
                            textStyle: {
                                color: &#x27;rgb(139,69,19)&#x27;
                            }
                        }
                    },
                    emphasis: {                 // 也是选中样式
                        // color: 各异,
                        borderColor: &#x27;rgba(0,0,0,0)&#x27;,
                        borderWidth: 1,
                        areaStyle: {
                            color: &#x27;rgba(255,215,0,0.8)&#x27;
                        },
                        label: {
                            show: false,
                            textStyle: {
                                color: &#x27;rgb(100,0,0)&#x27;
                            }
                        }
                    }
                }
            },

            island: {
                r: 15,
                calculateStep: 0.1  // 滚轮可计算步长 0.1 = 10%
            },

            markPoint : {
                symbol: &#x27;pin&#x27;,         // 标注类型
                symbolSize: 10,        // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
                //symbolRotate : null, // 标注旋转控制
                large : false,
                effect : {
                    show: false,
                    period: 15,             // 运动周期，无单位，值越大越慢
                    scaleSize : 2         // 放大倍数，以markPoint点size为基准
                    // color : &#x27;gold&#x27;,
                    // shadowColor : &#x27;rgba(255,215,0,0.8)&#x27;,
                    // shadowBlur : 0          // 炫光模糊
                },
                itemStyle: {
                    normal: {
                        // color: 各异，
                        // borderColor: 各异,     // 标注边线颜色，优先于color 
                        borderWidth: 2,            // 标注边线线宽，单位px，默认为1
                        label: {
                            show: true,
                            // 标签文本格式器，同Tooltip.formatter，不支持回调
                            // formatter : null,
                            position: &#x27;inside&#x27; // 可选为&#x27;left&#x27;|&#x27;right&#x27;|&#x27;top&#x27;|&#x27;bottom&#x27;
                            // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                        }
                    },
                    emphasis: {
                        // color: 各异
                        label: {
                            show: true
                            // 标签文本格式器，同Tooltip.formatter，不支持回调
                            // formatter : null,
                            // position: &#x27;inside&#x27;  // &#x27;left&#x27;|&#x27;right&#x27;|&#x27;top&#x27;|&#x27;bottom&#x27;
                            // textStyle: null     // 默认使用全局文本样式，详见TEXTSTYLE
                        }
                    }
                }
            },

            markLine : {
                // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string
                symbol: [&#x27;circle&#x27;, &#x27;arrow&#x27;],
                // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
                symbolSize: [2, 4],
                // 标线起始和结束的symbol旋转控制
                //symbolRotate : null,
                //smooth : false,
                large : false,
                effect : {
                    show: false,
                    period: 15,             // 运动周期，无单位，值越大越慢
                    scaleSize : 2           // 放大倍数，以markLine线lineWidth为基准
                    // color : &#x27;gold&#x27;,
                    // shadowColor : &#x27;rgba(255,215,0,0.8)&#x27;,
                    // shadowBlur : lineWidth * 2      // 炫光模糊，默认等于scaleSize计算所得
                },
                itemStyle: {
                    normal: {
                        // color: 各异,           // 标线主色，线色，symbol主色
                        // borderColor: 随color,     // 标线symbol边框颜色，优先于color 
                        borderWidth: 1.5,          // 标线symbol边框线宽，单位px，默认为2
                        label: {
                            show: true,
                            // 标签文本格式器，同Tooltip.formatter，不支持回调
                            // formatter : null,
                            // 可选为 &#x27;start&#x27;|&#x27;end&#x27;|&#x27;left&#x27;|&#x27;right&#x27;|&#x27;top&#x27;|&#x27;bottom&#x27;
                            position: &#x27;end&#x27;
                            // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
                        },
                        lineStyle: {
                            // color: 随borderColor, // 主色，线色，优先级高于borderColor和color
                            // width: 随borderWidth, // 优先于borderWidth
                            type: &#x27;dashed&#x27;
                            // shadowColor : &#x27;rgba(0,0,0,0)&#x27;, //默认透明
                            // shadowBlur: 0,
                            // shadowOffsetX: 0,
                            // shadowOffsetY: 0
                        }
                    },
                    emphasis: {
                        // color: 各异
                        label: {
                            show: false
                            // 标签文本格式器，同Tooltip.formatter，不支持回调
                            // formatter : null,
                            // position: &#x27;inside&#x27; // &#x27;left&#x27;|&#x27;right&#x27;|&#x27;top&#x27;|&#x27;bottom&#x27;
                            // textStyle: null    // 默认使用全局文本样式，详见TEXTSTYLE
                        },
                        lineStyle : {}
                    }
                }
            },

            // 主题，主题
            textStyle: {
                decoration: &#x27;none&#x27;,
                fontFamily: &#x27;Arial, Verdana, sans-serif&#x27;,
                fontFamily2: &#x27;微软雅黑&#x27;,    // IE8- 字体模糊并且，不支持不同字体混排，额外指定一份
                fontSize: 12,
                fontStyle: &#x27;normal&#x27;,
                fontWeight: &#x27;normal&#x27;
            },

            EVENT: {
                // -------全局通用
                REFRESH: &#x27;refresh&#x27;,
                RESTORE: &#x27;restore&#x27;,
                RESIZE: &#x27;resize&#x27;,
                CLICK: &#x27;click&#x27;,
                HOVER: &#x27;hover&#x27;,
                //MOUSEWHEEL: &#x27;mousewheel&#x27;,
                // -------业务交互逻辑
                DATA_CHANGED: &#x27;dataChanged&#x27;,
                DATA_ZOOM: &#x27;dataZoom&#x27;,
                DATA_RANGE: &#x27;dataRange&#x27;,
                LEGEND_SELECTED: &#x27;legendSelected&#x27;,
                MAP_SELECTED: &#x27;mapSelected&#x27;,
                PIE_SELECTED: &#x27;pieSelected&#x27;,
                MAGIC_TYPE_CHANGED: &#x27;magicTypeChanged&#x27;,
                DATA_VIEW_CHANGED: &#x27;dataViewChanged&#x27;,
                TIMELINE_CHANGED: &#x27;timelineChanged&#x27;,
                MAP_ROAM : &#x27;mapRoam&#x27;,
                // -------内部通信
                TOOLTIP_HOVER: &#x27;tooltipHover&#x27;,
                TOOLTIP_IN_GRID: &#x27;tooltipInGrid&#x27;,
                TOOLTIP_OUT_GRID: &#x27;tooltipOutGrid&#x27;
            },
            DRAG_ENABLE_TIME : 120,   // 降低图表内元素拖拽敏感度，单位ms，不建议外部干预
            EFFECT_ZLEVEL : 7,
            // 主题，默认标志图形类型列表
            symbolList : [
                &#x27;circle&#x27;, &#x27;rectangle&#x27;, &#x27;triangle&#x27;, &#x27;diamond&#x27;,
                &#x27;emptyCircle&#x27;, &#x27;emptyRectangle&#x27;, &#x27;emptyTriangle&#x27;, &#x27;emptyDiamond&#x27;
            ],
            loadingText : &#x27;Loading...&#x27;,
            // 可计算特性配置，孤岛，提示颜色
            calculable: false,              // 默认关闭可计算特性
            calculableColor: &#x27;rgba(255,165,0,0.6)&#x27;,       // 拖拽提示边框颜色
            calculableHolderColor: &#x27;#ccc&#x27;, // 可计算占位提示颜色
            nameConnector: &#x27; &amp; &#x27;,
            valueConnector: &#x27; : &#x27;,
            animation: true,
            addDataAnimation: true,         // 动态数据接口是否开启动画效果
            animationThreshold: 2000,       // 动画元素阀值，产生的图形原素超过2000不出动画
            animationDuration: 2000,
            animationEasing: &#x27;ExponentialOut&#x27;    //BounceOut
        };

        return config;
    });
// Copyright 2006 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


// Known Issues:
//
// * Patterns only support repeat.
// * Radial gradient are not implemented. The VML version of these look very
//   different from the canvas one.
// * Clipping paths are not implemented.
// * Coordsize. The width and height attribute have higher priority than the
//   width and height style values which isn&#x27;t correct.
// * Painting mode isn&#x27;t implemented.
// * Canvas width/height should is using content-box by default. IE in
//   Quirks mode will draw the canvas using border-box. Either change your
//   doctype to HTML5
//   (http://www.whatwg.org/specs/web-apps/current-work/#the-doctype)
//   or use Box Sizing Behavior from WebFX
//   (http://webfx.eae.net/dhtml/boxsizing/boxsizing.html)
// * Non uniform scaling does not correctly scale strokes.
// * Optimize. There is always room for speed improvements.

// AMD by kener.linfeng@gmail.com
    define(&#x27;zrender/lib/excanvas&#x27;,[&#x27;require&#x27;],function(require) {

// Only add this code if we do not already have a canvas implementation
        if (!document.createElement(&#x27;canvas&#x27;).getContext) {

            (function() {

                // alias some functions to make (compiled) code shorter
                var m = Math;
                var mr = m.round;
                var ms = m.sin;
                var mc = m.cos;
                var abs = m.abs;
                var sqrt = m.sqrt;

                // this is used for sub pixel precision
                var Z = 10;
                var Z2 = Z / 2;

                var IE_VERSION = +navigator.userAgent.match(/MSIE ([\d.]+)?/)[1];

                /**
                 * This funtion is assigned to the &lt;canvas&gt; elements as element.getContext().
                 * @this {HTMLElement}
                 * @return {CanvasRenderingContext2D_}
                 */
                function getContext() {
                    return this.context_ ||
                        (this.context_ = new CanvasRenderingContext2D_(this));
                }

                var slice = Array.prototype.slice;

                /**
                 * Binds a function to an object. The returned function will always use the
                 * passed in {@code obj} as {@code this}.
                 *
                 * Example:
                 *
                 *   g = bind(f, obj, a, b)
                 *   g(c, d) // will do f.call(obj, a, b, c, d)
                 *
                 * @param {Function} f The function to bind the object to
                 * @param {Object} obj The object that should act as this when the function
                 *     is called
                 * @param {*} var_args Rest arguments that will be used as the initial
                 *     arguments when the function is called
                 * @return {Function} A new function that has bound this
                 */
                function bind(f, obj, var_args) {
                    var a = slice.call(arguments, 2);
                    return function() {
                        return f.apply(obj, a.concat(slice.call(arguments)));
                    };
                }

                function encodeHtmlAttribute(s) {
                    return String(s).replace(/&amp;/g, &#x27;&amp;amp;&#x27;).replace(/&quot;/g, &#x27;&amp;quot;&#x27;);
                }

                function addNamespace(doc, prefix, urn) {
                    if (!doc.namespaces[prefix]) {
                        doc.namespaces.add(prefix, urn, &#x27;#default#VML&#x27;);
                    }
                }

                function addNamespacesAndStylesheet(doc) {
                    addNamespace(doc, &#x27;g_vml_&#x27;, &#x27;urn:schemas-microsoft-com:vml&#x27;);
                    addNamespace(doc, &#x27;g_o_&#x27;, &#x27;urn:schemas-microsoft-com:office:office&#x27;);

                    // Setup default CSS.  Only add one style sheet per document
                    if (!doc.styleSheets[&#x27;ex_canvas_&#x27;]) {
                        var ss = doc.createStyleSheet();
                        ss.owningElement.id = &#x27;ex_canvas_&#x27;;
                        ss.cssText = &#x27;canvas{display:inline-block;overflow:hidden;&#x27; +
                            // default size is 300x150 in Gecko and Opera
                            &#x27;text-align:left;width:300px;height:150px}&#x27;;
                    }
                }

                // Add namespaces and stylesheet at startup.
                addNamespacesAndStylesheet(document);

                var G_vmlCanvasManager_ = {
                    init: function(opt_doc) {
                        var doc = opt_doc || document;
                        // Create a dummy element so that IE will allow canvas elements to be
                        // recognized.
                        doc.createElement(&#x27;canvas&#x27;);
                        doc.attachEvent(&#x27;onreadystatechange&#x27;, bind(this.init_, this, doc));
                    },

                    init_: function(doc) {
                        // find all canvas elements
                        var els = doc.getElementsByTagName(&#x27;canvas&#x27;);
                        for (var i = 0; i &lt; els.length; i++) {
                            this.initElement(els[i]);
                        }
                    },

                    /**
                     * Public initializes a canvas element so that it can be used as canvas
                     * element from now on. This is called automatically before the page is
                     * loaded but if you are creating elements using createElement you need to
                     * make sure this is called on the element.
                     * @param {HTMLElement} el The canvas element to initialize.
                     * @return {HTMLElement} the element that was created.
                     */
                    initElement: function(el) {
                        if (!el.getContext) {
                            el.getContext = getContext;

                            // Add namespaces and stylesheet to document of the element.
                            addNamespacesAndStylesheet(el.ownerDocument);

                            // Remove fallback content. There is no way to hide text nodes so we
                            // just remove all childNodes. We could hide all elements and remove
                            // text nodes but who really cares about the fallback content.
                            el.innerHTML = &#x27;&#x27;;

                            // do not use inline function because that will leak memory
                            el.attachEvent(&#x27;onpropertychange&#x27;, onPropertyChange);
                            el.attachEvent(&#x27;onresize&#x27;, onResize);

                            var attrs = el.attributes;
                            if (attrs.width &amp;&amp; attrs.width.specified) {
                                // TODO: use runtimeStyle and coordsize
                                // el.getContext().setWidth_(attrs.width.nodeValue);
                                el.style.width = attrs.width.nodeValue + &#x27;px&#x27;;
                            } else {
                                el.width = el.clientWidth;
                            }
                            if (attrs.height &amp;&amp; attrs.height.specified) {
                                // TODO: use runtimeStyle and coordsize
                                // el.getContext().setHeight_(attrs.height.nodeValue);
                                el.style.height = attrs.height.nodeValue + &#x27;px&#x27;;
                            } else {
                                el.height = el.clientHeight;
                            }
                            //el.getContext().setCoordsize_()
                        }
                        return el;
                    }
                };

                function onPropertyChange(e) {
                    var el = e.srcElement;

                    switch (e.propertyName) {
                        case &#x27;width&#x27;:
                            el.getContext().clearRect();
                            el.style.width = el.attributes.width.nodeValue + &#x27;px&#x27;;
                            // In IE8 this does not trigger onresize.
                            el.firstChild.style.width =  el.clientWidth + &#x27;px&#x27;;
                            break;
                        case &#x27;height&#x27;:
                            el.getContext().clearRect();
                            el.style.height = el.attributes.height.nodeValue + &#x27;px&#x27;;
                            el.firstChild.style.height = el.clientHeight + &#x27;px&#x27;;
                            break;
                    }
                }

                function onResize(e) {
                    var el = e.srcElement;
                    if (el.firstChild) {
                        el.firstChild.style.width =  el.clientWidth + &#x27;px&#x27;;
                        el.firstChild.style.height = el.clientHeight + &#x27;px&#x27;;
                    }
                }

                G_vmlCanvasManager_.init();

                // precompute &quot;00&quot; to &quot;FF&quot;
                var decToHex = [];
                for (var i = 0; i &lt; 16; i++) {
                    for (var j = 0; j &lt; 16; j++) {
                        decToHex[i * 16 + j] = i.toString(16) + j.toString(16);
                    }
                }

                function createMatrixIdentity() {
                    return [
                        [1, 0, 0],
                        [0, 1, 0],
                        [0, 0, 1]
                    ];
                }

                function matrixMultiply(m1, m2) {
                    var result = createMatrixIdentity();

                    for (var x = 0; x &lt; 3; x++) {
                        for (var y = 0; y &lt; 3; y++) {
                            var sum = 0;

                            for (var z = 0; z &lt; 3; z++) {
                                sum += m1[x][z] * m2[z][y];
                            }

                            result[x][y] = sum;
                        }
                    }
                    return result;
                }

                function copyState(o1, o2) {
                    o2.fillStyle     = o1.fillStyle;
                    o2.lineCap       = o1.lineCap;
                    o2.lineJoin      = o1.lineJoin;
                    o2.lineWidth     = o1.lineWidth;
                    o2.miterLimit    = o1.miterLimit;
                    o2.shadowBlur    = o1.shadowBlur;
                    o2.shadowColor   = o1.shadowColor;
                    o2.shadowOffsetX = o1.shadowOffsetX;
                    o2.shadowOffsetY = o1.shadowOffsetY;
                    o2.strokeStyle   = o1.strokeStyle;
                    o2.globalAlpha   = o1.globalAlpha;
                    o2.font          = o1.font;
                    o2.textAlign     = o1.textAlign;
                    o2.textBaseline  = o1.textBaseline;
                    o2.arcScaleX_    = o1.arcScaleX_;
                    o2.arcScaleY_    = o1.arcScaleY_;
                    o2.lineScale_    = o1.lineScale_;
                }

                var colorData = {
                    aliceblue: &#x27;#F0F8FF&#x27;,
                    antiquewhite: &#x27;#FAEBD7&#x27;,
                    aquamarine: &#x27;#7FFFD4&#x27;,
                    azure: &#x27;#F0FFFF&#x27;,
                    beige: &#x27;#F5F5DC&#x27;,
                    bisque: &#x27;#FFE4C4&#x27;,
                    black: &#x27;#000000&#x27;,
                    blanchedalmond: &#x27;#FFEBCD&#x27;,
                    blueviolet: &#x27;#8A2BE2&#x27;,
                    brown: &#x27;#A52A2A&#x27;,
                    burlywood: &#x27;#DEB887&#x27;,
                    cadetblue: &#x27;#5F9EA0&#x27;,
                    chartreuse: &#x27;#7FFF00&#x27;,
                    chocolate: &#x27;#D2691E&#x27;,
                    coral: &#x27;#FF7F50&#x27;,
                    cornflowerblue: &#x27;#6495ED&#x27;,
                    cornsilk: &#x27;#FFF8DC&#x27;,
                    crimson: &#x27;#DC143C&#x27;,
                    cyan: &#x27;#00FFFF&#x27;,
                    darkblue: &#x27;#00008B&#x27;,
                    darkcyan: &#x27;#008B8B&#x27;,
                    darkgoldenrod: &#x27;#B8860B&#x27;,
                    darkgray: &#x27;#A9A9A9&#x27;,
                    darkgreen: &#x27;#006400&#x27;,
                    darkgrey: &#x27;#A9A9A9&#x27;,
                    darkkhaki: &#x27;#BDB76B&#x27;,
                    darkmagenta: &#x27;#8B008B&#x27;,
                    darkolivegreen: &#x27;#556B2F&#x27;,
                    darkorange: &#x27;#FF8C00&#x27;,
                    darkorchid: &#x27;#9932CC&#x27;,
                    darkred: &#x27;#8B0000&#x27;,
                    darksalmon: &#x27;#E9967A&#x27;,
                    darkseagreen: &#x27;#8FBC8F&#x27;,
                    darkslateblue: &#x27;#483D8B&#x27;,
                    darkslategray: &#x27;#2F4F4F&#x27;,
                    darkslategrey: &#x27;#2F4F4F&#x27;,
                    darkturquoise: &#x27;#00CED1&#x27;,
                    darkviolet: &#x27;#9400D3&#x27;,
                    deeppink: &#x27;#FF1493&#x27;,
                    deepskyblue: &#x27;#00BFFF&#x27;,
                    dimgray: &#x27;#696969&#x27;,
                    dimgrey: &#x27;#696969&#x27;,
                    dodgerblue: &#x27;#1E90FF&#x27;,
                    firebrick: &#x27;#B22222&#x27;,
                    floralwhite: &#x27;#FFFAF0&#x27;,
                    forestgreen: &#x27;#228B22&#x27;,
                    gainsboro: &#x27;#DCDCDC&#x27;,
                    ghostwhite: &#x27;#F8F8FF&#x27;,
                    gold: &#x27;#FFD700&#x27;,
                    goldenrod: &#x27;#DAA520&#x27;,
                    grey: &#x27;#808080&#x27;,
                    greenyellow: &#x27;#ADFF2F&#x27;,
                    honeydew: &#x27;#F0FFF0&#x27;,
                    hotpink: &#x27;#FF69B4&#x27;,
                    indianred: &#x27;#CD5C5C&#x27;,
                    indigo: &#x27;#4B0082&#x27;,
                    ivory: &#x27;#FFFFF0&#x27;,
                    khaki: &#x27;#F0E68C&#x27;,
                    lavender: &#x27;#E6E6FA&#x27;,
                    lavenderblush: &#x27;#FFF0F5&#x27;,
                    lawngreen: &#x27;#7CFC00&#x27;,
                    lemonchiffon: &#x27;#FFFACD&#x27;,
                    lightblue: &#x27;#ADD8E6&#x27;,
                    lightcoral: &#x27;#F08080&#x27;,
                    lightcyan: &#x27;#E0FFFF&#x27;,
                    lightgoldenrodyellow: &#x27;#FAFAD2&#x27;,
                    lightgreen: &#x27;#90EE90&#x27;,
                    lightgrey: &#x27;#D3D3D3&#x27;,
                    lightpink: &#x27;#FFB6C1&#x27;,
                    lightsalmon: &#x27;#FFA07A&#x27;,
                    lightseagreen: &#x27;#20B2AA&#x27;,
                    lightskyblue: &#x27;#87CEFA&#x27;,
                    lightslategray: &#x27;#778899&#x27;,
                    lightslategrey: &#x27;#778899&#x27;,
                    lightsteelblue: &#x27;#B0C4DE&#x27;,
                    lightyellow: &#x27;#FFFFE0&#x27;,
                    limegreen: &#x27;#32CD32&#x27;,
                    linen: &#x27;#FAF0E6&#x27;,
                    magenta: &#x27;#FF00FF&#x27;,
                    mediumaquamarine: &#x27;#66CDAA&#x27;,
                    mediumblue: &#x27;#0000CD&#x27;,
                    mediumorchid: &#x27;#BA55D3&#x27;,
                    mediumpurple: &#x27;#9370DB&#x27;,
                    mediumseagreen: &#x27;#3CB371&#x27;,
                    mediumslateblue: &#x27;#7B68EE&#x27;,
                    mediumspringgreen: &#x27;#00FA9A&#x27;,
                    mediumturquoise: &#x27;#48D1CC&#x27;,
                    mediumvioletred: &#x27;#C71585&#x27;,
                    midnightblue: &#x27;#191970&#x27;,
                    mintcream: &#x27;#F5FFFA&#x27;,
                    mistyrose: &#x27;#FFE4E1&#x27;,
                    moccasin: &#x27;#FFE4B5&#x27;,
                    navajowhite: &#x27;#FFDEAD&#x27;,
                    oldlace: &#x27;#FDF5E6&#x27;,
                    olivedrab: &#x27;#6B8E23&#x27;,
                    orange: &#x27;#FFA500&#x27;,
                    orangered: &#x27;#FF4500&#x27;,
                    orchid: &#x27;#DA70D6&#x27;,
                    palegoldenrod: &#x27;#EEE8AA&#x27;,
                    palegreen: &#x27;#98FB98&#x27;,
                    paleturquoise: &#x27;#AFEEEE&#x27;,
                    palevioletred: &#x27;#DB7093&#x27;,
                    papayawhip: &#x27;#FFEFD5&#x27;,
                    peachpuff: &#x27;#FFDAB9&#x27;,
                    peru: &#x27;#CD853F&#x27;,
                    pink: &#x27;#FFC0CB&#x27;,
                    plum: &#x27;#DDA0DD&#x27;,
                    powderblue: &#x27;#B0E0E6&#x27;,
                    rosybrown: &#x27;#BC8F8F&#x27;,
                    royalblue: &#x27;#4169E1&#x27;,
                    saddlebrown: &#x27;#8B4513&#x27;,
                    salmon: &#x27;#FA8072&#x27;,
                    sandybrown: &#x27;#F4A460&#x27;,
                    seagreen: &#x27;#2E8B57&#x27;,
                    seashell: &#x27;#FFF5EE&#x27;,
                    sienna: &#x27;#A0522D&#x27;,
                    skyblue: &#x27;#87CEEB&#x27;,
                    slateblue: &#x27;#6A5ACD&#x27;,
                    slategray: &#x27;#708090&#x27;,
                    slategrey: &#x27;#708090&#x27;,
                    snow: &#x27;#FFFAFA&#x27;,
                    springgreen: &#x27;#00FF7F&#x27;,
                    steelblue: &#x27;#4682B4&#x27;,
                    tan: &#x27;#D2B48C&#x27;,
                    thistle: &#x27;#D8BFD8&#x27;,
                    tomato: &#x27;#FF6347&#x27;,
                    turquoise: &#x27;#40E0D0&#x27;,
                    violet: &#x27;#EE82EE&#x27;,
                    wheat: &#x27;#F5DEB3&#x27;,
                    whitesmoke: &#x27;#F5F5F5&#x27;,
                    yellowgreen: &#x27;#9ACD32&#x27;
                };


                function getRgbHslContent(styleString) {
                    var start = styleString.indexOf(&#x27;(&#x27;, 3);
                    var end = styleString.indexOf(&#x27;)&#x27;, start + 1);
                    var parts = styleString.substring(start + 1, end).split(&#x27;,&#x27;);
                    // add alpha if needed
                    if (parts.length != 4 || styleString.charAt(3) != &#x27;a&#x27;) {
                        parts[3] = 1;
                    }
                    return parts;
                }

                function percent(s) {
                    return parseFloat(s) / 100;
                }

                function clamp(v, min, max) {
                    return Math.min(max, Math.max(min, v));
                }

                function hslToRgb(parts){
                    var r, g, b, h, s, l;
                    h = parseFloat(parts[0]) / 360 % 360;
                    if (h &lt; 0)
                        h++;
                    s = clamp(percent(parts[1]), 0, 1);
                    l = clamp(percent(parts[2]), 0, 1);
                    if (s == 0) {
                        r = g = b = l; // achromatic
                    } else {
                        var q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
                        var p = 2 * l - q;
                        r = hueToRgb(p, q, h + 1 / 3);
                        g = hueToRgb(p, q, h);
                        b = hueToRgb(p, q, h - 1 / 3);
                    }

                    return &#x27;#&#x27; + decToHex[Math.floor(r * 255)] +
                        decToHex[Math.floor(g * 255)] +
                        decToHex[Math.floor(b * 255)];
                }

                function hueToRgb(m1, m2, h) {
                    if (h &lt; 0)
                        h++;
                    if (h &gt; 1)
                        h--;

                    if (6 * h &lt; 1)
                        return m1 + (m2 - m1) * 6 * h;
                    else if (2 * h &lt; 1)
                        return m2;
                    else if (3 * h &lt; 2)
                        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
                    else
                        return m1;
                }

                var processStyleCache = {};

                function processStyle(styleString) {
                    if (styleString in processStyleCache) {
                        return processStyleCache[styleString];
                    }

                    var str, alpha = 1;

                    styleString = String(styleString);
                    if (styleString.charAt(0) == &#x27;#&#x27;) {
                        str = styleString;
                    } else if (/^rgb/.test(styleString)) {
                        var parts = getRgbHslContent(styleString);
                        var str = &#x27;#&#x27;, n;
                        for (var i = 0; i &lt; 3; i++) {
                            if (parts[i].indexOf(&#x27;%&#x27;) != -1) {
                                n = Math.floor(percent(parts[i]) * 255);
                            } else {
                                n = +parts[i];
                            }
                            str += decToHex[clamp(n, 0, 255)];
                        }
                        alpha = +parts[3];
                    } else if (/^hsl/.test(styleString)) {
                        var parts = getRgbHslContent(styleString);
                        str = hslToRgb(parts);
                        alpha = parts[3];
                    } else {
                        str = colorData[styleString] || styleString;
                    }
                    return processStyleCache[styleString] = {color: str, alpha: alpha};
                }

                var DEFAULT_STYLE = {
                    style: &#x27;normal&#x27;,
                    variant: &#x27;normal&#x27;,
                    weight: &#x27;normal&#x27;,
                    size: 12,           //10
                    family: &#x27;微软雅黑&#x27;     //&#x27;sans-serif&#x27;
                };

                // Internal text style cache
                var fontStyleCache = {};

                function processFontStyle(styleString) {
                    if (fontStyleCache[styleString]) {
                        return fontStyleCache[styleString];
                    }

                    var el = document.createElement(&#x27;div&#x27;);
                    var style = el.style;
                    var fontFamily;
                    try {
                        style.font = styleString;
                        fontFamily = style.fontFamily.split(&#x27;,&#x27;)[0];
                    } catch (ex) {
                        // Ignore failures to set to invalid font.
                    }

                    return fontStyleCache[styleString] = {
                        style: style.fontStyle || DEFAULT_STYLE.style,
                        variant: style.fontVariant || DEFAULT_STYLE.variant,
                        weight: style.fontWeight || DEFAULT_STYLE.weight,
                        size: style.fontSize || DEFAULT_STYLE.size,
                        family: fontFamily || DEFAULT_STYLE.family
                    };
                }

                function getComputedStyle(style, element) {
                    var computedStyle = {};

                    for (var p in style) {
                        computedStyle[p] = style[p];
                    }

                    // Compute the size
                    var canvasFontSize = parseFloat(element.currentStyle.fontSize),
                        fontSize = parseFloat(style.size);

                    if (typeof style.size == &#x27;number&#x27;) {
                        computedStyle.size = style.size;
                    } else if (style.size.indexOf(&#x27;px&#x27;) != -1) {
                        computedStyle.size = fontSize;
                    } else if (style.size.indexOf(&#x27;em&#x27;) != -1) {
                        computedStyle.size = canvasFontSize * fontSize;
                    } else if(style.size.indexOf(&#x27;%&#x27;) != -1) {
                        computedStyle.size = (canvasFontSize / 100) * fontSize;
                    } else if (style.size.indexOf(&#x27;pt&#x27;) != -1) {
                        computedStyle.size = fontSize / .75;
                    } else {
                        computedStyle.size = canvasFontSize;
                    }

                    // Different scaling between normal text and VML text. This was found using
                    // trial and error to get the same size as non VML text.
                    //computedStyle.size *= 0.981;

                    return computedStyle;
                }

                function buildStyle(style) {
                    return style.style + &#x27; &#x27; + style.variant + &#x27; &#x27; + style.weight + &#x27; &#x27; +
                        style.size + &quot;px &#x27;&quot; + style.family + &quot;&#x27;&quot;;
                }

                var lineCapMap = {
                    &#x27;butt&#x27;: &#x27;flat&#x27;,
                    &#x27;round&#x27;: &#x27;round&#x27;
                };

                function processLineCap(lineCap) {
                    return lineCapMap[lineCap] || &#x27;square&#x27;;
                }

                /**
                 * This class implements CanvasRenderingContext2D interface as described by
                 * the WHATWG.
                 * @param {HTMLElement} canvasElement The element that the 2D context should
                 * be associated with
                 */
                function CanvasRenderingContext2D_(canvasElement) {
                    this.m_ = createMatrixIdentity();

                    this.mStack_ = [];
                    this.aStack_ = [];
                    this.currentPath_ = [];

                    // Canvas context properties
                    this.strokeStyle = &#x27;#000&#x27;;
                    this.fillStyle = &#x27;#000&#x27;;

                    this.lineWidth = 1;
                    this.lineJoin = &#x27;miter&#x27;;
                    this.lineCap = &#x27;butt&#x27;;
                    this.miterLimit = Z * 1;
                    this.globalAlpha = 1;
                    // this.font = &#x27;10px sans-serif&#x27;;
                    this.font = &#x27;12px 微软雅黑&#x27;;        // 决定还是改这吧，影响代价最小
                    this.textAlign = &#x27;left&#x27;;
                    this.textBaseline = &#x27;alphabetic&#x27;;
                    this.canvas = canvasElement;

                    var cssText = &#x27;width:&#x27; + canvasElement.clientWidth + &#x27;px;height:&#x27; +
                        canvasElement.clientHeight + &#x27;px;overflow:hidden;position:absolute&#x27;;
                    var el = canvasElement.ownerDocument.createElement(&#x27;div&#x27;);
                    el.style.cssText = cssText;
                    canvasElement.appendChild(el);

                    var overlayEl = el.cloneNode(false);
                    // Use a non transparent background.
                    overlayEl.style.backgroundColor = &#x27;#fff&#x27;; //red, I don&#x27;t know why, it work! 
                    overlayEl.style.filter = &#x27;alpha(opacity=0)&#x27;;
                    canvasElement.appendChild(overlayEl);

                    this.element_ = el;
                    this.arcScaleX_ = 1;
                    this.arcScaleY_ = 1;
                    this.lineScale_ = 1;
                }

                var contextPrototype = CanvasRenderingContext2D_.prototype;
                contextPrototype.clearRect = function() {
                    if (this.textMeasureEl_) {
                        this.textMeasureEl_.removeNode(true);
                        this.textMeasureEl_ = null;
                    }
                    this.element_.innerHTML = &#x27;&#x27;;
                };

                contextPrototype.beginPath = function() {
                    // TODO: Branch current matrix so that save/restore has no effect
                    //       as per safari docs.
                    this.currentPath_ = [];
                };

                contextPrototype.moveTo = function(aX, aY) {
                    var p = getCoords(this, aX, aY);
                    this.currentPath_.push({type: &#x27;moveTo&#x27;, x: p.x, y: p.y});
                    this.currentX_ = p.x;
                    this.currentY_ = p.y;
                };

                contextPrototype.lineTo = function(aX, aY) {
                    var p = getCoords(this, aX, aY);
                    this.currentPath_.push({type: &#x27;lineTo&#x27;, x: p.x, y: p.y});

                    this.currentX_ = p.x;
                    this.currentY_ = p.y;
                };

                contextPrototype.bezierCurveTo = function(aCP1x, aCP1y,
                                                          aCP2x, aCP2y,
                                                          aX, aY) {
                    var p = getCoords(this, aX, aY);
                    var cp1 = getCoords(this, aCP1x, aCP1y);
                    var cp2 = getCoords(this, aCP2x, aCP2y);
                    bezierCurveTo(this, cp1, cp2, p);
                };

                // Helper function that takes the already fixed cordinates.
                function bezierCurveTo(self, cp1, cp2, p) {
                    self.currentPath_.push({
                        type: &#x27;bezierCurveTo&#x27;,
                        cp1x: cp1.x,
                        cp1y: cp1.y,
                        cp2x: cp2.x,
                        cp2y: cp2.y,
                        x: p.x,
                        y: p.y
                    });
                    self.currentX_ = p.x;
                    self.currentY_ = p.y;
                }

                contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
                    // the following is lifted almost directly from
                    // http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes

                    var cp = getCoords(this, aCPx, aCPy);
                    var p = getCoords(this, aX, aY);

                    var cp1 = {
                        x: this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),
                        y: this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)
                    };
                    var cp2 = {
                        x: cp1.x + (p.x - this.currentX_) / 3.0,
                        y: cp1.y + (p.y - this.currentY_) / 3.0
                    };

                    bezierCurveTo(this, cp1, cp2, p);
                };

                contextPrototype.arc = function(aX, aY, aRadius,
                                                aStartAngle, aEndAngle, aClockwise) {
                    aRadius *= Z;
                    var arcType = aClockwise ? &#x27;at&#x27; : &#x27;wa&#x27;;

                    var xStart = aX + mc(aStartAngle) * aRadius - Z2;
                    var yStart = aY + ms(aStartAngle) * aRadius - Z2;

                    var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
                    var yEnd = aY + ms(aEndAngle) * aRadius - Z2;

                    // IE won&#x27;t render arches drawn counter clockwise if xStart == xEnd.
                    if (xStart == xEnd &amp;&amp; !aClockwise) {
                        xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use something
                        // that can be represented in binary
                    }

                    var p = getCoords(this, aX, aY);
                    var pStart = getCoords(this, xStart, yStart);
                    var pEnd = getCoords(this, xEnd, yEnd);

                    this.currentPath_.push({type: arcType,
                        x: p.x,
                        y: p.y,
                        radius: aRadius,
                        xStart: pStart.x,
                        yStart: pStart.y,
                        xEnd: pEnd.x,
                        yEnd: pEnd.y});

                };

                contextPrototype.rect = function(aX, aY, aWidth, aHeight) {
                    this.moveTo(aX, aY);
                    this.lineTo(aX + aWidth, aY);
                    this.lineTo(aX + aWidth, aY + aHeight);
                    this.lineTo(aX, aY + aHeight);
                    this.closePath();
                };

                contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {
                    var oldPath = this.currentPath_;
                    this.beginPath();

                    this.moveTo(aX, aY);
                    this.lineTo(aX + aWidth, aY);
                    this.lineTo(aX + aWidth, aY + aHeight);
                    this.lineTo(aX, aY + aHeight);
                    this.closePath();
                    this.stroke();

                    this.currentPath_ = oldPath;
                };

                contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {
                    var oldPath = this.currentPath_;
                    this.beginPath();

                    this.moveTo(aX, aY);
                    this.lineTo(aX + aWidth, aY);
                    this.lineTo(aX + aWidth, aY + aHeight);
                    this.lineTo(aX, aY + aHeight);
                    this.closePath();
                    this.fill();

                    this.currentPath_ = oldPath;
                };

                contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {
                    var gradient = new CanvasGradient_(&#x27;gradient&#x27;);
                    gradient.x0_ = aX0;
                    gradient.y0_ = aY0;
                    gradient.x1_ = aX1;
                    gradient.y1_ = aY1;
                    return gradient;
                };

                contextPrototype.createRadialGradient = function(aX0, aY0, aR0,
                                                                 aX1, aY1, aR1) {
                    var gradient = new CanvasGradient_(&#x27;gradientradial&#x27;);
                    gradient.x0_ = aX0;
                    gradient.y0_ = aY0;
                    gradient.r0_ = aR0;
                    gradient.x1_ = aX1;
                    gradient.y1_ = aY1;
                    gradient.r1_ = aR1;
                    return gradient;
                };

                contextPrototype.drawImage = function(image, var_args) {
                    var dx, dy, dw, dh, sx, sy, sw, sh;

                    // to find the original width we overide the width and height
                    var oldRuntimeWidth = image.runtimeStyle.width;
                    var oldRuntimeHeight = image.runtimeStyle.height;
                    image.runtimeStyle.width = &#x27;auto&#x27;;
                    image.runtimeStyle.height = &#x27;auto&#x27;;

                    // get the original size
                    var w = image.width;
                    var h = image.height;

                    // and remove overides
                    image.runtimeStyle.width = oldRuntimeWidth;
                    image.runtimeStyle.height = oldRuntimeHeight;

                    if (arguments.length == 3) {
                        dx = arguments[1];
                        dy = arguments[2];
                        sx = sy = 0;
                        sw = dw = w;
                        sh = dh = h;
                    } else if (arguments.length == 5) {
                        dx = arguments[1];
                        dy = arguments[2];
                        dw = arguments[3];
                        dh = arguments[4];
                        sx = sy = 0;
                        sw = w;
                        sh = h;
                    } else if (arguments.length == 9) {
                        sx = arguments[1];
                        sy = arguments[2];
                        sw = arguments[3];
                        sh = arguments[4];
                        dx = arguments[5];
                        dy = arguments[6];
                        dw = arguments[7];
                        dh = arguments[8];
                    } else {
                        throw Error(&#x27;Invalid number of arguments&#x27;);
                    }

                    var d = getCoords(this, dx, dy);

                    var w2 = sw / 2;
                    var h2 = sh / 2;

                    var vmlStr = [];

                    var W = 10;
                    var H = 10;

                    var scaleX = scaleY = 1;

                    // For some reason that I&#x27;ve now forgotten, using divs didn&#x27;t work
                    vmlStr.push(&#x27; &lt;g_vml_:group&#x27;,
                        &#x27; coordsize=&quot;&#x27;, Z * W, &#x27;,&#x27;, Z * H, &#x27;&quot;&#x27;,
                        &#x27; coordorigin=&quot;0,0&quot;&#x27; ,
                        &#x27; style=&quot;width:&#x27;, W, &#x27;px;height:&#x27;, H, &#x27;px;position:absolute;&#x27;);

                    // If filters are necessary (rotation exists), create them
                    // filters are bog-slow, so only create them if abbsolutely necessary
                    // The following check doesn&#x27;t account for skews (which don&#x27;t exist
                    // in the canvas spec (yet) anyway.

                    if (this.m_[0][0] != 1 || this.m_[0][1] ||
                        this.m_[1][1] != 1 || this.m_[1][0]) {
                        var filter = [];

                        scaleX = Math.sqrt(this.m_[0][0] * this.m_[0][0] + this.m_[0][1] * this.m_[0][1]);
                        scaleY = Math.sqrt(this.m_[1][0] * this.m_[1][0] + this.m_[1][1] * this.m_[1][1]);

                        // Note the 12/21 reversal
                        filter.push(&#x27;M11=&#x27;, this.m_[0][0] / scaleX, &#x27;,&#x27;,
                            &#x27;M12=&#x27;, this.m_[1][0] / scaleY, &#x27;,&#x27;,
                            &#x27;M21=&#x27;, this.m_[0][1] / scaleX, &#x27;,&#x27;,
                            &#x27;M22=&#x27;, this.m_[1][1] / scaleY, &#x27;,&#x27;,
                            &#x27;Dx=&#x27;, mr(d.x / Z), &#x27;,&#x27;,
                            &#x27;Dy=&#x27;, mr(d.y / Z), &#x27;&#x27;);

                        // Bounding box calculation (need to minimize displayed area so that
                        // filters don&#x27;t waste time on unused pixels.
                        var max = d;
                        var c2 = getCoords(this, dx + dw, dy);
                        var c3 = getCoords(this, dx, dy + dh);
                        var c4 = getCoords(this, dx + dw, dy + dh);

                        max.x = m.max(max.x, c2.x, c3.x, c4.x);
                        max.y = m.max(max.y, c2.y, c3.y, c4.y);

                        vmlStr.push(&#x27;padding:0 &#x27;, mr(max.x / Z), &#x27;px &#x27;, mr(max.y / Z),
                            &#x27;px 0;filter:progid:DXImageTransform.Microsoft.Matrix(&#x27;,
                            filter.join(&#x27;&#x27;), &quot;, sizingmethod=&#x27;clip&#x27;);&quot;);

                    } else {
                        vmlStr.push(&#x27;top:&#x27;, mr(d.y / Z), &#x27;px;left:&#x27;, mr(d.x / Z), &#x27;px;&#x27;);
                    }

                    vmlStr.push(&#x27; &quot;&gt;&#x27;);

                    // Draw a special cropping div if needed
                    if (sx || sy) {
                        // Apply scales to width and height
                        vmlStr.push(&#x27;&lt;div style=&quot;overflow: hidden; width:&#x27;, Math.ceil((dw + sx * dw / sw) * scaleX), &#x27;px;&#x27;,
                            &#x27; height:&#x27;, Math.ceil((dh + sy * dh / sh) * scaleY), &#x27;px;&#x27;,
                            &#x27; filter:progid:DxImageTransform.Microsoft.Matrix(Dx=&#x27;,
                                -sx * dw / sw * scaleX, &#x27;,Dy=&#x27;, -sy * dh / sh * scaleY, &#x27;);&quot;&gt;&#x27;);
                    }


                    // Apply scales to width and height
                    vmlStr.push(&#x27;&lt;div style=&quot;width:&#x27;, Math.round(scaleX * w * dw / sw), &#x27;px;&#x27;,
                        &#x27; height:&#x27;, Math.round(scaleY * h * dh / sh), &#x27;px;&#x27;,
                        &#x27; filter:&#x27;);

                    // If there is a globalAlpha, apply it to image
                    if(this.globalAlpha &lt; 1) {
                        vmlStr.push(&#x27; progid:DXImageTransform.Microsoft.Alpha(opacity=&#x27; + (this.globalAlpha * 100) + &#x27;)&#x27;);
                    }

                    vmlStr.push(&#x27; progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&#x27;, image.src, &#x27;,sizingMethod=scale)&quot;&gt;&#x27;);

                    // Close the crop div if necessary            
                    if (sx || sy) vmlStr.push(&#x27;&lt;/div&gt;&#x27;);

                    vmlStr.push(&#x27;&lt;/div&gt;&lt;/div&gt;&#x27;);

                    this.element_.insertAdjacentHTML(&#x27;BeforeEnd&#x27;, vmlStr.join(&#x27;&#x27;));
                };

                contextPrototype.stroke = function(aFill) {
                    var lineStr = [];
                    var lineOpen = false;

                    var W = 10;
                    var H = 10;

                    lineStr.push(&#x27;&lt;g_vml_:shape&#x27;,
                        &#x27; filled=&quot;&#x27;, !!aFill, &#x27;&quot;&#x27;,
                        &#x27; style=&quot;position:absolute;width:&#x27;, W, &#x27;px;height:&#x27;, H, &#x27;px;&quot;&#x27;,
                        &#x27; coordorigin=&quot;0,0&quot;&#x27;,
                        &#x27; coordsize=&quot;&#x27;, Z * W, &#x27;,&#x27;, Z * H, &#x27;&quot;&#x27;,
                        &#x27; stroked=&quot;&#x27;, !aFill, &#x27;&quot;&#x27;,
                        &#x27; path=&quot;&#x27;);

                    var newSeq = false;
                    var min = {x: null, y: null};
                    var max = {x: null, y: null};

                    for (var i = 0; i &lt; this.currentPath_.length; i++) {
                        var p = this.currentPath_[i];
                        var c;

                        switch (p.type) {
                            case &#x27;moveTo&#x27;:
                                c = p;
                                lineStr.push(&#x27; m &#x27;, mr(p.x), &#x27;,&#x27;, mr(p.y));
                                break;
                            case &#x27;lineTo&#x27;:
                                lineStr.push(&#x27; l &#x27;, mr(p.x), &#x27;,&#x27;, mr(p.y));
                                break;
                            case &#x27;close&#x27;:
                                lineStr.push(&#x27; x &#x27;);
                                p = null;
                                break;
                            case &#x27;bezierCurveTo&#x27;:
                                lineStr.push(&#x27; c &#x27;,
                                    mr(p.cp1x), &#x27;,&#x27;, mr(p.cp1y), &#x27;,&#x27;,
                                    mr(p.cp2x), &#x27;,&#x27;, mr(p.cp2y), &#x27;,&#x27;,
                                    mr(p.x), &#x27;,&#x27;, mr(p.y));
                                break;
                            case &#x27;at&#x27;:
                            case &#x27;wa&#x27;:
                                lineStr.push(&#x27; &#x27;, p.type, &#x27; &#x27;,
                                    mr(p.x - this.arcScaleX_ * p.radius), &#x27;,&#x27;,
                                    mr(p.y - this.arcScaleY_ * p.radius), &#x27; &#x27;,
                                    mr(p.x + this.arcScaleX_ * p.radius), &#x27;,&#x27;,
                                    mr(p.y + this.arcScaleY_ * p.radius), &#x27; &#x27;,
                                    mr(p.xStart), &#x27;,&#x27;, mr(p.yStart), &#x27; &#x27;,
                                    mr(p.xEnd), &#x27;,&#x27;, mr(p.yEnd));
                                break;
                        }


                        // TODO: Following is broken for curves due to
                        //       move to proper paths.

                        // Figure out dimensions so we can do gradient fills
                        // properly
                        if (p) {
                            if (min.x == null || p.x &lt; min.x) {
                                min.x = p.x;
                            }
                            if (max.x == null || p.x &gt; max.x) {
                                max.x = p.x;
                            }
                            if (min.y == null || p.y &lt; min.y) {
                                min.y = p.y;
                            }
                            if (max.y == null || p.y &gt; max.y) {
                                max.y = p.y;
                            }
                        }
                    }
                    lineStr.push(&#x27; &quot;&gt;&#x27;);

                    if (!aFill) {
                        appendStroke(this, lineStr);
                    } else {
                        appendFill(this, lineStr, min, max);
                    }

                    lineStr.push(&#x27;&lt;/g_vml_:shape&gt;&#x27;);

                    this.element_.insertAdjacentHTML(&#x27;beforeEnd&#x27;, lineStr.join(&#x27;&#x27;));
                };

                function appendStroke(ctx, lineStr) {
                    var a = processStyle(ctx.strokeStyle);
                    var color = a.color;
                    var opacity = a.alpha * ctx.globalAlpha;
                    var lineWidth = ctx.lineScale_ * ctx.lineWidth;

                    // VML cannot correctly render a line if the width is less than 1px.
                    // In that case, we dilute the color to make the line look thinner.
                    if (lineWidth &lt; 1) {
                        opacity *= lineWidth;
                    }

                    lineStr.push(
                        &#x27;&lt;g_vml_:stroke&#x27;,
                        &#x27; opacity=&quot;&#x27;, opacity, &#x27;&quot;&#x27;,
                        &#x27; joinstyle=&quot;&#x27;, ctx.lineJoin, &#x27;&quot;&#x27;,
                        &#x27; miterlimit=&quot;&#x27;, ctx.miterLimit, &#x27;&quot;&#x27;,
                        &#x27; endcap=&quot;&#x27;, processLineCap(ctx.lineCap), &#x27;&quot;&#x27;,
                        &#x27; weight=&quot;&#x27;, lineWidth, &#x27;px&quot;&#x27;,
                        &#x27; color=&quot;&#x27;, color, &#x27;&quot; /&gt;&#x27;
                    );
                }

                function appendFill(ctx, lineStr, min, max) {
                    var fillStyle = ctx.fillStyle;
                    var arcScaleX = ctx.arcScaleX_;
                    var arcScaleY = ctx.arcScaleY_;
                    var width = max.x - min.x;
                    var height = max.y - min.y;
                    if (fillStyle instanceof CanvasGradient_) {
                        // TODO: Gradients transformed with the transformation matrix.
                        var angle = 0;
                        var focus = {x: 0, y: 0};

                        // additional offset
                        var shift = 0;
                        // scale factor for offset
                        var expansion = 1;

                        if (fillStyle.type_ == &#x27;gradient&#x27;) {
                            var x0 = fillStyle.x0_ / arcScaleX;
                            var y0 = fillStyle.y0_ / arcScaleY;
                            var x1 = fillStyle.x1_ / arcScaleX;
                            var y1 = fillStyle.y1_ / arcScaleY;
                            var p0 = getCoords(ctx, x0, y0);
                            var p1 = getCoords(ctx, x1, y1);
                            var dx = p1.x - p0.x;
                            var dy = p1.y - p0.y;
                            angle = Math.atan2(dx, dy) * 180 / Math.PI;

                            // The angle should be a non-negative number.
                            if (angle &lt; 0) {
                                angle += 360;
                            }

                            // Very small angles produce an unexpected result because they are
                            // converted to a scientific notation string.
                            if (angle &lt; 1e-6) {
                                angle = 0;
                            }
                        } else {
                            var p0 = getCoords(ctx, fillStyle.x0_, fillStyle.y0_);
                            focus = {
                                x: (p0.x - min.x) / width,
                                y: (p0.y - min.y) / height
                            };

                            width  /= arcScaleX * Z;
                            height /= arcScaleY * Z;
                            var dimension = m.max(width, height);
                            shift = 2 * fillStyle.r0_ / dimension;
                            expansion = 2 * fillStyle.r1_ / dimension - shift;
                        }

                        // We need to sort the color stops in ascending order by offset,
                        // otherwise IE won&#x27;t interpret it correctly.
                        var stops = fillStyle.colors_;
                        stops.sort(function(cs1, cs2) {
                            return cs1.offset - cs2.offset;
                        });

                        var length = stops.length;
                        var color1 = stops[0].color;
                        var color2 = stops[length - 1].color;
                        var opacity1 = stops[0].alpha * ctx.globalAlpha;
                        var opacity2 = stops[length - 1].alpha * ctx.globalAlpha;

                        var colors = [];
                        for (var i = 0; i &lt; length; i++) {
                            var stop = stops[i];
                            colors.push(stop.offset * expansion + shift + &#x27; &#x27; + stop.color);
                        }

                        // When colors attribute is used, the meanings of opacity and o:opacity2
                        // are reversed.
                        lineStr.push(&#x27;&lt;g_vml_:fill type=&quot;&#x27;, fillStyle.type_, &#x27;&quot;&#x27;,
                            &#x27; method=&quot;none&quot; focus=&quot;100%&quot;&#x27;,
                            &#x27; color=&quot;&#x27;, color1, &#x27;&quot;&#x27;,
                            &#x27; color2=&quot;&#x27;, color2, &#x27;&quot;&#x27;,
                            &#x27; colors=&quot;&#x27;, colors.join(&#x27;,&#x27;), &#x27;&quot;&#x27;,
                            &#x27; opacity=&quot;&#x27;, opacity2, &#x27;&quot;&#x27;,
                            &#x27; g_o_:opacity2=&quot;&#x27;, opacity1, &#x27;&quot;&#x27;,
                            &#x27; angle=&quot;&#x27;, angle, &#x27;&quot;&#x27;,
                            &#x27; focusposition=&quot;&#x27;, focus.x, &#x27;,&#x27;, focus.y, &#x27;&quot; /&gt;&#x27;);
                    } else if (fillStyle instanceof CanvasPattern_) {
                        if (width &amp;&amp; height) {
                            var deltaLeft = -min.x;
                            var deltaTop = -min.y;
                            lineStr.push(&#x27;&lt;g_vml_:fill&#x27;,
                                &#x27; position=&quot;&#x27;,
                                    deltaLeft / width * arcScaleX * arcScaleX, &#x27;,&#x27;,
                                    deltaTop / height * arcScaleY * arcScaleY, &#x27;&quot;&#x27;,
                                &#x27; type=&quot;tile&quot;&#x27;,
                                // TODO: Figure out the correct size to fit the scale.
                                //&#x27; size=&quot;&#x27;, w, &#x27;px &#x27;, h, &#x27;px&quot;&#x27;,
                                &#x27; src=&quot;&#x27;, fillStyle.src_, &#x27;&quot; /&gt;&#x27;);
                        }
                    } else {
                        var a = processStyle(ctx.fillStyle);
                        var color = a.color;
                        var opacity = a.alpha * ctx.globalAlpha;
                        lineStr.push(&#x27;&lt;g_vml_:fill color=&quot;&#x27;, color, &#x27;&quot; opacity=&quot;&#x27;, opacity,
                            &#x27;&quot; /&gt;&#x27;);
                    }
                }

                contextPrototype.fill = function() {
                    this.stroke(true);
                };

                contextPrototype.closePath = function() {
                    this.currentPath_.push({type: &#x27;close&#x27;});
                };

                function getCoords(ctx, aX, aY) {
                    var m = ctx.m_;
                    return {
                        x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,
                        y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2
                    };
                };

                contextPrototype.save = function() {
                    var o = {};
                    copyState(this, o);
                    this.aStack_.push(o);
                    this.mStack_.push(this.m_);
                    this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
                };

                contextPrototype.restore = function() {
                    if (this.aStack_.length) {
                        copyState(this.aStack_.pop(), this);
                        this.m_ = this.mStack_.pop();
                    }
                };

                function matrixIsFinite(m) {
                    return isFinite(m[0][0]) &amp;&amp; isFinite(m[0][1]) &amp;&amp;
                        isFinite(m[1][0]) &amp;&amp; isFinite(m[1][1]) &amp;&amp;
                        isFinite(m[2][0]) &amp;&amp; isFinite(m[2][1]);
                }

                function setM(ctx, m, updateLineScale) {
                    if (!matrixIsFinite(m)) {
                        return;
                    }
                    ctx.m_ = m;

                    if (updateLineScale) {
                        // Get the line scale.
                        // Determinant of this.m_ means how much the area is enlarged by the
                        // transformation. So its square root can be used as a scale factor
                        // for width.
                        var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
                        ctx.lineScale_ = sqrt(abs(det));
                    }
                }

                contextPrototype.translate = function(aX, aY) {
                    var m1 = [
                        [1,  0,  0],
                        [0,  1,  0],
                        [aX, aY, 1]
                    ];

                    setM(this, matrixMultiply(m1, this.m_), false);
                };

                contextPrototype.rotate = function(aRot) {
                    var c = mc(aRot);
                    var s = ms(aRot);

                    var m1 = [
                        [c,  s, 0],
                        [-s, c, 0],
                        [0,  0, 1]
                    ];

                    setM(this, matrixMultiply(m1, this.m_), false);
                };

                contextPrototype.scale = function(aX, aY) {
                    this.arcScaleX_ *= aX;
                    this.arcScaleY_ *= aY;
                    var m1 = [
                        [aX, 0,  0],
                        [0,  aY, 0],
                        [0,  0,  1]
                    ];

                    setM(this, matrixMultiply(m1, this.m_), true);
                };

                contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {
                    var m1 = [
                        [m11, m12, 0],
                        [m21, m22, 0],
                        [dx,  dy,  1]
                    ];

                    setM(this, matrixMultiply(m1, this.m_), true);
                };

                contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
                    var m = [
                        [m11, m12, 0],
                        [m21, m22, 0],
                        [dx,  dy,  1]
                    ];

                    setM(this, m, true);
                };

                /**
                 * The text drawing function.
                 * The maxWidth argument isn&#x27;t taken in account, since no browser supports
                 * it yet.
                 */
                contextPrototype.drawText_ = function(text, x, y, maxWidth, stroke) {
                    var m = this.m_,
                        delta = 1000,
                        left = 0,
                        right = delta,
                        offset = {x: 0, y: 0},
                        lineStr = [];

                    var fontStyle = getComputedStyle(processFontStyle(this.font),
                        this.element_);

                    var fontStyleString = buildStyle(fontStyle);

                    var elementStyle = this.element_.currentStyle;
                    var textAlign = this.textAlign.toLowerCase();
                    switch (textAlign) {
                        case &#x27;left&#x27;:
                        case &#x27;center&#x27;:
                        case &#x27;right&#x27;:
                            break;
                        case &#x27;end&#x27;:
                            textAlign = elementStyle.direction == &#x27;ltr&#x27; ? &#x27;right&#x27; : &#x27;left&#x27;;
                            break;
                        case &#x27;start&#x27;:
                            textAlign = elementStyle.direction == &#x27;rtl&#x27; ? &#x27;right&#x27; : &#x27;left&#x27;;
                            break;
                        default:
                            textAlign = &#x27;left&#x27;;
                    }

                    // 1.75 is an arbitrary number, as there is no info about the text baseline
                    switch (this.textBaseline) {
                        case &#x27;hanging&#x27;:
                        case &#x27;top&#x27;:
                            offset.y = fontStyle.size / 1.75;
                            break;
                        case &#x27;middle&#x27;:
                            break;
                        default:
                        case null:
                        case &#x27;alphabetic&#x27;:
                        case &#x27;ideographic&#x27;:
                        case &#x27;bottom&#x27;:
                            offset.y = -fontStyle.size / 2.25;
                            break;
                    }

                    switch(textAlign) {
                        case &#x27;right&#x27;:
                            left = delta;
                            right = 0.05;
                            break;
                        case &#x27;center&#x27;:
                            left = right = delta / 2;
                            break;
                    }

                    var d = getCoords(this, x + offset.x, y + offset.y);

                    lineStr.push(&#x27;&lt;g_vml_:line from=&quot;&#x27;, -left ,&#x27; 0&quot; to=&quot;&#x27;, right ,&#x27; 0.05&quot; &#x27;,
                        &#x27; coordsize=&quot;100 100&quot; coordorigin=&quot;0 0&quot;&#x27;,
                        &#x27; filled=&quot;&#x27;, !stroke, &#x27;&quot; stroked=&quot;&#x27;, !!stroke,
                        &#x27;&quot; style=&quot;position:absolute;width:1px;height:1px;&quot;&gt;&#x27;);

                    if (stroke) {
                        appendStroke(this, lineStr);
                    } else {
                        // TODO: Fix the min and max params.
                        appendFill(this, lineStr, {x: -left, y: 0},
                            {x: right, y: fontStyle.size});
                    }

                    var skewM = m[0][0].toFixed(3) + &#x27;,&#x27; + m[1][0].toFixed(3) + &#x27;,&#x27; +
                        m[0][1].toFixed(3) + &#x27;,&#x27; + m[1][1].toFixed(3) + &#x27;,0,0&#x27;;

                    var skewOffset = mr(d.x / Z) + &#x27;,&#x27; + mr(d.y / Z);

                    lineStr.push(&#x27;&lt;g_vml_:skew on=&quot;t&quot; matrix=&quot;&#x27;, skewM ,&#x27;&quot; &#x27;,
                        &#x27; offset=&quot;&#x27;, skewOffset, &#x27;&quot; origin=&quot;&#x27;, left ,&#x27; 0&quot; /&gt;&#x27;,
                        &#x27;&lt;g_vml_:path textpathok=&quot;true&quot; /&gt;&#x27;,
                        &#x27;&lt;g_vml_:textpath on=&quot;true&quot; string=&quot;&#x27;,
                        encodeHtmlAttribute(text),
                        &#x27;&quot; style=&quot;v-text-align:&#x27;, textAlign,
                        &#x27;;font:&#x27;, encodeHtmlAttribute(fontStyleString),
                        &#x27;&quot; /&gt;&lt;/g_vml_:line&gt;&#x27;);

                    this.element_.insertAdjacentHTML(&#x27;beforeEnd&#x27;, lineStr.join(&#x27;&#x27;));
                };

                contextPrototype.fillText = function(text, x, y, maxWidth) {
                    this.drawText_(text, x, y, maxWidth, false);
                };

                contextPrototype.strokeText = function(text, x, y, maxWidth) {
                    this.drawText_(text, x, y, maxWidth, true);
                };

                contextPrototype.measureText = function(text) {
                    if (!this.textMeasureEl_) {
                        var s = &#x27;&lt;span style=&quot;position:absolute;&#x27; +
                            &#x27;top:-20000px;left:0;padding:0;margin:0;border:none;&#x27; +
                            &#x27;white-space:pre;&quot;&gt;&lt;/span&gt;&#x27;;
                        this.element_.insertAdjacentHTML(&#x27;beforeEnd&#x27;, s);
                        this.textMeasureEl_ = this.element_.lastChild;
                    }
                    var doc = this.element_.ownerDocument;
                    this.textMeasureEl_.innerHTML = &#x27;&#x27;;
                    this.textMeasureEl_.style.font = this.font;
                    // Don&#x27;t use innerHTML or innerText because they allow markup/whitespace.
                    this.textMeasureEl_.appendChild(doc.createTextNode(text));
                    return {width: this.textMeasureEl_.offsetWidth};
                };

                /******** STUBS ********/
                contextPrototype.clip = function() {
                    // TODO: Implement
                };

                contextPrototype.arcTo = function() {
                    // TODO: Implement
                };

                contextPrototype.createPattern = function(image, repetition) {
                    return new CanvasPattern_(image, repetition);
                };

                // Gradient / Pattern Stubs
                function CanvasGradient_(aType) {
                    this.type_ = aType;
                    this.x0_ = 0;
                    this.y0_ = 0;
                    this.r0_ = 0;
                    this.x1_ = 0;
                    this.y1_ = 0;
                    this.r1_ = 0;
                    this.colors_ = [];
                }

                CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {
                    aColor = processStyle(aColor);
                    this.colors_.push({offset: aOffset,
                        color: aColor.color,
                        alpha: aColor.alpha});
                };

                function CanvasPattern_(image, repetition) {
                    assertImageIsValid(image);
                    switch (repetition) {
                        case &#x27;repeat&#x27;:
                        case null:
                        case &#x27;&#x27;:
                            this.repetition_ = &#x27;repeat&#x27;;
                            break
                        case &#x27;repeat-x&#x27;:
                        case &#x27;repeat-y&#x27;:
                        case &#x27;no-repeat&#x27;:
                            this.repetition_ = repetition;
                            break;
                        default:
                            throwException(&#x27;SYNTAX_ERR&#x27;);
                    }

                    this.src_ = image.src;
                    this.width_ = image.width;
                    this.height_ = image.height;
                }

                function throwException(s) {
                    throw new DOMException_(s);
                }

                function assertImageIsValid(img) {
                    if (!img || img.nodeType != 1 || img.tagName != &#x27;IMG&#x27;) {
                        throwException(&#x27;TYPE_MISMATCH_ERR&#x27;);
                    }
                    if (img.readyState != &#x27;complete&#x27;) {
                        throwException(&#x27;INVALID_STATE_ERR&#x27;);
                    }
                }

                function DOMException_(s) {
                    this.code = this[s];
                    this.message = s +&#x27;: DOM Exception &#x27; + this.code;
                }
                var p = DOMException_.prototype = new Error;
                p.INDEX_SIZE_ERR = 1;
                p.DOMSTRING_SIZE_ERR = 2;
                p.HIERARCHY_REQUEST_ERR = 3;
                p.WRONG_DOCUMENT_ERR = 4;
                p.INVALID_CHARACTER_ERR = 5;
                p.NO_DATA_ALLOWED_ERR = 6;
                p.NO_MODIFICATION_ALLOWED_ERR = 7;
                p.NOT_FOUND_ERR = 8;
                p.NOT_SUPPORTED_ERR = 9;
                p.INUSE_ATTRIBUTE_ERR = 10;
                p.INVALID_STATE_ERR = 11;
                p.SYNTAX_ERR = 12;
                p.INVALID_MODIFICATION_ERR = 13;
                p.NAMESPACE_ERR = 14;
                p.INVALID_ACCESS_ERR = 15;
                p.VALIDATION_ERR = 16;
                p.TYPE_MISMATCH_ERR = 17;

                // set up externs
                G_vmlCanvasManager = G_vmlCanvasManager_;
                CanvasRenderingContext2D = CanvasRenderingContext2D_;
                CanvasGradient = CanvasGradient_;
                CanvasPattern = CanvasPattern_;
                DOMException = DOMException_;
            })();

        } // if
        else { // make the canvas test simple by kener.linfeng@gmail.com
            G_vmlCanvasManager = false;
        }
        return G_vmlCanvasManager;
    }); // define;
    /**
     * zrender: 公共辅助函数
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * clone：深度克隆
     * merge：合并源对象的属性到目标对象
     * getContext：获取一个自由使用的canvas 2D context，使用原生方法，如isPointInPath，measureText等
     */
    define(
        &#x27;zrender/tool/util&#x27;,[&#x27;require&#x27;,&#x27;../lib/excanvas&#x27;],function(require) {
            // 用于处理merge时无法遍历Date等对象的问题
            var BUILTIN_OBJECT = {
                &#x27;[object Function]&#x27;: 1,
                &#x27;[object RegExp]&#x27;: 1,
                &#x27;[object Date]&#x27;: 1,
                &#x27;[object Error]&#x27;: 1,
                &#x27;[object CanvasGradient]&#x27;: 1
            };

            /**
             * 对一个object进行深度拷贝
             *
             * @param {Any} source 需要进行拷贝的对象
             * @return {Any} 拷贝后的新对象
             */
            function clone(source) {
                if (typeof source == &#x27;object&#x27; &amp;&amp; source !== null) {
                    var result = source;
                    if (source instanceof Array) {
                        result = [];
                        for (var i = 0, len = source.length; i &lt; len; i++) {
                            result[i] = clone(source[i]);
                        }
                    }
                    else if (!BUILTIN_OBJECT[Object.prototype.toString.call(source)]) {
                        result = {};
                        for (var key in source) {
                            if (source.hasOwnProperty(key)) {
                                result[key] = clone(source[key]);
                            }
                        }
                    }

                    return result;
                }

                return source;
            }

            function mergeItem(target, source, key, overwrite) {
                if (source.hasOwnProperty(key)) {
                    if (typeof target[key] == &#x27;object&#x27;
                        &amp;&amp; !BUILTIN_OBJECT[ Object.prototype.toString.call(target[key]) ]
                        ) {
                        // 如果需要递归覆盖，就递归调用merge
                        merge(
                            target[key],
                            source[key],
                            overwrite
                        );
                    }
                    else if (overwrite || !(key in target)) {
                        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
                        target[key] = source[key];
                    }
                }
            }

            /**
             * 合并源对象的属性到目标对象
             * modify from Tangram
             * @param {*} target 目标对象
             * @param {*} source 源对象
             * @param {boolean} overwrite 是否覆盖
             */
            function merge(target, source, overwrite) {
                for (var i in source) {
                    mergeItem(target, source, i, overwrite);
                }

                return target;
            }

            var _ctx;

            function getContext() {
                if (!_ctx) {
                    require(&#x27;../lib/excanvas&#x27;);
                    if (G_vmlCanvasManager) {
                        var _div = document.createElement(&#x27;div&#x27;);
                        _div.style.position = &#x27;absolute&#x27;;
                        _div.style.top = &#x27;-1000px&#x27;;
                        document.body.appendChild(_div);

                        _ctx = G_vmlCanvasManager.initElement(_div)
                            .getContext(&#x27;2d&#x27;);
                    }
                    else {
                        _ctx = document.createElement(&#x27;canvas&#x27;).getContext(&#x27;2d&#x27;);
                    }
                }
                return _ctx;
            }

            var _canvas;
            var _pixelCtx;
            var _width;
            var _height;
            var _offsetX = 0;
            var _offsetY = 0;

            /**
             * 获取像素拾取专用的上下文
             * @return {Object} 上下文
             */
            function getPixelContext() {
                if (!_pixelCtx) {
                    _canvas = document.createElement(&#x27;canvas&#x27;);
                    _width = _canvas.width;
                    _height = _canvas.height;
                    _pixelCtx = _canvas.getContext(&#x27;2d&#x27;);
                }
                return _pixelCtx;
            }

            /**
             * 如果坐标处在_canvas外部，改变_canvas的大小
             * @param {number} x : 横坐标
             * @param {number} y : 纵坐标
             * 注意 修改canvas的大小 需要重新设置translate
             */
            function adjustCanvasSize(x, y) {
                // 每次加的长度
                var _v = 100;
                var _flag;

                if (x + _offsetX &gt; _width) {
                    _width = x + _offsetX + _v;
                    _canvas.width = _width;
                    _flag = true;
                }

                if (y + _offsetY &gt; _height) {
                    _height = y + _offsetY + _v;
                    _canvas.height = _height;
                    _flag = true;
                }

                if (x &lt; -_offsetX) {
                    _offsetX = Math.ceil(-x / _v) * _v;
                    _width += _offsetX;
                    _canvas.width = _width;
                    _flag = true;
                }

                if (y &lt; -_offsetY) {
                    _offsetY = Math.ceil(-y / _v) * _v;
                    _height += _offsetY;
                    _canvas.height = _height;
                    _flag = true;
                }

                if (_flag) {
                    _pixelCtx.translate(_offsetX, _offsetY);
                }
            }

            /**
             * 获取像素canvas的偏移量
             * @return {Object} 偏移量
             */
            function getPixelOffset() {
                return {
                    x : _offsetX,
                    y : _offsetY
                };
            }

            /**
             * 查询数组中元素的index
             */
            function indexOf(array, value){
                if (array.indexOf) {
                    return array.indexOf(value);
                }
                for(var i = 0, len=array.length; i&lt;len; i++) {
                    if (array[i] === value) {
                        return i;
                    }
                }
                return -1;
            }

            /**
             * 构造类继承关系
             *
             * @param {Function} clazz 源类
             * @param {Function} baseClazz 基类
             */
            function inherits(clazz, baseClazz) {
                var clazzPrototype = clazz.prototype;
                function F() {}
                F.prototype = baseClazz.prototype;
                clazz.prototype = new F();

                for (var prop in clazzPrototype) {
                    clazz.prototype[prop] = clazzPrototype[prop];
                }
                clazz.constructor = clazz;
            }

            return {
                inherits: inherits,
                clone : clone,
                merge : merge,
                getContext : getContext,
                getPixelContext : getPixelContext,
                getPixelOffset : getPixelOffset,
                adjustCanvasSize : adjustCanvasSize,
                indexOf : indexOf
            };
        }
    );

    /**
     * echarts设备环境识别
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author firede[firede@firede.us]
     * @desc thanks zepto.
     */
    define(&#x27;zrender/tool/env&#x27;,[],function() {
        // Zepto.js
        // (c) 2010-2013 Thomas Fuchs
        // Zepto.js may be freely distributed under the MIT license.

        function detect( ua ) {
            var os = this.os = {};
            var browser = this.browser = {};
            var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
            var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            var iphone = !ipad &amp;&amp; ua.match(/(iPhone\sOS)\s([\d_]+)/);
            var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
            var touchpad = webos &amp;&amp; ua.match(/TouchPad/);
            var kindle = ua.match(/Kindle\/([\d.]+)/);
            var silk = ua.match(/Silk\/([\d._]+)/);
            var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
            var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
            var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
            var playbook = ua.match(/PlayBook/);
            var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
            var firefox = ua.match(/Firefox\/([\d.]+)/);
            var ie = ua.match(/MSIE ([\d.]+)/);
            var safari = webkit &amp;&amp; ua.match(/Mobile\//) &amp;&amp; !chrome;
            var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) &amp;&amp; !chrome;
            var ie = ua.match(/MSIE\s([\d.]+)/);

            // Todo: clean this up with a better OS/browser seperation:
            // - discern (more) between multiple browsers on android
            // - decide if kindle fire in silk mode is android or not
            // - Firefox on Android doesn&#x27;t specify the Android version
            // - possibly devide in os, device and browser hashes

            if (browser.webkit = !!webkit) browser.version = webkit[1];

            if (android) os.android = true, os.version = android[2];
            if (iphone &amp;&amp; !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, &#x27;.&#x27;);
            if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, &#x27;.&#x27;);
            if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, &#x27;.&#x27;) : null;
            if (webos) os.webos = true, os.version = webos[2];
            if (touchpad) os.touchpad = true;
            if (blackberry) os.blackberry = true, os.version = blackberry[2];
            if (bb10) os.bb10 = true, os.version = bb10[2];
            if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
            if (playbook) browser.playbook = true;
            if (kindle) os.kindle = true, os.version = kindle[1];
            if (silk) browser.silk = true, browser.version = silk[1];
            if (!silk &amp;&amp; os.android &amp;&amp; ua.match(/Kindle Fire/)) browser.silk = true;
            if (chrome) browser.chrome = true, browser.version = chrome[1];
            if (firefox) browser.firefox = true, browser.version = firefox[1];
            if (ie) browser.ie = true, browser.version = ie[1];
            if (safari &amp;&amp; (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
            if (webview) browser.webview = true;
            if (ie) browser.ie = true, browser.version = ie[1];

            os.tablet = !!(ipad || playbook || (android &amp;&amp; !ua.match(/Mobile/)) ||
                (firefox &amp;&amp; ua.match(/Tablet/)) || (ie &amp;&amp; !ua.match(/Phone/) &amp;&amp; ua.match(/Touch/)));
            os.phone  = !!(!os.tablet &amp;&amp; !os.ipod &amp;&amp; (android || iphone || webos || blackberry || bb10 ||
                (chrome &amp;&amp; ua.match(/Android/)) || (chrome &amp;&amp; ua.match(/CriOS\/([\d.]+)/)) ||
                (firefox &amp;&amp; ua.match(/Mobile/)) || (ie &amp;&amp; ua.match(/Touch/))));

            return {
                browser: browser,
                os: os,
                // 原生canvas支持
                canvasSupported : document.createElement(&#x27;canvas&#x27;).getContext
                    ? true : false
            }
        }

        return detect( navigator.userAgent );
    });
    /**
     * zrender: config默认配置项
     *
     * @desc zrender是一个轻量级的Canvas类库，MVC封装，数据驱动，提供类Dom事件模型。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(
        &#x27;zrender/config&#x27;,{
            EVENT : {                       // 支持事件列表
                RESIZE : &#x27;resize&#x27;,          // 窗口大小变化
                CLICK : &#x27;click&#x27;,            // 鼠标按钮被（手指）按下，事件对象是：目标图形元素或空

                MOUSEWHEEL : &#x27;mousewheel&#x27;,  // 鼠标滚轮变化，事件对象是：目标图形元素或空
                MOUSEMOVE : &#x27;mousemove&#x27;,    // 鼠标（手指）被移动，事件对象是：目标图形元素或空
                MOUSEOVER : &#x27;mouseover&#x27;,    // 鼠标移到某图形元素之上，事件对象是：目标图形元素
                MOUSEOUT : &#x27;mouseout&#x27;,      // 鼠标从某图形元素移开，事件对象是：目标图形元素
                MOUSEDOWN : &#x27;mousedown&#x27;,    // 鼠标按钮（手指）被按下，事件对象是：目标图形元素或空
                MOUSEUP : &#x27;mouseup&#x27;,        // 鼠标按键（手指）被松开，事件对象是：目标图形元素或空

                //
                GLOBALOUT : &#x27;globalout&#x27;,    // 全局离开，MOUSEOUT触发比较频繁，一次离开优化绑定

                // 一次成功元素拖拽的行为事件过程是：
                // dragstart &gt; dragenter &gt; dragover [&gt; dragleave] &gt; drop &gt; dragend
                DRAGSTART : &#x27;dragstart&#x27;,    // 开始拖拽时触发，事件对象是：被拖拽图形元素
                DRAGEND : &#x27;dragend&#x27;,        // 拖拽完毕时触发（在drop之后触发），事件对象是：被拖拽图形元素
                DRAGENTER : &#x27;dragenter&#x27;,    // 拖拽图形元素进入目标图形元素时触发，事件对象是：目标图形元素
                DRAGOVER : &#x27;dragover&#x27;,      // 拖拽图形元素在目标图形元素上移动时触发，事件对象是：目标图形元素
                DRAGLEAVE : &#x27;dragleave&#x27;,    // 拖拽图形元素离开目标图形元素时触发，事件对象是：目标图形元素
                DROP : &#x27;drop&#x27;,              // 拖拽图形元素放在目标图形元素内时触发，事件对象是：目标图形元素

                touchClickDelay : 300       // touch end - start &lt; delay is click
            },

            // 是否异常捕获
            catchBrushException: false,

            /**
             * debug日志选项：catchBrushException为true下有效
             * 0 : 不生成debug数据，发布用
             * 1 : 异常抛出，调试用
             * 2 : 控制台输出，调试用
             */
            debugMode: 0
        }
    );
    /**
     * zrender: 日志记录
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     */

    define(
        &#x27;zrender/tool/log&#x27;,[&#x27;require&#x27;,&#x27;../config&#x27;],function (require) {
            var config = require(&#x27;../config&#x27;);

            return function() {
                if (config.debugMode === 0) {
                    return;
                }
                else if (config.debugMode == 1) {
                    for (var k in arguments) {
                        throw new Error(arguments[k]);
                    }
                }
                else if (config.debugMode &gt; 1) {
                    for (var k in arguments) {
                        console.log(arguments[k]);
                    }
                }
            };

            /* for debug
             return function(mes) {
             document.getElementById(&#x27;wrong-message&#x27;).innerHTML =
             mes + &#x27; &#x27; + (new Date() - 0)
             + &#x27;&lt;br/&gt;&#x27; 
             + document.getElementById(&#x27;wrong-message&#x27;).innerHTML;
             };
             */
        }
    );

    /**
     * zrender: 生成唯一id
     *
     * @author errorrik (errorrik@gmail.com)
     */

    define(
        &#x27;zrender/tool/guid&#x27;,[],function() {
            var idStart = 0x0907;

            return function () {
                return &#x27;zrender__&#x27; + (idStart++);
            };
        }
    );

    /**
     * zrender: 事件辅助类
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * getX：获取事件横坐标
     * getY：或者事件纵坐标
     * getDelta：或者鼠标滚轮变化
     * stop：停止事件传播
     * Dispatcher：事件分发器
     */
    define(
        &#x27;zrender/tool/event&#x27;,[],function() {
            /**
             * 提取鼠标（手指）x坐标
             *
             * @param  {Event} e 事件.
             * @return {number} 鼠标（手指）x坐标.
             */
            function getX(e) {
                return typeof e.zrenderX != &#x27;undefined&#x27; &amp;&amp; e.zrenderX
                    || typeof e.offsetX != &#x27;undefined&#x27; &amp;&amp; e.offsetX
                    || typeof e.layerX != &#x27;undefined&#x27; &amp;&amp; e.layerX
                    || typeof e.clientX != &#x27;undefined&#x27; &amp;&amp; e.clientX;
            }

            /**
             * 提取鼠标y坐标
             *
             * @param  {Event} e 事件.
             * @return {number} 鼠标（手指）y坐标.
             */
            function getY(e) {
                return typeof e.zrenderY != &#x27;undefined&#x27; &amp;&amp; e.zrenderY
                    || typeof e.offsetY != &#x27;undefined&#x27; &amp;&amp; e.offsetY
                    || typeof e.layerY != &#x27;undefined&#x27; &amp;&amp; e.layerY
                    || typeof e.clientY != &#x27;undefined&#x27; &amp;&amp; e.clientY;
            }

            /**
             * 提取鼠标滚轮变化
             *
             * @param  {Event} e 事件.
             * @return {number} 滚轮变化，正值说明滚轮是向上滚动，如果是负值说明滚轮是向下滚动
             */
            function getDelta(e) {
                return typeof e.wheelDelta != &#x27;undefined&#x27; &amp;&amp; e.wheelDelta
                    || typeof e.detail != &#x27;undefined&#x27; &amp;&amp; -e.detail;
            }

            /**
             * 停止冒泡和阻止默认行为
             *
             * @type {Function}
             * @param {Event} e : event对象
             */
            var stop = window.Event &amp;&amp; Event.prototype.preventDefault
                ? function (e) {
                e.preventDefault();
                e.stopPropagation();
            }
                : function (e) {
                e.returnValue = false;
                e.cancelBubble = true;
            };

            /**
             * 事件分发器
             */
            function Dispatcher() {
                var _self = this;
                var _h = {};

                /**
                 * 单次触发绑定，dispatch后销毁
                 *
                 * @param {string} event 事件字符串
                 * @param {Function} handler 响应函数
                 */
                function one(event, handler) {
                    if(!handler || !event) {
                        return _self;
                    }

                    if(!_h[event]) {
                        _h[event] = [];
                    }

                    _h[event].push({
                        h : handler,
                        one : true
                    });

                    return _self;
                }

                /**
                 * 事件绑定
                 *
                 * @param {string} event 事件字符串
                 * @param {Function} handler : 响应函数
                 */
                function bind(event, handler) {
                    if(!handler || !event) {
                        return _self;
                    }

                    if(!_h[event]) {
                        _h[event] = [];
                    }

                    _h[event].push({
                        h : handler,
                        one : false
                    });

                    return _self;
                }

                /**
                 * 事件解绑定
                 *
                 * @param {string} event 事件字符串
                 * @param {Function} handler : 响应函数
                 */
                function unbind(event, handler) {
                    if(!event) {
                        _h = {};
                        return _self;
                    }

                    if(handler) {
                        if(_h[event]) {
                            var newList = [];
                            for (var i = 0, l = _h[event].length; i &lt; l; i++) {
                                if (_h[event][i][&#x27;h&#x27;] != handler) {
                                    newList.push(_h[event][i]);
                                }
                            }
                            _h[event] = newList;
                        }

                        if(_h[event] &amp;&amp; _h[event].length === 0) {
                            delete _h[event];
                        }
                    }
                    else {
                        delete _h[event];
                    }

                    return _self;
                }

                /**
                 * 事件分发
                 *
                 * @param {string} type : 事件类型
                 * @param {Object} event : event对象
                 * @param {Object} [attachment] : 附加信息
                 */
                function dispatch(type, event, attachment, that) {
                    if(_h[type]) {
                        var newList = [];
                        var eventPacket = attachment || {};
                        eventPacket.type = type;
                        eventPacket.event = event;
                        //eventPacket._target = self;
                        var thisObject;
                        for (var i = 0, l = _h[type].length; i &lt; l; i++) {
                            thisObject = that || _h[type][i][&#x27;h&#x27;];
                            _h[type][i][&#x27;h&#x27;].call(thisObject, eventPacket);
                            if (!_h[type][i][&#x27;one&#x27;]) {
                                newList.push(_h[type][i]);
                            }
                        }

                        if (newList.length != _h[type].length) {
                            _h[type] = newList;
                        }
                    }

                    return _self;
                }

                _self.one = one;
                _self.bind = bind;
                _self.unbind = unbind;
                _self.dispatch = dispatch;
            }

            return {
                getX : getX,
                getY : getY,
                getDelta : getDelta,
                stop : stop,
                Dispatcher : Dispatcher
            };
        }
    );
    /**
     * Handler控制模块
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *         errorrik (errorrik@gmail.com)
     */

    define(
        &#x27;zrender/Handler&#x27;,[&#x27;require&#x27;,&#x27;./config&#x27;,&#x27;./tool/env&#x27;,&#x27;./tool/event&#x27;],function (require) {
            var config = require(&#x27;./config&#x27;);
            var env = require(&#x27;./tool/env&#x27;);
            var eventTool = require(&#x27;./tool/event&#x27;);
            var EVENT = config.EVENT;

            var domHandlerNames = [
                &#x27;resize&#x27;, &#x27;click&#x27;,
                &#x27;mousewheel&#x27;, &#x27;mousemove&#x27;, &#x27;mouseout&#x27;, &#x27;mouseup&#x27;, &#x27;mousedown&#x27;,
                &#x27;touchstart&#x27;, &#x27;touchend&#x27;, &#x27;touchmove&#x27;
            ];

            var domHandlers = {
                /**
                 * 窗口大小改变响应函数
                 *
                 * @param {event} event dom事件对象
                 */
                resize: function (event) {
                    event = event || window.event;
                    this._lastHover = null;
                    this._isMouseDown = 0;

                    // 分发config.EVENT.RESIZE事件，global
                    this.dispatch(EVENT.RESIZE, event);
                },

                /**
                 * 点击响应函数
                 *
                 * @param {event} event dom事件对象
                 */
                click: function (event) {
                    event = this._zrenderEventFixed(event);

                    //分发config.EVENT.CLICK事件
                    var _lastHover = this._lastHover;
                    if (( _lastHover &amp;&amp; _lastHover.clickable )
                        || !_lastHover
                        ) {
                        this._dispatchAgency(_lastHover, EVENT.CLICK, event);
                    }

                    this._mousemoveHandler(event);
                },

                /**
                 * 鼠标滚轮响应函数
                 *
                 * @param {event} event dom事件对象
                 */
                mousewheel: function (event) {
                    event = this._zrenderEventFixed(event);

                    //分发config.EVENT.MOUSEWHEEL事件
                    this._dispatchAgency(this._lastHover, EVENT.MOUSEWHEEL, event);
                    this._mousemoveHandler(event);
                },

                /**
                 * 鼠标（手指）移动响应函数
                 *
                 * @param {event} event dom事件对象
                 */
                mousemove: function (event) {
                    if (this.painter.isLoading()) {
                        return;
                    }

                    event = this._zrenderEventFixed(event);
                    this._lastX = this._mouseX;
                    this._lastY = this._mouseY;
                    this._mouseX = eventTool.getX(event);
                    this._mouseY = eventTool.getY(event);

                    // 可能出现config.EVENT.DRAGSTART事件
                    // 避免手抖点击误认为拖拽
                    //if (this._mouseX - this._lastX &gt; 1 || this._mouseY - this._lastY &gt; 1) {
                    this._processDragStart(event);
                    //}
                    this._hasfound = 0;
                    this._event = event;
                    this.storage.iterShape(this._findHover, { normal: &#x27;down&#x27;});

                    // 找到的在迭代函数里做了处理，没找到得在迭代完后处理
                    if (!this._hasfound) {
                        // 过滤首次拖拽产生的mouseout和dragLeave
                        if (!this._draggingTarget
                            || (this._lastHover &amp;&amp; this._lastHover != this._draggingTarget)
                            ) {
                            // 可能出现config.EVENT.MOUSEOUT事件
                            this._processOutShape(event);

                            // 可能出现config.EVENT.DRAGLEAVE事件
                            this._processDragLeave(event);
                        }

                        this._lastHover = null;
                        this.storage.delHover();
                        this.painter.clearHover();
                    }
                    //如果存在拖拽中元素，被拖拽的图形元素最后addHover
                    if (this._draggingTarget) {
                        this.storage.drift(
                            this._draggingTarget.id,
                                this._mouseX - this._lastX,
                                this._mouseY - this._lastY
                        );
                        this.storage.addHover(this._draggingTarget);
                    }

                    // set cursor for root element
                    var cursor = &#x27;default&#x27;;
                    if (this._draggingTarget || (this._hasfound &amp;&amp; this._lastHover.draggable)) {
                        cursor = &#x27;move&#x27;;
                    }
                    else if (this._hasfound &amp;&amp; this._lastHover.clickable) {
                        cursor = &#x27;pointer&#x27;;
                    }
                    this.root.style.cursor = cursor;

                    // 分发config.EVENT.MOUSEMOVE事件
                    this._dispatchAgency(this._lastHover, EVENT.MOUSEMOVE, event);

                    if (this._draggingTarget || this._hasfound || this.storage.hasHoverShape()) {
                        this.painter.refreshHover();
                    }
                },

                /**
                 * 鼠标（手指）离开响应函数
                 *
                 * @param {event} event dom事件对象
                 */
                mouseout: function (event) {
                    event = this._zrenderEventFixed(event);

                    var element = event.toElement || event.relatedTarget;
                    if (element != this.root) {
                        while (element &amp;&amp; element.nodeType != 9) {
                            // 忽略包含在root中的dom引起的mouseOut
                            if (element == this.root) {
                                this._mousemoveHandler(event);
                                return;
                            }

                            element = element.parentNode;
                        }
                    }

                    event.zrenderX = this._lastX;
                    event.zrenderY = this._lastY;
                    this.root.style.cursor = &#x27;default&#x27;;
                    this._isMouseDown = 0;

                    this._processOutShape(event);
                    this._processDrop(event);
                    this._processDragEnd(event);
                    if (!this.painter.isLoading()) {
                        this.painter.refreshHover();
                    }

                    this.dispatch(EVENT.GLOBALOUT, event);
                },

                /**
                 * 鼠标（手指）按下响应函数
                 *
                 * @param {event} event dom事件对象
                 */
                mousedown: function (event) {
                    if (this._lastDownButton == 2) {
                        this._lastDownButton = event.button;
                        this._mouseDownTarget = null;
                        // 仅作为关闭右键菜单使用
                        return;
                    }

                    this._lastMouseDownMoment = new Date();
                    event = this._zrenderEventFixed(event);
                    this._isMouseDown = 1;

                    //分发config.EVENT.MOUSEDOWN事件
                    this._mouseDownTarget = this._lastHover;
                    this._dispatchAgency(this._lastHover, EVENT.MOUSEDOWN, event);
                    this._lastDownButton = event.button;
                },

                /**
                 * 鼠标（手指）抬起响应函数
                 *
                 * @param {event} event dom事件对象
                 */
                mouseup:function (event) {
                    event = this._zrenderEventFixed(event);
                    this.root.style.cursor = &#x27;default&#x27;;
                    this._isMouseDown = 0;
                    this._mouseDownTarget = null;

                    //分发config.EVENT.MOUSEUP事件
                    this._dispatchAgency(this._lastHover, EVENT.MOUSEUP, event);
                    this._processDrop(event);
                    this._processDragEnd(event);
                },

                /**
                 * Touch开始响应函数
                 *
                 * @param {event} event dom事件对象
                 */
                touchstart: function (event) {
                    //eventTool.stop(event);// 阻止浏览器默认事件，重要
                    event = this._zrenderEventFixed(event, true);
                    this._lastTouchMoment = new Date();

                    //平板补充一次findHover
                    this._mobildFindFixed(event);
                    this._mousedownHandler(event);
                },

                /**
                 * Touch移动响应函数
                 *
                 * @param {event} event dom事件对象
                 */
                touchmove: function (event) {
                    event = this._zrenderEventFixed(event, true);
                    this._mousemoveHandler(event);
                    if (this._isDragging) {
                        eventTool.stop(event);// 阻止浏览器默认事件，重要
                    }
                },

                /**
                 * Touch结束响应函数
                 *
                 * @param {event} event dom事件对象
                 */
                touchend: function (event) {
                    //eventTool.stop(event);// 阻止浏览器默认事件，重要
                    event = this._zrenderEventFixed(event, true);
                    this._mouseupHandler(event);

                    if (new Date() - this._lastTouchMoment &lt; EVENT.touchClickDelay) {
                        this._mobildFindFixed(event);
                        this._clickHandler(event);
                    }
                    this.painter.clearHover();
                }
            };

            /**
             * bind一个参数的function
             *
             * @inner
             * @param {Function} handler 要bind的function
             * @param {Object} context 运行时this环境
             * @return {Function}
             */
            function bind1Arg( handler, context ) {
                return function ( e ) {
                    return handler.call( context, e );
                };
            }

            /**
             * 为控制类实例初始化dom 事件处理函数
             *
             * @inner
             * @param {Handler} instance 控制类实例
             */
            function initDomHandler( instance ) {
                var len = domHandlerNames.length;
                while ( len-- ) {
                    var name = domHandlerNames[ len ];
                    instance[ &#x27;_&#x27; + name + &#x27;Handler&#x27; ] = bind1Arg( domHandlers[ name ], instance );
                }
            }

            /**
             * 控制类 (C)
             *
             * @param {HTMLElement} root 绘图区域
             * @param {storage} storage Storage实例
             * @param {painter} painter Painter实例
             *
             * 分发事件支持详见config.EVENT
             */
            function Handler(root, storage, painter) {
                // 添加事件分发器特性
                eventTool.Dispatcher.call(this);

                this.root = root;
                this.storage = storage;
                this.painter = painter;

                // 各种事件标识的私有变量
                // this._hasfound = false;              //是否找到hover图形元素
                // this._lastHover = null;              //最后一个hover图形元素
                // this._mouseDownTarget = null;
                // this._draggingTarget = null;         //当前被拖拽的图形元素
                // this._isMouseDown = false;
                // this._isDragging = false;
                // this._lastMouseDownMoment;
                // this._lastTouchMoment;
                // this._lastDownButton;

                this._lastX =
                    this._lastY =
                        this._mouseX =
                            this._mouseY = 0;

                this._findHover = bind1Arg(findHover, this);
                this._domHover = painter.getDomHover();
                initDomHandler(this);

                // 初始化，事件绑定，支持的所有事件都由如下原生事件计算得来
                if (window.addEventListener) {
                    window.addEventListener(&#x27;resize&#x27;, this._resizeHandler);

                    if (env.os.tablet || env.os.phone) {
                        // mobile支持
                        root.addEventListener(&#x27;touchstart&#x27;, this._touchstartHandler);
                        root.addEventListener(&#x27;touchmove&#x27;, this._touchmoveHandler);
                        root.addEventListener(&#x27;touchend&#x27;, this._touchendHandler);
                    }
                    else {
                        // mobile的click/move/up/down自己模拟
                        root.addEventListener(&#x27;click&#x27;, this._clickHandler);
                        root.addEventListener(&#x27;mousewheel&#x27;, this._mousewheelHandler);
                        root.addEventListener(&#x27;mousemove&#x27;, this._mousemoveHandler);
                        root.addEventListener(&#x27;mousedown&#x27;, this._mousedownHandler);
                        root.addEventListener(&#x27;mouseup&#x27;, this._mouseupHandler);
                    }
                    root.addEventListener(&#x27;DOMMouseScroll&#x27;, this._mousewheelHandler);
                    root.addEventListener(&#x27;mouseout&#x27;, this._mouseoutHandler);
                }
                else {
                    window.attachEvent(&#x27;onresize&#x27;, this._resizeHandler);

                    root.attachEvent(&#x27;onclick&#x27;, this._clickHandler);
                    root.attachEvent(&#x27;onmousewheel&#x27;, this._mousewheelHandler);
                    root.attachEvent(&#x27;onmousemove&#x27;, this._mousemoveHandler);
                    root.attachEvent(&#x27;onmouseout&#x27;, this._mouseoutHandler);
                    root.attachEvent(&#x27;onmousedown&#x27;, this._mousedownHandler);
                    root.attachEvent(&#x27;onmouseup&#x27;, this._mouseupHandler);
                }
            }

            /**
             * 自定义事件绑定
             * @param {string} eventName 事件名称，resize，hover，drag，etc~
             * @param {Function} handler 响应函数
             */
            Handler.prototype.on = function (eventName, handler) {
                this.bind(eventName, handler);
                return this;
            };

            /**
             * 自定义事件解绑
             * @param {string} eventName 事件名称，resize，hover，drag，etc~
             * @param {Function} handler 响应函数
             */
            Handler.prototype.un = function (eventName, handler) {
                this.unbind(eventName, handler);
                return this;
            };

            /**
             * 事件触发
             * @param {string} eventName 事件名称，resize，hover，drag，etc~
             * @param {event=} eventArgs event dom事件对象
             */
            Handler.prototype.trigger = function (eventName, eventArgs) {
                switch (eventName) {
                    case EVENT.RESIZE:
                    case EVENT.CLICK:
                    case EVENT.MOUSEWHEEL:
                    case EVENT.MOUSEMOVE:
                    case EVENT.MOUSEDOWN:
                    case EVENT.MOUSEUP:
                    case EVENT.MOUSEOUT:
                        this[&#x27;_&#x27; + eventName + &#x27;Handler&#x27;](eventArgs);
                        break;
                }
            };

            /**
             * 释放
             */
            Handler.prototype.dispose = function () {
                var root = this.root;

                if (window.removeEventListener) {
                    window.removeEventListener(&#x27;resize&#x27;, this._resizeHandler);

                    if (env.os.tablet || env.os.phone) {
                        // mobile支持
                        root.removeEventListener(&#x27;touchstart&#x27;, this._touchstartHandler);
                        root.removeEventListener(&#x27;touchmove&#x27;, this._touchmoveHandler);
                        root.removeEventListener(&#x27;touchend&#x27;, this._touchendHandler);
                    }
                    else {
                        // mobile的click自己模拟
                        root.removeEventListener(&#x27;click&#x27;, this._clickHandler);
                        root.removeEventListener(&#x27;mousewheel&#x27;, this._mousewheelHandler);
                        root.removeEventListener(&#x27;mousemove&#x27;, this._mousemoveHandler);
                        root.removeEventListener(&#x27;mousedown&#x27;, this._mousedownHandler);
                        root.removeEventListener(&#x27;mouseup&#x27;, this._mouseupHandler);
                    }
                    root.removeEventListener(&#x27;DOMMouseScroll&#x27;, this._mousewheelHandler);
                    root.removeEventListener(&#x27;mouseout&#x27;, this._mouseoutHandler);
                }
                else {
                    window.detachEvent(&#x27;onresize&#x27;, this._resizeHandler);

                    root.detachEvent(&#x27;onclick&#x27;, this._clickHandler);
                    root.detachEvent(&#x27;onmousewheel&#x27;, this._mousewheelHandler);
                    root.detachEvent(&#x27;onmousemove&#x27;, this._mousemoveHandler);
                    root.detachEvent(&#x27;onmouseout&#x27;, this._mouseoutHandler);
                    root.detachEvent(&#x27;onmousedown&#x27;, this._mousedownHandler);
                    root.detachEvent(&#x27;onmouseup&#x27;, this._mouseupHandler);
                }

                this.root =
                    this._domHover =
                        this.storage =
                            this.painter = null;

                this.un();
            };

            /**
             * 拖拽开始
             *
             * @private
             * @param {Object} event 事件对象
             */
            Handler.prototype._processDragStart = function (event) {
                var _lastHover = this._lastHover;

                if (this._isMouseDown
                    &amp;&amp; _lastHover
                    &amp;&amp; _lastHover.draggable
                    &amp;&amp; !this._draggingTarget
                    &amp;&amp; this._mouseDownTarget == _lastHover
                    ) {
                    // 拖拽点击生效时长阀门，某些场景需要降低拖拽敏感度
                    if (_lastHover.dragEnableTime &amp;&amp;
                        new Date() - this._lastMouseDownMoment &lt; _lastHover.dragEnableTime
                        ) {
                        return;
                    }

                    var _draggingTarget = _lastHover;
                    this._draggingTarget = _draggingTarget;
                    this._isDragging = 1;

                    _draggingTarget.invisible = true;
                    this.storage.mod(_draggingTarget.id, _draggingTarget);

                    //分发config.EVENT.DRAGSTART事件
                    this._dispatchAgency(
                        _draggingTarget,
                        EVENT.DRAGSTART,
                        event
                    );
                    this.painter.refresh();
                }
            };

            /**
             * 拖拽进入目标元素
             *
             * @private
             * @param {Object} event 事件对象
             */
            Handler.prototype._processDragEnter = function (event) {
                if (this._draggingTarget) {
                    //分发config.EVENT.DRAGENTER事件
                    this._dispatchAgency(
                        this._lastHover,
                        EVENT.DRAGENTER,
                        event,
                        this._draggingTarget
                    );
                }
            };

            /**
             * 拖拽在目标元素上移动
             *
             * @private
             * @param {Object} event 事件对象
             */
            Handler.prototype._processDragOver = function (event) {
                if (this._draggingTarget) {
                    //分发config.EVENT.DRAGOVER事件
                    this._dispatchAgency(
                        this._lastHover,
                        EVENT.DRAGOVER,
                        event,
                        this._draggingTarget
                    );
                }
            };

            /**
             * 拖拽离开目标元素
             *
             * @private
             * @param {Object} event 事件对象
             */
            Handler.prototype._processDragLeave = function (event) {
                if (this._draggingTarget) {
                    //分发config.EVENT.DRAGLEAVE事件
                    this._dispatchAgency(
                        this._lastHover,
                        EVENT.DRAGLEAVE,
                        event,
                        this._draggingTarget
                    );
                }
            };

            /**
             * 拖拽在目标元素上完成
             *
             * @private
             * @param {Object} event 事件对象
             */
            Handler.prototype._processDrop = function (event) {
                if (this._draggingTarget) {
                    this._draggingTarget.invisible = false;
                    this.storage.mod(this._draggingTarget.id, this._draggingTarget);
                    this.painter.refresh();

                    //分发config.EVENT.DROP事件
                    this._dispatchAgency(
                        this._lastHover,
                        EVENT.DROP,
                        event,
                        this._draggingTarget
                    );
                }
            };

            /**
             * 拖拽结束
             *
             * @private
             * @param {Object} event 事件对象
             */
            Handler.prototype._processDragEnd = function (event) {
                if (this._draggingTarget) {
                    //分发config.EVENT.DRAGEND事件
                    this._dispatchAgency(
                        this._draggingTarget,
                        EVENT.DRAGEND,
                        event
                    );

                    this._lastHover = null;
                }

                this._isDragging = 0;
                this._draggingTarget = null;
            };

            /**
             * 鼠标在某个图形元素上移动
             *
             * @private
             * @param {Object} event 事件对象
             */
            Handler.prototype._processOverShape = function (event) {
                //分发config.EVENT.MOUSEOVER事件
                this._dispatchAgency(this._lastHover, EVENT.MOUSEOVER, event);
            };

            /**
             * 鼠标离开某个图形元素
             *
             * @private
             * @param {Object} event 事件对象
             */
            Handler.prototype._processOutShape = function (event) {
                //分发config.EVENT.MOUSEOUT事件
                this._dispatchAgency(this._lastHover, EVENT.MOUSEOUT, event);
            };

            /**
             * 事件分发代理
             *
             * @private
             * @param {Object} targetShape 目标图形元素
             * @param {string} eventName 事件名称
             * @param {Object} event 事件对象
             * @param {Object=} draggedShape 拖拽事件特有，当前被拖拽图形元素
             */
            Handler.prototype._dispatchAgency = function (targetShape, eventName, event, draggedShape) {
                var eventHandler = &#x27;on&#x27; + eventName;
                var eventPacket = {
                    type : eventName,
                    event : event,
                    target : targetShape
                };

                if (draggedShape) {
                    eventPacket.dragged = draggedShape;
                }

                if (targetShape) {
                    //“不存在shape级事件”或“存在shape级事件但事件回调返回非true”
                    if (!targetShape[eventHandler]
                        || !targetShape[eventHandler](eventPacket)
                        ) {
                        this.dispatch(
                            eventName,
                            event,
                            eventPacket
                        );
                    }
                }
                else if (!draggedShape) {
                    //无hover目标，无拖拽对象，原生事件分发
                    this.dispatch(eventName, event);
                }
            };

            // touch指尖错觉的尝试偏移量配置
            var MOBILE_TOUCH_OFFSETS = [
                { x: 10 },
                { x: -20 },
                { x: 10, y: 10},
                { y: -20}
            ];

            // touch有指尖错觉，四向尝试，让touch上的点击更好触发事件
            Handler.prototype._mobildFindFixed = function (event) {
                this._lastHover = null;
                this._mouseX = event.zrenderX;
                this._mouseY = event.zrenderY;

                this._event = event;
                this.storage.iterShape(this._findHover, { normal: &#x27;down&#x27;});
                for ( var i = 0; !this._lastHover &amp;&amp; i &lt; MOBILE_TOUCH_OFFSETS.length ; i++ ) {
                    var offset = MOBILE_TOUCH_OFFSETS[ i ];
                    offset.x &amp;&amp; ( this._mouseX += offset.x );
                    offset.y &amp;&amp; ( this._mouseX += offset.y );
                    this.storage.iterShape(this._findHover, { normal: &#x27;down&#x27;});
                }

                if (this._lastHover) {
                    event.zrenderX = this._mouseX;
                    event.zrenderY = this._mouseY;
                }
            };

            /**
             * 迭代函数，查找hover到的图形元素并即时做些事件分发
             *
             * @private
             * @param {Object} e 图形元素
             */
            function findHover(shape) {
                if (
                    ( this._draggingTarget &amp;&amp; this._draggingTarget.id == shape.id ) //迭代到当前拖拽的图形上
                    || shape.isSilent() // 打酱油的路过，啥都不响应的shape~
                    ) {
                    return false;
                }

                var event = this._event;
                if (shape.isCover(this._mouseX, this._mouseY)) {
                    if (shape.hoverable) {
                        this.storage.addHover(shape);
                    }

                    if (this._lastHover != shape) {
                        this._processOutShape(event);

                        //可能出现config.EVENT.DRAGLEAVE事件
                        this._processDragLeave(event);

                        this._lastHover = shape;

                        //可能出现config.EVENT.DRAGENTER事件
                        this._processDragEnter(event);
                    }

                    this._processOverShape(event);

                    //可能出现config.EVENT.DRAGOVER
                    this._processDragOver(event);

                    this._hasfound = 1;

                    return true;    //找到则中断迭代查找
                }

                return false;
            }

            /**
             * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标
             *
             * @private
             */
            Handler.prototype._zrenderEventFixed = function (event, isTouch) {
                if ( event.zrenderFixed ) {
                    return event;
                }

                if (!isTouch) {
                    event = event || window.event;
                    // 进入对象优先~
                    var target = event.toElement
                        || event.relatedTarget
                        || event.srcElement
                        || event.target;

                    if (target &amp;&amp; target != this._domHover) {
                        event.zrenderX = (typeof event.offsetX != &#x27;undefined&#x27;
                            ? event.offsetX
                            : event.layerX)
                            + target.offsetLeft;
                        event.zrenderY = (typeof event.offsetY != &#x27;undefined&#x27;
                            ? event.offsetY
                            : event.layerY)
                            + target.offsetTop;
                    }
                }
                else {
                    var touch = event.type != &#x27;touchend&#x27;
                        ? event.targetTouches[0]
                        : event.changedTouches[0];
                    if (touch) {
                        // touch事件坐标是全屏的~
                        event.zrenderX = touch.clientX - this.root.offsetLeft
                            + document.body.scrollLeft;
                        event.zrenderY = touch.clientY - this.root.offsetTop
                            + document.body.scrollTop;
                    }
                }

                event.zrenderFixed = 1;
                return event;
            };

            return Handler;
        }
    );

    /**
     * zrender: 3x2矩阵操作类
     *
     * author: lang(shenyi01@baidu.com)
     * code from mat2d in http://glmatrix.net/
     */

    define(
        &#x27;zrender/tool/matrix&#x27;,[],function() {

            var matrix = {
                create : function() {
                    return [1, 0,
                        0, 1,
                        0, 0];
                },
                identity : function(out) {
                    out[0] = 1;
                    out[1] = 0;
                    out[2] = 0;
                    out[3] = 1;
                    out[4] = 0;
                    out[5] = 0;
                },
                mul : function(out, m1, m2) {
                    out[0] = m1[0] * m2[0] + m1[2] * m2[1];
                    out[1] = m1[1] * m2[0] + m1[3] * m2[1];
                    out[2] = m1[0] * m2[2] + m1[2] * m2[3];
                    out[3] = m1[1] * m2[2] + m1[3] * m2[3];
                    out[4] = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
                    out[5] = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
                    return out;
                },

                translate : function(out, a, v) {
                    out[0] = a[0];
                    out[1] = a[1];
                    out[2] = a[2];
                    out[3] = a[3];
                    out[4] = a[4] + v[0];
                    out[5] = a[5] + v[1];
                    return out;
                },
                rotate : function(out, a, rad) {
                    var aa = a[0], ac = a[2], atx = a[4];
                    var ab = a[1], ad = a[3], aty = a[5];
                    var st = Math.sin(rad);
                    var ct = Math.cos(rad);

                    out[0] = aa*ct + ab*st;
                    out[1] = -aa*st + ab*ct;
                    out[2] = ac*ct + ad*st;
                    out[3] = -ac*st + ct*ad;
                    out[4] = ct*atx + st*aty;
                    out[5] = ct*aty - st*atx;
                    return out;
                },
                scale : function(out, a, v) {
                    var vx = v[0], vy = v[1];
                    out[0] = a[0] * vx;
                    out[1] = a[1] * vy;
                    out[2] = a[2] * vx;
                    out[3] = a[3] * vy;
                    out[4] = a[4] * vx;
                    out[5] = a[5] * vy;
                    return out;
                },
                /**
                 * 求逆矩阵
                 */
                invert : function(out, a) {

                    var aa = a[0], ac = a[2], atx = a[4];
                    var ab = a[1], ad = a[3], aty = a[5];

                    var det = aa * ad - ab * ac;
                    if(!det){
                        return null;
                    }
                    det = 1.0 / det;

                    out[0] = ad * det;
                    out[1] = -ab * det;
                    out[2] = -ac * det;
                    out[3] = aa * det;
                    out[4] = (ac * aty - ad * atx) * det;
                    out[5] = (ab * atx - aa * aty) * det;
                    return out;
                },

                /**
                 * 矩阵左乘向量
                 */
                mulVector : function(out, a, v) {
                    var aa = a[0], ac = a[2], atx = a[4];
                    var ab = a[1], ad = a[3], aty = a[5];

                    out[0] = v[0] * aa + v[1] * ac + atx;
                    out[1] = v[0] * ab + v[1] * ad + aty;

                    return out;
                }
            };

            return matrix;
        }
    );
    /**
     * zrender : 颜色辅助类
     *
     * author: CrossDo (chenhuaimu@baidu.com)
     *
     * getColor：获取色板颜色
     * customPalette : 自定义调色板
     * resetPalette : 重置调色板
     *
     * getHighlightColor : 获取默认高亮颜色
     * customHighlight : 自定义默认高亮颜色
     * resetHighlight : 重置默认高亮颜色
     *
     * getRadialGradient : 径向渐变
     * getLinearGradient : 线性渐变
     * getGradientColors : 获取颜色之间渐变颜色数组
     * getStepColors : 获取两种颜色之间渐变颜色数组
     * reverse : 颜色翻转
     * mix : 颜色混合
     * lift : 颜色升降
     * trim : 清除空格
     * random : 随机颜色
     * toRGB  : 转为RGB格式
     * toRGBA : 转为RGBA格式
     * toHex  : 转为#RRGGBB格式
     * toHSL  : 转为HSL格式
     * toHSLA : 转为HSLA格式
     * toHSB  : 转为HSB格式
     * toHSBA : 转为HSBA格式
     * toHSV  : 转为HSV格式
     * toHSVA : 转为HSVA格式
     * toName : 转为颜色名字
     * toColor: 颜色值数组转为指定格式颜色
     * toArray: 返回颜色值数组
     * alpha  : 设置颜色的透明度
     **/
    define( &#x27;zrender/tool/color&#x27;,[&#x27;require&#x27;,&#x27;../tool/util&#x27;],function(require) {
        var util = require(&#x27;../tool/util&#x27;);

        var _ctx;

        // Color palette is an array containing the default colors for the chart&#x27;s
        // series.
        // When all colors are used, new colors are selected from the start again.
        // Defaults to:
        // 默认色板
        var palette = [
            &#x27;#ff9277&#x27;, &#x27; #dddd00&#x27;, &#x27; #ffc877&#x27;, &#x27; #bbe3ff&#x27;, &#x27; #d5ffbb&#x27;,
            &#x27;#bbbbff&#x27;, &#x27; #ddb000&#x27;, &#x27; #b0dd00&#x27;, &#x27; #e2bbff&#x27;, &#x27; #ffbbe3&#x27;,
            &#x27;#ff7777&#x27;, &#x27; #ff9900&#x27;, &#x27; #83dd00&#x27;, &#x27; #77e3ff&#x27;, &#x27; #778fff&#x27;,
            &#x27;#c877ff&#x27;, &#x27; #ff77ab&#x27;, &#x27; #ff6600&#x27;, &#x27; #aa8800&#x27;, &#x27; #77c7ff&#x27;,
            &#x27;#ad77ff&#x27;, &#x27; #ff77ff&#x27;, &#x27; #dd0083&#x27;, &#x27; #777700&#x27;, &#x27; #00aa00&#x27;,
            &#x27;#0088aa&#x27;, &#x27; #8400dd&#x27;, &#x27; #aa0088&#x27;, &#x27; #dd0000&#x27;, &#x27; #772e00&#x27;
        ];
        var _palette = palette;

        var highlightColor = &#x27;rgba(255,255,0,0.5)&#x27;;
        var _highlightColor = highlightColor;

        // 颜色格式
        /*jshint maxlen: 330 */
        var colorRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;

        var _nameColors = {
            aliceblue : &#x27;#f0f8ff&#x27;,
            antiquewhite : &#x27;#faebd7&#x27;,
            aqua : &#x27;#0ff&#x27;,
            aquamarine : &#x27;#7fffd4&#x27;,
            azure : &#x27;#f0ffff&#x27;,
            beige : &#x27;#f5f5dc&#x27;,
            bisque : &#x27;#ffe4c4&#x27;,
            black : &#x27;#000&#x27;,
            blanchedalmond : &#x27;#ffebcd&#x27;,
            blue : &#x27;#00f&#x27;,
            blueviolet : &#x27;#8a2be2&#x27;,
            brown : &#x27;#a52a2a&#x27;,
            burlywood : &#x27;#deb887&#x27;,
            cadetblue : &#x27;#5f9ea0&#x27;,
            chartreuse : &#x27;#7fff00&#x27;,
            chocolate : &#x27;#d2691e&#x27;,
            coral : &#x27;#ff7f50&#x27;,
            cornflowerblue : &#x27;#6495ed&#x27;,
            cornsilk : &#x27;#fff8dc&#x27;,
            crimson : &#x27;#dc143c&#x27;,
            cyan : &#x27;#0ff&#x27;,
            darkblue : &#x27;#00008b&#x27;,
            darkcyan : &#x27;#008b8b&#x27;,
            darkgoldenrod : &#x27;#b8860b&#x27;,
            darkgray : &#x27;#a9a9a9&#x27;,
            darkgrey : &#x27;#a9a9a9&#x27;,
            darkgreen : &#x27;#006400&#x27;,
            darkkhaki : &#x27;#bdb76b&#x27;,
            darkmagenta : &#x27;#8b008b&#x27;,
            darkolivegreen : &#x27;#556b2f&#x27;,
            darkorange : &#x27;#ff8c00&#x27;,
            darkorchid : &#x27;#9932cc&#x27;,
            darkred : &#x27;#8b0000&#x27;,
            darksalmon : &#x27;#e9967a&#x27;,
            darkseagreen : &#x27;#8fbc8f&#x27;,
            darkslateblue : &#x27;#483d8b&#x27;,
            darkslategray : &#x27;#2f4f4f&#x27;,
            darkslategrey : &#x27;#2f4f4f&#x27;,
            darkturquoise : &#x27;#00ced1&#x27;,
            darkviolet : &#x27;#9400d3&#x27;,
            deeppink : &#x27;#ff1493&#x27;,
            deepskyblue : &#x27;#00bfff&#x27;,
            dimgray : &#x27;#696969&#x27;,
            dimgrey : &#x27;#696969&#x27;,
            dodgerblue : &#x27;#1e90ff&#x27;,
            firebrick : &#x27;#b22222&#x27;,
            floralwhite : &#x27;#fffaf0&#x27;,
            forestgreen : &#x27;#228b22&#x27;,
            fuchsia : &#x27;#f0f&#x27;,
            gainsboro : &#x27;#dcdcdc&#x27;,
            ghostwhite : &#x27;#f8f8ff&#x27;,
            gold : &#x27;#ffd700&#x27;,
            goldenrod : &#x27;#daa520&#x27;,
            gray : &#x27;#808080&#x27;,
            grey : &#x27;#808080&#x27;,
            green : &#x27;#008000&#x27;,
            greenyellow : &#x27;#adff2f&#x27;,
            honeydew : &#x27;#f0fff0&#x27;,
            hotpink : &#x27;#ff69b4&#x27;,
            indianred : &#x27;#cd5c5c&#x27;,
            indigo : &#x27;#4b0082&#x27;,
            ivory : &#x27;#fffff0&#x27;,
            khaki : &#x27;#f0e68c&#x27;,
            lavender : &#x27;#e6e6fa&#x27;,
            lavenderblush : &#x27;#fff0f5&#x27;,
            lawngreen : &#x27;#7cfc00&#x27;,
            lemonchiffon : &#x27;#fffacd&#x27;,
            lightblue : &#x27;#add8e6&#x27;,
            lightcoral : &#x27;#f08080&#x27;,
            lightcyan : &#x27;#e0ffff&#x27;,
            lightgoldenrodyellow : &#x27;#fafad2&#x27;,
            lightgray : &#x27;#d3d3d3&#x27;,
            lightgrey : &#x27;#d3d3d3&#x27;,
            lightgreen : &#x27;#90ee90&#x27;,
            lightpink : &#x27;#ffb6c1&#x27;,
            lightsalmon : &#x27;#ffa07a&#x27;,
            lightseagreen : &#x27;#20b2aa&#x27;,
            lightskyblue : &#x27;#87cefa&#x27;,
            lightslategray : &#x27;#789&#x27;,
            lightslategrey : &#x27;#789&#x27;,
            lightsteelblue : &#x27;#b0c4de&#x27;,
            lightyellow : &#x27;#ffffe0&#x27;,
            lime : &#x27;#0f0&#x27;,
            limegreen : &#x27;#32cd32&#x27;,
            linen : &#x27;#faf0e6&#x27;,
            magenta : &#x27;#f0f&#x27;,
            maroon : &#x27;#800000&#x27;,
            mediumaquamarine : &#x27;#66cdaa&#x27;,
            mediumblue : &#x27;#0000cd&#x27;,
            mediumorchid : &#x27;#ba55d3&#x27;,
            mediumpurple : &#x27;#9370d8&#x27;,
            mediumseagreen : &#x27;#3cb371&#x27;,
            mediumslateblue : &#x27;#7b68ee&#x27;,
            mediumspringgreen : &#x27;#00fa9a&#x27;,
            mediumturquoise : &#x27;#48d1cc&#x27;,
            mediumvioletred : &#x27;#c71585&#x27;,
            midnightblue : &#x27;#191970&#x27;,
            mintcream : &#x27;#f5fffa&#x27;,
            mistyrose : &#x27;#ffe4e1&#x27;,
            moccasin : &#x27;#ffe4b5&#x27;,
            navajowhite : &#x27;#ffdead&#x27;,
            navy : &#x27;#000080&#x27;,
            oldlace : &#x27;#fdf5e6&#x27;,
            olive : &#x27;#808000&#x27;,
            olivedrab : &#x27;#6b8e23&#x27;,
            orange : &#x27;#ffa500&#x27;,
            orangered : &#x27;#ff4500&#x27;,
            orchid : &#x27;#da70d6&#x27;,
            palegoldenrod : &#x27;#eee8aa&#x27;,
            palegreen : &#x27;#98fb98&#x27;,
            paleturquoise : &#x27;#afeeee&#x27;,
            palevioletred : &#x27;#d87093&#x27;,
            papayawhip : &#x27;#ffefd5&#x27;,
            peachpuff : &#x27;#ffdab9&#x27;,
            peru : &#x27;#cd853f&#x27;,
            pink : &#x27;#ffc0cb&#x27;,
            plum : &#x27;#dda0dd&#x27;,
            powderblue : &#x27;#b0e0e6&#x27;,
            purple : &#x27;#800080&#x27;,
            red : &#x27;#f00&#x27;,
            rosybrown : &#x27;#bc8f8f&#x27;,
            royalblue : &#x27;#4169e1&#x27;,
            saddlebrown : &#x27;#8b4513&#x27;,
            salmon : &#x27;#fa8072&#x27;,
            sandybrown : &#x27;#f4a460&#x27;,
            seagreen : &#x27;#2e8b57&#x27;,
            seashell : &#x27;#fff5ee&#x27;,
            sienna : &#x27;#a0522d&#x27;,
            silver : &#x27;#c0c0c0&#x27;,
            skyblue : &#x27;#87ceeb&#x27;,
            slateblue : &#x27;#6a5acd&#x27;,
            slategray : &#x27;#708090&#x27;,
            slategrey : &#x27;#708090&#x27;,
            snow : &#x27;#fffafa&#x27;,
            springgreen : &#x27;#00ff7f&#x27;,
            steelblue : &#x27;#4682b4&#x27;,
            tan : &#x27;#d2b48c&#x27;,
            teal : &#x27;#008080&#x27;,
            thistle : &#x27;#d8bfd8&#x27;,
            tomato : &#x27;#ff6347&#x27;,
            turquoise : &#x27;#40e0d0&#x27;,
            violet : &#x27;#ee82ee&#x27;,
            wheat : &#x27;#f5deb3&#x27;,
            white : &#x27;#fff&#x27;,
            whitesmoke : &#x27;#f5f5f5&#x27;,
            yellow : &#x27;#ff0&#x27;,
            yellowgreen : &#x27;#9acd32&#x27;
        };

        /**
         * 自定义调色板
         */
        function customPalette(userPalete) {
            palette = userPalete;
        }

        /**
         * 复位默认色板
         */
        function resetPalette() {
            palette = _palette;
        }

        /**
         * 获取色板颜色
         *
         * @param {number} idx : 色板位置
         * @param {array} [userPalete] : 自定义色板
         *
         * @return {color} 颜色#000000~#ffffff
         */
        function getColor(idx, userPalete) {
            idx = idx | 0;
            userPalete = userPalete || palette;
            return userPalete[idx % userPalete.length];
        }

        /**
         * 自定义默认高亮颜色
         */
        function customHighlight(userHighlightColor) {
            highlightColor = userHighlightColor;
        }

        /**
         * 重置默认高亮颜色
         */
        function resetHighlight() {
            _highlightColor = highlightColor;
        }

        /**
         * 获取默认高亮颜色
         */
        function getHighlightColor() {
            return highlightColor;
        }

        /**
         * 径向渐变
         *
         * @param {number} x0 渐变起点
         * @param {number} y0
         * @param {number} r0
         * @param {number} x1 渐变终点
         * @param {number} y1
         * @param {number} r1
         * @param {Array} colorList 颜色列表
         */
        function getRadialGradient(x0, y0, r0, x1, y1, r1, colorList) {
            if (!_ctx) {
                _ctx = util.getContext();
            }
            var gradient = _ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
            for ( var i = 0, l = colorList.length; i &lt; l; i++) {
                gradient.addColorStop(colorList[i][0], colorList[i][1]);
            }
            gradient.__nonRecursion = true;
            return gradient;
        }

        /**
         * 线性渐变
         * @param {Object} x0 渐变起点
         * @param {Object} y0
         * @param {Object} x1 渐变终点
         * @param {Object} y1
         * @param {Array} colorList 颜色列表
         */
        function getLinearGradient(x0, y0, x1, y1, colorList) {
            if (!_ctx) {
                _ctx = util.getContext();
            }
            var gradient = _ctx.createLinearGradient(x0, y0, x1, y1);
            for ( var i = 0, l = colorList.length; i &lt; l; i++) {
                gradient.addColorStop(colorList[i][0], colorList[i][1]);
            }
            gradient.__nonRecursion = true;
            return gradient;
        }

        /**
         * 获取两种颜色之间渐变颜色数组
         * @param {color} start 起始颜色
         * @param {color} end 结束颜色
         * @param {number} step 渐变级数
         * @return {Array}  颜色数组
         */
        function getStepColors(start, end, step) {
            start = toRGBA(start);
            end = toRGBA(end);
            start = getData(start);
            end = getData(end);

            var colors = [];
            var stepR = (end[0] - start[0]) / step;
            var stepG = (end[1] - start[1]) / step;
            var stepB = (end[2] - start[2]) / step;
            // 生成颜色集合
            // fix by linfeng 颜色堆积
            for (var i = 0, r = start[0], g = start[1], b = start[2]; i &lt; step; i++
                ) {
                colors[i] = toColor([
                    adjust(Math.floor(r), [0, 255]),
                    adjust(Math.floor(g), [0, 255]),
                    adjust(Math.floor(b), [0, 255])
                ]);
                r += stepR;
                g += stepG;
                b += stepB;
            }
            r = end[0];
            g = end[1];
            b = end[2];
            colors[i] = toColor([r, g, b]);
            return colors;
        }

        /**
         * 获取指定级数的渐变颜色数组
         * @param {Array} colors 颜色组
         * @param {number=20} step 渐变级数
         * @return {Array}  颜色数组
         */
        function getGradientColors(colors, step) {
            var ret = [];
            var len = colors.length;
            if (step === undefined) {
                step = 20;
            }
            if (len === 1) {
                ret = getStepColors(colors[0], colors[0], step);
            } else if (len &gt; 1) {
                for ( var i = 0, n = len - 1; i &lt; n; i++) {
                    var steps = getStepColors(colors[i], colors[i + 1], step);
                    if (i &lt; n - 1) {
                        steps.pop();
                    }
                    ret = ret.concat(steps);
                }
            }
            return ret;
        }

        /**
         * 颜色值数组转为指定格式颜色,例如:&lt;br/&gt;
         * data = [60,20,20,0.1] format = &#x27;rgba&#x27;
         * 返回：rgba(60,20,20,0.1)
         * @param {Array} data 颜色值数组
         * @param {string} format 格式,默认rgb
         * @return {string} 颜色
         */
        function toColor(data, format) {
            format = format || &#x27;rgb&#x27;;
            if (data &amp;&amp; (data.length === 3 || data.length === 4)) {
                data = map(data,
                    function(c) {
                        return c &gt; 1 ? Math.ceil(c) : c;
                    });

                if (format.indexOf(&#x27;hex&#x27;) &gt; -1) {
                    return &#x27;#&#x27; + ((1 &lt;&lt; 24) + (data[0] &lt;&lt; 16) + (data[1] &lt;&lt; 8) + (+data[2])).toString(16).slice(1);
                } else if (format.indexOf(&#x27;hs&#x27;) &gt; -1) {
                    var sx = map(data.slice(1, 3),
                        function(c) {
                            return c + &#x27;%&#x27;;
                        });
                    data[1] = sx[0];
                    data[2] = sx[1];
                }

                if (format.indexOf(&#x27;a&#x27;) &gt; -1) {
                    if (data.length === 3) {
                        data.push(1);
                    }
                    data[3] = adjust(data[3], [0, 1]);
                    return format + &#x27;(&#x27; + data.slice(0, 4).join(&#x27;,&#x27;) + &#x27;)&#x27;;
                }

                return format + &#x27;(&#x27; + data.slice(0, 3).join(&#x27;,&#x27;) + &#x27;)&#x27;;
            }
        }

        /**
         * 返回颜色值数组
         *
         * @param {color} color 颜色
         * @return {Array} 颜色值数组
         */
        function toArray(color) {
            color = trim(color);
            if (color.indexOf(&#x27;rgba&#x27;) &lt; 0) {
                color = toRGBA(color);
            }

            var data = [];
            var i = 0;
            color.replace(/[\d.]+/g, function (n) {
                if (i &lt; 3) {
                    n = n | 0;
                } else {
                    // Alpha
                    n = +n;
                }
                data[i++] = n;
            });
            return data;
        }

        /**
         * 颜色格式转化
         *
         * @param {Array} data 颜色值数组
         * @param {string} format 格式,默认rgb
         * @return {string} 颜色
         */
        function convert(color, format) {
            var data = getData(color);
            var alpha = data[3];
            if(typeof alpha === &#x27;undefined&#x27;) {
                alpha = 1;
            }

            if (color.indexOf(&#x27;hsb&#x27;) &gt; -1) {
                data = _HSV_2_RGB(data);
            } else if (color.indexOf(&#x27;hsl&#x27;) &gt; -1) {
                data = _HSL_2_RGB(data);
            }

            if (format.indexOf(&#x27;hsb&#x27;) &gt; -1 || format.indexOf(&#x27;hsv&#x27;) &gt; -1) {
                data = _RGB_2_HSB(data);
            } else if (format.indexOf(&#x27;hsl&#x27;) &gt; -1) {
                data = _RGB_2_HSL(data);
            }

            data[3] = alpha;

            return toColor(data, format);
        }

        /**
         * 转换为rgba格式的颜色
         *
         * @param {string} color 颜色
         * @return {string} rgba颜色，rgba(r,g,b,a)
         */
        function toRGBA(color) {
            return convert(color, &#x27;rgba&#x27;);
        }

        /**
         * 转换为rgb数字格式的颜色
         *
         * @param {string} color 颜色
         * @return {string} rgb颜色，rgb(0,0,0)格式
         */
        function toRGB(color) {
            return convert(color, &#x27;rgb&#x27;);
        }

        /**
         * 转换为16进制颜色
         *
         * @param {string} color 颜色
         * @return {string} 16进制颜色，#rrggbb格式
         */
        function toHex(color) {
            return convert(color, &#x27;hex&#x27;);
        }

        /**
         * 转换为HSV颜色
         *
         * @param {string} color 颜色
         * @return {string} HSVA颜色，hsva(h,s,v,a)
         */
        function toHSVA(color) {
            return convert(color, &#x27;hsva&#x27;);
        }

        /**
         * 转换为HSV颜色
         *
         * @param {string} color 颜色
         * @return {string} HSV颜色，hsv(h,s,v)
         */
        function toHSV(color) {
            return convert(color, &#x27;hsv&#x27;);
        }

        /**
         * 转换为HSBA颜色
         *
         * @param {string} color 颜色
         * @return {string} HSBA颜色，hsba(h,s,b,a)
         */
        function toHSBA(color) {
            return convert(color, &#x27;hsba&#x27;);
        }

        /**
         * 转换为HSB颜色
         *
         * @param {string} color 颜色
         * @return {string} HSB颜色，hsb(h,s,b)
         */
        function toHSB(color) {
            return convert(color, &#x27;hsb&#x27;);
        }

        /**
         * 转换为HSLA颜色
         *
         * @param {string} color 颜色
         * @return {string} HSLA颜色，hsla(h,s,l,a)
         */
        function toHSLA(color) {
            return convert(color, &#x27;hsla&#x27;);
        }

        /**
         * 转换为HSL颜色
         *
         * @param {string} color 颜色
         * @return {string} HSL颜色，hsl(h,s,l)
         */
        function toHSL(color) {
            return convert(color, &#x27;hsl&#x27;);
        }

        /**
         * 转换颜色名
         *
         * @param {string} color 颜色
         * @return {string} 颜色名
         */
        function toName(color) {
            for ( var key in _nameColors) {
                if (toHex(_nameColors[key]) === toHex(color)) {
                    return key;
                }
            }
            return null;
        }

        /**
         * 移除颜色中多余空格
         *
         * @param {string} color 颜色
         * @return {string} 无空格颜色
         */
        function trim(color) {
            return String(color).replace(/\s+/g, &#x27;&#x27;);
        }

        /**
         * 颜色规范化
         *
         * @param {string} color 颜色
         * @return {string} 规范化后的颜色
         */
        function normalize(color) {
            // 颜色名
            if (_nameColors[color]) {
                color = _nameColors[color];
            }
            // 去掉空格
            color = trim(color);
            // hsv与hsb等价
            color = color.replace(/hsv/i, &#x27;hsb&#x27;);
            // rgb转为rrggbb
            if (/^#[\da-f]{3}$/i.test(color)) {
                color = parseInt(color.slice(1), 16);
                var r = (color &amp; 0xf00) &lt;&lt; 8;
                var g = (color &amp; 0xf0) &lt;&lt; 4;
                var b = color &amp; 0xf;

                color = &#x27;#&#x27;+ ((1 &lt;&lt; 24) + (r &lt;&lt; 4) + r + (g &lt;&lt; 4) + g + (b &lt;&lt; 4) + b).toString(16).slice(1);
            }
            // 或者使用以下正则替换，不过 chrome 下性能相对差点
            // color = color.replace(/^#([\da-f])([\da-f])([\da-f])$/i, &#x27;#$1$1$2$2$3$3&#x27;);
            return color;
        }

        /**
         * 颜色加深或减淡，当level&gt;0加深，当level&lt;0减淡
         *
         * @param {string} color 颜色
         * @param {number} level 升降程度,取值区间[-1,1]
         * @return {string} 加深或减淡后颜色值
         */
        function lift(color, level) {
            var direct = level &gt; 0 ? 1 : -1;
            if (typeof level === &#x27;undefined&#x27;) {
                level = 0;
            }
            level = Math.abs(level) &gt; 1 ? 1 : Math.abs(level);
            color = toRGB(color);
            var data = getData(color);
            for ( var i = 0; i &lt; 3; i++) {
                if (direct === 1) {
                    data[i] = data[i] * (1 - level) | 0;
                } else {
                    data[i] = ((255 - data[i]) * level + data[i]) | 0;
                }
            }
            return &#x27;rgb(&#x27; + data.join(&#x27;,&#x27;) + &#x27;)&#x27;;
        }

        /**
         * 颜色翻转,[255-r,255-g,255-b,1-a]
         *
         * @param {string} color 颜色
         * @return {string} 翻转颜色
         */
        function reverse(color) {
            var data = getData(toRGBA(color));
            data = map(data,
                function(c) {
                    return 255 - c;
                });
            return toColor(data, &#x27;rgb&#x27;);
        }

        /**
         * 简单两种颜色混合
         *
         * @param {string} color1 第一种颜色
         * @param {string} color2 第二种颜色
         * @param {string} weight 混合权重[0-1]
         * @return {string} 结果色,rgb(r,g,b)或rgba(r,g,b,a)
         */
        function mix(color1, color2, weight) {
            if(typeof weight === &#x27;undefined&#x27;) {
                weight = 0.5;
            }
            weight = 1 - adjust(weight, [0, 1]);

            var w = weight * 2 - 1;
            var data1 = getData(toRGBA(color1));
            var data2 = getData(toRGBA(color2));

            var d = data1[3] - data2[3];

            var weight1 = (((w * d === -1) ? w : (w + d) / (1 + w * d)) + 1) / 2;
            var weight2 = 1 - weight1;

            var data = [];

            for ( var i = 0; i &lt; 3; i++) {
                data[i] = data1[i] * weight1 + data2[i] * weight2;
            }

            var alpha = data1[3] * weight + data2[3] * (1 - weight);
            alpha = Math.max(0, Math.min(1, alpha));

            if (data1[3] === 1 &amp;&amp; data2[3] === 1) {// 不考虑透明度
                return toColor(data, &#x27;rgb&#x27;);
            }
            data[3] = alpha;
            return toColor(data, &#x27;rgba&#x27;);
        }

        /**
         * 随机颜色
         *
         * @return {string} 颜色值，#rrggbb格式
         */
        function random() {
            return &#x27;#&#x27; + Math.random().toString(16).slice(2, 8);
        }

        /**
         * 获取颜色值数组,返回值范围： &lt;br/&gt;
         * RGB 范围[0-255] &lt;br/&gt;
         * HSL/HSV/HSB 范围[0-1]&lt;br/&gt;
         * A透明度范围[0-1]
         * 支持格式：
         * #rgb
         * #rrggbb
         * rgb(r,g,b)
         * rgb(r%,g%,b%)
         * rgba(r,g,b,a)
         * hsb(h,s,b) // hsv与hsb等价
         * hsb(h%,s%,b%)
         * hsba(h,s,b,a)
         * hsl(h,s,l)
         * hsl(h%,s%,l%)
         * hsla(h,s,l,a)
         *
         * @param {string} color 颜色
         * @return {Array} 颜色值数组或null
         */
        function getData(color) {
            color = normalize(color);
            var r = color.match(colorRegExp);
            if (r === null) {
                throw new Error(&#x27;The color format error&#x27;); // 颜色格式错误
            }
            var d;
            var a;
            var data = [];
            var rgb;

            if (r[2]) {
                // #rrggbb
                d = r[2].replace(&#x27;#&#x27;, &#x27;&#x27;).split(&#x27;&#x27;);
                rgb = [d[0] + d[1], d[2] + d[3], d[4] + d[5]];
                data = map(rgb,
                    function(c) {
                        return adjust(parseInt(c, 16), [0, 255]);
                    });

            }
            else if (r[4]) {
                // rgb rgba
                var rgba = (r[4]).split(&#x27;,&#x27;);
                a = rgba[3];
                rgb = rgba.slice(0, 3);
                data = map(
                    rgb,
                    function(c) {
                        c = Math.floor(
                                c.indexOf(&#x27;%&#x27;) &gt; 0 ? parseInt(c, 0) * 2.55 : c
                        );
                        return adjust(c, [0, 255]);
                    }
                );

                if(typeof a !== &#x27;undefined&#x27;) {
                    data.push(adjust(parseFloat(a), [0, 1]));
                }
            }
            else if (r[5] || r[6]) {
                // hsb hsba hsl hsla
                var hsxa = (r[5] || r[6]).split(&#x27;,&#x27;);
                var h = parseInt(hsxa[0], 0) / 360;
                var s = hsxa[1];
                var x = hsxa[2];
                a = hsxa[3];
                data = map([s, x],
                    function(c) {
                        return adjust(parseFloat(c) / 100, [0, 1]);
                    });
                data.unshift(h);
                if( typeof a !== &#x27;undefined&#x27;) {
                    data.push(adjust(parseFloat(a), [0, 1]));
                }
            }
            return data;
        }

        /**
         * 设置颜色透明度
         * @param {string} color 颜色
         * @param {number} alpha 透明度,区间[0,1]
         * @return {string} rgba颜色值
         */
        function alpha(color, a) {
            if (a === null) {
                a = 1;
            }
            var data = getData(toRGBA(color));
            data[3] = adjust(Number(a).toFixed(4), [0, 1]);

            return toColor(data, &#x27;rgba&#x27;);
        }

        // 数组映射
        function map(array, fun) {
            if (typeof fun !== &#x27;function&#x27;) {
                throw new TypeError();
            }
            var len = array ? array.length : 0;
            for ( var i = 0; i &lt; len; i++) {
                array[i] = fun(array[i]);
            }
            return array;
        }

        // 调整值区间
        function adjust(value, region) {
            // &lt; to &lt;= &amp; &gt; to &gt;=
            // modify by linzhifeng 2014-05-25 because -0 == 0
            if (value &lt;= region[0]) {
                value = region[0];
            }
            else if (value &gt;= region[1]) {
                value = region[1];
            }
            return value;
        }

        // 参见 http:// www.easyrgb.com/index.php?X=MATH
        function _HSV_2_RGB(data) {
            var H = data[0];
            var S = data[1];
            var V = data[2];
            // HSV from 0 to 1
            var R, G, B;
            if (S === 0) {
                R = V * 255;
                G = V * 255;
                B = V * 255;
            } else {
                var h = H * 6;
                if (h === 6) {
                    h = 0;
                }
                var i = h | 0;
                var v1 = V * (1 - S);
                var v2 = V * (1 - S * (h - i));
                var v3 = V * (1 - S * (1 - (h - i)));
                var r = 0;
                var g = 0;
                var b = 0;

                if (i === 0) {
                    r = V;
                    g = v3;
                    b = v1;
                } else if (i === 1) {
                    r = v2;
                    g = V;
                    b = v1;
                } else if (i === 2) {
                    r = v1;
                    g = V;
                    b = v3;
                } else if (i === 3) {
                    r = v1;
                    g = v2;
                    b = V;
                } else if (i === 4) {
                    r = v3;
                    g = v1;
                    b = V;
                } else {
                    r = V;
                    g = v1;
                    b = v2;
                }

                // RGB results from 0 to 255
                R = r * 255;
                G = g * 255;
                B = b * 255;
            }
            return [ R, G, B ];
        }

        function _HSL_2_RGB(data) {
            var H = data[0];
            var S = data[1];
            var L = data[2];
            // HSL from 0 to 1
            var R, G, B;
            if (S === 0) {
                R = L * 255;
                G = L * 255;
                B = L * 255;
            } else {
                var v2;
                if (L &lt; 0.5) {
                    v2 = L * (1 + S);
                } else {
                    v2 = (L + S) - (S * L);
                }

                var v1 = 2 * L - v2;

                R = 255 * _HUE_2_RGB(v1, v2, H + (1 / 3));
                G = 255 * _HUE_2_RGB(v1, v2, H);
                B = 255 * _HUE_2_RGB(v1, v2, H - (1 / 3));
            }
            return [ R, G, B ];
        }

        function _HUE_2_RGB(v1, v2, vH) {
            if (vH &lt; 0) {
                vH += 1;
            }
            if (vH &gt; 1) {
                vH -= 1;
            }
            if ((6 * vH) &lt; 1) {
                return (v1 + (v2 - v1) * 6 * vH);
            }
            if ((2 * vH) &lt; 1) {
                return (v2);
            }
            if ((3 * vH) &lt; 2) {
                return (v1 + (v2 - v1) * ((2 / 3) - vH) * 6);
            }
            return v1;
        }

        function _RGB_2_HSB(data) {
            // RGB from 0 to 255
            var R = (data[0] / 255);
            var G = (data[1] / 255);
            var B = (data[2] / 255);

            var vMin = Math.min(R, G, B); // Min. value of RGB
            var vMax = Math.max(R, G, B); // Max. value of RGB
            var delta = vMax - vMin; // Delta RGB value
            var V = vMax;
            var H;
            var S;

            // HSV results from 0 to 1
            if (delta === 0) {
                H = 0;
                S = 0;
            } else {
                S = delta / vMax;

                var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
                var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
                var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;

                if (R === vMax) {
                    H = deltaB - deltaG;
                } else if (G === vMax) {
                    H = (1 / 3) + deltaR - deltaB;
                } else if (B === vMax) {
                    H = (2 / 3) + deltaG - deltaR;
                }

                if (H &lt; 0) {
                    H += 1;
                }
                if (H &gt; 1) {
                    H -= 1;
                }
            }
            H = H * 360;
            S = S * 100;
            V = V * 100;
            return [ H, S, V ];
        }

        function _RGB_2_HSL(data) {
            // RGB from 0 to 255
            var R = (data[0] / 255);
            var G = (data[1] / 255);
            var B = (data[2] / 255);

            var vMin = Math.min(R, G, B); // Min. value of RGB
            var vMax = Math.max(R, G, B); // Max. value of RGB
            var delta = vMax - vMin; // Delta RGB value

            var L = (vMax + vMin) / 2;
            var H;
            var S;
            // HSL results from 0 to 1
            if (delta === 0) {
                H = 0;
                S = 0;
            } else {
                if (L &lt; 0.5) {
                    S = delta / (vMax + vMin);
                } else {
                    S = delta / (2 - vMax - vMin);
                }

                var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
                var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
                var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;

                if (R === vMax) {
                    H = deltaB - deltaG;
                } else if (G === vMax) {
                    H = (1 / 3) + deltaR - deltaB;
                } else if (B === vMax) {
                    H = (2 / 3) + deltaG - deltaR;
                }

                if (H &lt; 0) {
                    H += 1;
                }

                if (H &gt; 1) {
                    H -= 1;
                }
            }

            H = H * 360;
            S = S * 100;
            L = L * 100;

            return [ H, S, L ];
        }

        return {
            customPalette : customPalette,
            resetPalette : resetPalette,
            getColor : getColor,
            getHighlightColor : getHighlightColor,
            customHighlight : customHighlight,
            resetHighlight : resetHighlight,
            getRadialGradient : getRadialGradient,
            getLinearGradient : getLinearGradient,
            getGradientColors : getGradientColors,
            getStepColors : getStepColors,
            reverse : reverse,
            mix : mix,
            lift : lift,
            trim : trim,
            random : random,
            toRGB : toRGB,
            toRGBA : toRGBA,
            toHex : toHex,
            toHSL : toHSL,
            toHSLA : toHSLA,
            toHSB : toHSB,
            toHSBA : toHSBA,
            toHSV : toHSV,
            toHSVA : toHSVA,
            toName : toName,
            toColor : toColor,
            toArray : toArray,
            alpha : alpha,
            getData : getData
        };
    });


    /**
     * zrender : shape基类
     *
     * desc:    zrender是一个轻量级的Canvas类库，MVC封装，数据驱动，提供类Dom事件模型。
     * author:  Kener (@Kener-林峰, linzhifeng@baidu.com)
     *          errorrik (errorrik@gmail.com)
     *
     * 可配图形属性：
     {
       // 基础属性，详见各shape
       shape  : {string},       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 变换
       position : {array},        // 默认为[0, 0], shape的坐标
       rotation : {number|array}, // 默认为[0, 0, 0]，shape绕自身旋转的角度，不被translate 影响
                                  // 后两个值为旋转的origin
       scale : {array},           // 默认为[1, 1, 0, 0], shape纵横缩放比例，不被translate影响
                                  // 后两个值为缩放的origin

       // 样式属性，详见各shape，默认状态样式属性
       style  : {Object},

       // 样式属性，详见各shape，高亮样式属性，当不存在highlightStyle时使用默认样式扩展显示
       highlightStyle : {Object},

       // 交互属性，zrender支持，非图形类实现
       hoverable : {boolean},   // 默认为true，可悬浮响应，默认悬浮响应为高亮显示
                                // 可在onbrush中捕获并阻塞高亮绘画
       clickable : {boolean},   // 默认为false，可点击响应，影响鼠标hover时图标是否为可点击样式
                                // 为false则阻断点击事件抛出，为true可在onclick中捕获
       draggable : {boolean},   // 默认为false，可拖拽响应，默认拖拽响应改变图形位置，
                                // 可在ondrift中捕获并阻塞默认拖拽行为

       // 事件属性
       onbrush : {Function}, // 默认为null，当前图形被刷画时回调，可用于实现自定义绘画
                 // 回传参数为：
                 // @param {2D Context} context 当前canvas context
     // @param {Object} shape 当前shape
     // @param {boolean} isHighlight 是否高亮
     // @return {boolean} 回调返回true则不执行默认绘画
     ondrift : {Function}, // 默认为null，当前图形被拖拽改变位置时回调，可用于限制拖拽范围
     // 回传参数为：
     // @param {Object} shape 当前shape
     // @param {number} dx x方向变化
     // @param {number} dy y方向变化
     onclick : {Function}, // 默认为null，当前图形点击响应，回传参数为：
     // @param {Object} eventPacket 对象内容如下：
     // @param {string} eventPacket.type 事件类型，EVENT.CLICK
     // @param {event} eventPacket.event 原始dom事件对象
     // @param {Object} eventPacket.target 当前图形shape对象
     // @return {boolean} 回调返回true则阻止抛出全局事件

     onmousewheel : {Function}, // 默认为null，当前图形上鼠标滚轮触发，回传参数格式同onclick，其中：
     // 事件类型为confit.EVENT.MOUSEWHEEL
     // @return {boolean} 回调返回true则阻止抛出全局事件

     onmousemove : {Function}, // 默认为null，当前图上形鼠标（或手指）移动触发，回传参数格式同onclick，其中：
     // 事件类型为confit.EVENT.MOUSEMOVE
     // @return {boolean} 回调返回true则阻止抛出全局事件

     onmouseover : {Function}, // 默认为null，鼠标（或手指）移动到当前图形上触发，回传参数格式同onclick：
     // 事件类型为confit.EVENT.MOUSEOVER
     // @return {boolean} 回调返回true则阻止抛出全局事件

     onmouseout : {Function}, // 默认为null，鼠标（或手指）从当前图形移开，回传参数格式同onclick，其中：
     // 事件类型为confit.EVENT.MOUSEOUT
     // @return {boolean} 回调返回true则阻止抛出全局事件

     onmousedown : {Function}, // 默认为null，鼠标按钮（或手指）按下，回传参数格式同onclick，其中：
     // 事件类型为confit.EVENT.MOUSEDOWN
     // @return {boolean} 回调返回true则阻止抛出全局事件

     onmouseup : {Function}, // 默认为null，鼠标按钮（或手指）松开，回传参数格式同onclick，其中：
     // 事件类型为confit.EVENT.MOUSEUP
     // @return {boolean} 回调返回true则阻止抛出全局事件

     ondragstart : {Function}, // 默认为null，开始拖拽时触发，回传参数格式同onclick，其中：
     // 事件类型为confit.EVENT.DRAGSTART
     // @return {boolean} 回调返回true则阻止抛出全局事件

     ondragend : {Function}, // 默认为null，拖拽完毕时触发，回传参数格式同onclick，其中：
     // 事件类型为confit.EVENT.DRAGEND
     // @return {boolean} 回调返回true则阻止抛出全局事件

     ondragenter : {Function}, // 默认为null，拖拽图形元素进入目标图形元素时触发
     // 回传参数格式同onclick，其中：
     // @param {string} eventPacket.type 事件类型，EVENT.DRAGENTER
     // @param {Object} eventPacket.target 目标图形元素shape对象
     // @param {Object} eventPacket.dragged 拖拽图形元素shape对象
     // @return {boolean} 回调返回true则阻止抛出全局事件

     ondragover : {Function}, // 默认为null，拖拽图形元素在目标图形元素上移动时触发，
     // 回传参数格式同onclick，其中：
     // @param {string} eventPacket.type 事件类型，EVENT.DRAGOVER
     // @param {Object} eventPacket.target 目标图形元素shape对象
     // @param {Object} eventPacket.dragged 拖拽图形元素shape对象
     // @return {boolean} 回调返回true则阻止抛出全局事件

     ondragleave : {Function}, // 默认为null，拖拽图形元素离开目标图形元素时触发，
     // 回传参数格式同onclick，其中：
     // @param {string} eventPacket.type 事件类型，EVENT.DRAGLEAVE
     // @param {Object} eventPacket.target 目标图形元素shape对象
     // @param {Object} eventPacket.dragged 拖拽图形元素shape对象
     // @return {boolean} 回调返回true则阻止抛出全局事件

     ondrop : {Function}, // 默认为null，拖拽图形元素放在目标图形元素内时触发，
     // 回传参数格式同onclick，其中：
     // @param {string} eventPacket.type 事件类型，EVENT.DRAG
     // @param {Object} eventPacket.target 目标图形元素shape对象
     // @param {Object} eventPacket.dragged 拖拽图形元素shape对象
     // @return {boolean} 回调返回true则阻止抛出全局事件
     }
     */
    define(
        &#x27;zrender/shape/Base&#x27;,[&#x27;require&#x27;,&#x27;../tool/matrix&#x27;,&#x27;../tool/guid&#x27;,&#x27;../tool/area&#x27;,&#x27;../tool/area&#x27;,&#x27;../tool/color&#x27;,&#x27;../tool/area&#x27;],function(require) {
            var matrix = require(&#x27;../tool/matrix&#x27;);
            var guid = require(&#x27;../tool/guid&#x27;);

            function _fillText(ctx, text, x, y, textFont, textAlign, textBaseline) {
                if (textFont) {
                    ctx.font = textFont;
                }
                ctx.textAlign = textAlign;
                ctx.textBaseline = textBaseline;
                var rect = _getTextRect(
                    text, x, y, textFont, textAlign, textBaseline
                );

                text = (text + &#x27;&#x27;).split(&#x27;\n&#x27;);
                var lineHeight = require(&#x27;../tool/area&#x27;).getTextHeight(&#x27;国&#x27;, textFont);

                switch (textBaseline) {
                    case &#x27;top&#x27;:
                        y = rect.y;
                        break;
                    case &#x27;bottom&#x27;:
                        y = rect.y + lineHeight;
                        break;
                    default:
                        y = rect.y + lineHeight / 2;
                }

                for (var i = 0, l = text.length; i &lt; l; i++) {
                    ctx.fillText(text[i], x, y);
                    y += lineHeight;
                }
            }

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             *
             * @inner
             * @param {Object} style
             */
            function _getTextRect(text, x, y, textFont, textAlign, textBaseline) {
                var area = require(&#x27;../tool/area&#x27;);
                var width = area.getTextWidth(text, textFont);
                var lineHeight = area.getTextHeight(&#x27;国&#x27;, textFont);

                text = (text + &#x27;&#x27;).split(&#x27;\n&#x27;);

                switch (textAlign) {
                    case &#x27;end&#x27;:
                    case &#x27;right&#x27;:
                        x -= width;
                        break;
                    case &#x27;center&#x27;:
                        x -= (width / 2);
                        break;
                }

                switch (textBaseline) {
                    case &#x27;top&#x27;:
                        break;
                    case &#x27;bottom&#x27;:
                        y -= lineHeight * text.length;
                        break;
                    default:
                        y -= lineHeight * text.length / 2;
                }

                return {
                    x : x,
                    y : y,
                    width : width,
                    height : lineHeight * text.length
                };
            }

            function Base( options ) {
                this.id = options.id || guid();
                this.zlevel = 0;
                this.draggable = false;
                this.clickable = false;
                this.hoverable = true;
                this.position = [0, 0];
                this.rotation = [0, 0, 0];
                this.scale = [1, 1, 0, 0];

                for ( var key in options ) {
                    this[ key ] = options[ key ];
                }

                this.style = this.style || {};
            }

            /**
             * 画刷
             *
             * @param ctx       画布句柄
             * @param isHighlight   是否为高亮状态
             * @param updateCallback 需要异步加载资源的shape可以通过这个callback(e)
             *                       让painter更新视图，base.brush没用，需要的话重载brush
             */
            Base.prototype.brush = function (ctx, isHighlight) {
                var style = this.style;

                if (this.brushTypeOnly) {
                    style.brushType = this.brushTypeOnly;
                }

                if (isHighlight) {
                    // 根据style扩展默认高亮样式
                    style = this.getHighlightStyle(
                        style,
                            this.highlightStyle || {},
                        this.brushTypeOnly
                    );
                }

                if (this.brushTypeOnly == &#x27;stroke&#x27;) {
                    style.strokeColor = style.strokeColor || style.color;
                }

                ctx.save();
                this.setContext(ctx, style);

                // 设置transform
                this.updateTransform(ctx);

                ctx.beginPath();
                this.buildPath(ctx, style);
                if (this.brushTypeOnly != &#x27;stroke&#x27;) {
                    ctx.closePath();
                }

                switch (style.brushType) {
                    case &#x27;both&#x27;:
                        ctx.fill();
                    case &#x27;stroke&#x27;:
                        style.lineWidth &gt; 0 &amp;&amp; ctx.stroke();
                        break;
                    default:
                        ctx.fill();
                }

                if (style.text) {
                    this.drawText(ctx, style, this.style);
                }

                ctx.restore();
            };

            var STYLE_CTX_MAP = [
                [&#x27;color&#x27;, &#x27;fillStyle&#x27;],
                [&#x27;strokeColor&#x27;, &#x27;strokeStyle&#x27;],
                [&#x27;opacity&#x27;, &#x27;globalAlpha&#x27;],
                [&#x27;lineCap&#x27;],
                [&#x27;lineJoin&#x27;],
                [&#x27;miterLimit&#x27;],
                [&#x27;lineWidth&#x27;],
                [&#x27;shadowBlur&#x27;],
                [&#x27;shadowColor&#x27;],
                [&#x27;shadowOffsetX&#x27;],
                [&#x27;shadowOffsetY&#x27;]
            ];

            /**
             * 画布通用设置
             *
             * @param ctx       画布句柄
             * @param style     通用样式
             */
            Base.prototype.setContext = function (ctx, style) {
                for (var i = 0, len = STYLE_CTX_MAP.length; i &lt; len; i++) {
                    var styleProp = STYLE_CTX_MAP[i][0];
                    var styleValue = style[styleProp];
                    var ctxProp = STYLE_CTX_MAP[i][1] || styleProp;

                    if (typeof styleValue != &#x27;undefined&#x27;) {
                        ctx[ctxProp] = styleValue;
                    }
                }
            };

            /**
             * 根据默认样式扩展高亮样式
             *
             * @param ctx Canvas 2D上下文
             * @param {Object} style 默认样式
             * @param {Object} highlightStyle 高亮样式
             */
            Base.prototype.getHighlightStyle = function (style, highlightStyle, brushTypeOnly) {
                var newStyle = {};
                for (var k in style) {
                    newStyle[k] = style[k];
                }

                var color = require(&#x27;../tool/color&#x27;);
                var highlightColor = color.getHighlightColor();
                // 根据highlightStyle扩展
                if (style.brushType != &#x27;stroke&#x27;) {
                    // 带填充则用高亮色加粗边线
                    newStyle.strokeColor = highlightColor;
                    newStyle.lineWidth = (style.lineWidth || 1)
                        + this.getHighlightZoom();
                    newStyle.brushType = &#x27;both&#x27;;
                }
                else {
                    if (brushTypeOnly != &#x27;stroke&#x27;) {
                        // 描边型的则用原色加工高亮
                        newStyle.strokeColor = highlightColor;
                        newStyle.lineWidth = (style.lineWidth || 1)
                            + this.getHighlightZoom();
                    }
                    else {
                        // 线型的则用原色加工高亮
                        newStyle.strokeColor = highlightStyle.strokeColor
                            || color.mix(
                                style.strokeColor,
                                color.toRGB(highlightColor)
                            );
                    }
                }

                // 可自定义覆盖默认值
                for (var k in highlightStyle) {
                    if (typeof highlightStyle[k] != &#x27;undefined&#x27;) {
                        newStyle[k] = highlightStyle[k];
                    }
                }

                return newStyle;
            };

            Base.prototype.updateNeedTransform = function () {
                this.needTransform = Math.abs(this.rotation[0]) &gt; 0.0001
                    || Math.abs(this.position[0]) &gt; 0.0001
                    || Math.abs(this.position[1]) &gt; 0.0001
                    || Math.abs(this.scale[0] - 1) &gt; 0.0001
                    || Math.abs(this.scale[1] - 1) &gt; 0.0001;
            };

            /**
             * 高亮放大效果参数
             * 当前统一设置为6，如有需要差异设置，通过this.type判断实例类型
             */
            Base.prototype.getHighlightZoom = function () {
                return this.type != &#x27;text&#x27; ? 6 : 2;
            };

            /**
             * 默认漂移
             *
             * @param dx 横坐标变化
             * @param dy 纵坐标变化
             */
            Base.prototype.drift = function (dx, dy) {
                this.position[0] += dx;
                this.position[1] += dy;
            };

            /**
             * 获取鼠标坐标变换
             */
            Base.prototype.getTansform = function (x, y) {
                var originPos = [x, y];
                // 对鼠标的坐标也做相同的变换
                if (this.needTransform &amp;&amp; this._transform) {
                    var inverseMatrix = [];
                    matrix.invert(inverseMatrix, this._transform);

                    matrix.mulVector(originPos, inverseMatrix, [x, y, 1]);

                    if (x == originPos[0] &amp;&amp; y == originPos[1]) {
                        // 避免外部修改导致的needTransform不准确
                        this.updateNeedTransform();
                    }
                }
                return originPos;
            };

            /**
             * 默认区域包含判断
             *
             * @param x 横坐标
             * @param y 纵坐标
             */
            Base.prototype.isCover = function (x, y) {
                var originPos = this.getTansform(x, y);
                x = originPos[0];
                y = originPos[1];

                // 快速预判并保留判断矩形
                var rect = this.style.__rect;
                if (!rect) {
                    rect = this.style.__rect = this.getRect(this.style);
                }

                if (x &gt;= rect.x
                    &amp;&amp; x &lt;= (rect.x + rect.width)
                    &amp;&amp; y &gt;= rect.y
                    &amp;&amp; y &lt;= (rect.y + rect.height)
                    ) {
                    // 矩形内
                    return require(&#x27;../tool/area&#x27;).isInside(this, this.style, x, y);
                }

                return false;
            };

            /**
             * 附加文本
             *
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             * @param {Object} normalStyle 默认样式，用于定位文字显示
             */
            Base.prototype.drawText = function (ctx, style, normalStyle) {
                // 字体颜色策略
                var textColor = style.textColor || style.color || style.strokeColor;
                ctx.fillStyle = textColor;

                /*
                 if (style.textPosition == &#x27;inside&#x27;) {
                 ctx.shadowColor = &#x27;rgba(0,0,0,0)&#x27;;   // 内部文字不带shadowColor
                 }
                 */

                // 文本与图形间空白间隙
                var dd = 10;
                var al;         // 文本水平对齐
                var bl;         // 文本垂直对齐
                var tx;         // 文本横坐标
                var ty;         // 文本纵坐标

                var textPosition = style.textPosition       // 用户定义
                    || this.textPosition     // shape默认
                    || &#x27;top&#x27;;                // 全局默认

                switch (textPosition) {
                    case &#x27;inside&#x27;:
                    case &#x27;top&#x27;:
                    case &#x27;bottom&#x27;:
                    case &#x27;left&#x27;:
                    case &#x27;right&#x27;:
                        if (this.getRect) {
                            var rect = (normalStyle || style).__rect
                                || this.getRect(normalStyle || style);

                            switch (textPosition) {
                                case &#x27;inside&#x27;:
                                    tx = rect.x + rect.width / 2;
                                    ty = rect.y + rect.height / 2;
                                    al = &#x27;center&#x27;;
                                    bl = &#x27;middle&#x27;;
                                    if (style.brushType != &#x27;stroke&#x27;
                                        &amp;&amp; textColor == style.color
                                        ) {
                                        ctx.fillStyle = &#x27;#fff&#x27;;
                                    }
                                    break;
                                case &#x27;left&#x27;:
                                    tx = rect.x - dd;
                                    ty = rect.y + rect.height / 2;
                                    al = &#x27;end&#x27;;
                                    bl = &#x27;middle&#x27;;
                                    break;
                                case &#x27;right&#x27;:
                                    tx = rect.x + rect.width + dd;
                                    ty = rect.y + rect.height / 2;
                                    al = &#x27;start&#x27;;
                                    bl = &#x27;middle&#x27;;
                                    break;
                                case &#x27;top&#x27;:
                                    tx = rect.x + rect.width / 2;
                                    ty = rect.y - dd;
                                    al = &#x27;center&#x27;;
                                    bl = &#x27;bottom&#x27;;
                                    break;
                                case &#x27;bottom&#x27;:
                                    tx = rect.x + rect.width / 2;
                                    ty = rect.y + rect.height + dd;
                                    al = &#x27;center&#x27;;
                                    bl = &#x27;top&#x27;;
                                    break;
                            }
                        }
                        break;
                    case &#x27;start&#x27;:
                    case &#x27;end&#x27;:
                        var xStart;
                        var xEnd;
                        var yStart;
                        var yEnd;
                        if (typeof style.pointList != &#x27;undefined&#x27;) {
                            var pointList = style.pointList;
                            if (pointList.length &lt; 2) {
                                // 少于2个点就不画了~
                                return;
                            }
                            var length = pointList.length;
                            switch (textPosition) {
                                case &#x27;start&#x27;:
                                    xStart = pointList[0][0];
                                    xEnd = pointList[1][0];
                                    yStart = pointList[0][1];
                                    yEnd = pointList[1][1];
                                    break;
                                case &#x27;end&#x27;:
                                    xStart = pointList[length - 2][0];
                                    xEnd = pointList[length - 1][0];
                                    yStart = pointList[length - 2][1];
                                    yEnd = pointList[length - 1][1];
                                    break;
                            }
                        }
                        else {
                            xStart = style.xStart || 0;
                            xEnd = style.xEnd || 0;
                            yStart = style.yStart || 0;
                            yEnd = style.yEnd || 0;
                        }

                        switch (textPosition) {
                            case &#x27;start&#x27;:
                                al = xStart &lt; xEnd ? &#x27;end&#x27; : &#x27;start&#x27;;
                                bl = yStart &lt; yEnd ? &#x27;bottom&#x27; : &#x27;top&#x27;;
                                tx = xStart;
                                ty = yStart;
                                break;
                            case &#x27;end&#x27;:
                                al = xStart &lt; xEnd ? &#x27;start&#x27; : &#x27;end&#x27;;
                                bl = yStart &lt; yEnd ? &#x27;top&#x27; : &#x27;bottom&#x27;;
                                tx = xEnd;
                                ty = yEnd;
                                break;
                        }
                        dd -= 4;
                        if (xStart != xEnd) {
                            tx -= (al == &#x27;end&#x27; ? dd : -dd);
                        }
                        else {
                            al = &#x27;center&#x27;;
                        }

                        if (yStart != yEnd) {
                            ty -= (bl == &#x27;bottom&#x27; ? dd : -dd);
                        }
                        else {
                            bl = &#x27;middle&#x27;;
                        }
                        break;
                    case &#x27;specific&#x27;:
                        tx = style.textX || 0;
                        ty = style.textY || 0;
                        al = &#x27;start&#x27;;
                        bl = &#x27;middle&#x27;;
                        break;
                }

                if (tx != null &amp;&amp; ty != null) {
                    _fillText(
                        ctx,
                        style.text,
                        tx, ty,
                        style.textFont,
                            style.textAlign || al,
                            style.textBaseline || bl
                    );
                }
            };

            Base.prototype.isSilent = function () {
                return !(
                    this.hoverable || this.draggable
                    || this.onmousemove || this.onmouseover || this.onmouseout
                    || this.onmousedown || this.onmouseup || this.onclick
                    || this.ondragenter || this.ondragover || this.ondragleave
                    || this.ondrop
                    );
            };

            Base.prototype.updateTransform = function (ctx) {
                if (!this.needTransform) {
                    return;
                }

                var _transform = this._transform || matrix.create();
                matrix.identity(_transform);
                if (this.scale &amp;&amp; (this.scale[0] !== 1 || this.scale[1] !== 1)) {
                    var originX = this.scale[2] || 0;
                    var originY = this.scale[3] || 0;
                    if (originX || originY) {
                        matrix.translate(
                            _transform, _transform, [-originX, -originY]
                        );
                    }
                    matrix.scale(_transform, _transform, this.scale);
                    if ( originX || originY ) {
                        matrix.translate(
                            _transform, _transform, [originX, originY]
                        );
                    }
                }

                if (this.rotation) {
                    if (this.rotation instanceof Array) {
                        if (this.rotation[0] !== 0) {
                            var originX = this.rotation[1] || 0;
                            var originY = this.rotation[2] || 0;
                            if (originX || originY) {
                                matrix.translate(
                                    _transform, _transform, [-originX, -originY]
                                );
                            }
                            matrix.rotate(_transform, _transform, this.rotation[0]);
                            if (originX || originY) {
                                matrix.translate(
                                    _transform, _transform, [originX, originY]
                                );
                            }
                        }
                    }
                    else {
                        if (this.rotation !== 0) {
                            matrix.rotate(_transform, _transform, this.rotation);
                        }
                    }
                }

                if (this.position &amp;&amp; (this.position[0] !==0 || this.position[1] !== 0)) {
                    matrix.translate(_transform, _transform, this.position);
                }

                // 保存这个变换矩阵
                this._transform = _transform;
                ctx.transform.apply(ctx, _transform);
            };

            return Base;
        }
    );

    /**
     * zrender
     *
     * author: CrossDo (chenhuaimu@baidu.com)
     *
     * shape类：路径
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;path&#x27;,         // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           path          : {string},// 必须，路径。例如:M 0 0 L 0 10 L 10 10 Z (一个三角形)
                                    //M = moveto
                                    //L = lineto
                                    //H = horizontal lineto
                                    //V = vertical lineto
                                    //C = curveto
                                    //S = smooth curveto
                                    //Q = quadratic Belzier curve
                                    //T = smooth quadratic Belzier curveto
                                    //Z = closepath


           x             : {number},  // 必须，x轴坐标
           y             : {number},  // 必须，y轴坐标


           brushType     : {string},  // 默认为fill，绘画方式
                                      // fill(填充) | stroke(描边) | both(填充+描边)
           color         : {color},   // 默认为&#x27;#000&#x27;，填充颜色，支持rgba
           strokeColor   : {color},   // 默认为&#x27;#000&#x27;，描边颜色（轮廓），支持rgba
           lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

           opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
           shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
           shadowColor   : {color},   // 默认为&#x27;#000&#x27;，阴影色彩，支持rgba
           shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
           shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

           text          : {string},  // 默认为null，附加文本
           textFont      : {string},  // 默认为null，附加文本样式，eg:&#x27;bold 18px verdana&#x27;
           textPosition  : {string},  // 默认为top，附加文本位置。
                                      // inside | left | right | top | bottom
           textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                      // start | end | left | right | center
           textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                      // top | bottom | middle |
                                      // alphabetic | hanging | ideographic
           textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                      // &#x27;inside&#x27; ? &#x27;#fff&#x27; : color
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }

     **/

    define(&#x27;zrender/shape/Path&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;],function (require) {
        var Base = require(&#x27;./Base&#x27;);

        function Path(options) {
            Base.call(this, options);
        }

        Path.prototype = {
            type: &#x27;path&#x27;,

            _parsePathData : function(data) {
                if (!data) {
                    return [];
                }

                // command string
                var cs = data;

                // command chars
                var cc = [
                    &#x27;m&#x27;, &#x27;M&#x27;, &#x27;l&#x27;, &#x27;L&#x27;, &#x27;v&#x27;, &#x27;V&#x27;, &#x27;h&#x27;, &#x27;H&#x27;, &#x27;z&#x27;, &#x27;Z&#x27;,
                    &#x27;c&#x27;, &#x27;C&#x27;, &#x27;q&#x27;, &#x27;Q&#x27;, &#x27;t&#x27;, &#x27;T&#x27;, &#x27;s&#x27;, &#x27;S&#x27;, &#x27;a&#x27;, &#x27;A&#x27;
                ];

                cs = cs.replace(/-/g, &#x27; -&#x27;);
                cs = cs.replace(/  /g, &#x27; &#x27;);
                cs = cs.replace(/ /g, &#x27;,&#x27;);
                cs = cs.replace(/,,/g, &#x27;,&#x27;);


                var n;
                // create pipes so that we can split the data
                for (n = 0; n &lt; cc.length; n++) {
                    cs = cs.replace(new RegExp(cc[n], &#x27;g&#x27;), &#x27;|&#x27; + cc[n]);
                }

                // create array
                var arr = cs.split(&#x27;|&#x27;);
                var ca = [];
                // init context point
                var cpx = 0;
                var cpy = 0;
                for (n = 1; n &lt; arr.length; n++) {
                    var str = arr[n];
                    var c = str.charAt(0);
                    str = str.slice(1);
                    str = str.replace(new RegExp(&#x27;e,-&#x27;, &#x27;g&#x27;), &#x27;e-&#x27;);

                    var p = str.split(&#x27;,&#x27;);
                    if (p.length &gt; 0 &amp;&amp; p[0] === &#x27;&#x27;) {
                        p.shift();
                    }

                    for (var i = 0; i &lt; p.length; i++) {
                        p[i] = parseFloat(p[i]);
                    }
                    while (p.length &gt; 0) {
                        if (isNaN(p[0])) {
                            break;
                        }
                        var cmd = null;
                        var points = [];

                        var ctlPtx;
                        var ctlPty;
                        var prevCmd;

                        var rx;
                        var ry;
                        var psi;
                        var fa;
                        var fs;

                        var x1 = cpx;
                        var y1 = cpy;

                        // convert l, H, h, V, and v to L
                        switch (c) {
                            case &#x27;l&#x27;:
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = &#x27;L&#x27;;
                                points.push(cpx, cpy);
                                break;
                            case &#x27;L&#x27;:
                                cpx = p.shift();
                                cpy = p.shift();
                                points.push(cpx, cpy);
                                break;
                            case &#x27;m&#x27;:
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = &#x27;M&#x27;;
                                points.push(cpx, cpy);
                                c = &#x27;l&#x27;;
                                break;
                            case &#x27;M&#x27;:
                                cpx = p.shift();
                                cpy = p.shift();
                                cmd = &#x27;M&#x27;;
                                points.push(cpx, cpy);
                                c = &#x27;L&#x27;;
                                break;

                            case &#x27;h&#x27;:
                                cpx += p.shift();
                                cmd = &#x27;L&#x27;;
                                points.push(cpx, cpy);
                                break;
                            case &#x27;H&#x27;:
                                cpx = p.shift();
                                cmd = &#x27;L&#x27;;
                                points.push(cpx, cpy);
                                break;
                            case &#x27;v&#x27;:
                                cpy += p.shift();
                                cmd = &#x27;L&#x27;;
                                points.push(cpx, cpy);
                                break;
                            case &#x27;V&#x27;:
                                cpy = p.shift();
                                cmd = &#x27;L&#x27;;
                                points.push(cpx, cpy);
                                break;
                            case &#x27;C&#x27;:
                                points.push(p.shift(), p.shift(), p.shift(), p.shift());
                                cpx = p.shift();
                                cpy = p.shift();
                                points.push(cpx, cpy);
                                break;
                            case &#x27;c&#x27;:
                                points.push(
                                        cpx + p.shift(), cpy + p.shift(),
                                        cpx + p.shift(), cpy + p.shift()
                                );
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = &#x27;C&#x27;;
                                points.push(cpx, cpy);
                                break;
                            case &#x27;S&#x27;:
                                ctlPtx = cpx;
                                ctlPty = cpy;
                                prevCmd = ca[ca.length - 1];
                                if (prevCmd.command === &#x27;C&#x27;) {
                                    ctlPtx = cpx + (cpx - prevCmd.points[2]);
                                    ctlPty = cpy + (cpy - prevCmd.points[3]);
                                }
                                points.push(ctlPtx, ctlPty, p.shift(), p.shift());
                                cpx = p.shift();
                                cpy = p.shift();
                                cmd = &#x27;C&#x27;;
                                points.push(cpx, cpy);
                                break;
                            case &#x27;s&#x27;:
                                ctlPtx = cpx, ctlPty = cpy;
                                prevCmd = ca[ca.length - 1];
                                if (prevCmd.command === &#x27;C&#x27;) {
                                    ctlPtx = cpx + (cpx - prevCmd.points[2]);
                                    ctlPty = cpy + (cpy - prevCmd.points[3]);
                                }
                                points.push(
                                    ctlPtx, ctlPty,
                                        cpx + p.shift(), cpy + p.shift()
                                );
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = &#x27;C&#x27;;
                                points.push(cpx, cpy);
                                break;
                            case &#x27;Q&#x27;:
                                points.push(p.shift(), p.shift());
                                cpx = p.shift();
                                cpy = p.shift();
                                points.push(cpx, cpy);
                                break;
                            case &#x27;q&#x27;:
                                points.push(cpx + p.shift(), cpy + p.shift());
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = &#x27;Q&#x27;;
                                points.push(cpx, cpy);
                                break;
                            case &#x27;T&#x27;:
                                ctlPtx = cpx, ctlPty = cpy;
                                prevCmd = ca[ca.length - 1];
                                if (prevCmd.command === &#x27;Q&#x27;) {
                                    ctlPtx = cpx + (cpx - prevCmd.points[0]);
                                    ctlPty = cpy + (cpy - prevCmd.points[1]);
                                }
                                cpx = p.shift();
                                cpy = p.shift();
                                cmd = &#x27;Q&#x27;;
                                points.push(ctlPtx, ctlPty, cpx, cpy);
                                break;
                            case &#x27;t&#x27;:
                                ctlPtx = cpx, ctlPty = cpy;
                                prevCmd = ca[ca.length - 1];
                                if (prevCmd.command === &#x27;Q&#x27;) {
                                    ctlPtx = cpx + (cpx - prevCmd.points[0]);
                                    ctlPty = cpy + (cpy - prevCmd.points[1]);
                                }
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = &#x27;Q&#x27;;
                                points.push(ctlPtx, ctlPty, cpx, cpy);
                                break;
                            case &#x27;A&#x27;:
                                rx = p.shift();
                                ry = p.shift();
                                psi = p.shift();
                                fa = p.shift();
                                fs = p.shift();

                                x1 = cpx, y1 = cpy;
                                cpx = p.shift(), cpy = p.shift();
                                cmd = &#x27;A&#x27;;
                                points = this._convertPoint(
                                    x1, y1, cpx, cpy, fa, fs, rx, ry, psi
                                );
                                break;
                            case &#x27;a&#x27;:
                                rx = p.shift();
                                ry = p.shift();
                                psi = p.shift();
                                fa = p.shift();
                                fs = p.shift();

                                x1 = cpx, y1 = cpy;
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = &#x27;A&#x27;;
                                points = this._convertPoint(
                                    x1, y1, cpx, cpy, fa, fs, rx, ry, psi
                                );
                                break;

                        }

                        ca.push({
                            command : cmd || c,
                            points : points
                        });
                    }

                    if (c === &#x27;z&#x27; || c === &#x27;Z&#x27;) {
                        ca.push({
                            command : &#x27;z&#x27;,
                            points : []
                        });
                    }
                }

                return ca;

            },

            _convertPoint : function(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
                var psi = psiDeg * (Math.PI / 180.0);
                var xp = Math.cos(psi) * (x1 - x2) / 2.0
                    + Math.sin(psi) * (y1 - y2) / 2.0;
                var yp = -1 * Math.sin(psi) * (x1 - x2) / 2.0
                    + Math.cos(psi) * (y1 - y2) / 2.0;

                var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);

                if (lambda &gt; 1) {
                    rx *= Math.sqrt(lambda);
                    ry *= Math.sqrt(lambda);
                }

                var f = Math.sqrt((((rx * rx) * (ry * ry))
                        - ((rx * rx) * (yp * yp))
                        - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)
                        + (ry * ry) * (xp * xp))
                );

                if (fa === fs) {
                    f *= -1;
                }
                if (isNaN(f)) {
                    f = 0;
                }

                var cxp = f * rx * yp / ry;
                var cyp = f * -ry * xp / rx;

                var cx = (x1 + x2) / 2.0
                    + Math.cos(psi) * cxp
                    - Math.sin(psi) * cyp;
                var cy = (y1 + y2) / 2.0
                    + Math.sin(psi) * cxp
                    + Math.cos(psi) * cyp;

                var vMag = function(v) {
                    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
                };
                var vRatio = function(u, v) {
                    return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
                };
                var vAngle = function(u, v) {
                    return (u[0] * v[1] &lt; u[1] * v[0] ? -1 : 1)
                        * Math.acos(vRatio(u, v));
                };
                var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);
                var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];
                var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];
                var dTheta = vAngle(u, v);

                if (vRatio(u, v) &lt;= -1) {
                    dTheta = Math.PI;
                }
                if (vRatio(u, v) &gt;= 1) {
                    dTheta = 0;
                }
                if (fs === 0 &amp;&amp; dTheta &gt; 0) {
                    dTheta = dTheta - 2 * Math.PI;
                }
                if (fs === 1 &amp;&amp; dTheta &lt; 0) {
                    dTheta = dTheta + 2 * Math.PI;
                }
                return [ cx, cy, rx, ry, theta, dTheta, psi, fs ];
            },

            /**
             * 创建路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath : function(ctx, style) {
                var path = style.path;

                var pathArray = this.pathArray || this._parsePathData(path);

                // 平移坐标
                var x = style.x || 0;
                var y = style.y || 0;

                var p;
                // 记录边界点，用于判断inside
                var pointList = style.pointList = [];
                var singlePointList = [];
                for (var i = 0, l = pathArray.length; i &lt; l; i++) {
                    if (pathArray[i].command.toUpperCase() == &#x27;M&#x27;) {
                        singlePointList.length &gt; 0
                        &amp;&amp; pointList.push(singlePointList);
                        singlePointList = [];
                    }
                    p = pathArray[i].points;
                    for (var j = 0, k = p.length; j &lt; k; j += 2) {
                        singlePointList.push([p[j] + x, p[j+1] + y]);
                    }
                }
                singlePointList.length &gt; 0 &amp;&amp; pointList.push(singlePointList);

                var c;
                for (var i = 0, l = pathArray.length; i &lt; l; i++) {
                    c = pathArray[i].command;
                    p = pathArray[i].points;
                    // 平移变换
                    for (var j = 0, k = p.length; j &lt; k; j++) {
                        if (j % 2 === 0) {
                            p[j] += x;
                        } else {
                            p[j] += y;
                        }
                    }
                    switch (c) {
                        case &#x27;L&#x27;:
                            ctx.lineTo(p[0], p[1]);
                            break;
                        case &#x27;M&#x27;:
                            ctx.moveTo(p[0], p[1]);
                            break;
                        case &#x27;C&#x27;:
                            ctx.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
                            break;
                        case &#x27;Q&#x27;:
                            ctx.quadraticCurveTo(p[0], p[1], p[2], p[3]);
                            break;
                        case &#x27;A&#x27;:
                            var cx = p[0];
                            var cy = p[1];
                            var rx = p[2];
                            var ry = p[3];
                            var theta = p[4];
                            var dTheta = p[5];
                            var psi = p[6];
                            var fs = p[7];
                            var r = (rx &gt; ry) ? rx : ry;
                            var scaleX = (rx &gt; ry) ? 1 : rx / ry;
                            var scaleY = (rx &gt; ry) ? ry / rx : 1;

                            ctx.translate(cx, cy);
                            ctx.rotate(psi);
                            ctx.scale(scaleX, scaleY);
                            ctx.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
                            ctx.scale(1 / scaleX, 1 / scaleY);
                            ctx.rotate(-psi);
                            ctx.translate(-cx, -cy);
                            break;
                        case &#x27;z&#x27;:
                            ctx.closePath();
                            break;
                    }
                }

                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style 样式
             */
            getRect : function(style) {
                if (style.__rect) {
                    return style.__rect;
                }

                var lineWidth;
                if (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;fill&#x27;) {
                    lineWidth = style.lineWidth || 1;
                }
                else {
                    lineWidth = 0;
                }

                var minX = Number.MAX_VALUE;
                var maxX = Number.MIN_VALUE;

                var minY = Number.MAX_VALUE;
                var maxY = Number.MIN_VALUE;

                // 平移坐标
                var x = style.x || 0;
                var y = style.y || 0;

                var pathArray = this.pathArray || this._parsePathData(style.path);
                for (var i = 0; i &lt; pathArray.length; i++) {
                    var p = pathArray[i].points;

                    for (var j = 0; j &lt; p.length; j++) {
                        if (j % 2 === 0) {
                            if (p[j] + x &lt; minX) {
                                minX = p[j] + x;
                            }
                            if (p[j] + x &gt; maxX) {
                                maxX = p[j] + x;
                            }
                        }
                        else {
                            if (p[j] + y &lt; minY) {
                                minY = p[j] + y;
                            }
                            if (p[j] + y &gt; maxY) {
                                maxY = p[j] + y;
                            }
                        }
                    }
                }

                var rect;
                if (minX === Number.MAX_VALUE
                    || maxX === Number.MIN_VALUE
                    || minY === Number.MAX_VALUE
                    || maxY === Number.MIN_VALUE
                    ) {
                    rect = {
                        x : 0,
                        y : 0,
                        width : 0,
                        height : 0
                    };
                }
                else {
                    rect = {
                        x : Math.round(minX - lineWidth / 2),
                        y : Math.round(minY - lineWidth / 2),
                        width : maxX - minX + lineWidth,
                        height : maxY - minY + lineWidth
                    };
                }
                style.__rect = rect;
                return rect;
            }
        };

        require(&#x27;../tool/util&#x27;).inherits(Path, Base);
        return Path;
    });
    /**
     * zrender: 图形空间辅助类
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * isInside：是否在区域内部
     * isOutside：是否在区域外部
     * getTextWidth：测算单行文本宽度
     */
    define(
        &#x27;zrender/tool/area&#x27;,[&#x27;require&#x27;,&#x27;../tool/util&#x27;,&#x27;../shape/Path&#x27;],function(require) {
            var util = require(&#x27;../tool/util&#x27;);

            var _ctx;

            var _textWidthCache = {};
            var _textHeightCache = {};
            var _textWidthCacheCounter = 0;
            var _textHeightCacheCounter = 0;
            var TEXT_CACHE_MAX = 20000;

            /**
             * 包含判断
             *
             * @param {Object} shape : 图形
             * @param {Object} area ： 目标区域
             * @param {number} x ： 横坐标
             * @param {number} y ： 纵坐标
             */
            function isInside(shape, area, x, y) {
                if (!area || !shape) {
                    // 无参数或不支持类型
                    return false;
                }
                var zoneType = shape.type;

                _ctx = _ctx || util.getContext();

                if (!_isInsideRectangle(area.__rect || shape.getRect(area), x, y)) {
                    // 不在矩形区域内直接返回false
                    return false;
                }

                // 未实现或不可用时(excanvas不支持)则数学运算，主要是line，brokenLine，ring
                var _mathReturn = _mathMethod(zoneType, area, x, y);
                if (typeof _mathReturn != &#x27;undefined&#x27;) {
                    return _mathReturn;
                }

                if (zoneType != &#x27;bezier-curve&#x27;
                    &amp;&amp; shape.buildPath
                    &amp;&amp; _ctx.isPointInPath
                    ) {
                    return _buildPathMethod(shape, _ctx, area, x, y);
                }
                else if (_ctx.getImageData) {
                    return _pixelMethod(shape, area, x, y);
                }

                // 上面的方法都行不通时
                switch (zoneType) {
                    case &#x27;heart&#x27;: //心形---------10 // Todo，不精确
                    case &#x27;droplet&#x27;:// 水滴----------11 // Todo，不精确
                    case &#x27;ellipse&#x27;: // Todo，不精确
                        return true;
                    // 旋轮曲线  不准确
                    case &#x27;trochoid&#x27;:
                        var _r = area.location == &#x27;out&#x27;
                            ? area.r1 + area.r2 + area.d
                            : area.r1 - area.r2 + area.d;
                        return _isInsideCircle(area, x, y, _r);
                    // 玫瑰线 不准确
                    case &#x27;rose&#x27; :
                        return _isInsideCircle(area, x, y, area.maxr);
                    //路径，椭圆，曲线等-----------------13
                    default:
                        return false;   // Todo，暂不支持
                }
            }

            /**
             * 用数学方法判断，三个方法中最快，但是支持的shape少
             *
             * @param {string} zoneType ： 图形类型
             * @param {Object} area ：目标区域
             * @param {number} x ： 横坐标
             * @param {number} y ： 纵坐标
             * @return {boolean=} true表示坐标处在图形中
             */
            function _mathMethod(zoneType, area, x, y) {
                // 在矩形内则部分图形需要进一步判断
                switch (zoneType) {
                    //线-----------------------1
                    case &#x27;line&#x27;:
                        return _isInsideLine(area, x, y);
                    //折线----------------------2
                    case &#x27;broken-line&#x27;:
                        return _isInsideBrokenLine(area, x, y);
                    //文本----------------------3
                    case &#x27;text&#x27;:
                        return true;
                    //圆环----------------------4
                    case &#x27;ring&#x27;:
                        return _isInsideRing(area, x, y);
                    //矩形----------------------5
                    case &#x27;rectangle&#x27;:
                        return true;
                    //圆形----------------------6
                    case &#x27;circle&#x27;:
                        return _isInsideCircle(area, x, y, area.r);
                    //扇形----------------------7
                    case &#x27;sector&#x27;:
                        return _isInsideSector(area, x, y);
                    //多边形---------------------8
                    case &#x27;path&#x27;:
                        return _isInsidePath(area, x, y);
                    case &#x27;polygon&#x27;:
                    case &#x27;star&#x27;:
                    case &#x27;isogon&#x27;:
                        return _isInsidePolygon(area, x, y);
                    //图片----------------------9
                    case &#x27;image&#x27;:
                        return true;
                }
            }

            /**
             * 通过buildPath方法来判断，三个方法中较快，但是不支持线条类型的shape，
             * 而且excanvas不支持isPointInPath方法
             *
             * @param {Object} shape ： shape
             * @param {Object} context : 上下文
             * @param {Object} area ：目标区域
             * @param {number} x ： 横坐标
             * @param {number} y ： 纵坐标
             * @return {boolean} true表示坐标处在图形中
             */
            function _buildPathMethod(shape, context, area, x, y) {
                // 图形类实现路径创建了则用类的path
                context.beginPath();
                shape.buildPath(context, area);
                context.closePath();
                return context.isPointInPath(x, y);
            }

            /**
             * 通过像素值来判断，三个方法中最慢，但是支持广,不足之处是excanvas不支持像素处理
             *
             * @param {Object} shape  shape类
             * @param {Object} area 目标区域
             * @param {number} x  横坐标
             * @param {number} y  纵坐标
             * @return {boolean} true表示坐标处在图形中
             */
            function _pixelMethod(shape, area, x, y) {
                var _rect = area.__rect || shape.getRect(area);
                var _context = util.getPixelContext();
                var _offset = util.getPixelOffset();

                util.adjustCanvasSize(x, y);
                _context.clearRect(_rect.x, _rect.y, _rect.width, _rect.height);
                _context.beginPath();
                shape.brush(_context, {style : area});
                _context.closePath();

                return _isPainted(_context, x + _offset.x, y + _offset.y);
            }

            /**
             * 坐标像素值，判断坐标是否被作色
             *
             * @param {Object} context : 上下文
             * @param {number} x : 横坐标
             * @param {number} y : 纵坐标
             * @param {number=} unit : 触发的精度，越大越容易触发，可选，缺省是为1
             * @return {boolean} 已经被画过返回true
             */
            function _isPainted(context, x, y, unit) {
                var pixelsData;

                if (typeof unit != &#x27;undefined&#x27;) {
                    unit = (unit || 1 ) &gt;&gt; 1;
                    pixelsData = context.getImageData(
                            x - unit,
                            y - unit,
                            unit + unit,
                            unit + unit
                    ).data;
                }
                else {
                    pixelsData = context.getImageData(x, y, 1, 1).data;
                }

                var len = pixelsData.length;
                while (len--) {
                    if (pixelsData[len] !== 0) {
                        return true;
                    }
                }

                return false;
            }

            /**
             * !isInside
             */
            function isOutside(shape, area, x, y) {
                return !isInside(shape, area, x, y);
            }

            /**
             * 线段包含判断
             */
            function _isInsideLine(area, x, y) {
                var _x1 = area.xStart;
                var _y1 = area.yStart;
                var _x2 = area.xEnd;
                var _y2 = area.yEnd;
                var _l = Math.max(area.lineWidth, 5);
                var _a = 0;
                var _b = _x1;

                var minX, maxX;
                if (_x1 &lt; _x2) {
                    minX = _x1 - _l; maxX = _x2 + _l;
                } else {
                    minX = _x2 - _l; maxX = _x1 + _l;
                }

                var minY, maxY;
                if (_y1 &lt; _y2) {
                    minY = _y1 - _l; maxY = _y2 + _l;
                } else {
                    minY = _y2 - _l; maxY = _y1 + _l;
                }

                if (x &lt; minX || x &gt; maxX || y &lt; minY || y &gt; maxY) {
                    return false;
                }

                if (_x1 !== _x2) {
                    _a = (_y1 - _y2) / (_x1 - _x2);
                    _b = (_x1 * _y2 - _x2 * _y1) / (_x1 - _x2) ;
                }
                else {
                    return Math.abs(x - _x1) &lt;= _l / 2;
                }

                var _s = (_a * x - y + _b) * (_a * x - y + _b) / (_a * _a + 1);
                return  _s &lt;= _l / 2 * _l / 2;
            }

            function _isInsideBrokenLine(area, x, y) {
                var pointList = area.pointList;
                var lineArea = {
                    xStart : 0,
                    yStart : 0,
                    xEnd : 0,
                    yEnd : 0,
                    lineWidth : 0
                };
                for (var i = 0, l = pointList.length - 1; i &lt; l; i++) {
                    lineArea.xStart = pointList[i][0];
                    lineArea.yStart = pointList[i][1];
                    lineArea.xEnd = pointList[i + 1][0];
                    lineArea.yEnd = pointList[i + 1][1];
                    lineArea.lineWidth = Math.max(area.lineWidth, 10);

                    if (_isInsideLine(lineArea, x, y)) {
                        return true;
                    }
                }

                return false;
            }

            function _isInsideRing(area, x, y) {
                return _isInsideCircle(area, x, y, area.r)
                    &amp;&amp; !_isInsideCircle({x: area.x, y: area.y}, x, y, area.r0 || 0);
            }

            /**
             * 矩形包含判断
             */
            function _isInsideRectangle(area, x, y) {
                return x &gt;= area.x
                    &amp;&amp; x &lt;= (area.x + area.width)
                    &amp;&amp; y &gt;= area.y
                    &amp;&amp; y &lt;= (area.y + area.height);
            }

            /**
             * 圆形包含判断
             */
            function _isInsideCircle(area, x, y, r) {
                return (x - area.x) * (x - area.x) + (y - area.y) * (y - area.y)
                    &lt; r * r;
            }

            /**
             * 扇形包含判断
             */
            function _isInsideSector(area, x, y) {
                if (!_isInsideCircle(area, x, y, area.r)
                    || (area.r0 &gt; 0
                        &amp;&amp; _isInsideCircle(
                            {
                                x : area.x,
                                y : area.y
                            },
                            x, y,
                            area.r0
                        )
                        )
                    ){
                    // 大圆外或者小圆内直接false
                    return false;
                }

                // 判断夹角
                if (Math.abs(area.endAngle - area.startAngle) &gt;= 360) {
                    // 大于360度的扇形，在环内就为true
                    return true;
                }

                var angle = (360
                    - Math.atan2(y - area.y, x - area.x) / Math.PI
                    * 180)
                    % 360;
                var endA = (360 + area.endAngle) % 360;
                var startA = (360 + area.startAngle) % 360;
                if (endA &gt; startA) {
                    return (angle &gt;= startA &amp;&amp; angle &lt;= endA);
                }

                return !(angle &gt;= endA &amp;&amp; angle &lt;= startA);
            }

            /**
             * 多边形包含判断
             * 警告：下面这段代码会很难看，建议跳过~
             */
            function _isInsidePolygon(area, x, y) {
                /**
                 * 射线判别法
                 * 如果一个点在多边形内部，任意角度做射线肯定会与多边形要么有一个交点，要么有与多边形边界线重叠
                 * 如果一个点在多边形外部，任意角度做射线要么与多边形有一个交点，
                 * 要么有两个交点，要么没有交点，要么有与多边形边界线重叠。
                 */
                var i;
                var j;
                var polygon = area.pointList;
                var N = polygon.length;
                var inside = false;
                var redo = true;
                var v;

                for (i = 0; i &lt; N; ++i) {
                    // 是否在顶点上
                    if (polygon[i][0] == x &amp;&amp; polygon[i][1] == y ) {
                        redo = false;
                        inside = true;
                        break;
                    }
                }

                if (redo) {
                    redo = false;
                    inside = false;
                    for (i = 0,j = N - 1; i &lt; N; j = i++) {
                        if ((polygon[i][1] &lt; y &amp;&amp; y &lt; polygon[j][1])
                            || (polygon[j][1] &lt; y &amp;&amp; y &lt; polygon[i][1])
                            ) {
                            if (x &lt;= polygon[i][0] || x &lt;= polygon[j][0]) {
                                v = (y - polygon[i][1])
                                    * (polygon[j][0] - polygon[i][0])
                                    / (polygon[j][1] - polygon[i][1])
                                    + polygon[i][0];
                                if (x &lt; v) {          // 在线的左侧
                                    inside = !inside;
                                }
                                else if (x == v) {   // 在线上
                                    inside = true;
                                    break;
                                }
                            }
                        }
                        else if (y == polygon[i][1]) {
                            if (x &lt; polygon[i][0]) {    // 交点在顶点上
                                polygon[i][1] &gt; polygon[j][1] ? --y : ++y;
                                //redo = true;
                                break;
                            }
                        }
                        else if (polygon[i][1] == polygon[j][1] // 在水平的边界线上
                            &amp;&amp; y == polygon[i][1]
                            &amp;&amp; ((polygon[i][0] &lt; x &amp;&amp; x &lt; polygon[j][0])
                                || (polygon[j][0] &lt; x &amp;&amp; x &lt; polygon[i][0]))
                            ) {
                            inside = true;
                            break;
                        }
                    }
                }
                return inside;
            }

            /**
             * 路径包含判断，依赖多边形判断
             */
            function _isInsidePath(area, x, y) {
                if (!area.pointList) {
                    require(&#x27;../shape/Path&#x27;).prototype.buildPath(_ctx, area);
                }
                var pointList = area.pointList;
                var insideCatch = false;
                for (var i = 0, l = pointList.length; i &lt; l; i++) {
                    insideCatch = _isInsidePolygon(
                        { pointList : pointList[i] }, x, y
                    );

                    if (insideCatch) {
                        break;
                    }
                }

                return insideCatch;
            }

            /**
             * 测算多行文本宽度
             * @param {Object} text
             * @param {Object} textFont
             */
            function getTextWidth(text, textFont) {
                var key = text+&#x27;:&#x27;+textFont;
                if (_textWidthCache[key]) {
                    return _textWidthCache[key];
                }
                _ctx = _ctx || util.getContext();
                _ctx.save();

                if (textFont) {
                    _ctx.font = textFont;
                }

                text = (text + &#x27;&#x27;).split(&#x27;\n&#x27;);
                var width = 0;
                for (var i = 0, l = text.length; i &lt; l; i++) {
                    width =  Math.max(
                        _ctx.measureText(text[i]).width,
                        width
                    );
                }
                _ctx.restore();

                _textWidthCache[key] = width;
                if (++_textWidthCacheCounter &gt; TEXT_CACHE_MAX) {
                    // 内存释放
                    _textWidthCacheCounter = 0;
                    _textWidthCache = {};
                }

                return width;
            }

            /**
             * 测算多行文本高度
             * @param {Object} text
             * @param {Object} textFont
             */
            function getTextHeight(text, textFont) {
                var key = text+&#x27;:&#x27;+textFont;
                if (_textHeightCache[key]) {
                    return _textHeightCache[key];
                }

                _ctx = _ctx || util.getContext();

                _ctx.save();
                if (textFont) {
                    _ctx.font = textFont;
                }

                text = (text + &#x27;&#x27;).split(&#x27;\n&#x27;);
                //比较粗暴
                var height = (_ctx.measureText(&#x27;国&#x27;).width + 2) * text.length;

                _ctx.restore();

                _textHeightCache[key] = height;
                if (++_textHeightCacheCounter &gt; TEXT_CACHE_MAX) {
                    // 内存释放
                    _textHeightCacheCounter = 0;
                    _textHeightCache = {};
                }
                return height;
            }

            return {
                isInside : isInside,
                isOutside : isOutside,
                getTextWidth : getTextWidth,
                getTextHeight : getTextHeight
            };
        }
    );

    /**
     * zrender
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：文字
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;text&#x27;,         // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           x             : {number},  // 必须，横坐标
           y             : {number},  // 必须，纵坐标
           brushType     : {string},  // 默认为fill，绘画方式
                                      // fill(填充) | stroke(描边) | both(填充+描边)
           color         : {color},   // 默认为&#x27;#000&#x27;，填充颜色，支持rgba
           strokeColor   : {color},   // 默认为&#x27;#000&#x27;，线条颜色（轮廓），支持rgba
           lineWidth     : {number},  // 默认为1，线条宽度

           opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
           shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
           shadowColor   : {color},   // 默认为&#x27;#000&#x27;，阴影色彩，支持rgba
           shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
           shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

           text          : {string},  // 必须，文本内容
           textFont      : {string},  // 默认为null，文本文字样式，eg:&#x27;bold 18px verdana&#x27;
           textAlign     : {string},  // 默认为start，文本水平对齐。
                                      // start | end | left | right | center
           textBaseline  : {string},  // 默认为middle，文本垂直对齐。
                                      // top | bottom | middle |
                                      // alphabetic | hanging | ideographic
           maxWidth      : {number}   // 默认为null，最大宽度
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     例子：
     {
       shape  : &#x27;text&#x27;,
       id     : &#x27;123456&#x27;,
       zlevel : 1,
       style  : {
           x : 200,
           y : 100,
           color : &#x27;red&#x27;,
           text : &#x27;Baidu&#x27;
       },
       myName : &#x27;kener&#x27;,  //可自带任何有效自定义属性

       clickable : true,
       onClick : function(eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
     */
    define(
        &#x27;zrender/shape/Text&#x27;,[&#x27;require&#x27;,&#x27;../tool/area&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;],function (require) {
            var area = require(&#x27;../tool/area&#x27;);
            var Base = require(&#x27;./Base&#x27;);

            function Text(options) {
                Base.call(this, options);
            }

            Text.prototype =  {
                type: &#x27;text&#x27;,

                /**
                 * 画刷，重载基类方法
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param isHighlight 是否为高亮状态
                 */
                brush : function(ctx, isHighlight) {
                    var style = this.style;
                    if (isHighlight) {
                        // 根据style扩展默认高亮样式
                        style = this.getHighlightStyle(
                            style, this.highlightStyle || {}
                        );
                    }

                    if (typeof style.text == &#x27;undefined&#x27;) {
                        return;
                    }

                    ctx.save();
                    this.setContext(ctx, style);

                    // 设置transform
                    this.updateTransform(ctx);

                    if (style.textFont) {
                        ctx.font = style.textFont;
                    }
                    ctx.textAlign = style.textAlign || &#x27;start&#x27;;
                    ctx.textBaseline = style.textBaseline || &#x27;middle&#x27;;

                    var text = (style.text + &#x27;&#x27;).split(&#x27;\n&#x27;);
                    var lineHeight = area.getTextHeight(&#x27;国&#x27;, style.textFont);
                    var rect = this.getRect(style);
                    var x = style.x;
                    var y;
                    if (style.textBaseline == &#x27;top&#x27;) {
                        y = rect.y;
                    }
                    else if (style.textBaseline == &#x27;bottom&#x27;) {
                        y = rect.y + lineHeight;
                    }
                    else {
                        y = rect.y + lineHeight / 2;
                    }

                    for (var i = 0, l = text.length; i &lt; l; i++) {
                        if (style.maxWidth) {
                            switch (style.brushType) {
                                case &#x27;fill&#x27;:
                                    ctx.fillText(
                                        text[i],
                                        x, y, style.maxWidth
                                    );
                                    break;
                                case &#x27;stroke&#x27;:
                                    ctx.strokeText(
                                        text[i],
                                        x, y, style.maxWidth
                                    );
                                    break;
                                case &#x27;both&#x27;:
                                    ctx.fillText(
                                        text[i],
                                        x, y, style.maxWidth
                                    );
                                    ctx.strokeText(
                                        text[i],
                                        x, y, style.maxWidth
                                    );
                                    break;
                                default:
                                    ctx.fillText(
                                        text[i],
                                        x, y, style.maxWidth
                                    );
                            }
                        }
                        else{
                            switch (style.brushType) {
                                case &#x27;fill&#x27;:
                                    ctx.fillText(text[i], x, y);
                                    break;
                                case &#x27;stroke&#x27;:
                                    ctx.strokeText(text[i], x, y);
                                    break;
                                case &#x27;both&#x27;:
                                    ctx.fillText(text[i], x, y);
                                    ctx.strokeText(text[i], x, y);
                                    break;
                                default:
                                    ctx.fillText(text[i], x, y);
                            }
                        }
                        y += lineHeight;
                    }

                    ctx.restore();
                    return;
                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect : function(style) {
                    if (style.__rect) {
                        return style.__rect;
                    }

                    var width = area.getTextWidth(style.text, style.textFont);
                    var height = area.getTextHeight(style.text, style.textFont);

                    var textX = style.x;                 //默认start == left
                    if (style.textAlign == &#x27;end&#x27; || style.textAlign == &#x27;right&#x27;) {
                        textX -= width;
                    }
                    else if (style.textAlign == &#x27;center&#x27;) {
                        textX -= (width / 2);
                    }

                    var textY;
                    if (style.textBaseline == &#x27;top&#x27;) {
                        textY = style.y;
                    }
                    else if (style.textBaseline == &#x27;bottom&#x27;) {
                        textY = style.y - height;
                    }
                    else {
                        // middle
                        textY = style.y - height / 2;
                    }

                    style.__rect = {
                        x : textX,
                        y : textY,
                        width : width,
                        height : height
                    };

                    return style.__rect;
                }
            };

            require(&#x27;../tool/util&#x27;).inherits(Text, Base);
            return Text;
        }
    );

    /**
     * zrender
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com) ,
     *         strwind (@劲风FEI, yaofeifei@baidu.com)
     *
     * shape类：矩形
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;rectangle&#x27;,       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           x             : {number},  // 必须，左上角横坐标
           y             : {number},  // 必须，左上角纵坐标
           width         : {number},  // 必须，宽度
           height        : {number},  // 必须，高度
           radius        : {array},   // 默认为[0]，圆角 
           brushType     : {string},  // 默认为fill，绘画方式
                                      // fill(填充) | stroke(描边) | both(填充+描边)
           color         : {color},   // 默认为&#x27;#000&#x27;，填充颜色，支持rgba
           strokeColor   : {color},   // 默认为&#x27;#000&#x27;，描边颜色（轮廓），支持rgba
           lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

           opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
           shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
           shadowColor   : {color},   // 默认为&#x27;#000&#x27;，阴影色彩，支持rgba
           shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
           shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

           text          : {string},  // 默认为null，附加文本
           textFont      : {string},  // 默认为null，附加文本样式，eg:&#x27;bold 18px verdana&#x27;
           textPosition  : {string},  // 默认为top，附加文本位置。
                                      // inside | left | right | top | bottom
           textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                      // start | end | left | right | center
           textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                      // top | bottom | middle |
                                      // alphabetic | hanging | ideographic
           textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                      // &#x27;inside&#x27; ? &#x27;#fff&#x27; : color
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     例子：
     {
       shape  : &#x27;rectangle&#x27;,
       id     : &#x27;123456&#x27;,
       zlevel : 1,
       style  : {
           x : 200,
           y : 100,
           width : 150,
           height : 50,
           color : &#x27;#eee&#x27;,
           text : &#x27;Baidu&#x27;
       },
       myName : &#x27;kener&#x27;,  // 可自带任何有效自定义属性

       clickable : true,
       onClick : function(eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
     */
    define(
        &#x27;zrender/shape/Rectangle&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;],function (require) {
            var Base = require(&#x27;./Base&#x27;);

            function Rectangle(options) {
                Base.call(this, options);
            }

            Rectangle.prototype =  {
                type: &#x27;rectangle&#x27;,

                /**
                 * 绘制圆角矩形
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                _buildRadiusPath: function(ctx, style) {
                    //左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
                    //r缩写为1         相当于 [1, 1, 1, 1]
                    //r缩写为[1]       相当于 [1, 1, 1, 1]
                    //r缩写为[1, 2]    相当于 [1, 2, 1, 2]
                    //r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
                    var x = style.x;
                    var y = style.y;
                    var width = style.width;
                    var height = style.height;
                    var r = style.radius;
                    var r1;
                    var r2;
                    var r3;
                    var r4;

                    if(typeof r === &#x27;number&#x27;) {
                        r1 = r2 = r3 = r4 = r;
                    }
                    else if(r instanceof Array) {
                        if (r.length === 1) {
                            r1 = r2 = r3 = r4 = r[0];
                        }
                        else if(r.length === 2) {
                            r1 = r3 = r[0];
                            r2 = r4 = r[1];
                        }
                        else if(r.length === 3) {
                            r1 = r[0];
                            r2 = r4 = r[1];
                            r3 = r[2];
                        } else {
                            r1 = r[0];
                            r2 = r[1];
                            r3 = r[2];
                            r4 = r[3];
                        }
                    } else {
                        r1 = r2 = r3 = r4 = 0;
                    }
                    ctx.moveTo(x + r1, y);
                    ctx.lineTo(x + width - r2, y);
                    r2 !== 0 &amp;&amp; ctx.quadraticCurveTo(
                            x + width, y, x + width, y + r2
                    );
                    ctx.lineTo(x + width, y + height - r3);
                    r3 !== 0 &amp;&amp; ctx.quadraticCurveTo(
                            x + width, y + height, x + width - r3, y + height
                    );
                    ctx.lineTo(x + r4, y + height);
                    r4 !== 0 &amp;&amp; ctx.quadraticCurveTo(
                        x, y + height, x, y + height - r4
                    );
                    ctx.lineTo(x, y + r1);
                    r1 !== 0 &amp;&amp; ctx.quadraticCurveTo(x, y, x + r1, y);
                },

                /**
                 * 创建矩形路径
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                buildPath : function(ctx, style) {
                    if(!style.radius) {
                        ctx.moveTo(style.x, style.y);
                        ctx.lineTo(style.x + style.width, style.y);
                        ctx.lineTo(style.x + style.width, style.y + style.height);
                        ctx.lineTo(style.x, style.y + style.height);
                        ctx.lineTo(style.x, style.y);
                        //ctx.rect(style.x, style.y, style.width, style.height);
                    } else {
                        this._buildRadiusPath(ctx, style);
                    }
                    return;
                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect : function(style) {
                    if (style.__rect) {
                        return style.__rect;
                    }

                    var lineWidth;
                    if (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;fill&#x27;) {
                        lineWidth = style.lineWidth || 1;
                    }
                    else {
                        lineWidth = 0;
                    }
                    style.__rect = {
                        x : Math.round(style.x - lineWidth / 2),
                        y : Math.round(style.y - lineWidth / 2),
                        width : style.width + lineWidth,
                        height : style.height + lineWidth
                    };

                    return style.__rect;
                }
            };

            require(&#x27;../tool/util&#x27;).inherits(Rectangle, Base);
            return Rectangle;
        }
    );
    /**
     * zrender: loading特效类
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *         errorrik (errorrik@gmail.com)
     */

    define(
        &#x27;zrender/loadingEffect/Base&#x27;,[&#x27;require&#x27;,&#x27;../tool/util&#x27;,&#x27;../shape/Text&#x27;,&#x27;../shape/Rectangle&#x27;],function(require) {
            var util = require(&#x27;../tool/util&#x27;);
            var TextShape = require(&#x27;../shape/Text&#x27;);
            var RectangleShape = require(&#x27;../shape/Rectangle&#x27;);


            var DEFAULT_TEXT = &#x27;Loading...&#x27;;
            var DEFAULT_TEXT_FONT = &#x27;normal 16px Arial&#x27;;

            /**
             * @constructor
             *
             * @param {Object} options 选项
             * @param {color} options.backgroundColor 背景颜色
             * @param {Object} options.textStyle 文字样式，同shape/text.style
             * @param {number=} options.progress 进度参数，部分特效有用
             * @param {Object=} options.effect 特效参数，部分特效有用
             *
             * {
         *     effect,
         *     //loading话术
         *     text:&#x27;&#x27;,
         *     // 水平安放位置，默认为 &#x27;center&#x27;，可指定x坐标
         *     x:&#x27;center&#x27; || &#x27;left&#x27; || &#x27;right&#x27; || {number},
         *     // 垂直安放位置，默认为&#x27;top&#x27;，可指定y坐标
         *     y:&#x27;top&#x27; || &#x27;bottom&#x27; || {number},
         *
         *     textStyle:{
         *         textFont: &#x27;normal 20px Arial&#x27; || {textFont}, //文本字体
         *         color: {color}
         *     }
         * }
             */
            function Base(options) {
                this.setOptions(options);
            }

            /**
             * 创建loading文字图形
             *
             * @param {Object} textStyle 文字style，同shape/text.style
             */
            Base.prototype.createTextShape = function (textStyle) {
                return new TextShape({
                    highlightStyle : util.merge(
                        {
                            x : this.canvasWidth / 2,
                            y : this.canvasHeight / 2,
                            text : DEFAULT_TEXT,
                            textAlign : &#x27;center&#x27;,
                            textBaseline : &#x27;middle&#x27;,
                            textFont : DEFAULT_TEXT_FONT,
                            color: &#x27;#333&#x27;,
                            brushType : &#x27;fill&#x27;
                        },
                        textStyle,
                        true
                    )
                });
            };

            /**
             * 获取loading背景图形
             *
             * @param {color} color 背景颜色
             */
            Base.prototype.createBackgroundShape = function (color) {
                return new RectangleShape({
                    highlightStyle : {
                        x : 0,
                        y : 0,
                        width : this.canvasWidth,
                        height : this.canvasHeight,
                        brushType : &#x27;fill&#x27;,
                        color : color
                    }
                });
            };

            Base.prototype.start = function (painter) {
                this.canvasWidth = painter._width;
                this.canvasHeight = painter._height;

                function addShapeHandle(param) {
                    painter.storage.addHover(param);
                }
                function refreshHandle() {
                    painter.refreshHover();
                }
                this.loadingTimer = this._start(addShapeHandle, refreshHandle);
            };

            Base.prototype._start = function (/*addShapeHandle, refreshHandle*/) {
                return setInterval(function(){}, 10000);
            };

            Base.prototype.stop = function () {
                clearInterval(this.loadingTimer);
            };

            Base.prototype.setOptions = function (options) {
                this.options = options || {};
            };

            return Base;
        }
    );

    /**
     * zrender
     *
     * @author lang( shenyi01@baidu.com )
     *
     * shape类：图片
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;image&#x27;,       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           x             : {number},  // 必须，左上角横坐标
           y             : {number},  // 必须，左上角纵坐标
           width         : {number},  // 可选，宽度
           height        : {number},  // 可选，高度
           sx            : {number},  // 可选, 从图片中裁剪的x
           sy            : {number},  // 可选, 从图片中裁剪的y
           sWidth        : {number},  // 可选, 从图片中裁剪的宽度
           sHeight       : {number},  // 可选, 从图片中裁剪的高度
           image         : {string|Image} // 必须，图片url或者图片对象
           lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

           opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
           shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
           shadowColor   : {color},   // 默认为&#x27;#000&#x27;，阴影色彩，支持rgba
           shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
           shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

           text          : {string},  // 默认为null，附加文本
           textFont      : {string},  // 默认为null，附加文本样式，eg:&#x27;bold 18px verdana&#x27;
           textPosition  : {string},  // 默认为top，附加文本位置。
                                      // inside | left | right | top | bottom
           textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                      // start | end | left | right | center
           textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                      // top | bottom | middle |
                                      // alphabetic | hanging | ideographic
           textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                      // &#x27;inside&#x27; ? &#x27;#fff&#x27; : color
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     例子：
     {
       shape  : &#x27;image&#x27;,
       id     : &#x27;123456&#x27;,
       zlevel : 1,
       style  : {
           x : 200,
           y : 100,
           width : 150,
           height : 50,
           image : &#x27;tests.jpg&#x27;,
           text : &#x27;Baidu&#x27;
       },
       myName : &#x27;kener&#x27;,  // 可自带任何有效自定义属性

       clickable : true,
       onClick : function(eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
     */
    define(
        &#x27;zrender/shape/Image&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;],function (require) {
            var _cache = {};
            var _needsRefresh = [];
            var _refreshTimeout;

            var Base = require(&#x27;./Base&#x27;);

            function ZImage(options) {
                Base.call(this, options);
            }

            ZImage.prototype = {
                type: &#x27;image&#x27;,
                brush : function(ctx, isHighlight, refresh) {
                    var style = this.style || {};

                    if (isHighlight) {
                        // 根据style扩展默认高亮样式
                        style = this.getHighlightStyle(
                            style, this.highlightStyle || {}
                        );
                    }

                    var image = style.image;
                    var me = this;

                    if (typeof(image) === &#x27;string&#x27;) {
                        var src = image;
                        if (_cache[src]) {
                            image = _cache[src];
                        }
                        else {
                            image = new Image();//document.createElement(&#x27;image&#x27;);
                            image.onload = function(){
                                image.onload = null;
                                clearTimeout( _refreshTimeout );
                                _needsRefresh.push( me );
                                // 防止因为缓存短时间内触发多次onload事件
                                _refreshTimeout = setTimeout(function(){
                                    refresh &amp;&amp; refresh( _needsRefresh );
                                    // 清空needsRefresh
                                    _needsRefresh = [];
                                }, 10);
                            };
                            _cache[ src ] = image;

                            image.src = src;
                        }
                    }
                    if (image) {
                        //图片已经加载完成
                        if (window.ActiveXObject) {
                            if (image.readyState != &#x27;complete&#x27;) {
                                return;
                            }
                        }
                        else {
                            if (!image.complete) {
                                return;
                            }
                        }

                        ctx.save();
                        this.setContext(ctx, style);

                        // 设置transform
                        this.updateTransform(ctx);

                        var width = style.width || image.width;
                        var height = style.height || image.height;
                        var x = style.x;
                        var y = style.y;
                        if (style.sWidth &amp;&amp; style.sHeight) {
                            var sx = style.sx || 0;
                            var sy = style.sy || 0;
                            ctx.drawImage(
                                image,
                                sx, sy, style.sWidth, style.sHeight,
                                x, y, width, height
                            );
                        }
                        else if (style.sx &amp;&amp; style.sy) {
                            var sx = style.sx;
                            var sy = style.sy;
                            var sWidth = width - sx;
                            var sHeight = height - sy;
                            ctx.drawImage(
                                image,
                                sx, sy, sWidth, sHeight,
                                x, y, width, height
                            );
                        }
                        else {
                            ctx.drawImage(image, x, y, width, height);
                        }
                        // 如果没设置宽和高的话自动根据图片宽高设置
                        style.width = width;
                        style.height = height;
                        this.style.width = width;
                        this.style.height = height;


                        if (style.text) {
                            this.drawText(ctx, style, this.style);
                        }

                        ctx.restore();
                    }
                },

                /**
                 * 创建路径，用于判断hover时调用isPointInPath~
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                buildPath : function(ctx, style) {
                    ctx.rect(style.x, style.y, style.width, style.height);
                    return;
                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect : function(style) {
                    return {
                        x : style.x,
                        y : style.y,
                        width : style.width,
                        height : style.height
                    };
                }
            };

            require(&#x27;../tool/util&#x27;).inherits(ZImage, Base);
            return ZImage;
        }
    );

    /**
     * Painter绘图模块
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *         errorrik (errorrik@gmail.com)
     */
    define(
        &#x27;zrender/Painter&#x27;,[&#x27;require&#x27;,&#x27;./config&#x27;,&#x27;./tool/util&#x27;,&#x27;./tool/log&#x27;,&#x27;./loadingEffect/Base&#x27;,&#x27;./shape/Image&#x27;],function (require) {
            var config = require(&#x27;./config&#x27;);
            var util = require(&#x27;./tool/util&#x27;);
            var log = require(&#x27;./tool/log&#x27;);
            var BaseLoadingEffect = require(&#x27;./loadingEffect/Base&#x27;);

            // retina 屏幕优化
            var devicePixelRatio = window.devicePixelRatio || 1;
            var vmlCanvasManager = window.G_vmlCanvasManager;

            /**
             * 返回false的方法，用于避免页面被选中
             *
             * @inner
             */
            function returnFalse() {
                return false;
            }

            /**
             * 什么都不干的空方法
             *
             * @inner
             */
            function doNothing() {}

            /**
             * 绘图类 (V)
             *
             * @param {HTMLElement} root 绘图区域
             * @param {storage} storage Storage实例
             */
            function Painter(root, storage) {
                this.root = root;
                this.storage = storage;

                root.innerHTML = &#x27;&#x27;;
                this._width = this._getWidth(); // 宽，缓存记录
                this._height = this._getHeight(); // 高，缓存记录

                var domRoot = document.createElement(&#x27;div&#x27;);
                this._domRoot = domRoot;

                //domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
                domRoot.style.position = &#x27;relative&#x27;;
                domRoot.style.overflow = &#x27;hidden&#x27;;
                domRoot.style.width = this._width + &#x27;px&#x27;;
                domRoot.style.height = this._height + &#x27;px&#x27;;
                root.appendChild(domRoot);

                this._domList = {};       //canvas dom元素
                this._ctxList = {};       //canvas 2D context对象，与domList对应
                this._domListBack = {};
                this._ctxListBack = {};


                this._zLevelConfig = {}; // 每个zLevel 的配置，@config clearColor
                this._maxZlevel = storage.getMaxZlevel(); //最大zlevel，缓存记录
                // this._loadingTimer 

                this._loadingEffect = new BaseLoadingEffect({});
                this.shapeToImage = this._createShapeToImageProcessor();

                // 创建各层canvas
                // 背景
                this._domList.bg = createDom(&#x27;bg&#x27;, &#x27;div&#x27;, this);
                domRoot.appendChild(this._domList.bg);

                var canvasElem;
                var canvasCtx;

                // 实体
                for (var i = 0; i &lt;= this._maxZlevel; i++) {
                    canvasElem = createDom(i, &#x27;canvas&#x27;, this);
                    domRoot.appendChild(canvasElem);
                    this._domList[i] = canvasElem;
                    vmlCanvasManager &amp;&amp; vmlCanvasManager.initElement(canvasElem);

                    this._ctxList[i] = canvasCtx = canvasElem.getContext(&#x27;2d&#x27;);
                    if (devicePixelRatio != 1) {
                        canvasCtx.scale(devicePixelRatio, devicePixelRatio);
                    }
                }

                // 高亮
                canvasElem = createDom(&#x27;hover&#x27;, &#x27;canvas&#x27;, this);
                canvasElem.id = &#x27;_zrender_hover_&#x27;;
                domRoot.appendChild(canvasElem);
                this._domList.hover = canvasElem;
                vmlCanvasManager &amp;&amp; vmlCanvasManager.initElement(canvasElem);
                this._domList.hover.onselectstart = returnFalse;
                this._ctxList.hover = canvasCtx = canvasElem.getContext(&#x27;2d&#x27;);
                if (devicePixelRatio != 1) {
                    canvasCtx.scale(devicePixelRatio, devicePixelRatio);
                }
            }

            /**
             * 首次绘图，创建各种dom和context
             *
             * @param {Function=} callback 绘画结束后的回调函数
             */
            Painter.prototype.render = function (callback) {
                if (this.isLoading()) {
                    this.hideLoading();
                }

                //检查_maxZlevel是否变大，如是则同步创建需要的Canvas
                this._syncMaxZlevelCanvase();

                //清空已有内容，render默认为首次渲染
                this.clear();

                //升序遍历，shape上的zlevel指定绘画图层的z轴层叠
                this.storage.iterShape(
                    this._brush({ all : true }),
                    { normal: &#x27;up&#x27; }
                );

                // update到最新则清空标志位
                this.storage.clearChangedZlevel();

                if (typeof callback == &#x27;function&#x27;) {
                    callback();
                }

                return this;
            };

            /**
             * 刷新
             *
             * @param {Function=} callback 刷新结束后的回调函数
             */
            Painter.prototype.refresh = function (callback) {
                //检查_maxZlevel是否变大，如是则同步创建需要的Canvas
                this._syncMaxZlevelCanvase();

                //仅更新有修改的canvas
                var changedZlevel = this.storage.getChangedZlevel();
                //擦除有修改的canvas
                if (changedZlevel.all){
                    this.clear();
                }
                else {
                    for (var k in changedZlevel) {
                        if (this._ctxList[k]) {
                            this.clearLayer(k);
                        }
                    }
                }
                // 重绘内容，升序遍历，shape上的zlevel指定绘画图层的z轴层叠
                this.storage.iterShape(
                    this._brush(changedZlevel),
                    { normal: &#x27;up&#x27;}
                );

                // update到最新则清空标志位
                this.storage.clearChangedZlevel();

                if (typeof callback == &#x27;function&#x27;) {
                    callback();
                }

                return this;
            };

            /**
             * 视图更新
             *
             * @param {Array} shapeList 需要更新的图形元素列表
             * @param {Function} callback  视图更新后回调函数
             */
            Painter.prototype.update = function (shapeList, callback) {
                for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                    var shape = shapeList[i];
                    this.storage.mod(shape.id, shape);
                }

                this.refresh(callback);
                return this;
            };

            /**
             * 设置loading特效
             *
             * @param {Object} loadingEffect loading特效
             * @return {Painter}
             */
            Painter.prototype.setLoadingEffect = function (loadingEffect) {
                this._loadingEffect = loadingEffect;
                return this;
            };

            /**
             * 清除hover层外所有内容
             */
            Painter.prototype.clear = function () {
                for (var k in this._ctxList) {
                    if (k == &#x27;hover&#x27;) {
                        continue;
                    }

                    this.clearLayer(k);
                }

                return this;
            };

            /**
             * 修改指定zlevel的绘制参数
             */
            Painter.prototype.modLayer = function (zLevel, config) {
                if (config) {
                    var zLevelConfig = this._zLevelConfig;

                    if (!zLevelConfig[zLevel]) {
                        zLevelConfig[zLevel] = {};
                    }

                    util.merge(zLevelConfig[zLevel], config, true);
                }
            };

            /**
             * 刷新hover层
             */
            Painter.prototype.refreshHover = function () {
                var me = this;
                function brushHover(e) {
                    me._brushHover(e);
                }
                this.clearHover();
                this.storage.iterShape(brushHover, { hover: true });
                this.storage.delHover();

                return this;
            };

            /**
             * 清除hover层所有内容
             */
            Painter.prototype.clearHover = function () {
                var hover = this._ctxList &amp;&amp; this._ctxList.hover;
                hover &amp;&amp; hover.clearRect(
                    0, 0,
                        this._width * devicePixelRatio,
                        this._height * devicePixelRatio
                );

                return this;
            };

            /**
             * 显示loading
             *
             * @param {Object=} loadingEffect loading效果对象
             */
            Painter.prototype.showLoading = function (loadingEffect) {
                this._loadingEffect &amp;&amp; this._loadingEffect.stop();
                loadingEffect &amp;&amp; this.setLoadingEffect(loadingEffect);
                this._loadingEffect.start(this);
                this.loading = true;

                return this;
            };

            /**
             * loading结束
             */
            Painter.prototype.hideLoading = function () {
                this._loadingEffect.stop();

                this.clearHover();
                this.loading = false;
                return this;
            };

            /**
             * loading结束判断
             */
            Painter.prototype.isLoading = function () {
                return this.loading;
            };

            /**
             * 区域大小变化后重绘
             */
            Painter.prototype.resize = function () {
                var domRoot = this._domRoot;
                domRoot.style.display = &#x27;none&#x27;;

                var width = this._getWidth();
                var height = this._getHeight();

                domRoot.style.display = &#x27;&#x27;;

                // 优化没有实际改变的resize
                if (this._width != width || height != this._height){
                    this._width = width;
                    this._height = height;

                    domRoot.style.width = width + &#x27;px&#x27;;
                    domRoot.style.height = height + &#x27;px&#x27;;

                    for (var key in this._domList) {
                        var dom = this._domList[key];

                        dom.setAttribute(&#x27;width&#x27;, width);
                        dom.setAttribute(&#x27;height&#x27;, height);
                        dom.style.width = width + &#x27;px&#x27;;
                        dom.style.height = height + &#x27;px&#x27;;
                    }

                    this.storage.setChangedZlevle(&#x27;all&#x27;);
                    this.refresh();
                }

                return this;
            };

            /**
             * 清除单独的一个层
             */
            Painter.prototype.clearLayer = function (k) {
                if (!this._ctxList[k]) {
                    return;
                }
                var zLevelConfigK = this._zLevelConfig[k];

                if (zLevelConfigK) {
                    var haveClearColor = typeof(zLevelConfigK.clearColor) !== &#x27;undefined&#x27;;
                    var haveMotionBLur = zLevelConfigK.motionBlur;
                    var lastFrameAlpha = zLevelConfigK.lastFrameAlpha;
                    if (typeof(lastFrameAlpha) == &#x27;undefined&#x27;) {
                        lastFrameAlpha = 0.7;
                    }

                    var canvasElem = this._domList[k];
                    if (haveMotionBLur) {
                        if (typeof this._domListBack[k] === &#x27;undefined&#x27;) {
                            var backDom = createDom(&#x27;back-&#x27; + k, &#x27;canvas&#x27;, this);
                            backDom.width = canvasElem.width;
                            backDom.height = canvasElem.height;
                            backDom.style.width = canvasElem.style.width;
                            backDom.style.height = canvasElem.style.height;
                            this._domListBack[k] = backDom;
                            this._ctxListBack[k] = backDom.getContext(&#x27;2d&#x27;);
                            devicePixelRatio != 1
                            &amp;&amp; this._ctxListBack[k].scale(
                                devicePixelRatio, devicePixelRatio
                            );
                        }
                        this._ctxListBack[k].globalCompositeOperation = &#x27;copy&#x27;;
                        this._ctxListBack[k].drawImage(
                            canvasElem, 0, 0,
                                canvasElem.width / devicePixelRatio,
                                canvasElem.height / devicePixelRatio
                        );
                    }

                    var canvasCtx = this._ctxList[k];
                    if (haveClearColor) {
                        canvasCtx.save();
                        canvasCtx.fillStyle = zLevelConfigK.clearColor;
                        canvasCtx.fillRect(
                            0, 0,
                                this._width * devicePixelRatio,
                                this._height * devicePixelRatio
                        );
                        canvasCtx.restore();
                    }
                    else {
                        canvasCtx.clearRect(
                            0, 0,
                                this._width * devicePixelRatio,
                                this._height * devicePixelRatio
                        );
                    }

                    if (haveMotionBLur) {
                        var backDom = this._domListBack[k];
                        canvasCtx.save();
                        canvasCtx.globalAlpha = lastFrameAlpha;
                        canvasCtx.drawImage(
                            backDom, 0, 0,
                                backDom.width / devicePixelRatio,
                                backDom.height / devicePixelRatio
                        );
                        canvasCtx.restore();
                    }
                }
                else {
                    this._ctxList[k].clearRect(
                        0, 0,
                            this._width * devicePixelRatio,
                            this._height * devicePixelRatio
                    );
                }
            };

            /**
             * 释放
             */
            Painter.prototype.dispose = function () {
                if (this.isLoading()) {
                    this.hideLoading();
                }

                this.root.innerHTML = &#x27;&#x27;;

                this.root =
                    this.storage =

                        this._domRoot =
                            this._domList =
                                this._ctxList =

                                    this._ctxListBack =
                                        this._domListBack = null;
            };

            Painter.prototype.getDomHover = function () {
                return this._domList.hover;
            };

            Painter.prototype.toDataURL = function (type, backgroundColor, args) {
                if (vmlCanvasManager) {
                    return null;
                }

                var imageDom = createDom(&#x27;image&#x27;, &#x27;canvas&#x27;, this);
                this._domList.bg.appendChild(imageDom);
                var ctx = imageDom.getContext(&#x27;2d&#x27;);
                devicePixelRatio != 1
                &amp;&amp; ctx.scale(devicePixelRatio, devicePixelRatio);

                ctx.fillStyle = backgroundColor || &#x27;#fff&#x27;;
                ctx.rect(
                    0, 0,
                        this._width * devicePixelRatio,
                        this._height * devicePixelRatio
                );
                ctx.fill();

                //升序遍历，shape上的zlevel指定绘画图层的z轴层叠
                var me = this;
                function updatePainter(shapeList, callback) {
                    me.update(shapeList, callback);
                }
                this.storage.iterShape(
                    function (shape) {
                        if (!shape.invisible) {
                            if (!shape.onbrush //没有onbrush
                                //有onbrush并且调用执行返回false或undefined则继续粉刷
                                || (shape.onbrush &amp;&amp; !shape.onbrush(ctx, false))
                                ) {
                                if (config.catchBrushException) {
                                    try {
                                        shape.brush(ctx, false, updatePainter);
                                    }
                                    catch(error) {
                                        log(
                                            error,
                                                &#x27;brush error of &#x27; + shape.type,
                                            shape
                                        );
                                    }
                                }
                                else {
                                    shape.brush(ctx, false, updatePainter);
                                }
                            }
                        }
                    },
                    { normal: &#x27;up&#x27; }
                );
                var image = imageDom.toDataURL(type, args);
                ctx = null;
                this._domList.bg.removeChild(imageDom);
                return image;
            };

            /**
             * 获取绘图区域宽度
             */
            Painter.prototype.getWidth = function () {
                return this._width;
            };

            /**
             * 获取绘图区域高度
             */
            Painter.prototype.getHeight = function () {
                return this._height;
            };

            Painter.prototype._getWidth = function() {
                var root = this.root;
                var stl = root.currentStyle
                    || document.defaultView.getComputedStyle(root);

                return ((root.clientWidth || parseInt(stl.width, 10))
                    - parseInt(stl.paddingLeft, 10) // 请原谅我这比较粗暴
                    - parseInt(stl.paddingRight, 10)).toFixed(0) - 0;
            };

            Painter.prototype._getHeight = function () {
                var root = this.root;
                var stl = root.currentStyle
                    || document.defaultView.getComputedStyle(root);

                return ((root.clientHeight || parseInt(stl.height, 10))
                    - parseInt(stl.paddingTop, 10) // 请原谅我这比较粗暴
                    - parseInt(stl.paddingBottom, 10)).toFixed(0) - 0;
            };

            /**
             * 检查_maxZlevel是否变大，如是则同步创建需要的Canvas
             *
             * @private
             */
            Painter.prototype._syncMaxZlevelCanvase = function () {
                var curMaxZlevel = this.storage.getMaxZlevel();
                if (this._maxZlevel &lt; curMaxZlevel) {
                    //实体
                    for (var i = this._maxZlevel + 1; i &lt;= curMaxZlevel; i++) {
                        var canvasElem = createDom(i, &#x27;canvas&#x27;, this);
                        this._domList[i] = canvasElem;
                        this._domRoot.insertBefore(canvasElem, this._domList.hover);
                        if (vmlCanvasManager) {
                            vmlCanvasManager.initElement(canvasElem);
                        }

                        var canvasCtx = canvasElem.getContext(&#x27;2d&#x27;);
                        this._ctxList[i] = canvasCtx;
                        if (devicePixelRatio != 1) {
                            canvasCtx.scale(devicePixelRatio, devicePixelRatio);
                        }
                    }
                    this._maxZlevel = curMaxZlevel;
                }
            };

            /**
             * 刷画图形
             *
             * @private
             * @param {Object} changedZlevel 需要更新的zlevel索引
             */
            Painter.prototype._brush = function (changedZlevel) {
                var ctxList = this._ctxList;
                var me = this;
                function updatePainter(shapeList, callback) {
                    me.update(shapeList, callback);
                }

                return function(shape) {
                    if ((changedZlevel.all || changedZlevel[shape.zlevel])
                        &amp;&amp; !shape.invisible
                        ) {
                        var ctx = ctxList[shape.zlevel];
                        if (ctx) {
                            if (!shape.onbrush //没有onbrush
                                //有onbrush并且调用执行返回false或undefined则继续粉刷
                                || (shape.onbrush &amp;&amp; !shape.onbrush(ctx, false))
                                ) {
                                if (config.catchBrushException) {
                                    try {
                                        shape.brush(ctx, false, updatePainter);
                                    }
                                    catch(error) {
                                        log(
                                            error,
                                                &#x27;brush error of &#x27; + shape.type,
                                            shape
                                        );
                                    }
                                }
                                else {
                                    shape.brush(ctx, false, updatePainter);
                                }
                            }
                        }
                        else {
                            log(
                                &#x27;can not find the specific zlevel canvas!&#x27;
                            );
                        }
                    }
                };
            };

            /**
             * 鼠标悬浮刷画
             */
            Painter.prototype._brushHover = function (shape) {
                var ctx = this._ctxList.hover;
                var me = this;
                function updatePainter(shapeList, callback) {
                    me.update(shapeList, callback);
                }

                if (!shape.onbrush //没有onbrush
                    //有onbrush并且调用执行返回false或undefined则继续粉刷
                    || (shape.onbrush &amp;&amp; !shape.onbrush(ctx, true))
                    ) {
                    // Retina 优化
                    if (config.catchBrushException) {
                        try {
                            shape.brush(ctx, true, updatePainter);
                        }
                        catch(error) {
                            log(
                                error, &#x27;hoverBrush error of &#x27; + shape.type, shape
                            );
                        }
                    }
                    else {
                        shape.brush(ctx, true, updatePainter);
                    }
                }
            };

            Painter.prototype._shapeToImage = function (
                id, shape, width, height,
                canvas, ctx, devicePixelRatio
                ) {
                canvas.style.width = width + &#x27;px&#x27;;
                canvas.style.height = height + &#x27;px&#x27;;
                canvas.setAttribute(&#x27;width&#x27;, width * devicePixelRatio);
                canvas.setAttribute(&#x27;height&#x27;, height * devicePixelRatio);

                ctx.clearRect(0, 0, width * devicePixelRatio, height * devicePixelRatio);

                var shapeTransform = {
                    position : shape.position,
                    rotation : shape.rotation,
                    scale : shape.scale
                };
                shape.position = [0, 0, 0];
                shape.rotation = 0;
                shape.scale = [1, 1];
                if (shape) {
                    shape.brush(ctx, false);
                }

                var ImageShape = require( &#x27;./shape/Image&#x27; );
                var imgShape = new ImageShape({
                    id : id,
                    style : {
                        x : 0,
                        y : 0,
                        // TODO 直接使用canvas而不是通过base64
                        image : canvas.toDataURL()
                    }
                });

                if (shapeTransform.position != null) {
                    imgShape.position = shape.position = shapeTransform.position;
                }

                if (shapeTransform.rotation != null) {
                    imgShape.rotation = shape.rotation = shapeTransform.rotation;
                }

                if (shapeTransform.scale != null) {
                    imgShape.scale = shape.scale = shapeTransform.scale;
                }

                return imgShape;
            };

            Painter.prototype._createShapeToImageProcessor = function () {
                if (vmlCanvasManager) {
                    return doNothing;
                }

                var painter = this;
                var canvas = document.createElement(&#x27;canvas&#x27;);
                var ctx = canvas.getContext(&#x27;2d&#x27;);
                var devicePixelRatio = window.devicePixelRatio || 1;

                return function (id, e, width, height) {
                    return painter._shapeToImage(
                        id, e, width, height,
                        canvas, ctx, devicePixelRatio
                    );
                };
            };

            /**
             * 创建dom
             *
             * @inner
             * @param {string} id dom id 待用
             * @param {string} type dom type，such as canvas, div etc.
             * @param {Painter} painter painter instance
             */
            function createDom(id, type, painter) {
                var newDom = document.createElement(type);
                var width = painter._width;
                var height = painter._height;

                // 没append呢，请原谅我这样写，清晰~
                newDom.style.position = &#x27;absolute&#x27;;
                newDom.style.left = 0;
                newDom.style.top = 0;
                newDom.style.width = width + &#x27;px&#x27;;
                newDom.style.height = height + &#x27;px&#x27;;
                newDom.setAttribute(&#x27;width&#x27;, width * devicePixelRatio);
                newDom.setAttribute(&#x27;height&#x27;, height * devicePixelRatio);

                // id不作为索引用，避免可能造成的重名，定义为私有属性
                newDom.setAttribute(&#x27;data-zr-dom-id&#x27;, id);
                return newDom;
            }

            return Painter;
        }
    );

    /**
     * Storage内容仓库模块
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *         errorrik (errorrik@gmail.com)
     */
    define(
        &#x27;zrender/Storage&#x27;,[&#x27;require&#x27;,&#x27;./tool/util&#x27;,&#x27;./tool/log&#x27;,&#x27;./config&#x27;],function (require) {
            var util = require(&#x27;./tool/util&#x27;);
            var log = require(&#x27;./tool/log&#x27;);
            var config = require(&#x27;./config&#x27;);

            /**
             * 内容仓库 (M)
             *
             */
            function Storage() {
                // 所有常规形状，id索引的map
                this._elements = {};

                // 所有形状的z轴方向排列，提高遍历性能，zElements[0]的形状在zElements[1]形状下方
                this._zElements = [];

                // 高亮层形状，不稳定，动态增删，数组位置也是z轴方向，靠前显示在下方
                this._hoverElements = [];

                // 最大zlevel
                this._maxZlevel = 0;

                // 有数据改变的zlevel
                this._changedZlevel = {};
            }

            /**
             * 遍历迭代器
             *
             * @param {Function} fun 迭代回调函数，return true终止迭代
             * @param {Object=} option 迭代参数，缺省为仅降序遍历常规形状
             *     hover : true 是否迭代高亮层数据
             *     normal : &#x27;down&#x27; | &#x27;up&#x27; | &#x27;free&#x27; 是否迭代常规数据，迭代时是否指定及z轴顺序
             */
            Storage.prototype.iterShape = function (fun, option) {
                if (!option) {
                    option = {
                        hover: false,
                        normal: &#x27;down&#x27;
                    };
                }
                if (option.hover) {
                    //高亮层数据遍历
                    for (var i = 0, l = this._hoverElements.length; i &lt; l; i++) {
                        if (fun(this._hoverElements[i])) {
                            return this;
                        }
                    }
                }

                var zlist;
                var len;
                if (typeof option.normal != &#x27;undefined&#x27;) {
                    //z轴遍历: &#x27;down&#x27; | &#x27;up&#x27; | &#x27;free&#x27;
                    switch (option.normal) {
                        case &#x27;down&#x27;:
                            // 降序遍历，高层优先
                            var l = this._zElements.length;
                            while (l--) {
                                zlist = this._zElements[l];
                                if (zlist) {
                                    len = zlist.length;
                                    while (len--) {
                                        if (fun(zlist[len])) {
                                            return this;
                                        }
                                    }
                                }
                            }
                            break;
                        case &#x27;up&#x27;:
                            //升序遍历，底层优先
                            for (var i = 0, l = this._zElements.length; i &lt; l; i++) {
                                zlist = this._zElements[i];
                                if (zlist) {
                                    len = zlist.length;
                                    for (var k = 0; k &lt; len; k++) {
                                        if (fun(zlist[k])) {
                                            return this;
                                        }
                                    }
                                }
                            }
                            break;
                        // case &#x27;free&#x27;:
                        default:
                            //无序遍历
                            for (var i in this._elements) {
                                if (fun(this._elements[i])) {
                                    return this;
                                }
                            }
                            break;
                    }
                }

                return this;
            };

            /**
             * 修改
             *
             * @param {string} idx 唯一标识
             * @param {Object} params 参数
             */
            Storage.prototype.mod = function (shapeId, params) {
                var shape = this._elements[shapeId];
                if (shape) {
                    shape.updateNeedTransform();
                    shape.style.__rect = null;

                    this._changedZlevel[shape.zlevel] = true;    // 可能修改前后不在一层
                    if (params) {
                        util.merge(shape, params, true);
                    }

                    this._changedZlevel[shape.zlevel] = true;    // 可能修改前后不在一层
                    this._maxZlevel = Math.max(this._maxZlevel, shape.zlevel);
                }

                return this;
            };

            /**
             * 常规形状位置漂移，形状自身定义漂移函数
             *
             * @param {string} idx 形状唯一标识
             */
            Storage.prototype.drift = function (shapeId, dx, dy) {
                var shape = this._elements[shapeId];

                if (shape) {
                    shape.needTransform = true;
                    if (!shape.ondrift //ondrift
                        //有onbrush并且调用执行返回false或undefined则继续
                        || (shape.ondrift &amp;&amp; !shape.ondrift(dx, dy))
                        ) {
                        if (config.catchBrushException) {
                            try {
                                shape.drift(dx, dy);
                            }
                            catch(error) {
                                log(error, &#x27;drift error of &#x27; + shape.type, shape);
                            }
                        }
                        else {
                            shape.drift(dx, dy);
                        }
                    }

                    this._changedZlevel[shape.zlevel] = true;
                }

                return this;
            };

            /**
             * 添加高亮层数据
             *
             * @param {Object} params 参数
             */
            Storage.prototype.addHover = function (params) {
                if ((params.rotation &amp;&amp; Math.abs(params.rotation[0]) &gt; 0.0001)
                    || (params.position
                        &amp;&amp; (Math.abs(params.position[0]) &gt; 0.0001
                            || Math.abs(params.position[1]) &gt; 0.0001))
                    || (params.scale
                        &amp;&amp; (Math.abs(params.scale[0] - 1) &gt; 0.0001
                            || Math.abs(params.scale[1] - 1) &gt; 0.0001))
                    ) {
                    params.needTransform = true;
                }
                else {
                    params.needTransform = false;
                }

                this._hoverElements.push(params);
                return this;
            };

            /**
             * 删除高亮层数据
             */
            Storage.prototype.delHover = function () {
                this._hoverElements = [];
                return this;
            };

            Storage.prototype.hasHoverShape = function () {
                return this._hoverElements.length &gt; 0;
            };

            /**
             * 添加
             *
             * @param {Shape} shape 参数
             */
            Storage.prototype.add = function (shape) {
                shape.updateNeedTransform();
                shape.style.__rect = null;
                this._elements[shape.id] = shape;
                this._zElements[shape.zlevel] = this._zElements[shape.zlevel] || [];
                this._zElements[shape.zlevel].push(shape);

                this._maxZlevel = Math.max(this._maxZlevel, shape.zlevel);
                this._changedZlevel[shape.zlevel] = true;

                return this;
            };

            /**
             * 根据指定的shapeId获取相应的shape属性
             *
             * @param {string=} idx 唯一标识
             */
            Storage.prototype.get = function (shapeId) {
                return this._elements[shapeId];
            };

            /**
             * 删除，shapeId不指定则全清空
             *
             * @param {string= | Array} idx 唯一标识
             */
            Storage.prototype.del = function (shapeId) {
                if (typeof shapeId != &#x27;undefined&#x27;) {
                    var delMap = {};
                    if (!(shapeId instanceof Array)) {
                        // 单个
                        delMap[shapeId] = true;
                    }
                    else {
                        // 批量删除
                        if (shapeId.lenth &lt; 1) { // 空数组
                            return;
                        }
                        for (var i = 0, l = shapeId.length; i &lt; l; i++) {
                            delMap[shapeId[i].id] = true;
                        }
                    }
                    var newList;
                    var oldList;
                    var zlevel;
                    var zChanged = {};
                    for (var sId in delMap) {
                        if (this._elements[sId]) {
                            zlevel = this._elements[sId].zlevel;
                            this._changedZlevel[zlevel] = true;
                            if (!zChanged[zlevel]) {
                                oldList = this._zElements[zlevel];
                                newList = [];
                                for (var i = 0, l = oldList.length; i &lt; l; i++){
                                    if (!delMap[oldList[i].id]) {
                                        newList.push(oldList[i]);
                                    }
                                }
                                this._zElements[zlevel] = newList;
                                zChanged[zlevel] = true;
                            }

                            delete this._elements[sId];
                        }
                    }
                }
                else{
                    // 不指定shapeId清空
                    this._elements = {};
                    this._zElements = [];
                    this._hoverElements = [];
                    this._maxZlevel = 0;         //最大zlevel
                    this._changedZlevel = {      //有数据改变的zlevel
                        all : true
                    };
                }

                return this;
            };

            Storage.prototype.getMaxZlevel = function () {
                return this._maxZlevel;
            };

            Storage.prototype.getChangedZlevel = function () {
                return this._changedZlevel;
            };

            Storage.prototype.clearChangedZlevel = function () {
                this._changedZlevel = {};
                return this;
            };

            Storage.prototype.setChangedZlevle = function (level) {
                this._changedZlevel[level] = true;
                return this;
            };

            /**
             * 释放
             */
            Storage.prototype.dispose = function () {
                this._elements =
                    this._zElements =
                        this._hoverElements = null;
            };

            return Storage;
        }
    );

    /**
     * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
     * author: lang(shenyi01@baidu.com)
     */
    define(
        &#x27;zrender/animation/easing&#x27;,[],function() {
            var Easing = {
                // 线性
                Linear: function(k) {
                    return k;
                },

                // 二次方的缓动（t^2）
                QuadraticIn: function(k) {
                    return k * k;
                },
                QuadraticOut: function(k) {
                    return k * (2 - k);
                },
                QuadraticInOut: function(k) {
                    if ((k *= 2) &lt; 1) {
                        return 0.5 * k * k;
                    }
                    return - 0.5 * (--k * (k - 2) - 1);
                },

                // 三次方的缓动（t^3）
                CubicIn: function(k) {
                    return k * k * k;
                },
                CubicOut: function(k) {
                    return --k * k * k + 1;
                },
                CubicInOut: function(k) {
                    if ((k *= 2) &lt; 1) {
                        return 0.5 * k * k * k;
                    }
                    return 0.5 * ((k -= 2) * k * k + 2);
                },

                // 四次方的缓动（t^4）
                QuarticIn: function(k) {
                    return k * k * k * k;
                },
                QuarticOut: function(k) {
                    return 1 - (--k * k * k * k);
                },
                QuarticInOut: function(k) {
                    if ((k *= 2) &lt; 1) {
                        return 0.5 * k * k * k * k;
                    }
                    return - 0.5 * ((k -= 2) * k * k * k - 2);
                },

                // 五次方的缓动（t^5）
                QuinticIn: function(k) {
                    return k * k * k * k * k;
                },

                QuinticOut: function(k) {
                    return --k * k * k * k * k + 1;
                },
                QuinticInOut: function(k) {
                    if ((k *= 2) &lt; 1) {
                        return 0.5 * k * k * k * k * k;
                    }
                    return 0.5 * ((k -= 2) * k * k * k * k + 2);
                },

                // 正弦曲线的缓动（sin(t)）
                SinusoidalIn: function(k) {
                    return 1 - Math.cos(k * Math.PI / 2);
                },
                SinusoidalOut: function(k) {
                    return Math.sin(k * Math.PI / 2);
                },
                SinusoidalInOut: function(k) {
                    return 0.5 * (1 - Math.cos(Math.PI * k));
                },

                // 指数曲线的缓动（2^t）
                ExponentialIn: function(k) {
                    return k === 0 ? 0 : Math.pow(1024, k - 1);
                },
                ExponentialOut: function(k) {
                    return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);
                },
                ExponentialInOut: function(k) {
                    if (k === 0) {
                        return 0;
                    }
                    if (k === 1) {
                        return 1;
                    }
                    if ((k *= 2) &lt; 1) {
                        return 0.5 * Math.pow(1024, k - 1);
                    }
                    return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);
                },

                // 圆形曲线的缓动（sqrt(1-t^2)）
                CircularIn: function(k) {
                    return 1 - Math.sqrt(1 - k * k);
                },
                CircularOut: function(k) {
                    return Math.sqrt(1 - (--k * k));
                },
                CircularInOut: function(k) {
                    if ((k *= 2) &lt; 1) {
                        return - 0.5 * (Math.sqrt(1 - k * k) - 1);
                    }
                    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
                },

                // 创建类似于弹簧在停止前来回振荡的动画
                ElasticIn: function(k) {
                    var s, a = 0.1, p = 0.4;
                    if (k === 0) {
                        return 0;
                    }
                    if (k === 1) {
                        return 1;
                    }
                    if (!a || a &lt; 1) {
                        a = 1; s = p / 4;
                    }else{
                        s = p * Math.asin(1 / a) / (2 * Math.PI);
                    }
                    return - (a * Math.pow(2, 10 * (k -= 1)) *
                        Math.sin((k - s) * (2 * Math.PI) / p));
                },
                ElasticOut: function(k) {
                    var s, a = 0.1, p = 0.4;
                    if (k === 0) {
                        return 0;
                    }
                    if (k === 1) {
                        return 1;
                    }
                    if (!a || a &lt; 1) {
                        a = 1; s = p / 4;
                    }
                    else{
                        s = p * Math.asin(1 / a) / (2 * Math.PI);
                    }
                    return (a * Math.pow(2, - 10 * k) *
                        Math.sin((k - s) * (2 * Math.PI) / p) + 1);
                },
                ElasticInOut: function(k) {
                    var s, a = 0.1, p = 0.4;
                    if (k === 0) {
                        return 0;
                    }
                    if (k === 1) {
                        return 1;
                    }
                    if (!a || a &lt; 1) {
                        a = 1; s = p / 4;
                    }
                    else{
                        s = p * Math.asin(1 / a) / (2 * Math.PI);
                    }
                    if ((k *= 2) &lt; 1) {
                        return - 0.5 * (a * Math.pow(2, 10 * (k -= 1))
                            * Math.sin((k - s) * (2 * Math.PI) / p));
                    }
                    return a * Math.pow(2, -10 * (k -= 1))
                        * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;

                },

                // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
                BackIn: function(k) {
                    var s = 1.70158;
                    return k * k * ((s + 1) * k - s);
                },
                BackOut: function(k) {
                    var s = 1.70158;
                    return --k * k * ((s + 1) * k + s) + 1;
                },
                BackInOut: function(k) {
                    var s = 1.70158 * 1.525;
                    if ((k *= 2) &lt; 1) {
                        return 0.5 * (k * k * ((s + 1) * k - s));
                    }
                    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
                },

                // 创建弹跳效果
                BounceIn: function(k) {
                    return 1 - Easing.BounceOut(1 - k);
                },
                BounceOut: function(k) {
                    if (k &lt; (1 / 2.75)) {
                        return 7.5625 * k * k;
                    }
                    else if (k &lt; (2 / 2.75)) {
                        return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
                    } else if (k &lt; (2.5 / 2.75)) {
                        return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
                    } else {
                        return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
                    }
                },
                BounceInOut: function(k) {
                    if (k &lt; 0.5) {
                        return Easing.BounceIn(k * 2) * 0.5;
                    }
                    return Easing.BounceOut(k * 2 - 1) * 0.5 + 0.5;
                }
            };

            return Easing;
        }
    );


    /**
     * 动画主控制器
     * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
     * @config life(1000) 动画时长
     * @config delay(0) 动画延迟时间
     * @config loop(true)
     * @config gap(0) 循环的间隔时间
     * @config onframe
     * @config easing(optional)
     * @config ondestroy(optional)
     * @config onrestart(optional)
     */
    define(
        &#x27;zrender/animation/clip&#x27;,[&#x27;require&#x27;,&#x27;./easing&#x27;],function(require) {

            var Easing = require(&#x27;./easing&#x27;);

            function Clip(options) {

                this._targetPool = options.target || {};
                if (!(this._targetPool instanceof Array)) {
                    this._targetPool = [this._targetPool];
                }

                //生命周期
                this._life = options.life || 1000;
                //延时
                this._delay = options.delay || 0;
                //开始时间
                this._startTime = new Date().getTime() + this._delay;//单位毫秒

                //结束时间
                this._endTime = this._startTime + this._life * 1000;

                //是否循环
                this.loop = typeof options.loop == &#x27;undefined&#x27; ? false : options.loop;

                this.gap = options.gap || 0;

                this.easing = options.easing || &#x27;Linear&#x27;;

                this.onframe = options.onframe;
                this.ondestroy = options.ondestroy;
                this.onrestart = options.onrestart;
            }

            Clip.prototype = {
                step : function (time) {
                    var percent = (time - this._startTime) / this._life;

                    //还没开始
                    if (percent &lt; 0) {
                        return;
                    }

                    percent = Math.min(percent, 1);

                    var easingFunc = typeof this.easing == &#x27;string&#x27;
                        ? Easing[this.easing]
                        : this.easing;
                    var schedule = typeof easingFunc === &#x27;function&#x27;
                        ? easingFunc(percent)
                        : percent;

                    this.fire(&#x27;frame&#x27;, schedule);

                    // 结束
                    if (percent == 1) {
                        if (this.loop) {
                            this.restart();
                            // 重新开始周期
                            // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
                            return &#x27;restart&#x27;;

                        }

                        // 动画完成将这个控制器标识为待删除
                        // 在Animation.update中进行批量删除
                        this._needsRemove = true;
                        return &#x27;destroy&#x27;;
                    }

                    return null;
                },
                restart : function() {
                    var time = new Date().getTime();
                    var remainder = (time - this._startTime) % this._life;
                    this._startTime = new Date().getTime() - remainder + this.gap;
                },
                fire : function(eventType, arg) {
                    for (var i = 0, len = this._targetPool.length; i &lt; len; i++) {
                        if (this[&#x27;on&#x27; + eventType]) {
                            this[&#x27;on&#x27; + eventType](this._targetPool[i], arg);
                        }
                    }
                },
                constructor: Clip
            };

            return Clip;
        }
    );

    /**
     * 动画主类, 调度和管理所有动画控制器
     *
     * @author pissang(https://github.com/pissang)
     *
     * @class : Animation
     * @config : stage(optional) 绘制类, 需要提供update接口
     * @config : onframe(optional)
     * @method : add
     * @method : remove
     * @method : update
     * @method : start
     * @method : stop
     */
    define(
        &#x27;zrender/animation/animation&#x27;,[&#x27;require&#x27;,&#x27;./clip&#x27;,&#x27;../tool/color&#x27;],function(require) {



            var Clip = require(&#x27;./clip&#x27;);
            var color = require(&#x27;../tool/color&#x27;);

            var requestAnimationFrame = window.requestAnimationFrame
                || window.msRequestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.webkitRequestAnimationFrame
                || function(func){setTimeout(func, 16);};

            var arraySlice = Array.prototype.slice;

            function Animation(options) {

                options = options || {};

                this.stage = options.stage || {};

                this.onframe = options.onframe || function() {};

                // private properties
                this._clips = [];

                this._running = false;

                this._time = 0;
            }

            Animation.prototype = {
                add : function(clip) {
                    this._clips.push(clip);
                },
                remove : function(clip) {
                    var idx = this._clips.indexOf(clip);
                    if (idx &gt;= 0) {
                        this._clips.splice(idx, 1);
                    }
                },
                update : function() {

                    var time = new Date().getTime();
                    var delta = time - this._time;
                    var clips = this._clips;
                    var len = clips.length;

                    var deferredEvents = [];
                    var deferredClips = [];
                    for (var i = 0; i &lt; len; i++) {
                        var clip = clips[i];
                        var e = clip.step(time);
                        // Throw out the events need to be called after
                        // stage.update, like destroy
                        if (e) {
                            deferredEvents.push(e);
                            deferredClips.push(clip);
                        }
                    }
                    if (this.stage.update &amp;&amp; this._clips.length) {
                        this.stage.update();
                    }

                    // Remove the finished clip
                    for (var i = 0; i &lt; len;) {
                        if (clips[i]._needsRemove) {
                            clips[i] = clips[len-1];
                            clips.pop();
                            len--;
                        } else {
                            i++;
                        }
                    }

                    len = deferredEvents.length;
                    for (var i = 0; i &lt; len; i++) {
                        deferredClips[i].fire(deferredEvents[i]);
                    }

                    this._time = time;

                    this.onframe(delta);

                },
                start : function() {
                    var self = this;

                    this._running = true;

                    function step() {
                        if (self._running) {
                            self.update();
                            requestAnimationFrame(step);
                        }
                    }

                    requestAnimationFrame(step);
                },
                stop : function() {
                    this._running = false;
                },
                clear : function() {
                    this._clips = [];
                },
                animate : function(target, options) {
                    options = options || {};
                    var deferred = new Deferred(
                        target,
                        options.loop,
                        options.getter,
                        options.setter
                    );
                    deferred.animation = this;
                    return deferred;
                },
                constructor: Animation
            };

            function _defaultGetter(target, key) {
                return target[key];
            }

            function _defaultSetter(target, key, value) {
                target[key] = value;
            }

            function _interpolateNumber(p0, p1, percent) {
                return (p1 - p0) * percent + p0;
            }

            function _interpolateArray(p0, p1, percent, out, arrDim) {
                var len = p0.length;
                if (arrDim == 1) {
                    for (var i = 0; i &lt; len; i++) {
                        out[i] = _interpolateNumber(p0[i], p1[i], percent);
                    }
                } else {
                    var len2 = p0[0].length;
                    for (var i = 0; i &lt; len; i++) {
                        for (var j = 0; j &lt; len2; j++) {
                            out[i][j] = _interpolateNumber(
                                p0[i][j], p1[i][j], percent
                            );
                        }
                    }
                }
            }

            function _isArrayLike(data) {
                switch (typeof data) {
                    case &#x27;undefined&#x27;:
                    case &#x27;string&#x27;:
                        return false;
                }

                return typeof data.length !== &#x27;undefined&#x27;;
            }

            function _catmullRomInterpolateArray(
                p0, p1, p2, p3, t, t2, t3, out, arrDim
                ) {
                var len = p0.length;
                if (arrDim == 1) {
                    for (var i = 0; i &lt; len; i++) {
                        out[i] = _catmullRomInterpolate(
                            p0[i], p1[i], p2[i], p3[i], t, t2, t3
                        );
                    }
                } else {
                    var len2 = p0[0].length;
                    for (var i = 0; i &lt; len; i++) {
                        for (var j = 0; j &lt; len2; j++) {
                            out[i][j] = _catmullRomInterpolate(
                                p0[i][j], p1[i][j], p2[i][j], p3[i][j],
                                t, t2, t3
                            );
                        }
                    }
                }
            }

            function _catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
                var v0 = (p2 - p0) * 0.5;
                var v1 = (p3 - p1) * 0.5;
                return (2 * (p1 - p2) + v0 + v1) * t3
                    + (- 3 * (p1 - p2) - 2 * v0 - v1) * t2
                    + v0 * t + p1;
            }

            function _cloneValue(value) {
                if (_isArrayLike(value)) {
                    var len = value.length;
                    if (_isArrayLike(value[0])) {
                        var ret = [];
                        for (var i = 0; i &lt; len; i++) {
                            ret.push(arraySlice.call(value[i]));
                        }
                        return ret;
                    } else {
                        return arraySlice.call(value)
                    }
                } else {
                    return value;
                }
            }

            function rgba2String(rgba) {
                rgba[0] = Math.floor(rgba[0]);
                rgba[1] = Math.floor(rgba[1]);
                rgba[2] = Math.floor(rgba[2]);

                return &#x27;rgba(&#x27; + rgba.join(&#x27;,&#x27;) + &#x27;)&#x27;;
            }

            function Deferred(target, loop, getter, setter) {
                this._tracks = {};
                this._target = target;

                this._loop = loop || false;

                this._getter = getter || _defaultGetter;
                this._setter = setter || _defaultSetter;

                this._clipCount = 0;

                this._delay = 0;

                this._doneList = [];

                this._onframeList = [];

                this._clipList = [];
            }

            Deferred.prototype = {
                when : function(time /* ms */, props) {
                    for (var propName in props) {
                        if (! this._tracks[propName]) {
                            this._tracks[propName] = [];
                            // If time is 0 
                            //  Then props is given initialize value
                            // Else
                            //  Initialize value from current prop value
                            if (time !== 0) {
                                this._tracks[propName].push({
                                    time : 0,
                                    value : _cloneValue(
                                        this._getter(this._target, propName)
                                    )
                                });
                            }
                        }
                        this._tracks[propName].push({
                            time : parseInt(time, 10),
                            value : props[propName]
                        });
                    }
                    return this;
                },
                during : function(callback) {
                    this._onframeList.push(callback);
                    return this;
                },
                start : function(easing) {

                    var self = this;
                    var setter = this._setter;
                    var getter = this._getter;
                    var onFrameListLen = self._onframeList.length;
                    var useSpline = easing === &#x27;spline&#x27;;

                    var ondestroy = function() {
                        self._clipCount--;
                        if (self._clipCount === 0) {
                            // Clear all tracks
                            self._tracks = {};

                            var len = self._doneList.length;
                            for (var i = 0; i &lt; len; i++) {
                                self._doneList[i].call(self);
                            }
                        }
                    };

                    var createTrackClip = function(keyframes, propName) {
                        var trackLen = keyframes.length;
                        if (!trackLen) {
                            return;
                        }
                        // Guess data type
                        var firstVal = keyframes[0].value;
                        var isValueArray = _isArrayLike(firstVal);
                        var isValueColor = false;

                        // For vertices morphing
                        var arrDim = (
                            isValueArray
                            &amp;&amp; _isArrayLike(firstVal[0])
                            )
                            ? 2 : 1;
                        // Sort keyframe as ascending
                        keyframes.sort(function(a, b) {
                            return a.time - b.time;
                        });
                        var trackMaxTime;
                        if (trackLen) {
                            trackMaxTime = keyframes[trackLen-1].time;
                        }else{
                            return;
                        }
                        // Percents of each keyframe
                        var kfPercents = [];
                        // Value of each keyframe
                        var kfValues = [];
                        for (var i = 0; i &lt; trackLen; i++) {
                            kfPercents.push(keyframes[i].time / trackMaxTime);
                            // Assume value is a color when it is a string
                            var value = keyframes[i].value;
                            if (typeof(value) == &#x27;string&#x27;) {
                                value = color.toArray(value);
                                if (value.length == 0) {    // Invalid color
                                    value[0] = value[1] = value[2] = 0;
                                    value[3] = 1;
                                }
                                isValueColor = true;
                            }
                            kfValues.push(value);
                        }

                        // Cache the key of last frame to speed up when 
                        // animation playback is sequency
                        var cacheKey = 0;
                        var cachePercent = 0;
                        var start;
                        var i, w;
                        var p0, p1, p2, p3;


                        if (isValueColor) {
                            var rgba = [0, 0, 0, 0];
                        }

                        var onframe = function(target, percent) {
                            // Find the range keyframes
                            // kf1-----kf2---------current--------kf3
                            // find kf2 and kf3 and do interpolation
                            if (percent &lt; cachePercent) {
                                // Start from next key
                                start = Math.min(cacheKey + 1, trackLen - 1);
                                for (i = start; i &gt;= 0; i--) {
                                    if (kfPercents[i] &lt;= percent) {
                                        break;
                                    }
                                }
                                i = Math.min(i, trackLen-2);
                            } else {
                                for (i = cacheKey; i &lt; trackLen; i++) {
                                    if (kfPercents[i] &gt; percent) {
                                        break;
                                    }
                                }
                                i = Math.min(i-1, trackLen-2);
                            }
                            cacheKey = i;
                            cachePercent = percent;

                            var range = (kfPercents[i+1] - kfPercents[i]);
                            if (range === 0) {
                                return;
                            } else {
                                w = (percent - kfPercents[i]) / range;
                            }
                            if (useSpline) {
                                p1 = kfValues[i];
                                p0 = kfValues[i === 0 ? i : i - 1];
                                p2 = kfValues[i &gt; trackLen - 2 ? trackLen - 1 : i + 1];
                                p3 = kfValues[i &gt; trackLen - 3 ? trackLen - 1 : i + 2];
                                if (isValueArray) {
                                    _catmullRomInterpolateArray(
                                        p0, p1, p2, p3, w, w*w, w*w*w,
                                        getter(target, propName),
                                        arrDim
                                    );
                                } else {
                                    var value;
                                    if (isValueColor) {
                                        value = _catmullRomInterpolateArray(
                                            p0, p1, p2, p3, w, w*w, w*w*w,
                                            rgba, 1
                                        );
                                        value = rgba2String(rgba);
                                    } else {
                                        value = _catmullRomInterpolate(
                                            p0, p1, p2, p3, w, w*w, w*w*w
                                        )
                                    }
                                    setter(
                                        target,
                                        propName,
                                        value
                                    );
                                }
                            } else {
                                if (isValueArray) {
                                    _interpolateArray(
                                        kfValues[i], kfValues[i+1], w,
                                        getter(target, propName),
                                        arrDim
                                    );
                                } else {
                                    var value;
                                    if (isValueColor) {
                                        _interpolateArray(
                                            kfValues[i], kfValues[i+1], w,
                                            rgba, 1
                                        );
                                        value = rgba2String(rgba);
                                    } else {
                                        value = _interpolateNumber(kfValues[i], kfValues[i+1], w);
                                    }
                                    setter(
                                        target,
                                        propName,
                                        value
                                    );
                                }
                            }

                            for (i = 0; i &lt; onFrameListLen; i++) {
                                self._onframeList[i](target, percent);
                            }
                        };

                        var clip = new Clip({
                            target : self._target,
                            life : trackMaxTime,
                            loop : self._loop,
                            delay : self._delay,
                            onframe : onframe,
                            ondestroy : ondestroy
                        });

                        if (easing &amp;&amp; easing !== &#x27;spline&#x27;) {
                            clip.easing = easing;
                        }
                        self._clipList.push(clip);
                        self._clipCount++;
                        self.animation.add(clip);
                    };

                    for (var propName in this._tracks) {
                        createTrackClip(this._tracks[propName], propName);
                    }
                    return this;
                },
                stop : function() {
                    for (var i = 0; i &lt; this._clipList.length; i++) {
                        var clip = this._clipList[i];
                        this.animation.remove(clip);
                    }
                    this._clipList = [];
                },
                delay : function(time){
                    this._delay = time;
                    return this;
                },
                done : function(func) {
                    this._doneList.push(func);
                    return this;
                }
            };

            return Animation;
        }
    );

    /*!
     * ZRender, a lightweight canvas library with a MVC architecture, data-driven 
     * and provides an event model like DOM.
     *  
     * Copyright (c) 2013, Baidu Inc.
     * All rights reserved.
     * 
     * LICENSE
     * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
     */

    /**
     * zrender: core核心类
     *
     * @desc zrender是一个轻量级的Canvas类库，MVC封装，数据驱动，提供类Dom事件模型。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(
        &#x27;zrender/zrender&#x27;,[&#x27;require&#x27;,&#x27;./lib/excanvas&#x27;,&#x27;./tool/util&#x27;,&#x27;./tool/log&#x27;,&#x27;./tool/guid&#x27;,&#x27;./Handler&#x27;,&#x27;./Painter&#x27;,&#x27;./Storage&#x27;,&#x27;./animation/animation&#x27;,&#x27;./tool/env&#x27;],function(require) {
            /*
             * HTML5 Canvas for Internet Explorer!
             * Modern browsers like Firefox, Safari, Chrome and Opera support
             * the HTML5 canvas tag to allow 2D command-based drawing.
             * ExplorerCanvas brings the same functionality to Internet Explorer.
             * To use, web developers only need to include a single script tag
             * in their existing web pages.
             *
             * https://code.google.com/p/explorercanvas/
             * http://explorercanvas.googlecode.com/svn/trunk/excanvas.js
             */
            // 核心代码会生成一个全局变量 G_vmlCanvasManager，模块改造后借用于快速判断canvas支持
            require(&#x27;./lib/excanvas&#x27;);

            var util = require(&#x27;./tool/util&#x27;);
            var log = require(&#x27;./tool/log&#x27;);
            var guid = require(&#x27;./tool/guid&#x27;);

            var Handler = require(&#x27;./Handler&#x27;);
            var Painter = require(&#x27;./Painter&#x27;);
            var Storage = require(&#x27;./Storage&#x27;);
            var Animation = require(&#x27;./animation/animation&#x27;);

            var _instances = {};    //ZRender实例map索引

            var zrender = {};
            zrender.version = &#x27;2.0.0&#x27;;

            /**
             * zrender初始化
             * 不让外部直接new ZRender实例，为啥？
             * 不为啥，提供全局可控同时减少全局污染和降低命名冲突的风险！
             *
             * @param {HTMLElement} dom dom对象，不帮你做document.getElementById了
             * @param {Object=} params 个性化参数，如自定义shape集合，带进来就好
             *
             * @return {ZRender} ZRender实例
             */
            zrender.init = function(dom, params) {
                var zi = new ZRender(guid(), dom, params || {});
                _instances[zi.id] = zi;
                return zi;
            };

            /**
             * zrender实例销毁，记在_instances里的索引也会删除了
             * 管生就得管死，可以通过zrender.dispose(zi)销毁指定ZRender实例
             * 当然也可以直接zi.dispose()自己销毁
             *
             * @param {ZRender=} zi ZRender对象，不传则销毁全部
             */
            zrender.dispose = function (zi) {
                if (zi) {
                    zi.dispose();
                }
                else {
                    for (var key in _instances) {
                        _instances[key].dispose();
                    }
                    _instances = {};
                }

                return zrender;
            };

            /**
             * 获取zrender实例
             *
             * @param {string} id ZRender对象索引
             */
            zrender.getInstance = function (id) {
                return _instances[id];
            };

            /**
             * 删除zrender实例，ZRender实例dispose时会调用，
             * 删除后getInstance则返回undefined
             * ps: 仅是删除，删除的实例不代表已经dispose了~~
             *     这是一个摆脱全局zrender.dispose()自动销毁的后门，
             *     take care of yourself~
             *
             * @param {string} id ZRender对象索引
             */
            zrender.delInstance = function (id) {
                delete _instances[id];
                return zrender;
            };

            function getAnimationUpdater(zrenderInstance) {
                return function(){
                    var animatingShapes = zrenderInstance.animatingShapes;
                    for (var i = 0, l = animatingShapes.length; i &lt; l; i++) {
                        zrenderInstance.storage.mod(animatingShapes[i].id);
                    }

                    if (animatingShapes.length) {
                        zrenderInstance.painter.refresh();
                    }
                };
            }

            /**
             * ZRender接口类，对外可用的所有接口都在这里！！
             * storage（M）、painter（V）、handler（C）为内部私有类，外部接口不可见
             * 非get接口统一返回支持链式调用~
             *
             * @param {string} id 唯一标识
             * @param {HTMLElement} dom dom对象，不帮你做document.getElementById
             *
             * @return {ZRender} ZRender实例
             */
            function ZRender(id, dom) {
                this.id = id;
                this.env = require(&#x27;./tool/env&#x27;);

                this.storage = new Storage();
                this.painter = new Painter(dom, this.storage);
                this.handler = new Handler(dom, this.storage, this.painter);

                // 动画控制
                this.animatingShapes = [];
                this.animation = new Animation({
                    stage : {
                        update : getAnimationUpdater(this)
                    }
                });
                this.animation.start();
            }

            /**
             * 获取实例唯一标识
             */
            ZRender.prototype.getId = function () {
                return this.id;
            };

            /**
             * 添加图形形状
             *
             * @param {Object} shape 形状对象，可用属性全集，详见各shape
             */
            ZRender.prototype.addShape = function (shape) {
                this.storage.add(shape);
                return this;
            };

            /**
             * 删除图形形状
             *
             * @param {string} shapeId 形状对象唯一标识
             */
            ZRender.prototype.delShape = function (shapeId) {
                this.storage.del(shapeId);
                return this;
            };

            /**
             * 修改图形形状
             *
             * @param {string} shapeId 形状对象唯一标识
             * @param {Object} shape 形状对象
             * @param {fast} boolean 默认为false, 如果为true的话会在merge中省略部分判断
             */
            ZRender.prototype.modShape = function (shapeId, shape, fast) {
                this.storage.mod(shapeId, shape, fast);
                return this;
            };

            /**
             * 修改指定zlevel的绘制配置项，例如clearColor
             *
             * @param {string} zLevel
             * @param {Object} config 配置对象, 目前支持clearColor
             */
            ZRender.prototype.modLayer = function (zLevel, config) {
                this.painter.modLayer(zLevel, config);
                return this;
            };

            /**
             * 添加额外高亮层显示，仅提供添加方法，每次刷新后高亮层图形均被清空
             *
             * @param {Object} shape 形状对象
             */
            ZRender.prototype.addHoverShape = function (shape) {
                this.storage.addHover(shape);
                return this;
            };

            /**
             * 渲染
             *
             * @param {Function} callback  渲染结束后回调函数
             * todo:增加缓动函数
             */
            ZRender.prototype.render = function (callback) {
                this.painter.render(callback);
                return this;
            };

            /**
             * 视图更新
             *
             * @param {Function} callback  视图更新后回调函数
             */
            ZRender.prototype.refresh = function (callback) {
                this.painter.refresh(callback);
                return this;
            };

            /**
             * 高亮层更新
             *
             * @param {Function} callback  视图更新后回调函数
             */
            ZRender.prototype.refreshHover = function (callback) {
                this.painter.refreshHover(callback);
                return this;
            };

            /**
             * 视图更新
             *
             * @param {Array} shapeList 需要更新的图形元素列表
             * @param {Function} callback  视图更新后回调函数
             */
            ZRender.prototype.update = function (shapeList, callback) {
                this.painter.update(shapeList, callback);
                return this;
            };

            ZRender.prototype.resize = function() {
                this.painter.resize();
                return this;
            };

            /**
             * 动画
             *
             * @param {string} shapeId 形状对象唯一标识
             * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性
             * @param {boolean} loop 动画是否循环
             * @return {Object} 动画的Deferred对象
             * Example:
             * zr.animate(circleId, &#x27;style&#x27;, false)
             *   .when(1000, { x: 10} )
             *   .done(function(){ console.log(&#x27;Animation done&#x27;)})
             *   .start()
             */
            ZRender.prototype.animate = function (shapeId, path, loop) {
                var shape = this.storage.get(shapeId);
                if (shape) {
                    var target;
                    if (path) {
                        var pathSplitted = path.split(&#x27;.&#x27;);
                        var prop = shape;
                        for (var i = 0, l = pathSplitted.length; i &lt; l; i++) {
                            if (!prop) {
                                continue;
                            }
                            prop = prop[pathSplitted[i]];
                        }
                        if (prop) {
                            target = prop;
                        }
                    }
                    else {
                        target = shape;
                    }

                    if (!target) {
                        log(
                                &#x27;Property &quot;&#x27;
                                + path
                                + &#x27;&quot; is not existed in shape &#x27;
                                + shapeId
                        );
                        return;
                    }

                    var animatingShapes = this.animatingShapes;
                    if (typeof shape.__aniCount === &#x27;undefined&#x27;) {
                        // 正在进行的动画记数
                        shape.__aniCount = 0;
                    }
                    if (shape.__aniCount === 0) {
                        animatingShapes.push(shape);
                    }
                    shape.__aniCount++;

                    return this.animation.animate(target, {loop : loop})
                        .done(function() {
                            shape.__aniCount --;
                            if (shape.__aniCount === 0) {
                                // 从animatingShapes里移除
                                var idx = util.indexOf(animatingShapes, shape);
                                animatingShapes.splice(idx, 1);
                            }
                        });
                }
                else {
                    log(&#x27;Shape &quot;&#x27;+ shapeId + &#x27;&quot; not existed&#x27;);
                }
            };

            /**
             * 停止所有动画
             */
            ZRender.prototype.clearAnimation = function () {
                this.animation.clear();
            };

            /**
             * loading显示
             *
             * @param {Object=} loadingEffect loading效果对象
             */
            ZRender.prototype.showLoading = function (loadingEffect) {
                this.painter.showLoading(loadingEffect);
                return this;
            };

            /**
             * loading结束
             */
            ZRender.prototype.hideLoading = function () {
                this.painter.hideLoading();
                return this;
            };

            /**
             * 获取视图宽度
             */
            ZRender.prototype.getWidth = function() {
                return this.painter.getWidth();
            };

            /**
             * 获取视图高度
             */
            ZRender.prototype.getHeight = function() {
                return this.painter.getHeight();
            };

            /**
             * 图像导出
             */
            ZRender.prototype.toDataURL = function(type, backgroundColor, args) {
                return this.painter.toDataURL(type, backgroundColor, args);
            };

            /**
             * 将常规shape转成image shape
             */
            ZRender.prototype.shapeToImage = function(e, width, height) {
                var id = guid();
                return this.painter.shapeToImage(id, e, width, height);
            };

            /**
             * 事件绑定
             *
             * @param {string} eventName 事件名称
             * @param {Function} eventHandler 响应函数
             */
            ZRender.prototype.on = function(eventName, eventHandler) {
                this.handler.on(eventName, eventHandler);
                return this;
            };

            /**
             * 事件解绑定，参数为空则解绑所有自定义事件
             *
             * @param {string} eventName 事件名称
             * @param {Function} eventHandler 响应函数
             */
            ZRender.prototype.un = function(eventName, eventHandler) {
                this.handler.un(eventName, eventHandler);
                return this;
            };

            /**
             * 事件触发
             *
             * @param {string} event 事件名称，resize，hover，drag，etc~
             * @param {event=} event event dom事件对象
             */
            ZRender.prototype.trigger = function (eventName, event) {
                this.handler.trigger(eventName, event);
                return this;
            };


            /**
             * 清除当前ZRender下所有类图的数据和显示，clear后MVC和已绑定事件均还存在在，ZRender可用
             */
            ZRender.prototype.clear = function () {
                this.storage.del();
                this.painter.clear();
                return this;
            };

            /**
             * 释放当前ZR实例（删除包括dom，数据、显示和事件绑定），dispose后ZR不可用
             */
            ZRender.prototype.dispose = function () {
                this.animation.stop();

                this.clear();
                this.storage.dispose();
                this.painter.dispose();
                this.handler.dispose();

                this.animation =
                    this.animatingShapes =
                        this.storage =
                            this.painter =
                                this.handler = null;

                //释放后告诉全局删除对自己的索引，没想到啥好方法
                zrender.delInstance(this.id);
            };

            return zrender;
        }
    );

    define(&#x27;zrender&#x27;, [&#x27;zrender/zrender&#x27;], function (main) { return main; });

    /**
     * echarts层级查找方法
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/util/ecQuery&#x27;,[&#x27;zrender/tool/util&#x27;],function() {
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);

        /**
         * 获取嵌套选项的基础方法
         * 返回optionTarget中位于optionLocation上的值，如果没有定义，则返回undefined
         */
        function query(optionTarget, optionLocation) {
            if (typeof optionTarget == &#x27;undefined&#x27;) {
                return;
            }

            if (!optionLocation) {
                return optionTarget;
            }

            optionLocation = optionLocation.split(&#x27;.&#x27;);
            var length = optionLocation.length;
            var curIdx = 0;
            while (curIdx &lt; length) {
                optionTarget = optionTarget[optionLocation[curIdx]];
                if (typeof optionTarget == &#x27;undefined&#x27;) {
                    return;
                }
                curIdx++;
            }

            return optionTarget;
        }

        /**
         * 获取多级控制嵌套属性的基础方法
         * 返回ctrList中优先级最高（最靠前）的非undefined属性，ctrList中均无定义则返回undefined
         */
        function deepQuery(ctrList, optionLocation) {
            var finalOption;
            for (var i = 0, l = ctrList.length; i &lt; l; i++) {
                finalOption = query(ctrList[i], optionLocation);
                if (typeof finalOption != &#x27;undefined&#x27;) {
                    return finalOption;
                }
            }
        }

        /**
         * 获取多级控制嵌套属性的基础方法
         * 根据ctrList中优先级合并产出目标属性
         */
        function deepMerge(ctrList, optionLocation) {
            var finalOption;
            var len = ctrList.length;
            while (len--) {
                var tempOption = query(ctrList[len], optionLocation);
                if (typeof tempOption != &#x27;undefined&#x27;) {
                    if (typeof finalOption == &#x27;undefined&#x27;) {
                        finalOption = zrUtil.clone(tempOption);
                    }
                    else {
                        zrUtil.merge(
                            finalOption, tempOption, true
                        );
                    }
                }
            }

            return finalOption;
        }

        return {
            query : query,
            deepQuery : deepQuery,
            deepMerge : deepMerge
        };
    });
    /**
     * echarts数字运算相关
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/util/number&#x27;,[],function() {
        function _trim(str) {
            return str.replace(/^\s+/, &#x27;&#x27;).replace(/\s+$/, &#x27;&#x27;);
        }

        /**
         * 百分比计算
         */
        function parsePercent(value, maxValue) {
            if (typeof value === &#x27;string&#x27;) {
                if (_trim(value).match(/%$/)) {
                    return parseFloat(value) / 100 * maxValue;
                }

                return parseFloat(value);
            }

            return value;
        }

        /**
         * 获取中心坐标
         */
        function parseCenter(zr, center) {
            return [
                parsePercent(center[0], zr.getWidth()),
                parsePercent(center[1], zr.getHeight()),
            ];
        }

        /**
         * 获取自适应半径
         */
        function parseRadius(zr, radius) {
            // 传数组实现环形图，[内半径，外半径]，传单个则默认为外半径为
            if (!(radius instanceof Array)) {
                radius = [0, radius];
            }
            var zrSize = Math.min(zr.getWidth(), zr.getHeight()) / 2;
            return [
                parsePercent(radius[0], zrSize),
                parsePercent(radius[1], zrSize),
            ];
        }

        /**
         * 每三位默认加,格式化
         */
        function addCommas(x) {
            if (isNaN(x)) {
                return &#x27;-&#x27;;
            }
            x = (x + &#x27;&#x27;).split(&#x27;.&#x27;);
            return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g,&#x27;$1,&#x27;)
                + (x.length &gt; 1 ? (&#x27;.&#x27; + x[1]) : &#x27;&#x27;);
        }

        return {
            parsePercent : parsePercent,
            parseCenter : parseCenter,
            parseRadius : parseRadius,
            addCommas : addCommas
        };
    });
    /**
     * echarts组件基类
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/component/base&#x27;,[&#x27;require&#x27;,&#x27;../config&#x27;,&#x27;../util/ecQuery&#x27;,&#x27;../util/number&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/tool/env&#x27;],function (require) {
        var ecConfig = require(&#x27;../config&#x27;);
        var ecQuery = require(&#x27;../util/ecQuery&#x27;);
        var number = require(&#x27;../util/number&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);

        function Base(ecTheme, messageCenter, zr, option, myChart){
            this.ecTheme = ecTheme;
            this.messageCenter = messageCenter;
            this.zr =zr;
            this.option = option;
            this.series = option.series;
            this.myChart = myChart;
            this.component = myChart.component;

            this._zlevelBase = this.getZlevelBase();
            this.shapeList = [];
            this.effectList = [];

            var self = this;
            self.hoverConnect = function (param) {
                var target = (param.target || {}).hoverConnect;
                if (target) {
                    var zlevel = 10;
                    var shape;
                    if (!(target instanceof Array)) {
                        shape = self.getShapeById(target);
                        if (shape) {
                            self.zr.addHoverShape(shape);
                            zlevel = Math.min(zlevel, shape.zlevel);
                        }
                    }
                    else {
                        for (var i = 0, l = target.length; i &lt; l; i++) {
                            shape = self.getShapeById(target[i]);
                            self.zr.addHoverShape(shape);
                            zlevel = Math.min(zlevel, shape.zlevel);
                        }
                    }
                    if (zlevel &lt; param.target.zlevel) {
                        self.zr.addHoverShape(param.target);
                    }
                }
            };
        }

        /**
         * 基类方法
         */
        Base.prototype = {
            canvasSupported : require(&#x27;zrender/tool/env&#x27;).canvasSupported,
            /**
             * 获取zlevel基数配置
             * @param {Object} contentType
             */
            getZlevelBase : function (contentType) {
                contentType = contentType || this.type + &#x27;&#x27;;

                switch (contentType) {
                    case ecConfig.COMPONENT_TYPE_GRID :
                    case ecConfig.COMPONENT_TYPE_AXIS_CATEGORY :
                    case ecConfig.COMPONENT_TYPE_AXIS_VALUE :
                    case ecConfig.COMPONENT_TYPE_POLAR :
                        return 0;

                    case ecConfig.CHART_TYPE_LINE :
                    case ecConfig.CHART_TYPE_BAR :
                    case ecConfig.CHART_TYPE_SCATTER :
                    case ecConfig.CHART_TYPE_PIE :
                    case ecConfig.CHART_TYPE_RADAR :
                    case ecConfig.CHART_TYPE_MAP :
                    case ecConfig.CHART_TYPE_K :
                    case ecConfig.CHART_TYPE_CHORD:
                    case ecConfig.CHART_TYPE_GUAGE:
                    case ecConfig.CHART_TYPE_FUNNEL:
                        return 2;

                    case ecConfig.COMPONENT_TYPE_LEGEND :
                    case ecConfig.COMPONENT_TYPE_DATARANGE:
                    case ecConfig.COMPONENT_TYPE_DATAZOOM :
                    case ecConfig.COMPONENT_TYPE_TIMELINE :
                        return 4;

                    case ecConfig.CHART_TYPE_ISLAND :
                        return 5;

                    case ecConfig.COMPONENT_TYPE_TOOLBOX :
                    case ecConfig.COMPONENT_TYPE_TITLE :
                        return 6;

                    // ecConfig.EFFECT_ZLEVEL = 7;

                    case ecConfig.COMPONENT_TYPE_TOOLTIP :
                        return 8;

                    default :
                        return 0;
                }
            },

            /**
             * 参数修正&amp;默认值赋值
             * @param {Object} opt 参数
             *
             * @return {Object} 修正后的参数
             */
            reformOption : function (opt) {
                return zrUtil.merge(
                        opt || {},
                    zrUtil.clone(this.ecTheme[this.type] || {})
                );
            },

            /**
             * css类属性数组补全，如padding，margin等~
             */
            reformCssArray : function (p) {
                if (p instanceof Array) {
                    switch (p.length + &#x27;&#x27;) {
                        case &#x27;4&#x27;:
                            return p;
                        case &#x27;3&#x27;:
                            return [p[0], p[1], p[2], p[1]];
                        case &#x27;2&#x27;:
                            return [p[0], p[1], p[0], p[1]];
                        case &#x27;1&#x27;:
                            return [p[0], p[0], p[0], p[0]];
                        case &#x27;0&#x27;:
                            return [0, 0, 0, 0];
                    }
                }
                else {
                    return [p, p, p, p];
                }
            },

            getShapeById : function(id) {
                for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                    if (this.shapeList[i].id == id) {
                        return this.shapeList[i];
                    }
                }
                return null;
            },

            /**
             * 获取自定义和默认配置合并后的字体设置
             */
            getFont : function (textStyle) {
                var finalTextStyle = zrUtil.merge(
                        zrUtil.clone(textStyle) || {},
                    this.ecTheme.textStyle
                );
                return finalTextStyle.fontStyle + &#x27; &#x27;
                    + finalTextStyle.fontWeight + &#x27; &#x27;
                    + finalTextStyle.fontSize + &#x27;px &#x27;
                    + finalTextStyle.fontFamily;
            },

            getItemStyleColor : function (itemColor, seriesIndex, dataIndex, data) {
                return typeof itemColor == &#x27;function&#x27;
                    ? itemColor(seriesIndex, dataIndex, data) : itemColor;

            },

            // 亚像素优化
            subPixelOptimize : function (position, lineWidth) {
                if (lineWidth % 2 == 1) {
                    //position += position == Math.ceil(position) ? 0.5 : 0;
                    position = Math.floor(position) + 0.5;
                }
                else {
                    position = Math.round(position);
                }
                return position;
            },


            resize : function () {
                this.refresh &amp;&amp; this.refresh();
                this.animationEffect &amp;&amp; this.animationEffect();
            },

            /**
             * 清除图形数据，实例仍可用
             */
            clear :function () {
                this.clearEffectShape &amp;&amp; this.clearEffectShape();
                this.zr &amp;&amp; this.zr.delShape(this.shapeList);
                this.shapeList = [];
            },

            /**
             * 释放后实例不可用
             */
            dispose : function () {
                this.clear();
                this.shapeList = null;
                this.effectList = null;
            },

            query : ecQuery.query,
            deepQuery : ecQuery.deepQuery,
            deepMerge : ecQuery.deepMerge,

            parsePercent : number.parsePercent,
            parseCenter : number.parseCenter,
            parseRadius : number.parseRadius,
            numAddCommas : number.addCommas
        };

        return Base;
    });

    /**
     * zrender: 数学辅助类
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * sin：正弦函数，自动缓存
     * cos：余弦函数，自动缓存
     * degreeToRadian：角度转弧度
     * radianToDegree：弧度转角度
     */
    define(
        &#x27;zrender/tool/math&#x27;,[],function() {
            /*
             var _cache = {
             sin : {},     //sin缓存
             cos : {}      //cos缓存
             };
             */
            var _radians = Math.PI / 180;

            /**
             * @param angle 弧度（角度）参数
             * @param isDegrees angle参数是否为角度计算，默认为false，angle为以弧度计量的角度
             */
            function sin(angle, isDegrees) {
                return Math.sin(isDegrees ? angle * _radians : angle);
                /*
                 angle = (isDegrees ? angle * _radians : angle).toFixed(4);
                 if(typeof _cache.sin[angle] == &#x27;undefined&#x27;) {
                 _cache.sin[angle] = Math.sin(angle);
                 }
                 return _cache.sin[angle];
                 */
            }

            /**
             * @param radians 弧度参数
             */
            function cos(angle, isDegrees) {
                return Math.cos(isDegrees ? angle * _radians : angle);
                /*
                 angle = (isDegrees ? angle * _radians : angle).toFixed(4);
                 if(typeof _cache.cos[angle] == &#x27;undefined&#x27;) {
                 _cache.cos[angle] = Math.cos(angle);
                 }
                 return _cache.cos[angle];
                 */
            }

            /**
             * 角度转弧度
             * @param {Object} angle
             */
            function degreeToRadian(angle) {
                return angle * _radians;
            }

            /**
             * 弧度转角度
             * @param {Object} angle
             */
            function radianToDegree(angle) {
                return angle / _radians;
            }

            return {
                sin : sin,
                cos : cos,
                degreeToRadian : degreeToRadian,
                radianToDegree : radianToDegree
            };
        }
    );
    /**
     * zrender
     *
     * @author sushuang (宿爽, sushuang@baidu.com)
     *
     * shape类：n角星（n&gt;3）
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;star&#x27;,       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           x             : {number},  // 必须，n角星外接圆心横坐标
           y             : {number},  // 必须，n角星外接圆心纵坐标
           r             : {number},  // 必须，n角星外接圆半径
           r0            : {number},  // n角星内部顶点（凹点）的外接圆半径，
                                      // 如果不指定此参数，则自动计算：取相隔外部顶点连线的交点作内部顶点
           n             : {number},  // 必须，指明几角星
           brushType     : {string},  // 默认为fill，绘画方式
                                      // fill(填充) | stroke(描边) | both(填充+描边)
           color         : {color},   // 默认为&#x27;#000&#x27;，填充颜色，支持rgba
           strokeColor   : {color},   // 默认为&#x27;#000&#x27;，描边颜色（轮廓），支持rgba
           lineWidth     : {number},  // 默认为1，线条宽度，描边下有效
           lineJoin      : {string},  // 默认为miter，线段连接样式。miter | round | bevel

           shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
           shadowColor   : {color},   // 默认为&#x27;#000&#x27;，阴影色彩，支持rgba
           shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
           shadowOffsetY : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左

           text          : {string},  // 默认为null，附加文本
           textFont      : {string},  // 默认为null，附加文本样式，eg:&#x27;bold 18px verdana&#x27;
           textPosition  : {string},  // 默认为outside，附加文本位置。
                                      // outside | inside
           textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                      // start | end | left | right | center
           textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                      // top | bottom | middle |
                                      // alphabetic | hanging | ideographic
           textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                      // &#x27;inside&#x27; ? &#x27;#fff&#x27; : color
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     例子：
     {
       shape  : &#x27;star&#x27;,
       id     : &#x27;123456&#x27;,
       zlevel : 1,
       style  : {
           x : 200,
           y : 100,
           r : 150,
           n : 5,
           color : &#x27;#eee&#x27;
       },
       myName : &#x27;kener&#x27;,   // 可自带任何有效自定义属性

       clickable : true,
       onClick : function(eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
     */
    define(
        &#x27;zrender/shape/Star&#x27;,[&#x27;require&#x27;,&#x27;../tool/math&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;],function (require) {

            var math = require(&#x27;../tool/math&#x27;);
            var sin = math.sin;
            var cos = math.cos;
            var PI = Math.PI;

            var Base = require(&#x27;./Base&#x27;);

            function Star(options) {
                Base.call(this, options);
            }

            Star.prototype = {
                type: &#x27;star&#x27;,

                /**
                 * 创建n角星（n&gt;3）路径
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                buildPath : function(ctx, style) {
                    var n = style.n;
                    if (!n || n &lt; 2) { return; }

                    var x = style.x;
                    var y = style.y;
                    var r = style.r;
                    var r0 = style.r0;

                    // 如果未指定内部顶点外接圆半径，则自动计算
                    if (r0 == null) {
                        r0 = n &gt; 4
                            // 相隔的外部顶点的连线的交点，
                            // 被取为内部交点，以此计算r0
                            ? r * cos(2 * PI / n) / cos(PI / n)
                            // 二三四角星的特殊处理
                            : r / 3;
                    }

                    var dStep = PI / n;
                    var deg = -PI / 2;
                    var xStart = x + r * cos(deg);
                    var yStart = y + r * sin(deg);
                    deg += dStep;

                    // 记录边界点，用于判断inside
                    var pointList = style.pointList = [];
                    pointList.push([xStart, yStart]);
                    for (var i = 0, end = n * 2 - 1, ri; i &lt; end; i ++) {
                        ri = i % 2 === 0 ? r0 : r;
                        pointList.push([x + ri * cos(deg), y + ri * sin(deg)]);
                        deg += dStep;
                    }
                    pointList.push([xStart, yStart]);

                    // 绘制
                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    for (var i = 0; i &lt; pointList.length; i ++) {
                        ctx.lineTo(pointList[i][0], pointList[i][1]);
                    }

                    return;
                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect : function(style) {
                    if (style.__rect) {
                        return style.__rect;
                    }

                    var lineWidth;
                    if (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;fill&#x27;) {
                        lineWidth = style.lineWidth || 1;
                    }
                    else {
                        lineWidth = 0;
                    }
                    style.__rect = {
                        x : Math.round(style.x - style.r - lineWidth / 2),
                        y : Math.round(style.y - style.r - lineWidth / 2),
                        width : style.r * 2 + lineWidth,
                        height : style.r * 2 + lineWidth
                    };

                    return style.__rect;
                }
            };

            require(&#x27;../tool/util&#x27;).inherits(Star, Base);
            return Star;
        }
    );
    /**
     * zrender
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：心形
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;heart&#x27;,       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           x             : {number},  // 必须，心形内部尖端横坐标
           y             : {number},  // 必须，心形内部尖端纵坐标
           a             : {number},  // 必须，心形横宽（中轴线到水平边缘最宽处距离）
           b             : {number},  // 必须，心形纵高（内尖到外尖距离）
           brushType     : {string},  // 默认为fill，绘画方式
                                      // fill(填充) | stroke(描边) | both(填充+描边)
           color         : {color},   // 默认为&#x27;#000&#x27;，填充颜色，支持rgba
           strokeColor   : {color},   // 默认为&#x27;#000&#x27;，描边颜色（轮廓），支持rgba
           lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

           shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
           shadowColor   : {color},   // 默认为&#x27;#000&#x27;，阴影色彩，支持rgba
           shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
           shadowOffsetY : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左

           text          : {string},  // 默认为null，附加文本
           textFont      : {string},  // 默认为null，附加文本样式，eg:&#x27;bold 18px verdana&#x27;
           textPosition  : {string},  // 默认为outside，附加文本位置。
                                      // outside | inside
           textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                      // start | end | left | right | center
           textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                      // top | bottom | middle |
                                      // alphabetic | hanging | ideographic
           textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                      // &#x27;inside&#x27; ? &#x27;#fff&#x27; : color
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     例子：
     {
       shape  : &#x27;heart&#x27;,
       id     : &#x27;123456&#x27;,
       zlevel : 1,
       style  : {
           x : 200,
           y : 100,
           a : 50,
           b : 80,
           color : &#x27;#eee&#x27;,
           text : &#x27;Baidu&#x27;
       },
       myName : &#x27;kener&#x27;,  // 可自带任何有效自定义属性

       clickable : true,
       onClick : function(eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
     */
    define(
        &#x27;zrender/shape/Heart&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;],function (require) {
            var Base = require(&#x27;./Base&#x27;);

            function Heart(options) {
                Base.call(this, options);
            }

            Heart.prototype = {
                type: &#x27;heart&#x27;,

                /**
                 * 创建扇形路径
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                buildPath : function(ctx, style) {
                    ctx.moveTo(style.x, style.y);
                    ctx.bezierCurveTo(
                            style.x + style.a / 2,
                            style.y - style.b * 2 / 3,
                            style.x + style.a * 2,
                            style.y + style.b / 3,
                        style.x,
                            style.y + style.b
                    );
                    ctx.bezierCurveTo(
                            style.x - style.a *  2,
                            style.y + style.b / 3,
                            style.x - style.a / 2,
                            style.y - style.b * 2 / 3,
                        style.x,
                        style.y
                    );
                    return;
                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect : function(style) {
                    if (style.__rect) {
                        return style.__rect;
                    }

                    var lineWidth;
                    if (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;fill&#x27;) {
                        lineWidth = style.lineWidth || 1;
                    }
                    else {
                        lineWidth = 0;
                    }
                    style.__rect = {
                        x : Math.round(style.x - style.a - lineWidth / 2),
                        y : Math.round(style.y - style.b / 4 - lineWidth / 2),
                        width : style.a * 2 + lineWidth,
                        height : style.b * 5 / 4 + lineWidth
                    };

                    return style.__rect;
                }
            };

            require(&#x27;../tool/util&#x27;).inherits(Heart, Base);
            return Heart;
        }
    );
    /**
     * zrender
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：水滴
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;heart&#x27;,       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           x             : {number},  // 必须，水滴中心横坐标
           y             : {number},  // 必须，水滴中心纵坐标
           a             : {number},  // 必须，水滴横宽（中心到水平边缘最宽处距离）
           b             : {number},  // 必须，水滴纵高（中心到尖端距离）
           brushType     : {string},  // 默认为fill，绘画方式
                                      // fill(填充) | stroke(描边) | both(填充+描边)
           color         : {color},   // 默认为&#x27;#000&#x27;，填充颜色，支持rgba
           strokeColor   : {color},   // 默认为&#x27;#000&#x27;，描边颜色（轮廓），支持rgba
           lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

           shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
           shadowColor   : {color},   // 默认为&#x27;#000&#x27;，阴影色彩，支持rgba
           shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
           shadowOffsetY : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左

           text          : {string},  // 默认为null，附加文本
           textFont      : {string},  // 默认为null，附加文本样式，eg:&#x27;bold 18px verdana&#x27;
           textPosition  : {string},  // 默认为outside，附加文本位置。
                                      // outside | inside
           textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                      // start | end | left | right | center
           textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                      // top | bottom | middle |
                                      // alphabetic | hanging | ideographic
           textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                      // &#x27;inside&#x27; ? &#x27;#fff&#x27; : color
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     例子：
     {
       shape  : &#x27;droplet&#x27;,
       id     : &#x27;123456&#x27;,
       zlevel : 1,
       style  : {
           x : 200,
           y : 100,
           a : 50,
           b : 80,
           color : &#x27;#eee&#x27;,
           text : &#x27;Baidu&#x27;
       },
       myName : &#x27;kener&#x27;,  // 可自带任何有效自定义属性

       clickable : true,
       onClick : function(eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
     */
    define(
        &#x27;zrender/shape/Droplet&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;],function (require) {
            var Base = require(&#x27;./Base&#x27;);

            function Droplet(options) {
                Base.call(this, options);
            }

            Droplet.prototype = {
                type: &#x27;droplet&#x27;,

                /**
                 * 创建扇形路径
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                buildPath : function(ctx, style) {
                    ctx.moveTo(style.x, style.y + style.a);
                    ctx.bezierCurveTo(
                            style.x + style.a,
                            style.y + style.a,
                            style.x + style.a * 3 / 2,
                            style.y - style.a / 3,
                        style.x,
                            style.y - style.b
                    );
                    ctx.bezierCurveTo(
                            style.x - style.a * 3 / 2,
                            style.y - style.a / 3,
                            style.x - style.a,
                            style.y + style.a,
                        style.x,
                            style.y + style.a
                    );
                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect : function(style) {
                    if (style.__rect) {
                        return style.__rect;
                    }

                    var lineWidth;
                    if (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;fill&#x27;) {
                        lineWidth = style.lineWidth || 1;
                    }
                    else {
                        lineWidth = 0;
                    }
                    style.__rect = {
                        x : Math.round(style.x - style.a - lineWidth / 2),
                        y : Math.round(style.y - style.b - lineWidth / 2),
                        width : style.a * 2 + lineWidth,
                        height : style.a + style.b + lineWidth
                    };

                    return style.__rect;
                }
            };

            require(&#x27;../tool/util&#x27;).inherits(Droplet, Base);
            return Droplet;
        }
    );
    /**
     * echarts扩展zrender shape
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：icon
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;icon&#x27;,       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           x             : {number},  // 必须，左上角横坐标
           y             : {number},  // 必须，左上角纵坐标
           width         : {number},  // 必须，宽度
           height        : {number},  // 必须，高度
           iconType      : {string},  // 必须，icon类型
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     */
    define(&#x27;echarts/util/shape/Icon&#x27;,[&#x27;require&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/shape/Star&#x27;,&#x27;zrender/shape/Heart&#x27;,&#x27;zrender/shape/Droplet&#x27;,&#x27;zrender/shape/Image&#x27;,&#x27;zrender/shape/Base&#x27;],function (require) {
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);

        function _iconMark(ctx, style) {
            var dx = style.width / 16;
            var dy = style.height / 16;
            ctx.moveTo(style.x,                 style.y + style.height);
            ctx.lineTo(style.x + 5 * dx,        style.y + 14 * dy);
            ctx.lineTo(style.x + style.width,   style.y + 3 * dy);
            ctx.lineTo(style.x + 13 * dx,       style.y);
            ctx.lineTo(style.x + 2 * dx,        style.y + 11 * dy);
            ctx.lineTo(style.x,                 style.y + style.height);

            ctx.moveTo(style.x + 6 * dx,        style.y + 10 * dy);
            ctx.lineTo(style.x + 14 * dx,       style.y + 2 * dy);

            ctx.moveTo(style.x + 10 * dx,       style.y + 13 * dy);
            ctx.lineTo(style.x + style.width,   style.y + 13 * dy);

            ctx.moveTo(style.x + 13 * dx,       style.y + 10 * dy);
            ctx.lineTo(style.x + 13 * dx,       style.y + style.height);

            // 避免自动闭合路径
            ctx.moveTo(style.x, style.y);
        }

        function _iconMarkUndo(ctx, style) {
            var dx = style.width / 16;
            var dy = style.height / 16;
            ctx.moveTo(style.x,                 style.y + style.height);
            ctx.lineTo(style.x + 5 * dx,        style.y + 14 * dy);
            ctx.lineTo(style.x + style.width,   style.y + 3 * dy);
            ctx.lineTo(style.x + 13 * dx,       style.y);
            ctx.lineTo(style.x + 2 * dx,        style.y + 11 * dy);
            ctx.lineTo(style.x,                 style.y + style.height);

            ctx.moveTo(style.x + 6 * dx,        style.y + 10 * dy);
            ctx.lineTo(style.x + 14 * dx,       style.y + 2 * dy);

            ctx.moveTo(style.x + 10 * dx,       style.y + 13 * dy);
            ctx.lineTo(style.x + style.width,   style.y + 13 * dy);

            // 避免自动闭合路径
            ctx.moveTo(style.x, style.y);
        }

        function _iconMarkClear(ctx, style) {
            var dx = style.width / 16;
            var dy = style.height / 16;

            ctx.moveTo(style.x + 4 * dx,        style.y + 15 * dy);
            ctx.lineTo(style.x + 9 * dx,        style.y + 13 * dy);
            ctx.lineTo(style.x + 14 * dx,       style.y + 8 * dy);
            ctx.lineTo(style.x + 11 * dx,       style.y + 5 * dy);
            ctx.lineTo(style.x + 6 * dx,        style.y + 10 * dy);
            ctx.lineTo(style.x + 4 * dx,        style.y + 15 * dy);

            ctx.moveTo(style.x + 5 * dx,        style.y);
            ctx.lineTo(style.x + 11 * dx,        style.y);
            ctx.moveTo(style.x + 5 * dx,        style.y + dy);
            ctx.lineTo(style.x + 11 * dx,        style.y + dy);
            ctx.moveTo(style.x,        style.y + 2 * dy);
            ctx.lineTo(style.x + style.width,        style.y + 2 * dy);

            ctx.moveTo(style.x,        style.y + 5 * dy);
            ctx.lineTo(style.x + 3 * dx,        style.y + style.height);
            ctx.lineTo(style.x + 13 * dx,        style.y + style.height);
            ctx.lineTo(style.x + style.width,        style.y + 5 * dy);

            // 避免自动闭合路径
            ctx.moveTo(style.x, style.y);
        }

        function _iconDataZoom(ctx, style) {
            var dx = style.width / 16;
            var dy = style.height / 16;

            ctx.moveTo(style.x,             style.y + 3 * dy);
            ctx.lineTo(style.x + 6 * dx,    style.y + 3 * dy);

            ctx.moveTo(style.x + 3 * dx,    style.y);
            ctx.lineTo(style.x + 3 * dx,    style.y + 6 * dy);

            ctx.moveTo(style.x + 3 * dx,      style.y + 8 * dy);
            ctx.lineTo(style.x + 3 * dx,      style.y + style.height);
            ctx.lineTo(style.x + style.width, style.y + style.height);
            ctx.lineTo(style.x + style.width, style.y + 3 * dy);
            ctx.lineTo(style.x + 8 * dx,      style.y + 3 * dy);

            // 避免自动闭合路径
            ctx.moveTo(style.x, style.y);
        }

        function _iconDataZoomReset(ctx, style) {
            var dx = style.width / 16;
            var dy = style.height / 16;

            ctx.moveTo(style.x + 6 * dx,      style.y);
            ctx.lineTo(style.x + 2 * dx,          style.y + 3 * dy);
            ctx.lineTo(style.x + 6 * dx,          style.y + 6 * dy);

            ctx.moveTo(style.x + 2 * dx,          style.y + 3 * dy);
            ctx.lineTo(style.x + 14 * dx,     style.y + 3 * dy);
            ctx.lineTo(style.x + 14 * dx,     style.y + 11 * dy);

            ctx.moveTo(style.x + 2 * dx,          style.y + 5 * dy);
            ctx.lineTo(style.x + 2 * dx,          style.y + 13 * dy);
            ctx.lineTo(style.x + 14 * dx,     style.y + 13 * dy);

            ctx.moveTo(style.x + 10 * dx,     style.y + 10 * dy);
            ctx.lineTo(style.x + 14 * dx,     style.y + 13 * dy);
            ctx.lineTo(style.x + 10 * dx,     style.y + style.height);

            // 避免自动闭合路径
            ctx.moveTo(style.x, style.y);
        }

        function _iconRestore(ctx, style) {
            var dx = style.width / 16;
            var dy = style.height / 16;
            var r = style.width / 2;

            ctx.lineWidth = 1.5;

            ctx.arc(style.x + r, style.y + r, r - dx, 0, Math.PI * 2 / 3);
            ctx.moveTo(style.x + 3 * dx,        style.y + style.height);
            ctx.lineTo(style.x + 0 * dx,        style.y + 12 * dy);
            ctx.lineTo(style.x + 5 * dx,        style.y + 11 * dy);

            ctx.moveTo(style.x, style.y + 8 * dy);
            ctx.arc(style.x + r, style.y + r, r - dx, Math.PI, Math.PI * 5 / 3);
            ctx.moveTo(style.x + 13 * dx,       style.y);
            ctx.lineTo(style.x + style.width,   style.y + 4 * dy);
            ctx.lineTo(style.x + 11 * dx,       style.y + 5 * dy);

            // 避免自动闭合路径
            ctx.moveTo(style.x, style.y);
        }

        function _iconLineChart(ctx, style) {
            var dx = style.width / 16;
            var dy = style.height / 16;

            ctx.moveTo(style.x, style.y);
            ctx.lineTo(style.x, style.y + style.height);
            ctx.lineTo(style.x + style.width, style.y + style.height);

            ctx.moveTo(style.x + 2 * dx,    style.y + 14 * dy);
            ctx.lineTo(style.x + 7 * dx,    style.y + 6 * dy);
            ctx.lineTo(style.x + 11 * dx,   style.y + 11 * dy);
            ctx.lineTo(style.x + 15 * dx,   style.y + 2 * dy);

            // 避免自动闭合路径
            ctx.moveTo(style.x, style.y);
        }

        function _iconBarChart(ctx, style) {
            var dx = style.width / 16;
            var dy = style.height / 16;

            ctx.moveTo(style.x, style.y);
            ctx.lineTo(style.x, style.y + style.height);
            ctx.lineTo(style.x + style.width, style.y + style.height);

            ctx.moveTo(style.x + 3 * dx,        style.y + 14 * dy);
            ctx.lineTo(style.x + 3 * dx,        style.y + 6 * dy);
            ctx.lineTo(style.x + 4 * dx,        style.y + 6 * dy);
            ctx.lineTo(style.x + 4 * dx,        style.y + 14 * dy);
            ctx.moveTo(style.x + 7 * dx,        style.y + 14 * dy);
            ctx.lineTo(style.x + 7 * dx,        style.y + 2 * dy);
            ctx.lineTo(style.x + 8 * dx,        style.y + 2 * dy);
            ctx.lineTo(style.x + 8 * dx,        style.y + 14 * dy);
            ctx.moveTo(style.x + 11 * dx,       style.y + 14 * dy);
            ctx.lineTo(style.x + 11 * dx,       style.y + 9 * dy);
            ctx.lineTo(style.x + 12 * dx,       style.y + 9 * dy);
            ctx.lineTo(style.x + 12 * dx,       style.y + 14 * dy);

            // 避免自动闭合路径
            ctx.moveTo(style.x, style.y);
        }

        function _iconStackChart(ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            var dy = Math.round(height / 3);
            var len = 3;
            while (len--) {
                ctx.rect(x, y + dy * len + 2, width, 2);
            }

            // 避免自动闭合路径
            ctx.moveTo(style.x, style.y);
        }

        function _iconTiledChart(ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            var dx = Math.round(width / 3);
            var len = 3;
            while (len--) {
                ctx.rect(x + dx * len, y, 2, height);
            }

            // 避免自动闭合路径
            ctx.moveTo(style.x, style.y);
        }

        function _iconDataView(ctx, style) {
            var dx = style.width / 16;

            ctx.moveTo(style.x + dx, style.y);
            ctx.lineTo(style.x + dx, style.y + style.height);
            ctx.lineTo(style.x + 15 * dx, style.y + style.height);
            ctx.lineTo(style.x + 15 * dx, style.y);
            ctx.lineTo(style.x + dx, style.y);

            ctx.moveTo(style.x + 3 * dx, style.y + 3 * dx);
            ctx.lineTo(style.x + 13 * dx, style.y + 3 * dx);

            ctx.moveTo(style.x + 3 * dx, style.y + 6 * dx);
            ctx.lineTo(style.x + 13 * dx, style.y + 6 * dx);

            ctx.moveTo(style.x + 3 * dx, style.y + 9 * dx);
            ctx.lineTo(style.x + 13 * dx, style.y + 9 * dx);

            ctx.moveTo(style.x + 3 * dx, style.y + 12 * dx);
            ctx.lineTo(style.x + 9 * dx, style.y + 12 * dx);

            // 避免自动闭合路径
            ctx.moveTo(style.x, style.y);
        }

        function _iconSave(ctx, style) {
            var dx = style.width / 16;
            var dy = style.height / 16;

            ctx.moveTo(style.x, style.y);
            ctx.lineTo(style.x, style.y + style.height);
            ctx.lineTo(style.x + style.width, style.y + style.height);
            ctx.lineTo(style.x + style.width, style.y);
            ctx.lineTo(style.x, style.y);

            ctx.moveTo(style.x + 4 * dx,    style.y);
            ctx.lineTo(style.x + 4 * dx,    style.y + 8 * dy);
            ctx.lineTo(style.x + 12 * dx,   style.y + 8 * dy);
            ctx.lineTo(style.x + 12 * dx,   style.y);

            ctx.moveTo(style.x + 6 * dx,    style.y + 11 * dy);
            ctx.lineTo(style.x + 6 * dx,    style.y + 13 * dy);
            ctx.lineTo(style.x + 10 * dx,   style.y + 13 * dy);
            ctx.lineTo(style.x + 10 * dx,   style.y + 11 * dy);
            ctx.lineTo(style.x + 6 * dx,    style.y + 11 * dy);

            // 避免自动闭合路径
            ctx.moveTo(style.x, style.y);
        }

        function _iconCross(ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            ctx.moveTo(x, y + height / 2);
            ctx.lineTo(x + width, y + height / 2);

            ctx.moveTo(x + width / 2, y);
            ctx.lineTo(x + width / 2, y + height);
        }

        function _iconCircle(ctx, style) {
            var width = style.width / 2;
            var height = style.height / 2;
            var r = Math.min(width, height);
            ctx.moveTo(
                    style.x + width + r,
                    style.y + height
            );
            ctx.arc(
                    style.x + width,
                    style.y + height,
                r,
                0,
                    Math.PI * 2
            );
        }

        function _iconRectangle(ctx, style) {
            ctx.rect(style.x, style.y, style.width, style.height);
        }

        function _iconTriangle(ctx, style) {
            var width = style.width / 2;
            var height = style.height / 2;
            var x = style.x + width;
            var y = style.y + height;
            var symbolSize = Math.min(width, height);
            ctx.moveTo(x, y - symbolSize);
            ctx.lineTo(x + symbolSize, y + symbolSize);
            ctx.lineTo(x - symbolSize, y + symbolSize);
            ctx.lineTo(x, y - symbolSize);
        }

        function _iconDiamond(ctx, style) {
            var width = style.width / 2;
            var height = style.height / 2;
            var x = style.x + width;
            var y = style.y + height;
            var symbolSize = Math.min(width, height);
            ctx.moveTo(x, y - symbolSize);
            ctx.lineTo(x + symbolSize, y);
            ctx.lineTo(x, y + symbolSize);
            ctx.lineTo(x - symbolSize, y);
            ctx.lineTo(x, y - symbolSize);
        }

        function _iconArrow(ctx, style) {
            var x = style.x;
            var y = style.y;
            var dx = style.width / 16;
            ctx.moveTo(x + 8 * dx,  y);
            ctx.lineTo(x + dx,      y + style.height);
            ctx.lineTo(x + 8 * dx,  y + style.height / 4 * 3);
            ctx.lineTo(x + 15 * dx, y + style.height);
            ctx.lineTo(x + 8 * dx,  y);
        }

        function _iconStar(ctx, style) {
            var StarShape = require(&#x27;zrender/shape/Star&#x27;);
            var width = style.width / 2;
            var height = style.height / 2;
            StarShape.prototype.buildPath(ctx, {
                x : style.x + width,
                y : style.y + height,
                r : Math.min(width, height),
                n : style.n || 5
            });
        }

        function _iconHeart(ctx, style) {
            var HeartShape = require(&#x27;zrender/shape/Heart&#x27;);
            HeartShape.prototype.buildPath(ctx, {
                x : style.x + style.width / 2,
                y : style.y + style.height * 0.2,
                a : style.width / 2,
                b : style.height * 0.8
            });
        }

        function _iconDroplet(ctx, style) {
            var DropletShape = require(&#x27;zrender/shape/Droplet&#x27;);
            DropletShape.prototype.buildPath(ctx, {
                x : style.x + style.width * 0.5,
                y : style.y + style.height * 0.5,
                a : style.width * 0.5,
                b : style.height * 0.8
            });
        }

        function _iconPin(ctx, style) {
            var x = style.x;
            var y = style.y - style.height / 2 * 1.5;
            var width = style.width / 2;
            var height = style.height / 2;
            var r = Math.min(width, height);
            ctx.arc(
                    x + width,
                    y + height,
                r,
                    Math.PI / 5 * 4,
                    Math.PI / 5
            );
            ctx.lineTo(x + width, y + height + r * 1.5);
        }

        function _iconImage(ctx, style) {
            setTimeout(function (){
                var ImageShape = require(&#x27;zrender/shape/Image&#x27;);
                var itemShape = new ImageShape({
                    style : style
                });
                itemShape.brush(ctx);
            },100);
        }

        var Base = require(&#x27;zrender/shape/Base&#x27;);

        function Icon(options) {
            Base.call(this, options);
        }

        Icon.prototype =  {
            type : &#x27;icon&#x27;,
            iconLibrary : {
                mark : _iconMark,
                markUndo : _iconMarkUndo,
                markClear : _iconMarkClear,
                dataZoom : _iconDataZoom,
                dataZoomReset : _iconDataZoomReset,
                restore : _iconRestore,
                lineChart : _iconLineChart,
                barChart : _iconBarChart,
                stackChart : _iconStackChart,
                tiledChart : _iconTiledChart,
                dataView : _iconDataView,
                saveAsImage : _iconSave,

                cross : _iconCross,
                circle : _iconCircle,
                rectangle : _iconRectangle,
                triangle : _iconTriangle,
                diamond : _iconDiamond,
                arrow : _iconArrow,
                star : _iconStar,
                heart : _iconHeart,
                droplet : _iconDroplet,
                pin : _iconPin,
                image : _iconImage
            },
            /**
             * 创建矩形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath : function (ctx, style) {
                if (this.iconLibrary[style.iconType]) {
                    this.iconLibrary[style.iconType](ctx, style);
                }
                else {
                    ctx.moveTo(style.x, style.y);
                    ctx.lineTo(style.x + style.width, style.y);
                    ctx.lineTo(style.x + style.width, style.y + style.height);
                    ctx.lineTo(style.x, style.y + style.height);
                    ctx.lineTo(style.x, style.y);
                }

                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect : function (style) {
                if (style.__rect) {
                    return style.__rect;
                }

                // pin比较特殊，让尖端在目标x,y上
                style.__rect = {
                    x : Math.round(style.x),
                    y : Math.round(style.y - (style.iconType == &#x27;pin&#x27;
                            ? (style.height / 2 * 1.5) : 0)
                    ),
                    width : style.width,
                    height : style.height
                };

                return style.__rect;
            },

            isCover : function (x, y) {
                var originPos = this.getTansform(x, y);
                x = originPos[0];
                y = originPos[1];

                // 快速预判并保留判断矩形
                var rect = this.style.__rect;
                if (!rect) {
                    rect = this.style.__rect = this.getRect(this.style);
                }
                // 提高交互体验，太小的图形包围盒四向扩大4px
                var delta = (rect.height &lt; 8 || rect.width &lt; 8 ) ? 4 : 0;
                if (x &gt;= rect.x - delta
                    &amp;&amp; x &lt;= (rect.x + rect.width + delta)
                    &amp;&amp; y &gt;= rect.y - delta
                    &amp;&amp; y &lt;= (rect.y + rect.height + delta)
                    ) {
                    // 矩形内
                    return true;
                }
                else {
                    return false;
                }
            }
        };

        zrUtil.inherits(Icon, Base);

        return Icon;
    });
    /**
     * 虚线lineTo
     *
     * author:  Kener (@Kener-林峰, linzhifeng@baidu.com)
     *          errorrik (errorrik@gmail.com)
     */

    define(
        &#x27;zrender/shape/util/dashedLineTo&#x27;,[],function (/* require */) {
            /**
             * 虚线lineTo
             */
            return function (ctx, x1, y1, x2, y2, dashLength) {
                dashLength = typeof dashLength != &#x27;number&#x27;
                    ? 5
                    : dashLength;

                var deltaX = x2 - x1;
                var deltaY = y2 - y1;
                var numDashes = Math.floor(
                        Math.sqrt(deltaX * deltaX + deltaY * deltaY) / dashLength
                );

                for (var i = 0; i &lt; numDashes; ++i) {
                    ctx[i % 2 ? &#x27;lineTo&#x27; : &#x27;moveTo&#x27;](
                            x1 + (deltaX / numDashes) * i,
                            y1 + (deltaY / numDashes) * i
                    );
                }
                ctx.lineTo(x2, y2);
            };
        }
    );

    /**
     * zrender
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：直线
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;line&#x27;,         // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           xStart        : {number},  // 必须，起点横坐标
           yStart        : {number},  // 必须，起点纵坐标
           xEnd          : {number},  // 必须，终点横坐标
           yEnd          : {number},  // 必须，终点纵坐标
           strokeColor   : {color},   // 默认为&#x27;#000&#x27;，线条颜色（轮廓），支持rgba
           lineType      : {string},  // 默认为solid，线条类型，solid | dashed | dotted
           lineWidth     : {number},  // 默认为1，线条宽度
           lineCap       : {string},  // 默认为butt，线帽样式。butt | round | square

           opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
           shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
           shadowColor   : {color},   // 默认为&#x27;#000&#x27;，阴影色彩，支持rgba
           shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
           shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

           text          : {string},  // 默认为null，附加文本
           textFont      : {string},  // 默认为null，附加文本样式，eg:&#x27;bold 18px verdana&#x27;
           textPosition  : {string},  // 默认为end，附加文本位置。
                                      // inside | start | end
           textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                      // start | end | left | right | center
           textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                      // top | bottom | middle |
                                      // alphabetic | hanging | ideographic
           textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                      // &#x27;inside&#x27; ? &#x27;#000&#x27; : color
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     例子：
     {
       shape  : &#x27;line&#x27;,
       id     : &#x27;123456&#x27;,
       zlevel : 1,
       style  : {
           xStart : 100,
           yStart : 100,
           xEnd : 200,
           yEnd : 200,
           strokeColor : &#x27;#eee&#x27;,
           lineWidth : 20,
           text : &#x27;Baidu&#x27;
       },
       myName : &#x27;kener&#x27;,  //可自带任何有效自定义属性

       clickable : true,
       onClick : function(eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
     */
    define(
        &#x27;zrender/shape/Line&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;./util/dashedLineTo&#x27;,&#x27;../tool/util&#x27;],function (require) {
            var Base = require(&#x27;./Base&#x27;);
            var dashedLineTo = require(&#x27;./util/dashedLineTo&#x27;);

            function Line(options) {
                this.brushTypeOnly = &#x27;stroke&#x27;;  //线条只能描边，填充后果自负
                this.textPosition = &#x27;end&#x27;;
                Base.call(this, options);
            }

            Line.prototype =  {
                type: &#x27;line&#x27;,

                /**
                 * 创建线条路径
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                buildPath : function(ctx, style) {
                    if (!style.lineType || style.lineType == &#x27;solid&#x27;) {
                        //默认为实线
                        ctx.moveTo(style.xStart, style.yStart);
                        ctx.lineTo(style.xEnd, style.yEnd);
                    }
                    else if (style.lineType == &#x27;dashed&#x27;
                        || style.lineType == &#x27;dotted&#x27;
                        ) {
                        var dashLength =(style.lineWidth || 1)
                            * (style.lineType == &#x27;dashed&#x27; ? 5 : 1);
                        dashedLineTo(
                            ctx,
                            style.xStart, style.yStart,
                            style.xEnd, style.yEnd,
                            dashLength
                        );
                    }
                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect : function(style) {
                    if (style.__rect) {
                        return style.__rect;
                    }

                    var lineWidth = style.lineWidth || 1;
                    style.__rect = {
                        x : Math.min(style.xStart, style.xEnd) - lineWidth,
                        y : Math.min(style.yStart, style.yEnd) - lineWidth,
                        width : Math.abs(style.xStart - style.xEnd)
                            + lineWidth,
                        height : Math.abs(style.yStart - style.yEnd)
                            + lineWidth
                    };

                    return style.__rect;
                }
            };

            require(&#x27;../tool/util&#x27;).inherits(Line, Base);
            return Line;
        }
    );
    /**
     * zrender: 向量操作类
     *
     * author : lang(shenyi01@baidu.com)
     */
    define(
        &#x27;zrender/tool/vector&#x27;,[],function() {
            var ArrayCtor = typeof Float32Array === &#x27;undefined&#x27;
                ? Array
                : Float32Array;

            var vector = {
                create : function(x, y) {
                    var out = new ArrayCtor(2);
                    out[0] = x || 0;
                    out[1] = y || 0;
                    return out;
                },
                copy : function(out, v) {
                    out[0] = v[0];
                    out[1] = v[1];
                },
                set : function(out, a, b) {
                    out[0] = a;
                    out[1] = b;
                },
                add : function(out, v1, v2) {
                    out[0] = v1[0] + v2[0];
                    out[1] = v1[1] + v2[1];
                    return out;
                },
                scaleAndAdd : function(out, v1, v2, a) {
                    out[0] = v1[0] + v2[0] * a;
                    out[1] = v1[1] + v2[1] * a;
                    return out;
                },
                sub : function(out, v1, v2) {
                    out[0] = v1[0] - v2[0];
                    out[1] = v1[1] - v2[1];
                    return out;
                },
                length : function(v) {
                    return Math.sqrt(this.lengthSquare(v));
                },
                lengthSquare : function(v) {
                    return v[0] * v[0] + v[1] * v[1];
                },
                mul : function(out, v1, v2) {
                    out[0] = v1[0] * v2[0];
                    out[1] = v1[1] * v2[1];
                    return out;
                },
                dot : function(v1, v2) {
                    return v1[0] * v2[0] + v1[1] * v2[1];
                },
                scale : function(out, v, s) {
                    out[0] = v[0] * s;
                    out[1] = v[1] * s;
                    return out;
                },
                normalize : function(out, v) {
                    var d = vector.length(v);
                    if(d === 0){
                        out[0] = 0;
                        out[1] = 0;
                    }else{
                        out[0] = v[0]/d;
                        out[1] = v[1]/d;
                    }
                    return out;
                },
                distance : function(v1, v2) {
                    return Math.sqrt(
                            (v1[0] - v2[0]) * (v1[0] - v2[0]) +
                            (v1[1] - v2[1]) * (v1[1] - v2[1])
                    );
                },
                negate : function(out, v) {
                    out[0] = -v[0];
                    out[1] = -v[1];
                },
                middle : function(out, v1, v2) {
                    out[0] = (v1[0] + v2[0])/2;
                    out[1] = (v1[1] + v2[1])/2;
                    return out;
                }
            };

            return vector;
        }
    );
    /**
     * 多线段平滑曲线 Catmull-Rom spline
     *
     * author:  Kener (@Kener-林峰, linzhifeng@baidu.com)
     *          errorrik (errorrik@gmail.com)
     */


    define(
        &#x27;zrender/shape/util/smoothSpline&#x27;,[&#x27;require&#x27;,&#x27;../../tool/vector&#x27;],function ( require ) {
            var vector = require(&#x27;../../tool/vector&#x27;);

            /**
             * @inner
             */
            function interpolate(p0, p1, p2, p3, t, t2, t3) {
                var v0 = (p2 - p0) * 0.5;
                var v1 = (p3 - p1) * 0.5;
                return (2 * (p1 - p2) + v0 + v1) * t3
                    + (- 3 * (p1 - p2) - 2 * v0 - v1) * t2
                    + v0 * t + p1;
            }

            /**
             * 多线段平滑曲线 Catmull-Rom spline
             */
            return function (points, isLoop) {
                var len = points.length;
                var ret = [];

                var distance = 0;
                for (var i = 1; i &lt; len; i++) {
                    distance += vector.distance(points[i-1], points[i]);
                }

                var segs = distance / 5;
                segs = segs &lt; len ? len : segs;
                for (var i = 0; i &lt; segs; i++) {
                    var pos = i / (segs-1) * (isLoop ? len : len - 1);
                    var idx = Math.floor(pos);

                    var w = pos - idx;

                    var p0;
                    var p1 = points[idx % len];
                    var p2;
                    var p3;
                    if (!isLoop) {
                        p0 = points[idx === 0 ? idx : idx - 1];
                        p2 = points[idx &gt; len - 2 ? len - 1 : idx + 1];
                        p3 = points[idx &gt; len - 3 ? len - 1 : idx + 2];
                    } else {
                        p0 = points[(idx -1 + len) % len];
                        p2 = points[(idx + 1) % len];
                        p3 = points[(idx + 2) % len];
                    }

                    var w2 = w * w;
                    var w3 = w * w2;

                    ret.push([
                        interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
                        interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
                    ]);
                }
                return ret;
            };
        }
    );

    /**
     * 贝塞尔平滑曲线
     *
     * author:  Kener (@Kener-林峰, linzhifeng@baidu.com)
     *          errorrik (errorrik@gmail.com)
     */

    define(
        &#x27;zrender/shape/util/smoothBezier&#x27;,[&#x27;require&#x27;,&#x27;../../tool/vector&#x27;],function ( require ) {
            var vector = require(&#x27;../../tool/vector&#x27;);

            /**
             * 贝塞尔平滑曲线
             */
            return function (points, smooth, isLoop) {
                var cps = [];

                var v = [];
                var v1 = [];
                var v2 = [];
                var prevPoint;
                var nextPoint;

                for (var i = 0, len = points.length; i &lt; len; i++) {
                    var point = points[i];
                    var prevPoint;
                    var nextPoint;

                    if (isLoop) {
                        prevPoint = points[i ? i - 1 : len - 1];
                        nextPoint = points[(i + 1) % len];
                    }
                    else {
                        if (i === 0 || i === len - 1) {
                            cps.push(points[i]);
                            continue;
                        }
                        else {
                            prevPoint = points[i - 1];
                            nextPoint = points[i + 1];
                        }
                    }

                    vector.sub(v, nextPoint, prevPoint);

                    //use degree to scale the handle length
                    vector.scale(v, v, smooth);

                    var d0 = vector.distance(point, prevPoint);
                    var d1 = vector.distance(point, nextPoint);
                    var sum = d0 + d1;
                    d0 /= sum;
                    d1 /= sum;

                    vector.scale(v1, v, -d0);
                    vector.scale(v2, v, d1);

                    cps.push(vector.add([], point, v1));
                    cps.push(vector.add([], point, v2));
                }

                if (isLoop) {
                    cps.push(cps.shift());
                }

                return cps;
            };
        }
    );

    /**
     * zrender
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：多边形
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;polygon&#x27;,      // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           pointList     : {Array},   // 必须，多边形各个顶角坐标
           brushType     : {string},  // 默认为fill，绘画方式
                                      // fill(填充) | stroke(描边) | both(填充+描边)
           color         : {color},   // 默认为&#x27;#000&#x27;，填充颜色，支持rgba
           strokeColor   : {color},   // 默认为&#x27;#000&#x27;，描边颜色（轮廓），支持rgba
           lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

           opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
           shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
           shadowColor   : {color},   // 默认为&#x27;#000&#x27;，阴影色彩，支持rgba
           shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
           shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

           text          : {string},  // 默认为null，附加文本
           textFont      : {string},  // 默认为null，附加文本样式，eg:&#x27;bold 18px verdana&#x27;
           textPosition  : {string},  // 默认为top，附加文本位置。
                                      // inside | left | right | top | bottom
           textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                      // start | end | left | right | center
           textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                      // top | bottom | middle |
                                      // alphabetic | hanging | ideographic
           textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                      // &#x27;inside&#x27; ? &#x27;#fff&#x27; : color
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     例子：
     {
       shape  : &#x27;polygon&#x27;,
       id     : &#x27;123456&#x27;,
       zlevel : 1,
       style  : {
           pointList : [[10, 10], [300, 20], [298, 400], [50, 450]]
           color : &#x27;#eee&#x27;,
           text : &#x27;Baidu&#x27;
       },
       myName : &#x27;kener&#x27;,  // 可自带任何有效自定义属性

       clickable : true,
       onClick : function(eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
     */
    define(
        &#x27;zrender/shape/Polygon&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;./util/smoothSpline&#x27;,&#x27;./util/smoothBezier&#x27;,&#x27;./util/dashedLineTo&#x27;,&#x27;../tool/util&#x27;],function (require) {
            var Base = require(&#x27;./Base&#x27;);
            var smoothSpline = require(&#x27;./util/smoothSpline&#x27;);
            var smoothBezier = require(&#x27;./util/smoothBezier&#x27;);
            var dashedLineTo = require(&#x27;./util/dashedLineTo&#x27;);


            function Polygon(options) {
                Base.call(this, options);
            }

            Polygon.prototype = {
                type: &#x27;polygon&#x27;,

                /**
                 * 画刷
                 * @param ctx       画布句柄
                 * @param isHighlight   是否为高亮状态
                 * @param updateCallback 需要异步加载资源的shape可以通过这个callback(e)
                 *                       让painter更新视图，base.brush没用，需要的话重载brush
                 */
                brush : function (ctx, isHighlight) {
                    var style = this.style;
                    if (isHighlight) {
                        // 根据style扩展默认高亮样式
                        style = this.getHighlightStyle(
                            style,
                                this.highlightStyle || {}
                        );
                    }

                    ctx.save();
                    this.setContext(ctx, style);

                    // 设置transform
                    this.updateTransform(ctx);

                    // 先fill再stroke
                    var hasPath = false;
                    if (style.brushType == &#x27;fill&#x27;
                        || style.brushType == &#x27;both&#x27;
                        || typeof style.brushType == &#x27;undefined&#x27; // 默认为fill
                        ) {
                        ctx.beginPath();
                        if (style.lineType == &#x27;dashed&#x27;
                            || style.lineType == &#x27;dotted&#x27;
                            ) {
                            // 特殊处理，虚线围不成path，实线再build一次
                            this.buildPath(
                                ctx,
                                {
                                    lineType: &#x27;solid&#x27;,
                                    lineWidth: style.lineWidth,
                                    pointList: style.pointList
                                }
                            );
                            hasPath = false; // 这个path不能用
                        }
                        else {
                            this.buildPath(ctx, style);
                            hasPath = true; // 这个path能用
                        }
                        ctx.closePath();
                        ctx.fill();
                    }

                    if (style.lineWidth &gt; 0
                        &amp;&amp; (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;both&#x27;)
                        ) {
                        if (!hasPath) {
                            ctx.beginPath();
                            this.buildPath(ctx, style);
                            ctx.closePath();
                        }
                        ctx.stroke();
                    }

                    if (style.text) {
                        this.drawText(ctx, style, this.style);
                    }

                    ctx.restore();

                    return;
                },

                /**
                 * 创建多边形路径
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                buildPath : function(ctx, style) {
                    // 虽然能重用brokenLine，但底层图形基于性能考虑，重复代码减少调用吧
                    var pointList = style.pointList;
                    // 开始点和结束点重复
                    /*
                     var start = pointList[0];
                     var end = pointList[pointList.length-1];

                     if (start &amp;&amp; end) {
                     if (start[0] == end[0] &amp;&amp;
                     start[1] == end[1]) {
                     // 移除最后一个点
                     pointList.pop();
                     }
                     }
                     */

                    if (pointList.length &lt; 2) {
                        // 少于2个点就不画了~
                        return;
                    }

                    if (style.smooth &amp;&amp; style.smooth !== &#x27;spline&#x27;) {
                        var controlPoints = smoothBezier(
                            pointList, style.smooth, true
                        );

                        ctx.moveTo(pointList[0][0], pointList[0][1]);
                        var cp1;
                        var cp2;
                        var p;
                        var len = pointList.length;
                        for (var i = 0; i &lt; len; i++) {
                            cp1 = controlPoints[i * 2];
                            cp2 = controlPoints[i * 2 + 1];
                            p = pointList[(i + 1) % len];
                            ctx.bezierCurveTo(
                                cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
                            );
                        }
                    }
                    else {
                        if (style.smooth === &#x27;spline&#x27;) {
                            pointList = smoothSpline(pointList, true);
                        }

                        if (!style.lineType || style.lineType == &#x27;solid&#x27;) {
                            //默认为实线
                            ctx.moveTo(pointList[0][0],pointList[0][1]);
                            for (var i = 1, l = pointList.length; i &lt; l; i++) {
                                ctx.lineTo(pointList[i][0],pointList[i][1]);
                            }
                            ctx.lineTo(pointList[0][0], pointList[0][1]);
                        }
                        else if (style.lineType == &#x27;dashed&#x27;
                            || style.lineType == &#x27;dotted&#x27;
                            ) {
                            var dashLength =
                                style._dashLength
                                || (style.lineWidth || 1)
                                * (style.lineType == &#x27;dashed&#x27; ? 5 : 1);
                            style._dashLength = dashLength;
                            ctx.moveTo(pointList[0][0],pointList[0][1]);
                            for (var i = 1, l = pointList.length; i &lt; l; i++) {
                                dashedLineTo(
                                    ctx,
                                    pointList[i - 1][0], pointList[i - 1][1],
                                    pointList[i][0], pointList[i][1],
                                    dashLength
                                );
                            }
                            dashedLineTo(
                                ctx,
                                pointList[pointList.length - 1][0],
                                pointList[pointList.length - 1][1],
                                pointList[0][0],
                                pointList[0][1],
                                dashLength
                            );
                        }
                    }
                    return;
                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect : function(style) {
                    if (style.__rect) {
                        return style.__rect;
                    }

                    var minX =  Number.MAX_VALUE;
                    var maxX =  Number.MIN_VALUE;
                    var minY = Number.MAX_VALUE;
                    var maxY = Number.MIN_VALUE;

                    var pointList = style.pointList;
                    for(var i = 0, l = pointList.length; i &lt; l; i++) {
                        if (pointList[i][0] &lt; minX) {
                            minX = pointList[i][0];
                        }
                        if (pointList[i][0] &gt; maxX) {
                            maxX = pointList[i][0];
                        }
                        if (pointList[i][1] &lt; minY) {
                            minY = pointList[i][1];
                        }
                        if (pointList[i][1] &gt; maxY) {
                            maxY = pointList[i][1];
                        }
                    }

                    var lineWidth;
                    if (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;fill&#x27;) {
                        lineWidth = style.lineWidth || 1;
                    }
                    else {
                        lineWidth = 0;
                    }

                    style.__rect = {
                        x : Math.round(minX - lineWidth / 2),
                        y : Math.round(minY - lineWidth / 2),
                        width : maxX - minX + lineWidth,
                        height : maxY - minY + lineWidth
                    };
                    return style.__rect;
                }
            };

            require(&#x27;../tool/util&#x27;).inherits(Polygon, Base);
            return Polygon;
        }
    );
    /**
     * zrender
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：折线
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;brokenLine&#x27;,         // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           pointList     : {Array},   // 必须，各个顶角坐标
           smooth        : {Number},  // 默认为0
           strokeColor   : {color},   // 默认为&#x27;#000&#x27;，线条颜色（轮廓），支持rgba
           lineType      : {string},  // 默认为solid，线条类型，solid | dashed | dotted
           lineWidth     : {number},  // 默认为1，线条宽度
           lineCap       : {string},  // 默认为butt，线帽样式。butt | round | square
           lineJoin      : {string},  // 默认为miter，线段连接样式。miter | round | bevel
           miterLimit    : {number},  // 默认为10，最大斜接长度，仅当lineJoin为miter时生效

           opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
           shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
           shadowColor   : {color},   // 默认为&#x27;#000&#x27;，阴影色彩，支持rgba
           shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
           shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

           text          : {string},  // 默认为null，附加文本
           textFont      : {string},  // 默认为null，附加文本样式，eg:&#x27;bold 18px verdana&#x27;
           textPosition  : {string},  // 默认为end，附加文本位置。
                                      // start | end
           textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                      // start | end | left | right | center
           textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                      // top | bottom | middle |
                                      // alphabetic | hanging | ideographic
           textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                      // &#x27;inside&#x27; ? &#x27;#000&#x27; : color
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     例子：
     {
       shape  : &#x27;brokenLine&#x27;,
       id     : &#x27;123456&#x27;,
       zlevel : 1,
       style  : {
           pointList : [[10, 10], [300, 20], [298, 400], [50, 450]],
           strokeColor : &#x27;#eee&#x27;,
           lineWidth : 20,
           text : &#x27;Baidu&#x27;
       },
       myName : &#x27;kener&#x27;,  //可自带任何有效自定义属性

       clickable : true,
       onClick : function(eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
     */
    define(
        &#x27;zrender/shape/BrokenLine&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;./util/smoothSpline&#x27;,&#x27;./util/smoothBezier&#x27;,&#x27;./util/dashedLineTo&#x27;,&#x27;./Polygon&#x27;,&#x27;../tool/util&#x27;],function (require) {
            var Base = require(&#x27;./Base&#x27;);
            var smoothSpline = require(&#x27;./util/smoothSpline&#x27;);
            var smoothBezier = require(&#x27;./util/smoothBezier&#x27;);
            var dashedLineTo = require(&#x27;./util/dashedLineTo&#x27;);

            function BrokenLine( options ) {
                this.brushTypeOnly = &#x27;stroke&#x27;;  //线条只能描边，填充后果自负
                this.textPosition = &#x27;end&#x27;;
                Base.call(this, options);
            }

            BrokenLine.prototype =  {
                type: &#x27;broken-line&#x27;,

                /**
                 * 创建多边形路径
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                buildPath : function(ctx, style) {
                    var pointList = style.pointList;
                    if (pointList.length &lt; 2) {
                        // 少于2个点就不画了~
                        return;
                    }

                    var len = Math.min(
                        style.pointList.length,
                        Math.round(style.pointListLength || style.pointList.length)
                    );

                    if (style.smooth &amp;&amp; style.smooth !== &#x27;spline&#x27;) {
                        var controlPoints = smoothBezier(
                            pointList, style.smooth
                        );

                        ctx.moveTo(pointList[0][0], pointList[0][1]);
                        var cp1;
                        var cp2;
                        var p;
                        for (var i = 0; i &lt; len - 1; i++) {
                            cp1 = controlPoints[i * 2];
                            cp2 = controlPoints[i * 2 + 1];
                            p = pointList[i + 1];
                            ctx.bezierCurveTo(
                                cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
                            );
                        }
                    }
                    else {
                        if (style.smooth === &#x27;spline&#x27;) {
                            pointList = smoothSpline(pointList);
                            len = pointList.length;
                        }
                        if (!style.lineType || style.lineType == &#x27;solid&#x27;) {
                            //默认为实线
                            ctx.moveTo(pointList[0][0],pointList[0][1]);
                            for (var i = 1; i &lt; len; i++) {
                                ctx.lineTo(pointList[i][0],pointList[i][1]);
                            }
                        }
                        else if (style.lineType == &#x27;dashed&#x27;
                            || style.lineType == &#x27;dotted&#x27;
                            ) {
                            var dashLength = (style.lineWidth || 1)
                                * (style.lineType == &#x27;dashed&#x27; ? 5 : 1);
                            ctx.moveTo(pointList[0][0],pointList[0][1]);
                            for (var i = 1; i &lt; len; i++) {
                                dashedLineTo(
                                    ctx,
                                    pointList[i - 1][0], pointList[i - 1][1],
                                    pointList[i][0], pointList[i][1],
                                    dashLength
                                );
                            }
                        }
                    }
                    return;
                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect : function(style) {
                    return require(&#x27;./Polygon&#x27;).prototype.getRect(style);
                }
            };

            require(&#x27;../tool/util&#x27;).inherits(BrokenLine, Base);
            return BrokenLine;
        }
    );

    /**
     * zrender
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：标线
     */
    define(&#x27;echarts/util/shape/MarkLine&#x27;,[&#x27;require&#x27;,&#x27;zrender/shape/Base&#x27;,&#x27;./Icon&#x27;,&#x27;zrender/shape/Line&#x27;,&#x27;zrender/shape/BrokenLine&#x27;,&#x27;zrender/tool/matrix&#x27;,&#x27;zrender/tool/area&#x27;,&#x27;zrender/shape/util/dashedLineTo&#x27;,&#x27;zrender/shape/util/smoothSpline&#x27;,&#x27;zrender/tool/util&#x27;],function (require) {
        var Base = require(&#x27;zrender/shape/Base&#x27;);
        var IconShape = require(&#x27;./Icon&#x27;);
        var LineShape = require(&#x27;zrender/shape/Line&#x27;);
        var lineInstance = new LineShape({});
        var BrokenLineShape = require(&#x27;zrender/shape/BrokenLine&#x27;);
        var brokenLineInstance = new BrokenLineShape({});

        var matrix = require(&#x27;zrender/tool/matrix&#x27;);
        var area = require(&#x27;zrender/tool/area&#x27;);
        var dashedLineTo = require(&#x27;zrender/shape/util/dashedLineTo&#x27;);
        var smoothSpline = require(&#x27;zrender/shape/util/smoothSpline&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);


        function MarkLine(options) {
            Base.call(this, options);
        }

        MarkLine.prototype =  {
            type : &#x27;mark-line&#x27;,
            /**
             * 画刷
             * @param ctx       画布句柄
             * @param e         形状实体
             * @param isHighlight   是否为高亮状态
             * @param updateCallback 需要异步加载资源的shape可以通过这个callback(e)
             *                       让painter更新视图，base.brush没用，需要的话重载brush
             */
            brush : function (ctx, isHighlight) {
                var style = this.style;

                if (isHighlight) {
                    // 根据style扩展默认高亮样式
                    style = this.getHighlightStyle(
                        style,
                            this.highlightStyle || {}
                    );
                }

                ctx.save();
                this.setContext(ctx, style);

                // 设置transform
                this.updateTransform(ctx);

                ctx.beginPath();
                this.buildLinePath(ctx, style);
                ctx.stroke();

                this.brushSymbol(ctx, style, 0);
                this.brushSymbol(ctx, style, 1);

                if (style.text) {
                    this.drawText(ctx, style, this.style);
                }

                ctx.restore();
            },

            /**
             * 创建线条路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildLinePath : function (ctx, style) {
                var pointList = style.pointList || this.getPointList(style);
                style.pointList = pointList;

                var len = Math.min(
                    style.pointList.length,
                    Math.round(style.pointListLength || style.pointList.length)
                );

                if (!style.lineType || style.lineType == &#x27;solid&#x27;) {
                    //默认为实线
                    ctx.moveTo(pointList[0][0],pointList[0][1]);
                    for (var i = 1; i &lt; len; i++) {
                        ctx.lineTo(pointList[i][0],pointList[i][1]);
                    }
                }
                else if (style.lineType == &#x27;dashed&#x27;
                    || style.lineType == &#x27;dotted&#x27;
                    ) {
                    if (style.smooth !== &#x27;spline&#x27;) {
                        // 直线
                        var dashLength = (style.lineWidth || 1)
                            * (style.lineType == &#x27;dashed&#x27; ? 5 : 1);
                        ctx.moveTo(pointList[0][0],pointList[0][1]);
                        for (var i = 1; i &lt; len; i++) {
                            dashedLineTo(
                                ctx,
                                pointList[i - 1][0], pointList[i - 1][1],
                                pointList[i][0], pointList[i][1],
                                dashLength
                            );
                        }
                    }
                    else {
                        // 曲线
                        for (var i = 1; i &lt; len; i += 2) {
                            ctx.moveTo(pointList[i - 1][0],pointList[i - 1][1]);
                            ctx.lineTo(pointList[i][0],pointList[i][1]);
                        }
                    }
                }
            },

            /**
             * 标线始末标注
             */
            brushSymbol : function (ctx, style, idx) {
                if (style.symbol[idx] == &#x27;none&#x27;) {
                    return;
                }
                ctx.save();
                ctx.beginPath();

                ctx.lineWidth = style.symbolBorder;
                ctx.strokeStyle = style.symbolBorderColor;
                // symbol
                style.iconType = style.symbol[idx].replace(&#x27;empty&#x27;, &#x27;&#x27;)
                    .toLowerCase();
                if (style.symbol[idx].match(&#x27;empty&#x27;)) {
                    ctx.fillStyle = &#x27;#fff&#x27;; //&#x27;rgba(0, 0, 0, 0)&#x27;;
                }

                // symbolRotate
                var len = Math.min(
                    style.pointList.length,
                    Math.round(style.pointListLength || style.pointList.length)
                );
                var x = idx === 0 ? style.pointList[0][0] : style.pointList[len - 1][0];
                var y = idx === 0 ? style.pointList[0][1] : style.pointList[len - 1][1];
                var rotate = typeof style.symbolRotate[idx] != &#x27;undefined&#x27;
                    ? (style.symbolRotate[idx] - 0) : 0;
                var transform;
                if (rotate !== 0) {
                    transform = matrix.create();
                    matrix.identity(transform);
                    if (x || y ) {
                        matrix.translate(transform, transform, [-x, -y]);
                    }
                    matrix.rotate(
                        transform, transform,
                            rotate * Math.PI / 180
                    );
                    if (x || y ) {
                        matrix.translate(transform, transform, [x, y]);
                    }
                    ctx.transform.apply(ctx, transform);
                }

                if (style.iconType == &#x27;arrow&#x27; &amp;&amp; rotate === 0) {
                    // 箭头自动旋转，手动画
                    this.buildArrawPath(ctx, style, idx);
                }
                else {
                    // symbolSize
                    var symbolSize = style.symbolSize[idx];
                    style.x = x - symbolSize;
                    style.y = y - symbolSize,
                        style.width = symbolSize * 2;
                    style.height = symbolSize * 2;
                    IconShape.prototype.buildPath(ctx, style);
                }

                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            },

            buildArrawPath : function (ctx, style, idx) {
                var len = Math.min(
                    style.pointList.length,
                    Math.round(style.pointListLength || style.pointList.length)
                );
                var symbolSize = style.symbolSize[idx] * 2;
                var xStart = style.pointList[0][0];
                var xEnd = style.pointList[len - 1][0];
                var yStart = style.pointList[0][1];
                var yEnd = style.pointList[len - 1][1];
                var delta = 0;
                if (style.smooth === &#x27;spline&#x27;) {
                    delta = 0.2; // 偏移0.2弧度
                }
                // 原谅我吧，这三角函数实在没想明白，只能这么笨了
                var rotate = Math.atan(
                    Math.abs((yEnd - yStart) / (xStart - xEnd)
                    ));
                if (idx === 0) {
                    if (xEnd &gt; xStart) {
                        if (yEnd &gt; yStart) {
                            rotate =  Math.PI * 2 - rotate + delta;
                        }
                        else {
                            rotate += delta;
                        }
                    }
                    else {
                        if (yEnd &gt; yStart) {
                            rotate += Math.PI - delta;
                        }
                        else {
                            rotate = Math.PI - rotate - delta;
                        }
                    }
                }
                else {
                    if (xStart &gt; xEnd) {
                        if (yStart &gt; yEnd) {
                            rotate =  Math.PI * 2 - rotate + delta;
                        }
                        else {
                            rotate += delta;
                        }
                    }
                    else {
                        if (yStart &gt; yEnd) {
                            rotate += Math.PI - delta;
                        }
                        else {
                            rotate = Math.PI - rotate - delta;
                        }
                    }
                }

                var halfRotate = Math.PI / 8; // 夹角
                var x = idx === 0 ? xStart : xEnd;
                var y = idx === 0 ? yStart : yEnd;
                var point= [
                    [
                            x + symbolSize * Math.cos(rotate - halfRotate),
                            y - symbolSize * Math.sin(rotate - halfRotate),
                    ],
                    [
                            x + symbolSize * 0.6 * Math.cos(rotate),
                            y - symbolSize * 0.6 * Math.sin(rotate),
                    ],
                    [
                            x + symbolSize * Math.cos(rotate + halfRotate),
                            y - symbolSize * Math.sin(rotate + halfRotate),
                    ]
                ];
                ctx.moveTo(x, y);
                for (var i = 0, l = point.length; i &lt;l; i++) {
                    ctx.lineTo(point[i][0], point[i][1]);
                }
                ctx.lineTo(x, y);
            },

            getPointList : function (style) {
                var pointList = [
                    [style.xStart, style.yStart],
                    [style.xEnd, style.yEnd]
                ];
                if (style.smooth === &#x27;spline&#x27;) {
                    var lastPointX = pointList[1][0];
                    var lastPointY = pointList[1][1];
                    pointList[3] = [lastPointX, lastPointY];
                    pointList[1] = this.getOffetPoint(pointList[0], pointList[3]);
                    pointList[2] = this.getOffetPoint(pointList[3], pointList[0]);
                    pointList = smoothSpline(pointList, false);
                    // 修正最后一点在插值产生的偏移
                    pointList[pointList.length - 1] = [lastPointX, lastPointY];
                }
                return pointList;
            },

            /**
             * {Array} start point
             * {Array} end point
             */
            getOffetPoint : function (sp, ep) {
                var distance = Math.sqrt(Math.round(
                        (sp[0] - ep[0]) * (sp[0] - ep[0]) + (sp[1] - ep[1]) * (sp[1] - ep[1])
                )) / 3;
                //console.log(delta);
                var mp = [sp[0], sp[1]];
                var angle;
                var deltaAngle = 0.2; // 偏移0.2弧度
                if (sp[0] != ep[0] &amp;&amp; sp[1] != ep[1]) {
                    // 斜率存在
                    var k = (ep[1] - sp[1]) / (ep[0] - sp[0]);
                    angle = Math.atan(k);
                }
                else if (sp[0] == ep[0]){
                    // 垂直线
                    angle = (sp[1] &lt;= ep[1] ? 1 : -1) * Math.PI / 2;
                }
                else {
                    // 水平线
                    angle = 0;
                }
                var dX;
                var dY;
                if (sp[0] &lt;= ep[0]) {
                    angle -= deltaAngle;
                    dX = Math.round(Math.cos(angle) * distance);
                    dY = Math.round(Math.sin(angle) * distance);
                    mp[0] += dX;
                    mp[1] += dY;
                }
                else {
                    angle += deltaAngle;
                    dX = Math.round(Math.cos(angle) * distance);
                    dY = Math.round(Math.sin(angle) * distance);
                    mp[0] -= dX;
                    mp[1] -= dY;
                }
                return mp;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect : function (style) {
                if (style.__rect) {
                    return style.__rect;
                }

                var lineWidth = style.lineWidth || 1;
                style.__rect = {
                    x : Math.min(style.xStart, style.xEnd) - lineWidth,
                    y : Math.min(style.yStart, style.yEnd) - lineWidth,
                    width : Math.abs(style.xStart - style.xEnd)
                        + lineWidth,
                    height : Math.abs(style.yStart - style.yEnd)
                        + lineWidth
                };

                return style.__rect;
            },

            isCover : function (x, y) {
                var originPos = this.getTansform(x, y);
                x = originPos[0];
                y = originPos[1];

                // 快速预判并保留判断矩形
                var rect = this.style.__rect;
                if (!rect) {
                    rect = this.style.__rect = this.getRect(this.style);
                }
                if (x &gt;= rect.x
                    &amp;&amp; x &lt;= (rect.x + rect.width)
                    &amp;&amp; y &gt;= rect.y
                    &amp;&amp; y &lt;= (rect.y + rect.height)
                    ) {
                    // 矩形内
                    return this.style.smooth !== &#x27;spline&#x27;
                        ? area.isInside(lineInstance, this.style, x, y)
                        : area.isInside(brokenLineInstance, this.style, x, y);
                }

                return false;
            }
        };

        zrUtil.inherits(MarkLine, Base);

        return MarkLine;
    });

// 由于大多数shape默认的isCover都是相同的逻辑
// 所以在echarts里临时抽象一个module，用于isCover method
// TODO: 对zrender的isCover和getRect方法进行抽象，重新整理该逻辑

    define(&#x27;echarts/util/shape/normalIsCover&#x27;,[],function () {
        return function (x, y) {
            var originPos = this.getTansform(x, y);
            x = originPos[0];
            y = originPos[1];

            // 快速预判并保留判断矩形
            var rect = this.style.__rect;
            if (!rect) {
                rect = this.style.__rect = this.getRect(this.style);
            }

            return x &gt;= rect.x
                &amp;&amp; x &lt;= (rect.x + rect.width)
                &amp;&amp; y &gt;= rect.y
                &amp;&amp; y &lt;= (rect.y + rect.height);
        };
    })
    ;
    /**
     * zrender
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：大规模散点图图形
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;symbol&#x27;,       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           pointList     : {Array},   // 必须，二维数组，二维内容如下
               x         : {number},  // 必须，横坐标
               y         : {number},  // 必须，纵坐标数组
               size      : {number},  // 必须，半宽
               type      : {string=}, // 默认为&#x27;circle&#x27;,图形类型
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     */
    define(&#x27;echarts/util/shape/Symbol&#x27;,[&#x27;require&#x27;,&#x27;zrender/shape/Base&#x27;,&#x27;zrender/shape/Polygon&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;./normalIsCover&#x27;],function (require) {
        var Base = require(&#x27;zrender/shape/Base&#x27;);
        var PolygonShape = require(&#x27;zrender/shape/Polygon&#x27;);
        var polygonInstance = new PolygonShape({});
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);

        function Symbol(options) {
            Base.call(this, options);
        }

        Symbol.prototype =  {
            type : &#x27;symbol&#x27;,
            /**
             * 创建矩形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath : function (ctx, style) {
                var pointList = style.pointList;
                var len = pointList.length;
                if (len === 0) {
                    return;
                }

                var subSize = 10000;
                var subSetLength = Math.ceil(len / subSize);
                var sub;
                var subLen;
                var isArray = pointList[0] instanceof Array;
                var size = style.size ? style.size : 2;
                var curSize = size;
                var halfSize = size / 2;
                var PI2 = Math.PI * 2;
                var percent;
                var x;
                var y;
                for (var j = 0; j &lt; subSetLength; j++) {
                    ctx.beginPath();
                    sub = j * subSize;
                    subLen = sub + subSize;
                    subLen = subLen &gt; len ? len : subLen;
                    for (var i = sub; i &lt; subLen; i++) {
                        if (style.random) {
                            percent = style[&#x27;randomMap&#x27; + (i % 20)] / 100;
                            curSize = size * percent * percent;
                            halfSize = curSize / 2;
                        }
                        if (isArray) {
                            x = pointList[i][0];
                            y = pointList[i][1];
                        }
                        else {
                            x = pointList[i].x;
                            y = pointList[i].y;
                        }
                        if (curSize &lt; 3) {
                            // 小于3像素视觉误差
                            ctx.rect(x - halfSize, y - halfSize, curSize, curSize);
                        }
                        else {
                            // 大于3像素才考虑图形
                            switch (style.iconType) {
                                case &#x27;circle&#x27; :
                                    ctx.moveTo(x, y);
                                    ctx.arc(x, y, halfSize, 0, PI2, true);
                                    break;
                                case &#x27;diamond&#x27; :
                                    ctx.moveTo(x, y - halfSize);
                                    ctx.lineTo(x + halfSize / 3, y - halfSize / 3);
                                    ctx.lineTo(x + halfSize, y);
                                    ctx.lineTo(x + halfSize / 3, y + halfSize / 3);
                                    ctx.lineTo(x, y + halfSize);
                                    ctx.lineTo(x - halfSize / 3, y + halfSize / 3);
                                    ctx.lineTo(x - halfSize, y);
                                    ctx.lineTo(x - halfSize / 3, y - halfSize / 3);
                                    ctx.lineTo(x, y - halfSize);
                                    break;
                                default :
                                    ctx.rect(x - halfSize, y - halfSize, curSize, curSize);
                            }
                        }
                    }
                    ctx.closePath();
                    if (j &lt; (subSetLength - 1)) {
                        switch (style.brushType) {
                            case &#x27;both&#x27;:
                                ctx.fill();
                            case &#x27;stroke&#x27;:
                                style.lineWidth &gt; 0 &amp;&amp; ctx.stroke();
                                break;
                            default:
                                ctx.fill();
                        }
                    }
                }
            },

            /* 像素模式
             buildPath : function (ctx, style) {
             var pointList = style.pointList;
             var rect = this.getRect(style);
             var ratio = window.devicePixelRatio || 1;
             // console.log(rect)
             // var ti = new Date();
             // bbox取整
             rect = {
             x : Math.floor(rect.x),
             y : Math.floor(rect.y),
             width : Math.floor(rect.width),
             height : Math.floor(rect.height)
             };
             var pixels = ctx.getImageData(
             rect.x * ratio, rect.y * ratio,
             rect.width * ratio, rect.height * ratio
             );
             var data = pixels.data;
             var idx;
             var zrColor = require(&#x27;zrender/tool/color&#x27;);
             var color = zrColor.toArray(style.color);
             var r = color[0];
             var g = color[1];
             var b = color[2];
             var width = rect.width;

             for (var i = 1, l = pointList.length; i &lt; l; i++) {
             idx = ((Math.floor(pointList[i][0]) - rect.x) * ratio
             + (Math.floor(pointList[i][1])- rect.y) * width * ratio * ratio
             ) * 4;
             data[idx] = r;
             data[idx + 1] = g;
             data[idx + 2] = b;
             data[idx + 3] = 255;
             }
             ctx.putImageData(pixels, rect.x * ratio, rect.y * ratio);
             // console.log(new Date() - ti);
             return;
             },
             */

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect : function (style) {
                return style.__rect || polygonInstance.getRect(style);
            },

            isCover : require(&#x27;./normalIsCover&#x27;)
        };

        zrUtil.inherits(Symbol, Base);

        return Symbol;
    });

    /**
     * echarts通用私有数据服务
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/util/ecData&#x27;,[],function() {
        /**
         * 打包私有数据
         *
         * @param {shape} shape 修改目标
         * @param {Object} series
         * @param {number} seriesIndex
         * @param {number | Object} data
         * @param {number} dataIndex
         * @param {*=} special
         * @param {*=} special2
         */
        function pack(
            shape, series, seriesIndex, data, dataIndex, name, special, special2
            ) {
            var value;
            if (typeof data != &#x27;undefined&#x27;) {
                value = data.value == null
                    ? data
                    : data.value;
            }

            shape._echartsData = {
                &#x27;_series&#x27; : series,
                &#x27;_seriesIndex&#x27; : seriesIndex,
                &#x27;_data&#x27; : data,
                &#x27;_dataIndex&#x27; : dataIndex,
                &#x27;_name&#x27; : name,
                &#x27;_value&#x27; : value,
                &#x27;_special&#x27; : special,
                &#x27;_special2&#x27; : special2
            };
            return shape._echartsData;
        }

        /**
         * 从私有数据中获取特定项
         * @param {shape} shape
         * @param {string} key
         */
        function get(shape, key) {
            var data = shape._echartsData;
            if (!key) {
                return data;
            }

            switch (key) {
                case &#x27;series&#x27; :
                case &#x27;seriesIndex&#x27; :
                case &#x27;data&#x27; :
                case &#x27;dataIndex&#x27; :
                case &#x27;name&#x27; :
                case &#x27;value&#x27; :
                case &#x27;special&#x27; :
                case &#x27;special2&#x27; :
                    return data &amp;&amp; data[&#x27;_&#x27; + key];
            }

            return null;
        }

        /**
         * 修改私有数据中获取特定项
         * @param {shape} shape
         * @param {string} key
         * @param {*} value
         */
        function set(shape, key, value) {
            shape._echartsData = shape._echartsData || {};
            switch (key) {
                case &#x27;series&#x27; :             // 当前系列值
                case &#x27;seriesIndex&#x27; :        // 系列数组位置索引
                case &#x27;data&#x27; :               // 当前数据值
                case &#x27;dataIndex&#x27; :          // 数据数组位置索引
                case &#x27;name&#x27; :
                case &#x27;value&#x27; :
                case &#x27;special&#x27; :
                case &#x27;special2&#x27; :
                    shape._echartsData[&#x27;_&#x27; + key] = value;
                    break;
            }
        }

        /**
         * 私有数据克隆，把source拷贝到target上
         * @param {shape} source 源
         * @param {shape} target 目标
         */
        function clone(source, target) {
            target._echartsData =  {
                &#x27;_series&#x27; : source._echartsData._series,
                &#x27;_seriesIndex&#x27; : source._echartsData._seriesIndex,
                &#x27;_data&#x27; : source._echartsData._data,
                &#x27;_dataIndex&#x27; : source._echartsData._dataIndex,
                &#x27;_name&#x27; : source._echartsData._name,
                &#x27;_value&#x27; : source._echartsData._value,
                &#x27;_special&#x27; : source._echartsData._special,
                &#x27;_special2&#x27; : source._echartsData._special2
            };
        }

        return {
            pack : pack,
            set : set,
            get : get,
            clone : clone
        };
    });
    /**
     * echarts图表动画基类
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/util/ecAnimation&#x27;,[&#x27;require&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/shape/Polygon&#x27;],function (require) {
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);

        /**
         * 折线型动画
         *
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function pointList(zr, oldShape, newShape, duration, easing) {
            var newPointList = newShape.style.pointList;
            var newPointListLen = newPointList.length;
            var oldPointList;

            if (!oldShape) {        // add
                oldPointList = [];
                if (newShape._orient != &#x27;vertical&#x27;) {
                    var y = newPointList[0][1];
                    for (var i = 0; i &lt; newPointListLen; i++) {
                        oldPointList[i] = [newPointList[i][0], y];
                    }
                }
                else {
                    var x = newPointList[0][0];
                    for (var i = 0; i &lt; newPointListLen; i++) {
                        oldPointList[i] = [x, newPointList[i][1]];
                    }
                }

                if (newShape.type == &#x27;half-smooth-polygon&#x27;) {
                    oldPointList[newPointListLen - 1] = zrUtil.clone(newPointList[newPointListLen - 1]);
                    oldPointList[newPointListLen - 2] = zrUtil.clone(newPointList[newPointListLen - 2]);
                }
                oldShape = {style : {pointList : oldPointList}};
            }

            oldPointList = oldShape.style.pointList;
            var oldPointListLen = oldPointList.length;
            if (oldPointListLen == newPointListLen) {
                newShape.style.pointList = oldPointList;
            }
            else if (oldPointListLen &lt; newPointListLen) {
                // 原来短，新的长，补全
                newShape.style.pointList = oldPointList.concat(newPointList.slice(oldPointListLen));
            }
            else {
                // 原来长，新的短，截断
                newShape.style.pointList = oldPointList.slice(0, newPointListLen);
            }

            zr.addShape(newShape);
            zr.animate(newShape.id, &#x27;style&#x27;)
                .when(
                duration,
                { pointList: newPointList }
            )
                .start(easing);
        }

        /**
         * 复制样式
         *
         * @inner
         * @param {Object} target 目标对象
         * @param {Object} source 源对象
         * @param {...string} props 复制的属性列表
         */
        function cloneStyle(target, source) {
            var len = arguments.length;
            for (var i = 2; i &lt; len; i++) {
                var prop = arguments[i];
                target.style[prop] = source.style[prop];
            }
        }

        /**
         * 方型动画
         *
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function rectangle(zr, oldShape, newShape, duration, easing) {
            var newShapeStyle = newShape.style;
            if (!oldShape) {        // add
                oldShape = {
                    style : {
                        x : newShapeStyle.x,
                        y : newShape._orient == &#x27;vertical&#x27;
                            ? newShapeStyle.y + newShapeStyle.height
                            : newShapeStyle.y,
                        width: newShape._orient == &#x27;vertical&#x27;
                            ? newShapeStyle.width : 0,
                        height: newShape._orient != &#x27;vertical&#x27;
                            ? newShapeStyle.height : 0
                    }
                };
            }

            var newX = newShapeStyle.x;
            var newY = newShapeStyle.y;
            var newWidth = newShapeStyle.width;
            var newHeight = newShapeStyle.height;
            cloneStyle(
                newShape, oldShape,
                &#x27;x&#x27;, &#x27;y&#x27;, &#x27;width&#x27;, &#x27;height&#x27;
            );

            zr.addShape(newShape);
            zr.animate(newShape.id, &#x27;style&#x27;)
                .when(
                duration,
                {
                    x: newX,
                    y: newY,
                    width: newWidth,
                    height: newHeight
                }
            )
                .start(easing);
        }


        /**
         * 环型动画
         *
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function ring(zr, oldShape, newShape, duration, easing) {
            var x = newShape.style.x;
            var y = newShape.style.y;
            var r0 = newShape.style.r0;
            var r = newShape.style.r;

            if (newShape._animationAdd != &#x27;r&#x27;) {
                newShape.style.r0 = 0;
                newShape.style.r = 0;
                newShape.rotation = [Math.PI*2, x, y];

                zr.addShape(newShape);
                zr.animate(newShape.id, &#x27;style&#x27;)
                    .when(
                    duration,
                    {
                        r0 : r0,
                        r : r
                    }
                )
                    .start(easing);
                zr.animate(newShape.id, &#x27;&#x27;)
                    .when(
                    Math.round(duration / 3 * 2),
                    { rotation : [0, x, y] }
                )
                    .start(easing);
            }
            else {
                newShape.style.r0 = newShape.style.r;

                zr.addShape(newShape);
                zr.animate(newShape.id, &#x27;style&#x27;)
                    .when(
                    duration,
                    {
                        r0 : r0
                    }
                )
                    .start(easing);
            }
        }

        /**
         * 扇形动画
         *
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function sector(zr, oldShape, newShape, duration, easing) {
            if (!oldShape) {        // add
                if (newShape._animationAdd != &#x27;r&#x27;) {
                    oldShape = {
                        style : {
                            startAngle : newShape.style.startAngle,
                            endAngle : newShape.style.startAngle
                        }
                    };
                }
                else {
                    oldShape = {style : {r0 : newShape.style.r}};
                }
            }

            var startAngle = newShape.style.startAngle;
            var endAngle = newShape.style.endAngle;

            cloneStyle(
                newShape, oldShape,
                &#x27;startAngle&#x27;, &#x27;endAngle&#x27;
            );

            zr.addShape(newShape);
            zr.animate(newShape.id, &#x27;style&#x27;)
                .when(
                duration,
                {
                    startAngle : startAngle,
                    endAngle : endAngle
                }
            )
                .start(easing);
        }

        /**
         * 文本动画
         *
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function text(zr, oldShape, newShape, duration, easing) {
            if (!oldShape) {        // add
                oldShape = {
                    style : {
                        x : newShape.style.textAlign == &#x27;left&#x27;
                            ? newShape.style.x + 100
                            : newShape.style.x - 100,
                        y : newShape.style.y
                    }
                };
            }

            var x = newShape.style.x;
            var y = newShape.style.y;

            cloneStyle(
                newShape, oldShape,
                &#x27;x&#x27;, &#x27;y&#x27;
            );

            zr.addShape(newShape);
            zr.animate(newShape.id, &#x27;style&#x27;)
                .when(
                duration,
                {
                    x : x,
                    y : y
                }
            )
                .start(easing);
        }

        /**
         * 多边形动画
         *
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function polygon(zr, oldShape, newShape, duration, easing) {
            var rect = require(&#x27;zrender/shape/Polygon&#x27;).prototype.getRect(newShape.style);
            var x = rect.x + rect.width / 2;
            var y = rect.y + rect.height / 2;

            newShape.scale = [0.1, 0.1, x, y];
            zr.addShape(newShape);
            zr.animate(newShape.id, &#x27;&#x27;)
                .when(
                duration,
                {
                    scale : [1, 1, x, y]
                }
            )
                .start(easing);
        }

        /**
         * gaugePointer动画
         *
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function gaugePointer(zr, oldShape, newShape, duration, easing) {
            if (!oldShape) {        // add
                oldShape = {
                    style : {
                        angle : newShape.style.startAngle
                    }
                };
            }

            var angle = newShape.style.angle;
            newShape.style.angle = oldShape.style.angle;
            zr.addShape(newShape);
            zr.animate(newShape.id, &#x27;style&#x27;)
                .when(
                duration,
                {
                    angle : angle
                }
            )
                .start(easing);
        }

        /**
         * icon动画
         *
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function icon(zr, oldShape, newShape, duration, easing) {
            // 避免markPoint特效取值在动画帧上
            newShape.style._x = newShape.style.x;
            newShape.style._y = newShape.style.y;
            newShape.style._width = newShape.style.width;
            newShape.style._height = newShape.style.height;

            if (!oldShape) {    // add
                var x = newShape._x || 0;
                var y = newShape._y || 0;
                newShape.scale = [0, 0, x, y];
                zr.addShape(newShape);
                zr.animate(newShape.id, &#x27;&#x27;)
                    .when(
                    duration,
                    {scale : [1, 1, x, y]}
                )
                    .start(easing || &#x27;QuinticOut&#x27;);
            }
            else {              // mod
                rectangle(zr, oldShape, newShape, duration, easing);
            }
        }

        /**
         * markline动画
         *
         * @param {ZRender} zr
         * @param {shape} oldShape
         * @param {shape} newShape
         * @param {number} duration
         * @param {tring} easing
         */
        function markline(zr, oldShape, newShape, duration, easing) {
            if (!oldShape) {    // add
                if (!newShape.style.smooth) {
                    newShape.style.pointList = [
                        [newShape.style.xStart, newShape.style.yStart],
                        [newShape.style.xStart, newShape.style.yStart]
                    ];
                    zr.addShape(newShape);
                    zr.animate(newShape.id, &#x27;style&#x27;)
                        .when(
                        duration,
                        {
                            pointList : [
                                [
                                    newShape.style.xStart,
                                    newShape.style.yStart
                                ],
                                [
                                        newShape._x || 0, newShape._y || 0
                                ]
                            ]
                        }
                    )
                        .start(easing || &#x27;QuinticOut&#x27;);
                }
                else {
                    // 曲线动画
                    newShape.style.pointListLength = 1;
                    zr.addShape(newShape);
                    newShape.style.pointList = newShape.style.pointList
                        || newShape.getPointList(newShape.style);
                    zr.animate(newShape.id, &#x27;style&#x27;)
                        .when(
                        duration,
                        {
                            pointListLength : newShape.style.pointList.length
                        }
                    )
                        .start(easing || &#x27;QuinticOut&#x27;);
                }
            }
        }

        return {
            pointList : pointList,
            rectangle : rectangle,
            ring : ring,
            sector : sector,
            text : text,
            polygon : polygon,
            gaugePointer : gaugePointer,
            icon : icon,
            markline : markline
        };
    });

    /**
     * zrender
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：圆
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;circle&#x27;,       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           x             : {number},  // 必须，圆心横坐标
           y             : {number},  // 必须，圆心纵坐标
           r             : {number},  // 必须，圆半径
           brushType     : {string},  // 默认为fill，绘画方式
                                      // fill(填充) | stroke(描边) | both(填充+描边)
           color         : {color},   // 默认为&#x27;#000&#x27;，填充颜色，支持rgba
           strokeColor   : {color},   // 默认为&#x27;#000&#x27;，描边颜色（轮廓），支持rgba
           lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

           opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
           shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
           shadowColor   : {color},   // 默认为&#x27;#000&#x27;，阴影色彩，支持rgba
           shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
           shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

           text          : {string},  // 默认为null，附加文本
           textFont      : {string},  // 默认为null，附加文本样式，eg:&#x27;bold 18px verdana&#x27;
           textPosition  : {string},  // 默认为top，附加文本位置。
                                      // inside | left | right | top | bottom
           textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                      // start | end | left | right | center
           textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                      // top | bottom | middle |
                                      // alphabetic | hanging | ideographic
           textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                      // &#x27;inside&#x27; ? &#x27;#fff&#x27; : color
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     例子：
     {
       shape  : &#x27;circle&#x27;,
       id     : &#x27;123456&#x27;,
       zlevel : 1,
       style  : {
           x : 200,
           y : 100,
           r : 50,
           color : &#x27;#eee&#x27;,
           text : &#x27;Baidu&#x27;
       },
       myName : &#x27;kener&#x27;,  // 可自带任何有效自定义属性

       clickable : true,
       onClick : function(eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
     */
    define(
        &#x27;zrender/shape/Circle&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;],function (require) {
            var Base = require(&#x27;./Base&#x27;);

            function Circle(options) {
                Base.call(this, options);
            }

            Circle.prototype = {
                type: &#x27;circle&#x27;,
                /**
                 * 创建圆形路径
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                buildPath : function (ctx, style) {
                    ctx.arc(style.x, style.y, style.r, 0, Math.PI * 2, true);
                    return;
                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect : function (style) {
                    if (style.__rect) {
                        return style.__rect;
                    }

                    var lineWidth;
                    if (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;fill&#x27;) {
                        lineWidth = style.lineWidth || 1;
                    }
                    else {
                        lineWidth = 0;
                    }
                    style.__rect = {
                        x : Math.round(style.x - style.r - lineWidth / 2),
                        y : Math.round(style.y - style.r - lineWidth / 2),
                        width : style.r * 2 + lineWidth,
                        height : style.r * 2 + lineWidth
                    };

                    return style.__rect;
                }
            };

            require(&#x27;../tool/util&#x27;).inherits(Circle, Base);
            return Circle;
        }
    );
    /**
     * echarts图表特效基类
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/util/ecEffect&#x27;,[&#x27;require&#x27;,&#x27;../util/ecData&#x27;,&#x27;zrender/shape/Circle&#x27;,&#x27;zrender/shape/Image&#x27;,&#x27;../util/shape/Icon&#x27;,&#x27;../util/shape/Symbol&#x27;,&#x27;zrender/tool/env&#x27;],function (require) {
        var ecData = require(&#x27;../util/ecData&#x27;);

        var CircleShape = require(&#x27;zrender/shape/Circle&#x27;);
        var ImageShape = require(&#x27;zrender/shape/Image&#x27;);
        var IconShape = require(&#x27;../util/shape/Icon&#x27;);
        var SymbolShape = require(&#x27;../util/shape/Symbol&#x27;);

        var canvasSupported = require(&#x27;zrender/tool/env&#x27;).canvasSupported;

        function point(zr, effectList, shape, zlevel) {
            var effect = shape.effect;
            var color = effect.color || shape.style.strokeColor || shape.style.color;
            var shadowColor = effect.shadowColor || color;
            var size = effect.scaleSize;
            var shadowBlur = typeof effect.shadowBlur != &#x27;undefined&#x27;
                ? effect.shadowBlur : size;

            var effectShape = new IconShape({
                zlevel : zlevel,
                style : {
                    brushType : &#x27;stroke&#x27;,
                    iconType : (shape.style.iconType != &#x27;pin&#x27;
                        &amp;&amp; shape.style.iconType != &#x27;droplet&#x27;)
                        ? shape.style.iconType
                        : &#x27;circle&#x27;,
                    x : shadowBlur + 1, // 线宽
                    y : shadowBlur + 1,
                    n : shape.style.n,
                    width : shape.style.width * size,
                    height : shape.style.height * size,
                    lineWidth : 1,
                    strokeColor : color,
                    shadowColor : shadowColor,
                    shadowBlur : shadowBlur
                },
                draggable : false,
                hoverable : false
            });

            if (canvasSupported) {  // 提高性能，换成image
                effectShape.style.image = zr.shapeToImage(
                    effectShape,
                        effectShape.style.width + shadowBlur * 2 + 2,
                        effectShape.style.height + shadowBlur * 2 + 2
                ).style.image;

                effectShape = new ImageShape({
                    zlevel : effectShape.zlevel,
                    style : effectShape.style,
                    draggable : false,
                    hoverable : false
                });
            }

            ecData.clone(shape, effectShape);

            // 改变坐标，不能移到前面
            effectShape.position = shape.position;
            effectList.push(effectShape);
            zr.addShape(effectShape);

            var devicePixelRatio = window.devicePixelRatio || 1;
            var offset = (effectShape.style.width / devicePixelRatio - shape.style.width) / 2;
            effectShape.style.x = shape.style._x - offset;
            effectShape.style.y = shape.style._y - offset;
            var duration = (effect.period + Math.random() * 10) * 100;

            zr.modShape(
                shape.id,
                { invisible : true}
            );

            var centerX = effectShape.style.x + (effectShape.style.width) / 2 / devicePixelRatio;
            var centerY = effectShape.style.y + (effectShape.style.height) / 2 / devicePixelRatio;
            zr.modShape(
                effectShape.id,
                {
                    scale : [0.1, 0.1, centerX, centerY]
                }
            );

            zr.animate(effectShape.id, &#x27;&#x27;, true)
                .when(
                duration,
                {
                    scale : [1, 1, centerX, centerY]
                }
            )
                .start();
        }

        function largePoint(zr, effectList, shape, zlevel) {
            var effect = shape.effect;
            var color = effect.color || shape.style.strokeColor || shape.style.color;
            var size = effect.scaleSize;
            var shadowColor = effect.shadowColor || color;
            var shadowBlur = typeof effect.shadowBlur != &#x27;undefined&#x27;
                ? effect.shadowBlur : (size * 2);
            var devicePixelRatio = window.devicePixelRatio || 1;
            var effectShape = new SymbolShape({
                zlevel : zlevel,
                position : shape.position,
                scale : shape.scale,
                style : {
                    pointList : shape.style.pointList,
                    iconType : shape.style.iconType,
                    color : color,
                    strokeColor : color,
                    shadowColor : shadowColor,
                    shadowBlur : shadowBlur * devicePixelRatio,
                    random : true,
                    brushType: &#x27;fill&#x27;,
                    lineWidth:1,
                    size : shape.style.size
                },
                draggable : false,
                hoverable : false
            });

            effectList.push(effectShape);
            zr.addShape(effectShape);
            zr.modShape(
                shape.id,
                { invisible : true}
            );

            var duration = Math.round(effect.period * 100);
            var clip1 = {};
            var clip2 = {};
            for (var i = 0; i &lt; 20; i++) {
                effectShape.style[&#x27;randomMap&#x27; + i] = 0;
                clip1 = {};
                clip1[&#x27;randomMap&#x27; + i] = 100;
                clip2 = {};
                clip2[&#x27;randomMap&#x27; + i] = 0;
                effectShape.style[&#x27;randomMap&#x27; + i] = Math.random() * 100;
                zr.animate(effectShape.id, &#x27;style&#x27;, true)
                    .when(duration, clip1)
                    .when(duration * 2, clip2)
                    .when(duration * 3, clip1)
                    .when(duration * 4, clip1)
                    .delay(Math.random() * duration * i)
                    //.delay(duration / 15 * (15 - i + 1))
                    .start();

            }
        }

        function line(zr, effectList, shape, zlevel) {
            var effect = shape.effect;
            var color = effect.color || shape.style.strokeColor || shape.style.color;
            var shadowColor = effect.shadowColor || shape.style.strokeColor || color;
            var size = shape.style.lineWidth * effect.scaleSize;
            var shadowBlur = typeof effect.shadowBlur != &#x27;undefined&#x27;
                ? effect.shadowBlur : size;

            var effectShape = new CircleShape({
                zlevel : zlevel,
                style : {
                    x : shadowBlur,
                    y : shadowBlur,
                    r : size,
                    color : color,
                    shadowColor : shadowColor,
                    shadowBlur : shadowBlur
                },
                draggable : false,
                hoverable : false
            });

            var offset;
            if (canvasSupported) {  // 提高性能，换成image
                effectShape.style.image = zr.shapeToImage(
                    effectShape,
                        (size + shadowBlur) * 2,
                        (size + shadowBlur) * 2
                ).style.image;
                effectShape = new ImageShape({
                    zlevel : effectShape.zlevel,
                    style : effectShape.style,
                    draggable : false,
                    hoverable : false
                });
                offset = shadowBlur;
            }
            else {
                offset = 0;
            }

            ecData.clone(shape, effectShape);

            // 改变坐标， 不能移到前面
            effectShape.position = shape.position;
            effectList.push(effectShape);
            zr.addShape(effectShape);

            effectShape.style.x = shape.style.xStart - offset;
            effectShape.style.y = shape.style.yStart - offset;
            var distance = (shape.style.xStart - shape.style.xEnd)
                * (shape.style.xStart - shape.style.xEnd)
                +
                (shape.style.yStart - shape.style.yEnd)
                * (shape.style.yStart - shape.style.yEnd);
            var duration = Math.round(Math.sqrt(Math.round(
                    distance * effect.period * effect.period
            )));
            if (!shape.style.smooth) {
                // 直线
                zr.animate(effectShape.id, &#x27;style&#x27;, true)
                    .when(
                    duration,
                    {
                        x : shape._x - offset,
                        y : shape._y - offset
                    }
                )
                    .start();
            }
            else {
                // 曲线
                var pointList = shape.style.pointList || shape.getPointList(shape.style);
                var len = pointList.length;
                duration = Math.round(duration / len);
                var deferred = zr.animate(effectShape.id, &#x27;style&#x27;, false);      //不循环动画
                var step = Math.ceil(len / 8);
                for (var j = 0; j &lt; len - step; j+= step) {
                    deferred.when(
                            duration * (j + 1),
                        {
                            x : pointList[j][0] - offset,
                            y : pointList[j][1] - offset
                        }
                    );
                }
                deferred.when(
                        duration * len,
                    {
                        x : pointList[len - 1][0] - offset,
                        y : pointList[len - 1][1] - offset
                    }
                );
                deferred.start(&#x27;spline&#x27;);
            }
        }

        return {
            point : point,
            largePoint : largePoint,
            line : line
        };
    });

    /**
     * 高精度数学运算
     */
    define(&#x27;echarts/util/accMath&#x27;,[],function() {
        // 除法函数，用来得到精确的除法结果 
        // 说明：javascript的除法结果会有误差，在两个浮点数相除的时候会比较明显。这个函数返回较为精确的除法结果。 
        // 调用：accDiv(arg1,arg2) 
        // 返回值：arg1除以arg2的精确结果
        function accDiv(arg1, arg2) {
            return accMul(arg1, 1 / arg2);
        }

        // 乘法函数，用来得到精确的乘法结果
        // 说明：javascript的乘法结果会有误差，在两个浮点数相乘的时候会比较明显。这个函数返回较为精确的乘法结果。 
        // 调用：accMul(arg1,arg2) 
        // 返回值：arg1乘以arg2的精确结果
        function accMul(arg1, arg2) {
            var m = 0;
            var s1 = arg1.toString();
            var s2 = arg2.toString();
            try {
                m += s1.split(&#x27;.&#x27;)[1].length;
            }
            catch(e) {}

            try {
                m += s2.split(&#x27;.&#x27;)[1].length;
            }
            catch(e){}

            return (s1.replace(&#x27;.&#x27;, &#x27;&#x27;) - 0) * (s2.replace(&#x27;.&#x27;, &#x27;&#x27;) - 0) / Math.pow(10, m);
        }

        // 加法函数，用来得到精确的加法结果 
        // 说明：javascript的加法结果会有误差，在两个浮点数相加的时候会比较明显。这个函数返回较为精确的加法结果。 
        // 调用：accAdd(arg1,arg2) 
        // 返回值：arg1加上arg2的精确结果 
        function accAdd(arg1, arg2) {
            var r1 = 0;
            var r2 = 0;

            try {
                r1 = arg1.toString().split(&#x27;.&#x27;)[1].length;
            }
            catch(e) {}

            try {
                r2 = arg2.toString().split(&#x27;.&#x27;)[1].length;
            }
            catch(e) {}

            var m = Math.pow(10, Math.max(r1, r2));
            return (Math.round(arg1 * m) + Math.round(arg2 * m)) / m;
        }

        //减法函数，用来得到精确的减法结果 
        //说明：javascript的减法结果会有误差，在两个浮点数减法的时候会比较明显。这个函数返回较为精确的减法结果。 
        //调用：accSub(arg1,arg2) 
        //返回值：arg1减法arg2的精确结果 
        function accSub(arg1,arg2) {
            return accAdd(arg1, -arg2);
        }

        return {
            accDiv : accDiv,
            accMul : accMul,
            accAdd : accAdd,
            accSub : accSub
        };
    });
    /**
     * echarts图表基类
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/chart/base&#x27;,[&#x27;require&#x27;,&#x27;zrender/shape/Image&#x27;,&#x27;../util/shape/Icon&#x27;,&#x27;../util/shape/MarkLine&#x27;,&#x27;../util/shape/Symbol&#x27;,&#x27;../config&#x27;,&#x27;../util/ecData&#x27;,&#x27;../util/ecAnimation&#x27;,&#x27;../util/ecEffect&#x27;,&#x27;../util/accMath&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/tool/area&#x27;],function (require) {
        // 图形依赖
        var ImageShape = require(&#x27;zrender/shape/Image&#x27;);
        var IconShape = require(&#x27;../util/shape/Icon&#x27;);
        var MarkLineShape = require(&#x27;../util/shape/MarkLine&#x27;);
        var SymbolShape = require(&#x27;../util/shape/Symbol&#x27;);

        var ecConfig = require(&#x27;../config&#x27;);
        var ecData = require(&#x27;../util/ecData&#x27;);
        var ecAnimation = require(&#x27;../util/ecAnimation&#x27;);
        var ecEffect = require(&#x27;../util/ecEffect&#x27;);
        var accMath = require(&#x27;../util/accMath&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);
        var zrArea = require(&#x27;zrender/tool/area&#x27;);

        function Base(){
            var self = this;
            this.selectedMap = {};
            this.lastShapeList = [];
            this.shapeHandler = {
                onclick : function () {
                    self.isClick = true;
                },

                ondragover : function (param) {
                    // 返回触发可计算特性的图形提示
                    var calculableShape = param.target;
                    calculableShape.highlightStyle = calculableShape.highlightStyle || {};

                    // 备份特出特性
                    var highlightStyle = calculableShape.highlightStyle;
                    var brushType = highlightStyle.brushTyep;
                    var strokeColor = highlightStyle.strokeColor;
                    var lineWidth = highlightStyle.lineWidth;

                    highlightStyle.brushType = &#x27;stroke&#x27;;
                    highlightStyle.strokeColor = self.ecTheme.calculableColor;
                    highlightStyle.lineWidth = calculableShape.type == &#x27;icon&#x27; ? 30 : 10;

                    self.zr.addHoverShape(calculableShape);

                    setTimeout(function (){
                        // 复位
                        if (calculableShape.highlightStyle) {
                            calculableShape.highlightStyle.brushType = brushType;
                            calculableShape.highlightStyle.strokeColor = strokeColor;
                            calculableShape.highlightStyle.lineWidth = lineWidth;
                        }
                    },20);
                },

                ondrop : function (param) {
                    // 排除一些非数据的拖拽进入
                    if (typeof ecData.get(param.dragged, &#x27;data&#x27;) != &#x27;undefined&#x27;) {
                        self.isDrop = true;
                    }
                },

                ondragend : function () {
                    self.isDragend = true;
                }
            };
        }

        /**
         * 基类方法
         */
        Base.prototype = {
            /**
             * 图形拖拽特性
             */
            setCalculable : function (shape) {
                shape.dragEnableTime = this.ecTheme.DRAG_ENABLE_TIME;
                shape.ondragover = this.shapeHandler.ondragover;
                shape.ondragend = this.shapeHandler.ondragend;
                shape.ondrop = this.shapeHandler.ondrop;
                return shape;
            },

            /**
             * 数据项被拖拽进来
             */
            ondrop : function (param, status) {
                if (!this.isDrop || !param.target) {
                    // 没有在当前实例上发生拖拽行为则直接返回
                    return;
                }
                var target = param.target;      // 拖拽安放目标
                var dragged = param.dragged;    // 当前被拖拽的图形对象

                var seriesIndex = ecData.get(target, &#x27;seriesIndex&#x27;);
                var dataIndex = ecData.get(target, &#x27;dataIndex&#x27;);

                var series = this.series;
                var data;
                var legend = this.component.legend;
                if (dataIndex == -1) {
                    // 落到calculableCase上，数据被拖拽进某个饼图|雷达|漏斗，增加数据
                    data = {
                        value : ecData.get(dragged, &#x27;value&#x27;),
                        name : ecData.get(dragged, &#x27;name&#x27;)
                    };

                    // 修饼图数值不为负值
                    if (this.type == ecConfig.CHART_TYPE_PIE &amp;&amp; data.value &lt; 0) {
                        data.value = 0;
                    }

                    var hasFind = false;
                    var sData = series[seriesIndex].data;
                    for (var i = 0, l = sData.length; i &lt; l; i++) {
                        if (sData[i].name == data.name &amp;&amp; sData[i].value == &#x27;-&#x27;) {
                            series[seriesIndex].data[i].value = data.value;
                            hasFind = true;
                        }
                    }
                    !hasFind &amp;&amp; series[seriesIndex].data.push(data);

                    legend &amp;&amp; legend.add(
                        data.name,
                            dragged.style.color || dragged.style.strokeColor
                    );
                }
                else {
                    // 落到数据item上，数据被拖拽到某个数据项上，数据修改
                    data = this.option.series[seriesIndex].data[dataIndex] || &#x27;-&#x27;;
                    if (typeof data.value != &#x27;undefined&#x27;) {
                        if (data.value != &#x27;-&#x27;) {
                            this.option.series[seriesIndex].data[dataIndex].value =
                                accMath.accAdd(
                                    this.option.series[seriesIndex].data[dataIndex].value,
                                    ecData.get(dragged, &#x27;value&#x27;)
                                );
                        }
                        else {
                            this.option.series[seriesIndex].data[dataIndex].value =
                                ecData.get(dragged, &#x27;value&#x27;);
                        }

                        if (this.type == ecConfig.CHART_TYPE_FUNNEL
                            || this.type == ecConfig.CHART_TYPE_PIE
                            ) {
                            legend &amp;&amp; legend.getRelatedAmount(data.name) == 1
                            &amp;&amp; this.component.legend.del(data.name);
                            data.name += this.option.nameConnector + ecData.get(dragged, &#x27;name&#x27;);
                            legend &amp;&amp; legend.add(
                                data.name,
                                    dragged.style.color || dragged.style.strokeColor
                            );
                        }
                    }
                    else {
                        if (data != &#x27;-&#x27;) {
                            this.option.series[seriesIndex].data[dataIndex] =
                                accMath.accAdd(
                                    this.option.series[seriesIndex].data[dataIndex],
                                    ecData.get(dragged, &#x27;value&#x27;)
                                );
                        }
                        else {
                            this.option.series[seriesIndex].data[dataIndex] =
                                ecData.get(dragged, &#x27;value&#x27;);
                        }
                    }
                }

                // 别status = {}赋值啊！！
                status.dragIn = status.dragIn || true;

                // 处理完拖拽事件后复位
                this.isDrop = false;

                var self = this;
                setTimeout(function(){
                    self.zr.trigger(&#x27;mousemove&#x27;, param.event);
                }, 300);

                return;
            },

            /**
             * 数据项被拖拽出去
             */
            ondragend : function (param, status) {
                if (!this.isDragend || !param.target) {
                    // 没有在当前实例上发生拖拽行为则直接返回
                    return;
                }
                var target = param.target;      // 被拖拽图形元素

                var seriesIndex = ecData.get(target, &#x27;seriesIndex&#x27;);
                var dataIndex = ecData.get(target, &#x27;dataIndex&#x27;);

                var series = this.series;
                // 删除被拖拽走的数据
                if (typeof series[seriesIndex].data[dataIndex].value != &#x27;undefined&#x27;) {
                    series[seriesIndex].data[dataIndex].value = &#x27;-&#x27;;
                    // 清理可能有且唯一的legend data
                    var name = series[seriesIndex].data[dataIndex].name;
                    if (this.component.legend
                        &amp;&amp; this.component.legend.getRelatedAmount(name) == 0
                        ) {
                        this.component.legend.del(name);
                    }
                }
                else {
                    series[seriesIndex].data[dataIndex] = &#x27;-&#x27;;
                }

                // 别status = {}赋值啊！！
                status.dragOut = true;
                status.needRefresh = true;

                // 处理完拖拽事件后复位
                this.isDragend = false;

                return;
            },

            /**
             * 图例选择
             */
            onlegendSelected : function (param, status) {
                var legendSelected = param.selected;
                for (var itemName in this.selectedMap) {
                    if (this.selectedMap[itemName] != legendSelected[itemName]) {
                        // 有一项不一致都需要重绘
                        status.needRefresh = true;
                    }
                    this.selectedMap[itemName] = legendSelected[itemName];
                }
                return;
            },

            /**
             * 添加文本
             */
            addLabel : function (tarShape, serie, data, name, orient) {
                // 多级控制
                var queryTarget = [data, serie];
                var nLabel = this.deepMerge(queryTarget, &#x27;itemStyle.normal.label&#x27;);
                var eLabel = this.deepMerge(queryTarget, &#x27;itemStyle.emphasis.label&#x27;);

                var nTextStyle = nLabel.textStyle || {};
                var eTextStyle = eLabel.textStyle || {};

                if (nLabel.show) {
                    tarShape.style.text = this._getLabelText(
                        serie, data, name, &#x27;normal&#x27;
                    );
                    tarShape.style.textPosition = typeof nLabel.position == &#x27;undefined&#x27;
                        ? (orient == &#x27;horizontal&#x27; ? &#x27;right&#x27; : &#x27;top&#x27;)
                        : nLabel.position;
                    tarShape.style.textColor = nTextStyle.color;
                    tarShape.style.textFont = this.getFont(nTextStyle);
                }
                if (eLabel.show) {
                    tarShape.highlightStyle.text = this._getLabelText(
                        serie, data, name, &#x27;emphasis&#x27;
                    );
                    tarShape.highlightStyle.textPosition = nLabel.show
                        ? tarShape.style.textPosition
                        : (typeof eLabel.position == &#x27;undefined&#x27;
                        ? (orient == &#x27;horizontal&#x27; ? &#x27;right&#x27; : &#x27;top&#x27;)
                        : eLabel.position);
                    tarShape.highlightStyle.textColor = eTextStyle.color;
                    tarShape.highlightStyle.textFont = this.getFont(eTextStyle);
                }

                return tarShape;
            },

            /**
             * 根据lable.format计算label text
             */
            _getLabelText : function (serie, data, name, status) {
                var formatter = this.deepQuery(
                    [data, serie],
                        &#x27;itemStyle.&#x27; + status + &#x27;.label.formatter&#x27;
                );
                if (!formatter &amp;&amp; status == &#x27;emphasis&#x27;) {
                    // emphasis时需要看看normal下是否有formatter
                    formatter = this.deepQuery(
                        [data, serie],
                        &#x27;itemStyle.normal.label.formatter&#x27;
                    );
                }

                var value = typeof data != &#x27;undefined&#x27;
                    ? (typeof data.value != &#x27;undefined&#x27;
                    ? data.value
                    : data)
                    : &#x27;-&#x27;;

                if (formatter) {
                    if (typeof formatter == &#x27;function&#x27;) {
                        return formatter(
                            serie.name,
                            name,
                            value
                        );
                    }
                    else if (typeof formatter == &#x27;string&#x27;) {
                        formatter = formatter.replace(&#x27;{a}&#x27;,&#x27;{a0}&#x27;)
                            .replace(&#x27;{b}&#x27;,&#x27;{b0}&#x27;)
                            .replace(&#x27;{c}&#x27;,&#x27;{c0}&#x27;);
                        formatter = formatter.replace(&#x27;{a0}&#x27;, serie.name)
                            .replace(&#x27;{b0}&#x27;, name)
                            .replace(&#x27;{c0}&#x27;, value);

                        return formatter;
                    }
                }
                else {
                    return value;
                }
            },

            /**
             * 标线标注
             */
            buildMark : function (seriesIndex) {
                var serie = this.series[seriesIndex];
                if (this.selectedMap[serie.name]) {
                    serie.markPoint &amp;&amp; this._buildMarkPoint(seriesIndex);
                    serie.markLine &amp;&amp; this._buildMarkLine(seriesIndex);
                }
            },

            /**
             * 标注逻辑
             */
            _buildMarkPoint : function (seriesIndex) {
                var attachStyle =  (this.markAttachStyle || {})[seriesIndex];
                var serie = this.series[seriesIndex];
                var _zlevelBase = this.getZlevelBase();
                var mpData;
                var pos;
                var markPoint = zrUtil.clone(serie.markPoint);
                for (var i = 0, l = markPoint.data.length; i &lt; l; i++) {
                    mpData = markPoint.data[i];
                    pos = this.getMarkCoord(seriesIndex, mpData);
                    markPoint.data[i].x = typeof mpData.x != &#x27;undefined&#x27;
                        ? mpData.x : pos[0];
                    markPoint.data[i].y = typeof mpData.y != &#x27;undefined&#x27;
                        ? mpData.y : pos[1];
                    if (mpData.type
                        &amp;&amp; (mpData.type == &#x27;max&#x27; || mpData.type == &#x27;min&#x27;)
                        ) {
                        // 特殊值内置支持
                        markPoint.data[i].value = pos[3];
                        markPoint.data[i].name = mpData.name || mpData.type;
                        markPoint.data[i].symbolSize = markPoint.data[i].symbolSize
                            || (zrArea.getTextWidth(pos[3], this.getFont()) / 2 + 5);
                    }
                }

                var shapeList = this._markPoint(seriesIndex, markPoint);

                for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                    shapeList[i].zlevel = _zlevelBase + 1;
                    for (var key in attachStyle) {
                        shapeList[i][key] = zrUtil.clone(attachStyle[key]);
                    }
                    this.shapeList.push(shapeList[i]);
                }
                // 个别特殊图表需要自己addShape
                if (this.type == ecConfig.CHART_TYPE_FORCE
                    || this.type == ecConfig.CHART_TYPE_CHORD
                    ) {
                    for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                        this.zr.addShape(shapeList[i]);
                    }
                }
            },

            /**
             * 标线逻辑
             */
            _buildMarkLine : function (seriesIndex) {
                var attachStyle =  (this.markAttachStyle || {})[seriesIndex];
                var serie = this.series[seriesIndex];
                var _zlevelBase = this.getZlevelBase();
                var mlData;
                var pos;
                var markLine = zrUtil.clone(serie.markLine);
                for (var i = 0, l = markLine.data.length; i &lt; l; i++) {
                    mlData = markLine.data[i];
                    if (mlData.type
                        &amp;&amp; (mlData.type == &#x27;max&#x27; || mlData.type == &#x27;min&#x27; || mlData.type == &#x27;average&#x27;)
                        ) {
                        // 特殊值内置支持
                        pos = this.getMarkCoord(seriesIndex, mlData);
                        markLine.data[i] = [zrUtil.clone(mlData), {}];
                        markLine.data[i][0].name = mlData.name || mlData.type;
                        markLine.data[i][0].value = pos[3];
                        pos = pos[2];
                        mlData = [{},{}];
                    }
                    else {
                        pos = [
                            this.getMarkCoord(seriesIndex, mlData[0]),
                            this.getMarkCoord(seriesIndex, mlData[1])
                        ];
                    }

                    markLine.data[i][0].x = typeof mlData[0].x != &#x27;undefined&#x27;
                        ? mlData[0].x : pos[0][0];
                    markLine.data[i][0].y = typeof mlData[0].y != &#x27;undefined&#x27;
                        ? mlData[0].y : pos[0][1];
                    markLine.data[i][1].x = typeof mlData[1].x != &#x27;undefined&#x27;
                        ? mlData[1].x : pos[1][0];
                    markLine.data[i][1].y = typeof mlData[1].y != &#x27;undefined&#x27;
                        ? mlData[1].y : pos[1][1];
                }

                var shapeList = this._markLine(seriesIndex, markLine);

                for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                    shapeList[i].zlevel = _zlevelBase + 1;
                    for (var key in attachStyle) {
                        shapeList[i][key] = zrUtil.clone(attachStyle[key]);
                    }
                    this.shapeList.push(shapeList[i]);
                }
                // 个别特殊图表需要自己addShape
                if (this.type == ecConfig.CHART_TYPE_FORCE
                    || this.type == ecConfig.CHART_TYPE_CHORD
                    ) {
                    for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                        this.zr.addShape(shapeList[i]);
                    }
                }
            },

            /**
             * 标注多级控制构造
             */
            _markPoint : function (seriesIndex, mpOption) {
                var serie = this.series[seriesIndex];
                var component = this.component;
                zrUtil.merge(
                    mpOption,
                    this.ecTheme.markPoint
                );
                mpOption.name = serie.name;

                var pList = [];
                var data = mpOption.data;
                var itemShape;

                var dataRange = component.dataRange;
                var legend = component.legend;
                var color;
                var value;
                var queryTarget;
                var nColor;
                var eColor;
                var effect;
                var zrWidth = this.zr.getWidth();
                var zrHeight = this.zr.getHeight();

                if (!mpOption.large) {
                    for (var i = 0, l = data.length; i &lt; l; i++) {
                        value = typeof data[i] != &#x27;undefined&#x27; &amp;&amp; typeof data[i].value != &#x27;undefined&#x27;
                            ? data[i].value
                            : &#x27;&#x27;;
                        // 图例
                        if (legend) {
                            color = legend.getColor(serie.name);
                        }
                        // 值域
                        if (dataRange) {
                            color = isNaN(value) ? color : dataRange.getColor(value);

                            queryTarget = [data[i], mpOption];
                            nColor = this.deepQuery(
                                queryTarget, &#x27;itemStyle.normal.color&#x27;
                            ) || color;
                            eColor = this.deepQuery(
                                queryTarget, &#x27;itemStyle.emphasis.color&#x27;
                            ) || nColor;
                            // 有值域，并且值域返回null且用户没有自己定义颜色，则隐藏这个mark
                            if (nColor == null &amp;&amp; eColor == null) {
                                continue;
                            }
                        }

                        // 标准化一些参数
                        data[i].tooltip = data[i].tooltip
                            || {trigger:&#x27;item&#x27;}; // tooltip.trigger指定为item
                        data[i].name = typeof data[i].name != &#x27;undefined&#x27;
                            ? data[i].name : &#x27;&#x27;;
                        data[i].value = value;

                        // 复用getSymbolShape
                        itemShape = this.getSymbolShape(
                            mpOption, seriesIndex,      // 系列 
                            data[i], i, data[i].name,   // 数据
                            this.parsePercent(data[i].x, zrWidth),   // 坐标
                            this.parsePercent(data[i].y, zrHeight),  // 坐标
                            &#x27;pin&#x27;, color,               // 默认symbol和color
                            &#x27;rgba(0,0,0,0)&#x27;,
                            &#x27;horizontal&#x27;                // 走向，用于默认文字定位
                        );
                        itemShape._mark = &#x27;point&#x27;;

                        effect = this.deepMerge(
                            [data[i], mpOption],
                            &#x27;effect&#x27;
                        );
                        if (effect.show) {
                            itemShape.effect = effect;
                        }

                        if (serie.type == ecConfig.CHART_TYPE_MAP) {
                            itemShape._geo = this.getMarkGeo(data[i]);
                        }

                        // 重新pack一下数据
                        ecData.pack(
                            itemShape,
                            serie, seriesIndex,
                            data[i], i,
                            data[i].name,
                            value
                        );
                        pList.push(itemShape);
                    }
                }
                else {
                    // 大规模MarkPoint
                    itemShape = this.getLargeMarkPoingShape(seriesIndex, mpOption);
                    itemShape._mark = &#x27;largePoint&#x27;;
                    itemShape &amp;&amp; pList.push(itemShape);
                }
                return pList;
            },

            /**
             * 标线多级控制构造
             */
            _markLine : function (seriesIndex, mlOption) {
                var serie = this.series[seriesIndex];
                var component = this.component;
                zrUtil.merge(
                    mlOption,
                    this.ecTheme.markLine
                );
                // 标准化一些同时支持Array和String的参数
                mlOption.symbol = mlOption.symbol instanceof Array
                    ? mlOption.symbol.length &gt; 1
                    ? mlOption.symbol
                    : [mlOption.symbol[0], mlOption.symbol[0]]
                    : [mlOption.symbol, mlOption.symbol];
                mlOption.symbolSize = mlOption.symbolSize instanceof Array
                    ? mlOption.symbolSize.length &gt; 1
                    ? mlOption.symbolSize
                    : [mlOption.symbolSize[0], mlOption.symbolSize[0]]
                    : [mlOption.symbolSize, mlOption.symbolSize];
                mlOption.symbolRotate = mlOption.symbolRotate instanceof Array
                    ? mlOption.symbolRotate.length &gt; 1
                    ? mlOption.symbolRotate
                    : [mlOption.symbolRotate[0], mlOption.symbolRotate[0]]
                    : [mlOption.symbolRotate, mlOption.symbolRotate];

                mlOption.name = serie.name;

                var pList = [];
                var data = mlOption.data;
                var itemShape;

                var dataRange = component.dataRange;
                var legend = component.legend;
                var color;
                var value;
                var queryTarget;
                var nColor;
                var eColor;
                var effect;
                var zrWidth = this.zr.getWidth();
                var zrHeight = this.zr.getHeight();
                var mergeData;
                for (var i = 0, l = data.length; i &lt; l; i++) {
                    // 图例
                    if (legend) {
                        color = legend.getColor(serie.name);
                    }
                    // 组装一个mergeData
                    mergeData = this.deepMerge(data[i]);
                    value = typeof mergeData != &#x27;undefined&#x27; &amp;&amp; typeof mergeData.value != &#x27;undefined&#x27;
                        ? mergeData.value
                        : &#x27;&#x27;;
                    // 值域
                    if (dataRange) {
                        color = isNaN(value) ? color : dataRange.getColor(value);

                        queryTarget = [mergeData, mlOption];
                        nColor = this.deepQuery(
                            queryTarget, &#x27;itemStyle.normal.color&#x27;
                        ) || color;
                        eColor = this.deepQuery(
                            queryTarget, &#x27;itemStyle.emphasis.color&#x27;
                        ) || nColor;
                        // 有值域，并且值域返回null且用户没有自己定义颜色，则隐藏这个mark
                        if (nColor == null &amp;&amp; eColor == null) {
                            continue;
                        }
                    }

                    // 标准化一些参数
                    data[i][0].tooltip = mergeData.tooltip
                        || {trigger:&#x27;item&#x27;}; // tooltip.trigger指定为item
                    data[i][0].name = typeof data[i][0].name != &#x27;undefined&#x27;
                        ? data[i][0].name : &#x27;&#x27;;
                    data[i][1].name = typeof data[i][1].name != &#x27;undefined&#x27;
                        ? data[i][1].name : &#x27;&#x27;;
                    data[i][0].value = typeof data[i][0].value != &#x27;undefined&#x27;
                        ? data[i][0].value : &#x27;&#x27;;

                    itemShape = this.getLineMarkShape(
                        mlOption,                   // markLine
                        seriesIndex,
                        data[i],                    // 数据
                        i,
                        this.parsePercent(data[i][0].x, zrWidth),   // 坐标
                        this.parsePercent(data[i][0].y, zrHeight),  // 坐标
                        this.parsePercent(data[i][1].x, zrWidth),   // 坐标
                        this.parsePercent(data[i][1].y, zrHeight),  // 坐标
                        color                       // 默认symbol和color
                    );
                    itemShape._mark = &#x27;line&#x27;;

                    effect = this.deepMerge(
                        [mergeData, mlOption],
                        &#x27;effect&#x27;
                    );
                    if (effect.show) {
                        itemShape.effect = effect;
                    }

                    if (serie.type == ecConfig.CHART_TYPE_MAP) {
                        itemShape._geo = [
                            this.getMarkGeo(data[i][0]),
                            this.getMarkGeo(data[i][1])
                        ];
                    }

                    // 重新pack一下数据
                    ecData.pack(
                        itemShape,
                        serie, seriesIndex,
                        data[i][0], i,
                            data[i][0].name + (data[i][1].name !== &#x27;&#x27;
                            ? (&#x27; &gt; &#x27; + data[i][1].name)
                            : &#x27;&#x27;),
                        value
                    );
                    pList.push(itemShape);
                }
                //console.log(pList);
                return pList;
            },

            getMarkCoord : function () {
                // 无转换位置
                return [0, 0];
            },

            /**
             * symbol构造器
             */
            getSymbolShape : function (
                serie, seriesIndex,     // 系列 
                data, dataIndex, name,  // 数据
                x, y,                   // 坐标
                symbol, color,          // 默认symbol和color，来自legend或dataRange全局分配
                emptyColor,             // 折线的emptySymbol用白色填充
                orient                  // 走向，用于默认文字定位
                ) {
                var queryTarget = [data, serie];
                var value = typeof data != &#x27;undefined&#x27;
                    ? (typeof data.value != &#x27;undefined&#x27;
                    ? data.value
                    : data)
                    : &#x27;-&#x27;;

                symbol = this.deepQuery(queryTarget, &#x27;symbol&#x27;) || symbol;
                var symbolSize = this.deepQuery(queryTarget, &#x27;symbolSize&#x27;);
                symbolSize = typeof symbolSize == &#x27;function&#x27;
                    ? symbolSize(value)
                    : symbolSize;
                var symbolRotate = this.deepQuery(queryTarget, &#x27;symbolRotate&#x27;);

                var normal = this.deepMerge(
                    queryTarget,
                    &#x27;itemStyle.normal&#x27;
                );
                var emphasis = this.deepMerge(
                    queryTarget,
                    &#x27;itemStyle.emphasis&#x27;
                );
                var nBorderWidth = typeof normal.borderWidth != &#x27;undefined&#x27;
                    ? normal.borderWidth
                    : (normal.lineStyle &amp;&amp; normal.lineStyle.width);
                if (typeof nBorderWidth == &#x27;undefined&#x27;) {
                    nBorderWidth = symbol.match(&#x27;empty&#x27;) ? 2 : 0;
                }
                var eBorderWidth = typeof emphasis.borderWidth != &#x27;undefined&#x27;
                    ? emphasis.borderWidth
                    : (emphasis.lineStyle &amp;&amp; emphasis.lineStyle.width);
                if (typeof eBorderWidth == &#x27;undefined&#x27;) {
                    eBorderWidth = nBorderWidth + 2;
                }

                var itemShape = new IconShape({
                    style : {
                        iconType : symbol.replace(&#x27;empty&#x27;, &#x27;&#x27;).toLowerCase(),
                        x : x - symbolSize,
                        y : y - symbolSize,
                        width : symbolSize * 2,
                        height : symbolSize * 2,
                        brushType : &#x27;both&#x27;,
                        color : symbol.match(&#x27;empty&#x27;)
                            ? emptyColor
                            : (this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data)
                            || color),
                        strokeColor : normal.borderColor
                            || this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data)
                            || color,
                        lineWidth: nBorderWidth
                    },
                    highlightStyle : {
                        color : symbol.match(&#x27;empty&#x27;)
                            ? emptyColor
                            : this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data),
                        strokeColor : emphasis.borderColor
                            || normal.borderColor
                            || this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data)
                            || color,
                        lineWidth: eBorderWidth
                    },
                    clickable : true
                });

                if (symbol.match(&#x27;image&#x27;)) {
                    itemShape.style.image =
                        symbol.replace(new RegExp(&#x27;^image:\\/\\/&#x27;), &#x27;&#x27;);
                    itemShape = new ImageShape({
                        style : itemShape.style,
                        highlightStyle : itemShape.highlightStyle,
                        clickable : true
                    });
                }

                if (typeof symbolRotate != &#x27;undefined&#x27;) {
                    itemShape.rotation = [
                            symbolRotate * Math.PI / 180, x, y
                    ];
                }

                if (symbol.match(&#x27;star&#x27;)) {
                    itemShape.style.iconType = &#x27;star&#x27;;
                    itemShape.style.n =
                        (symbol.replace(&#x27;empty&#x27;, &#x27;&#x27;).replace(&#x27;star&#x27;,&#x27;&#x27;) - 0) || 5;
                }

                if (symbol == &#x27;none&#x27;) {
                    itemShape.invisible = true;
                    itemShape.hoverable = false;
                }

                /*
                 if (this.deepQuery([data, serie, option], &#x27;calculable&#x27;)) {
                 this.setCalculable(itemShape);
                 itemShape.draggable = true;
                 }
                 */

                itemShape = this.addLabel(
                    itemShape,
                    serie, data, name,
                    orient
                );

                if (symbol.match(&#x27;empty&#x27;)) {
                    if (typeof itemShape.style.textColor == &#x27;undefined&#x27;) {
                        itemShape.style.textColor = itemShape.style.strokeColor;
                    }
                    if (typeof itemShape.highlightStyle.textColor == &#x27;undefined&#x27;) {
                        itemShape.highlightStyle.textColor =
                            itemShape.highlightStyle.strokeColor;
                    }
                }

                ecData.pack(
                    itemShape,
                    serie, seriesIndex,
                    data, dataIndex,
                    name
                );

                itemShape._x = x;
                itemShape._y = y;

                itemShape._dataIndex = dataIndex;
                itemShape._seriesIndex = seriesIndex;

                return itemShape;
            },

            /**
             * 标线构造器
             */
            getLineMarkShape : function (
                mlOption,               // 系列 
                seriesIndex,            // 系列索引
                data,                   // 数据
                dataIndex,              // 数据索引
                xStart, yStart,         // 坐标
                xEnd, yEnd,             // 坐标
                color                   // 默认color，来自legend或dataRange全局分配
                ) {
                var value0 = typeof data[0] != &#x27;undefined&#x27;
                    ? (typeof data[0].value != &#x27;undefined&#x27;
                    ? data[0].value
                    : data[0])
                    : &#x27;-&#x27;;
                var value1 = typeof data[1] != &#x27;undefined&#x27;
                    ? (typeof data[1].value != &#x27;undefined&#x27;
                    ? data[1].value
                    : data[1])
                    : &#x27;-&#x27;;
                var symbol = [
                        this.query(data[0], &#x27;symbol&#x27;) || mlOption.symbol[0],
                        this.query(data[1], &#x27;symbol&#x27;) || mlOption.symbol[1]
                ];
                var symbolSize = [
                        this.query(data[0], &#x27;symbolSize&#x27;) || mlOption.symbolSize[0],
                        this.query(data[1], &#x27;symbolSize&#x27;) || mlOption.symbolSize[1]
                ];
                symbolSize[0] = typeof symbolSize[0] == &#x27;function&#x27;
                    ? symbolSize[0](value0)
                    : symbolSize[0];
                symbolSize[1] = typeof symbolSize[1] == &#x27;function&#x27;
                    ? symbolSize[1](value1)
                    : symbolSize[1];
                var symbolRotate = [
                        this.query(data[0], &#x27;symbolRotate&#x27;) || mlOption.symbolRotate[0],
                        this.query(data[1], &#x27;symbolRotate&#x27;) || mlOption.symbolRotate[1]
                ];
                //console.log(symbol, symbolSize, symbolRotate);

                var queryTarget = [data[0], mlOption];
                var normal = this.deepMerge(
                    queryTarget,
                    &#x27;itemStyle.normal&#x27;
                );
                normal.color = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data);
                var emphasis = this.deepMerge(
                    queryTarget,
                    &#x27;itemStyle.emphasis&#x27;
                );
                emphasis.color = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data);

                var nlineStyle = normal.lineStyle;
                var elineStyle = emphasis.lineStyle;

                var nBorderWidth = nlineStyle.width;
                if (typeof nBorderWidth == &#x27;undefined&#x27;) {
                    nBorderWidth = normal.borderWidth;
                }
                var eBorderWidth = elineStyle.width;
                if (typeof eBorderWidth == &#x27;undefined&#x27;) {
                    if (typeof emphasis.borderWidth != &#x27;undefined&#x27;) {
                        eBorderWidth = emphasis.borderWidth;
                    }
                    else {
                        eBorderWidth = nBorderWidth + 2;
                    }
                }

                var itemShape = new MarkLineShape({
                    style : {
                        smooth : mlOption.smooth ? &#x27;spline&#x27; : false,
                        symbol : symbol,
                        symbolSize : symbolSize,
                        symbolRotate : symbolRotate,
                        //data : [data[0].name,data[1].name],
                        xStart : xStart,
                        yStart : yStart,         // 坐标
                        xEnd : xEnd,
                        yEnd : yEnd,             // 坐标
                        brushType : &#x27;both&#x27;,
                        lineType : nlineStyle.type,
                        shadowColor : nlineStyle.shadowColor
                            || nlineStyle.color
                            || normal.borderColor
                            || normal.color
                            || color,
                        shadowBlur: nlineStyle.shadowBlur,
                        shadowOffsetX: nlineStyle.shadowOffsetX,
                        shadowOffsetY: nlineStyle.shadowOffsetY,
                        color : normal.color || color,
                        strokeColor : nlineStyle.color
                            || normal.borderColor
                            || normal.color
                            || color,
                        lineWidth: nBorderWidth,
                        symbolBorderColor: normal.borderColor
                            || normal.color
                            || color,
                        symbolBorder: normal.borderWidth
                    },
                    highlightStyle : {
                        shadowColor : elineStyle.shadowColor,
                        shadowBlur: elineStyle.shadowBlur,
                        shadowOffsetX: elineStyle.shadowOffsetX,
                        shadowOffsetY: elineStyle.shadowOffsetY,
                        color : emphasis.color|| normal.color || color,
                        strokeColor : elineStyle.color
                            || nlineStyle.color
                            || emphasis.borderColor
                            || normal.borderColor
                            || emphasis.color
                            || normal.color
                            || color,
                        lineWidth: eBorderWidth,
                        symbolBorderColor: emphasis.borderColor
                            || normal.borderColor
                            || emphasis.color
                            || normal.color
                            || color,
                        symbolBorder: typeof emphasis.borderWidth == &#x27;undefined&#x27;
                            ? (normal.borderWidth + 2)
                            : (emphasis.borderWidth)
                    },
                    clickable : true
                });

                itemShape = this.addLabel(
                    itemShape,
                    mlOption,
                    data[0],
                        data[0].name + &#x27; : &#x27; + data[1].name
                );

                itemShape._x = xEnd;
                itemShape._y = yEnd;

                return itemShape;
            },

            /**
             * 大规模标注构造器
             */
            getLargeMarkPoingShape : function(seriesIndex, mpOption) {
                var serie = this.series[seriesIndex];
                var component = this.component;
                var data = mpOption.data;
                var itemShape;

                var dataRange = component.dataRange;
                var legend = component.legend;
                var color;
                var value;
                var queryTarget = [data[0], mpOption];
                var nColor;
                var eColor;
                var effect;

                // 图例
                if (legend) {
                    color = legend.getColor(serie.name);
                }
                // 值域
                if (dataRange) {
                    value = typeof data[0] != &#x27;undefined&#x27;
                        ? (typeof data[0].value != &#x27;undefined&#x27;
                        ? data[0].value
                        : data[0])
                        : &#x27;-&#x27;;
                    color = isNaN(value) ? color : dataRange.getColor(value);

                    nColor = this.deepQuery(
                        queryTarget, &#x27;itemStyle.normal.color&#x27;
                    ) || color;
                    eColor = this.deepQuery(
                        queryTarget, &#x27;itemStyle.emphasis.color&#x27;
                    ) || nColor;
                    // 有值域，并且值域返回null且用户没有自己定义颜色，则隐藏这个mark
                    if (nColor == null &amp;&amp; eColor == null) {
                        return;
                    }
                }
                color = this.deepMerge(queryTarget, &#x27;itemStyle.normal&#x27;).color
                    || color;

                symbol = this.deepQuery(queryTarget, &#x27;symbol&#x27;) || &#x27;circle&#x27;;
                symbol = symbol.replace(&#x27;empty&#x27;, &#x27;&#x27;).replace(/\d/g, &#x27;&#x27;);

                effect = this.deepMerge(
                    [data[0], mpOption],
                    &#x27;effect&#x27;
                );

                var devicePixelRatio = window.devicePixelRatio || 1;

                //console.log(data)
                itemShape = new SymbolShape({
                    style : {
                        pointList : data,
                        color : color,
                        strokeColor: color,
                        shadowColor : effect.shadowColor || color,
                        shadowBlur : (typeof effect.shadowBlur != &#x27;undefined&#x27; ? effect.shadowBlur : 8)
                            * devicePixelRatio,
                        size : this.deepQuery(queryTarget, &#x27;symbolSize&#x27;),
                        iconType : symbol,
                        brushType: &#x27;fill&#x27;,
                        lineWidth:1
                    },
                    draggable : false,
                    hoverable : false
                });

                if (effect.show) {
                    itemShape.effect = effect;
                }

                return itemShape;
            },

            backupShapeList : function () {
                if (this.shapeList &amp;&amp; this.shapeList.length &gt; 0) {
                    this.lastShapeList = this.shapeList;
                    this.shapeList = [];
                }
                else {
                    this.lastShapeList = [];
                }
            },

            addShapeList : function () {
                var maxLenth = this.option.animationThreshold / (this.canvasSupported ? 2 : 4);
                var lastShapeList = this.lastShapeList;
                var shapeList = this.shapeList;
                var duration = lastShapeList.length &gt; 0
                    ? 500 : this.query(this.option, &#x27;animationDuration&#x27;);
                var easing = this.query(this.option, &#x27;animationEasing&#x27;);
                var key;
                var oldMap = {};
                var newMap = {};
                if (this.option.animation
                    &amp;&amp; !this.option.renderAsImage
                    &amp;&amp; shapeList.length &lt; maxLenth
                    &amp;&amp; !this.motionlessOnce
                    ) {
                    // 通过已有的shape做动画过渡
                    for (var i = 0, l = lastShapeList.length; i &lt; l; i++) {
                        key = this._getAnimationKey(lastShapeList[i]);
                        if (key.match(&#x27;undefined&#x27;)) {
                            this.zr.delShape(lastShapeList[i].id);  // 非关键元素直接删除
                        }
                        else {
                            key += lastShapeList[i].type;
                            oldMap[key] = lastShapeList[i];
                        }
                    }
                    for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                        key = this._getAnimationKey(shapeList[i]);
                        if (key.match(&#x27;undefined&#x27;)) {
                            this.zr.addShape(shapeList[i]);         // 非关键元素直接添加
                        }
                        else {
                            key += shapeList[i].type;
                            newMap[key] = shapeList[i];
                        }
                    }

                    for (key in oldMap) {
                        if (!newMap[key]) {
                            // 新的没有 删除
                            this.zr.delShape(oldMap[key].id);
                        }
                    }
                    for (key in newMap) {
                        if (oldMap[key]) {
                            // 新旧都有 动画过渡
                            this.zr.delShape(oldMap[key].id);
                            this._animateMod(oldMap[key], newMap[key], duration, easing);
                        }
                        else {
                            // 新有旧没有  添加并动画过渡
                            //this._animateAdd(newMap[key], duration, easing);
                            this._animateMod(false, newMap[key], duration, easing);
                        }
                    }
                    this.zr.refresh();
                    this.animationEffect();
                }
                else {
                    this.motionlessOnce = false;
                    // clear old
                    this.zr.delShape(lastShapeList);
                    // 直接添加
                    for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                        this.zr.addShape(shapeList[i]);
                    }
                }
            },

            _getAnimationKey : function(shape) {
                if (this.type != ecConfig.CHART_TYPE_MAP) {
                    return ecData.get(shape, &#x27;seriesIndex&#x27;) + &#x27;_&#x27;
                        + ecData.get(shape, &#x27;dataIndex&#x27;)
                        + (shape._mark ? shape._mark : &#x27;&#x27;)
                        + (this.type == ecConfig.CHART_TYPE_RADAR
                            ? ecData.get(shape, &#x27;special&#x27;) : &#x27;&#x27;);
                }
                else {
                    return ecData.get(shape, &#x27;seriesIndex&#x27;) + &#x27;_&#x27;
                        + ecData.get(shape, &#x27;dataIndex&#x27;)
                        + (shape._mark ? shape._mark : &#x27;undefined&#x27;);
                }
            },

            /**
             * 动画过渡
             */
            _animateMod : function (oldShape, newShape, duration, easing) {
                switch (newShape.type) {
                    case &#x27;broken-line&#x27; :
                    case &#x27;half-smooth-polygon&#x27; :
                        ecAnimation.pointList(this.zr, oldShape, newShape, duration, easing);
                        break;
                    case &#x27;rectangle&#x27; :
                        ecAnimation.rectangle(this.zr, oldShape, newShape, duration, easing);
                        break;
                    case &#x27;icon&#x27; :
                        ecAnimation.icon(this.zr, oldShape, newShape, duration, easing);
                        break;
                    case &#x27;candle&#x27; :
                        if (duration &gt; 500) {
                            ecAnimation.candle(this.zr, oldShape, newShape, duration, easing);
                        }
                        else {
                            this.zr.addShape(newShape);
                        }
                        break;
                    case &#x27;ring&#x27; :
                    case &#x27;sector&#x27; :
                    case &#x27;circle&#x27; :
                        if (duration &gt; 500) {
                            // 进入动画，加旋转
                            ecAnimation.ring(
                                this.zr,
                                oldShape,
                                newShape,
                                    duration + ((ecData.get(newShape, &#x27;dataIndex&#x27;) || 0) % 20 * 100),
                                easing
                            );
                        }
                        else if (newShape.type == &#x27;sector&#x27;) {
                            ecAnimation.sector(this.zr, oldShape, newShape, duration, easing);
                        }
                        else {
                            this.zr.addShape(newShape);
                        }
                        break;
                    case &#x27;text&#x27; :
                        ecAnimation.text(this.zr, oldShape, newShape, duration, easing);
                        break;
                    case &#x27;polygon&#x27; :
                        if (duration &gt; 500) {
                            ecAnimation.polygon(this.zr, oldShape, newShape, duration, easing);
                        }
                        else {
                            ecAnimation.pointList(this.zr, oldShape, newShape, duration, easing);
                        }
                        break;
                    case &#x27;gauge-pointer&#x27; :
                        ecAnimation.gaugePointer(this.zr, oldShape, newShape, duration, easing);
                        break;
                    case &#x27;mark-line&#x27; :
                        ecAnimation.markline(this.zr, oldShape, newShape, duration, easing);
                        break;
                    case &#x27;line&#x27; :
                        ecAnimation.line(this.zr, oldShape, newShape, duration, easing);
                        break;
                    default :
                        this.zr.addShape(newShape);
                        break;
                }
            },

            /**
             * 标注动画
             * @param {number} duration 时长
             * @param {string=} easing 缓动效果
             * @param {Array=} addShapeList 指定特效对象，不知道默认使用this.shapeList
             */
            animationMark : function (duration , easing, addShapeList) {
                shapeList = addShapeList || this.shapeList;
                var x;
                var y;
                for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                    if (!shapeList[i]._mark) {
                        continue;
                    }
                    this._animateMod(false, shapeList[i], duration, easing);
                }
                this.animationEffect(addShapeList);
            },

            /**
             * 特效动画
             * @param {Array=} addShapeList 指定特效对象，不知道默认使用this.shapeList
             */
            animationEffect : function (addShapeList) {
                !addShapeList &amp;&amp; this.clearEffectShape();
                shapeList = addShapeList || this.shapeList;
                var zlevel = ecConfig.EFFECT_ZLEVEL;
                if (this.canvasSupported) {
                    this.zr.modLayer(
                        zlevel,
                        {
                            motionBlur : true,
                            lastFrameAlpha : 0.95
                        }
                    );
                }
                var shape;
                for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                    shape = shapeList[i];
                    if (!(shape._mark &amp;&amp; shape.effect &amp;&amp; shape.effect.show &amp;&amp; ecEffect[shape._mark])
                        ) {
                        continue;
                    }
                    ecEffect[shape._mark](this.zr, this.effectList, shape, zlevel);
                    this.effectList[this.effectList.length - 1]._mark = shape._mark;
                }
            },

            clearEffectShape : function (clearMotionBlur) {
                if (this.zr &amp;&amp; this.effectList &amp;&amp; this.effectList.length &gt; 0) {
                    clearMotionBlur &amp;&amp; this.zr.modLayer(
                        ecConfig.EFFECT_ZLEVEL,
                        { motionBlur : false}
                    );
                    this.zr.delShape(this.effectList);
                }
                this.effectList = [];
            },

            /**
             * 动态标线标注添加
             * @param {number} seriesIndex 系列索引
             * @param {Object} markData 标线标注对象，支持多个
             * @param {string} markType 标线标注类型
             */
            addMark : function (seriesIndex, markData, markType) {
                var serie = this.series[seriesIndex];
                if (this.selectedMap[serie.name]) {
                    var duration = 500;
                    var easing = this.query(this.option, &#x27;animationEasing&#x27;);
                    // 备份，复用_buildMarkX
                    var oriMarkData = serie[markType].data;
                    var lastLength = this.shapeList.length;

                    serie[markType].data = markData.data;
                    this[&#x27;_build&#x27; + markType.replace(&#x27;m&#x27;, &#x27;M&#x27;)](seriesIndex);
                    for (var i = lastLength, l = this.shapeList.length; i &lt; l; i++) {
                        this.zr.addShape(this.shapeList[i]);
                    }
                    this.zr.refresh();

                    if (this.option.animation &amp;&amp; !this.option.renderAsImage) {
                        this.animationMark(duration, easing, this.shapeList.slice(lastLength));
                    }
                    // 还原，复用_buildMarkX
                    serie[markType].data = oriMarkData;
                }
            },

            /**
             * 动态标线标注删除
             * @param {number} seriesIndex 系列索引
             * @param {string} markName 标线标注名称
             * @param {string} markType 标线标注类型
             */
            delMark : function (seriesIndex, markName, markType) {
                markType = markType.replace(&#x27;mark&#x27;, &#x27;&#x27;).replace(&#x27;large&#x27;, &#x27;&#x27;).toLowerCase();
                var serie = this.series[seriesIndex];
                if (this.selectedMap[serie.name]) {
                    var needRefresh = false;
                    var shapeList = [this.shapeList, this.effectList];
                    var len = 2;
                    while(len--) {
                        for (var i = 0, l = shapeList[len].length; i &lt; l; i++) {
                            if (shapeList[len][i]._mark == markType
                                &amp;&amp; ecData.get(shapeList[len][i], &#x27;seriesIndex&#x27;) == seriesIndex
                                &amp;&amp; ecData.get(shapeList[len][i], &#x27;name&#x27;) == markName
                                ) {
                                this.zr.delShape(shapeList[len][i].id);
                                shapeList[len].splice(i, 1);
                                needRefresh = true;
                                break;
                            }
                        }
                    }

                    needRefresh &amp;&amp; this.zr.refresh();
                }
            }
        };

        return Base;
    });

    /**
     * echart图表库
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     */
    define(&#x27;echarts/chart&#x27;,[],function (/*require*/) {     //chart
        var self = {};

        var _chartLibrary = {};         //echart图表库

        /**
         * 定义图形实现
         * @param {Object} name
         * @param {Object} clazz 图形实现
         */
        self.define = function (name, clazz) {
            _chartLibrary[name] = clazz;
            return self;
        };

        /**
         * 获取图形实现
         * @param {Object} name
         */
        self.get = function (name) {
            return _chartLibrary[name];
        };

        return self;
    });
    /**
     * echarts组件：孤岛数据
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/chart/island&#x27;,[&#x27;require&#x27;,&#x27;../component/base&#x27;,&#x27;./base&#x27;,&#x27;zrender/shape/Circle&#x27;,&#x27;../config&#x27;,&#x27;../util/ecData&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/tool/event&#x27;,&#x27;zrender/tool/color&#x27;,&#x27;../util/accMath&#x27;,&#x27;../chart&#x27;],function (require) {
        var ComponentBase = require(&#x27;../component/base&#x27;);
        var ChartBase = require(&#x27;./base&#x27;);

        // 图形依赖
        var CircleShape = require(&#x27;zrender/shape/Circle&#x27;);

        var ecConfig = require(&#x27;../config&#x27;);
        var ecData = require(&#x27;../util/ecData&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);
        var zrEvent = require(&#x27;zrender/tool/event&#x27;);

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 图表选项
         */
        function Island(ecTheme, messageCenter, zr, option, myChart) {
            // 基类
            ComponentBase.call(this, ecTheme, messageCenter, zr, {}, myChart);
            // 图表基类
            ChartBase.call(this);

            this._nameConnector;
            this._valueConnector;
            this._zrHeight = this.zr.getHeight();
            this._zrWidth = this.zr.getWidth();

            var self = this;
            /**
             * 滚轮改变孤岛数据值
             */
            self.shapeHandler.onmousewheel = function (param) {
                var shape = param.target;

                var event = param.event;
                var delta = zrEvent.getDelta(event);
                delta = delta &gt; 0 ? (-1) : 1;
                shape.style.r -= delta;
                shape.style.r = shape.style.r &lt; 5 ? 5 : shape.style.r;

                var value = ecData.get(shape, &#x27;value&#x27;);
                var dvalue = value * self.option.island.calculateStep;
                if (dvalue &gt; 1) {
                    value = Math.round(value - dvalue * delta);
                }
                else {
                    value = (value - dvalue * delta).toFixed(2) - 0;
                }

                var name = ecData.get(shape, &#x27;name&#x27;);
                shape.style.text = name + &#x27;:&#x27; + value;

                ecData.set(shape, &#x27;value&#x27;, value);
                ecData.set(shape, &#x27;name&#x27;, name);

                self.zr.modShape(shape.id);
                self.zr.refresh();
                zrEvent.stop(event);
            };
        }

        Island.prototype = {
            type : ecConfig.CHART_TYPE_ISLAND,
            /**
             * 孤岛合并
             *
             * @param {string} tarShapeIndex 目标索引
             * @param {Object} srcShape 源目标，合入目标后删除
             */
            _combine : function (tarShape, srcShape) {
                var zrColor = require(&#x27;zrender/tool/color&#x27;);
                var accMath = require(&#x27;../util/accMath&#x27;);
                var value = accMath.accAdd(
                    ecData.get(tarShape, &#x27;value&#x27;),
                    ecData.get(srcShape, &#x27;value&#x27;)
                );
                var name = ecData.get(tarShape, &#x27;name&#x27;)
                    + this._nameConnector
                    + ecData.get(srcShape, &#x27;name&#x27;);

                tarShape.style.text = name + this._valueConnector + value;

                ecData.set(tarShape, &#x27;value&#x27;, value);
                ecData.set(tarShape, &#x27;name&#x27;, name);
                tarShape.style.r = this.option.island.r;
                tarShape.style.color = zrColor.mix(
                    tarShape.style.color,
                    srcShape.style.color
                );
            },

            /**
             * 刷新
             */
            refresh : function (newOption) {
                if (newOption) {
                    newOption.island = this.reformOption(newOption.island);
                    this.option = newOption;

                    this._nameConnector = this.option.nameConnector;
                    this._valueConnector = this.option.valueConnector;
                }
            },

            getOption : function () {
                return this.option;
            },

            resize : function () {
                var newWidth = this.zr.getWidth();
                var newHieght = this.zr.getHeight();
                var xScale = newWidth / (this._zrWidth || newWidth);
                var yScale = newHieght / (this._zrHeight || newHieght);
                if (xScale == 1 &amp;&amp; yScale == 1) {
                    return;
                }
                this._zrWidth = newWidth;
                this._zrHeight = newHieght;
                for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                    this.zr.modShape(
                        this.shapeList[i].id,
                        {
                            style: {
                                x: Math.round(this.shapeList[i].style.x * xScale),
                                y: Math.round(this.shapeList[i].style.y * yScale)
                            }
                        }
                    );
                }
            },

            add : function (shape) {
                var name = ecData.get(shape, &#x27;name&#x27;);
                var value = ecData.get(shape, &#x27;value&#x27;);
                var seriesName = typeof ecData.get(shape, &#x27;series&#x27;) != &#x27;undefined&#x27;
                    ? ecData.get(shape, &#x27;series&#x27;).name
                    : &#x27;&#x27;;
                var font = this.getFont(this.option.island.textStyle);
                var islandShape = {
                    zlevel : this._zlevelBase,
                    style : {
                        x : shape.style.x,
                        y : shape.style.y,
                        r : this.option.island.r,
                        color : shape.style.color || shape.style.strokeColor,
                        text : name + this._valueConnector + value,
                        textFont : font
                    },
                    draggable : true,
                    hoverable : true,
                    onmousewheel : this.shapeHandler.onmousewheel,
                    _type : &#x27;island&#x27;
                };
                if (islandShape.style.color == &#x27;#fff&#x27;) {
                    islandShape.style.color = shape.style.strokeColor;
                }
                this.setCalculable(islandShape);
                islandShape.dragEnableTime = 0;
                ecData.pack(
                    islandShape,
                    {name:seriesName}, -1,
                    value, -1,
                    name
                );
                islandShape = new CircleShape(islandShape);
                this.shapeList.push(islandShape);
                this.zr.addShape(islandShape);
            },

            del : function (shape) {
                this.zr.delShape(shape.id);
                var newShapeList = [];
                for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                    if (this.shapeList[i].id != shape.id) {
                        newShapeList.push(this.shapeList[i]);
                    }
                }
                this.shapeList = newShapeList;
            },

            /**
             * 数据项被拖拽进来， 重载基类方法
             */
            ondrop : function (param, status) {
                if (!this.isDrop || !param.target) {
                    // 没有在当前实例上发生拖拽行为则直接返回
                    return;
                }
                // 拖拽产生孤岛数据合并
                var target = param.target;      // 拖拽安放目标
                var dragged = param.dragged;    // 当前被拖拽的图形对象

                this._combine(target, dragged);
                this.zr.modShape(target.id);

                status.dragIn = true;

                // 处理完拖拽事件后复位
                this.isDrop = false;

                return;
            },

            /**
             * 数据项被拖拽出去， 重载基类方法
             */
            ondragend : function (param, status) {
                var target = param.target;      // 拖拽安放目标
                if (!this.isDragend) {
                    // 拖拽的不是孤岛数据，如果没有图表接受孤岛数据，需要新增孤岛数据
                    if (!status.dragIn) {
                        target.style.x = zrEvent.getX(param.event);
                        target.style.y = zrEvent.getY(param.event);
                        this.add(target);
                        status.needRefresh = true;
                    }
                }
                else {
                    // 拖拽的是孤岛数据，如果有图表接受了孤岛数据，需要删除孤岛数据
                    if (status.dragIn) {
                        this.del(target);
                        status.needRefresh = true;
                    }
                }

                // 处理完拖拽事件后复位
                this.isDragend = false;

                return;
            }
        };

        zrUtil.inherits(Island, ChartBase);
        zrUtil.inherits(Island, ComponentBase);

        // 图表注册
        require(&#x27;../chart&#x27;).define(&#x27;island&#x27;, Island);

        return Island;
    });
    /**
     * echart组件库
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/component&#x27;,[],function (/*require*/) {     // component
        var self = {};

        var _componentLibrary = {};     // echart组件库

        /**
         * 定义图形实现
         * @param {Object} name
         * @param {Object} clazz 图形实现
         */
        self.define = function (name, clazz) {
            _componentLibrary[name] = clazz;
            return self;
        };

        /**
         * 获取图形实现
         * @param {Object} name
         */
        self.get = function (name) {
            return _componentLibrary[name];
        };

        return self;
    });
    /**
     * echarts组件：提示框
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/component/dataView&#x27;,[&#x27;require&#x27;,&#x27;./base&#x27;,&#x27;../config&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;../component&#x27;],function (require) {
        var Base = require(&#x27;./base&#x27;);

        var ecConfig = require(&#x27;../config&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 提示框参数
         * @param {HtmlElement} dom 目标对象
         */
        function DataView(ecTheme, messageCenter, zr, option, myChart) {
            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            this.dom = myChart.dom;

            // dataview dom &amp; css
            this._tDom = document.createElement(&#x27;div&#x27;);
            this._textArea = document.createElement(&#x27;textArea&#x27;);
            this._buttonRefresh = document.createElement(&#x27;button&#x27;);
            this._buttonClose = document.createElement(&#x27;button&#x27;);
            this._hasShow = false;

            // 缓存一些高宽数据
            this._zrHeight = zr.getHeight();
            this._zrWidth = zr.getWidth();

            this._tDom.className = &#x27;echarts-dataview&#x27;,
                this.hide();
            this.dom.firstChild.appendChild(this._tDom);

            if (window.addEventListener) {
                this._tDom.addEventListener(&#x27;click&#x27;, this._stop);
                this._tDom.addEventListener(&#x27;mousewheel&#x27;, this._stop);
                this._tDom.addEventListener(&#x27;mousemove&#x27;, this._stop);
                this._tDom.addEventListener(&#x27;mousedown&#x27;, this._stop);
                this._tDom.addEventListener(&#x27;mouseup&#x27;, this._stop);

                // mobile支持
                this._tDom.addEventListener(&#x27;touchstart&#x27;, this._stop);
                this._tDom.addEventListener(&#x27;touchmove&#x27;, this._stop);
                this._tDom.addEventListener(&#x27;touchend&#x27;, this._stop);
            }
            else {
                this._tDom.attachEvent(&#x27;onclick&#x27;, this._stop);
                this._tDom.attachEvent(&#x27;onmousewheel&#x27;, this._stop);
                this._tDom.attachEvent(&#x27;onmousemove&#x27;, this._stop);
                this._tDom.attachEvent(&#x27;onmousedown&#x27;, this._stop);
                this._tDom.attachEvent(&#x27;onmouseup&#x27;, this._stop);
            }
        }

        DataView.prototype = {
            type : ecConfig.COMPONENT_TYPE_DATAVIEW,
            _lang : [&#x27;Data View&#x27;, &#x27;close&#x27;, &#x27;refresh&#x27;],
            // 通用样式
            _gCssText : &#x27;position:absolute;&#x27;
                + &#x27;display:block;&#x27;
                + &#x27;overflow:hidden;&#x27;
                + &#x27;transition:height 0.8s,background-color 1s;&#x27;
                + &#x27;-moz-transition:height 0.8s,background-color 1s;&#x27;
                + &#x27;-webkit-transition:height 0.8s,background-color 1s;&#x27;
                + &#x27;-o-transition:height 0.8s,background-color 1s;&#x27;
                + &#x27;z-index:1;&#x27;
                + &#x27;left:0;&#x27;
                + &#x27;top:0;&#x27;,
            hide : function () {
                this._sizeCssText = &#x27;width:&#x27; + this._zrWidth + &#x27;px;&#x27;
                    + &#x27;height:&#x27; + 0 + &#x27;px;&#x27;
                    + &#x27;background-color:#f0ffff;&#x27;;
                this._tDom.style.cssText = this._gCssText + this._sizeCssText;
                // 这是个很恶心的事情
                /*
                 this.dom.onselectstart = function () {
                 return false;
                 };
                 */
            },

            show : function (newOption) {
                this._hasShow = true;
                var lang = this.query(this.option, &#x27;toolbox.feature.dataView.lang&#x27;)
                    || this._lang;

                this.option = newOption;

                this._tDom.innerHTML = &#x27;&lt;p style=&quot;padding:8px 0;margin:0 0 10px 0;&#x27;
                    + &#x27;border-bottom:1px solid #eee&quot;&gt;&#x27;
                    + (lang[0] || this._lang[0])
                    + &#x27;&lt;/p&gt;&#x27;;

                this._textArea.style.cssText =
                    &#x27;display:block;margin:0 0 8px 0;padding:4px 6px;overflow:auto;&#x27;
                    + &#x27;width:&#x27; + (this._zrWidth - 15) + &#x27;px;&#x27;
                    + &#x27;height:&#x27; + (this._zrHeight - 100) + &#x27;px;&#x27;;
                var customContent = this.query(
                    this.option, &#x27;toolbox.feature.dataView.optionToContent&#x27;
                );
                if (typeof customContent != &#x27;function&#x27;) {
                    this._textArea.value = this._optionToContent();
                }
                else {
                    this._textArea.value = customContent(this.option);
                }
                this._tDom.appendChild(this._textArea);

                this._buttonClose.style.cssText = &#x27;float:right;padding:1px 6px;&#x27;;
                this._buttonClose.innerHTML = lang[1] || this._lang[1];
                var self = this;
                this._buttonClose.onclick = function (){
                    self.hide();
                };
                this._tDom.appendChild(this._buttonClose);

                if (this.query(this.option, &#x27;toolbox.feature.dataView.readOnly&#x27;)
                    === false
                    ) {
                    this._buttonRefresh.style.cssText =
                        &#x27;float:right;margin-right:10px;padding:1px 6px;&#x27;;
                    this._buttonRefresh.innerHTML = lang[2] || this._lang[2];
                    this._buttonRefresh.onclick = function (){
                        self._save();
                    };
                    this._tDom.appendChild(this._buttonRefresh);
                    this._textArea.readOnly = false;
                    this._textArea.style.cursor = &#x27;default&#x27;;
                }
                else {
                    this._textArea.readOnly = true;
                    this._textArea.style.cursor = &#x27;text&#x27;;
                }

                this._sizeCssText = &#x27;width:&#x27; + this._zrWidth + &#x27;px;&#x27;
                    + &#x27;height:&#x27; + this._zrHeight + &#x27;px;&#x27;
                    + &#x27;background-color:#fff;&#x27;;
                this._tDom.style.cssText = this._gCssText + this._sizeCssText;
                // 这是个很恶心的事情
                /*
                 this.dom.onselectstart = function () {
                 return true;
                 };
                 */
            },

            _optionToContent : function () {
                var i;
                var j;
                var k;
                var len;
                var data;
                var valueList;
                var axisList = [];
                var content = &#x27;&#x27;;
                if (this.option.xAxis) {
                    if (this.option.xAxis instanceof Array) {
                        axisList = this.option.xAxis;
                    } else {
                        axisList = [this.option.xAxis];
                    }
                    for (i = 0, len = axisList.length; i &lt; len; i++) {
                        // 横纵默认为类目
                        if ((axisList[i].type || &#x27;category&#x27;) == &#x27;category&#x27;) {
                            valueList = [];
                            for (j = 0, k = axisList[i].data.length; j &lt; k; j++) {
                                data = axisList[i].data[j];
                                valueList.push(
                                        typeof data.value != &#x27;undefined&#x27;
                                        ? data.value : data
                                );
                            }
                            content += valueList.join(&#x27;, &#x27;) + &#x27;\n\n&#x27;;
                        }
                    }
                }

                if (this.option.yAxis) {
                    if (this.option.yAxis instanceof Array) {
                        axisList = this.option.yAxis;
                    } else {
                        axisList = [this.option.yAxis];
                    }
                    for (i = 0, len = axisList.length; i &lt; len; i++) {
                        if (axisList[i].type  == &#x27;category&#x27;) {
                            valueList = [];
                            for (j = 0, k = axisList[i].data.length; j &lt; k; j++) {
                                data = axisList[i].data[j];
                                valueList.push(
                                        typeof data.value != &#x27;undefined&#x27;
                                        ? data.value : data
                                );
                            }
                            content += valueList.join(&#x27;, &#x27;) + &#x27;\n\n&#x27;;
                        }
                    }
                }

                var series = this.option.series;
                var itemName;
                for (i = 0, len = series.length; i &lt; len; i++) {
                    valueList = [];
                    for (j = 0, k = series[i].data.length; j &lt; k; j++) {
                        data = series[i].data[j];
                        if (series[i].type == ecConfig.CHART_TYPE_PIE
                            || series[i].type == ecConfig.CHART_TYPE_MAP
                            ) {
                            itemName = (data.name || &#x27;-&#x27;) + &#x27;:&#x27;;
                        }
                        else {
                            itemName = &#x27;&#x27;;
                        }

                        if (series[i].type == ecConfig.CHART_TYPE_SCATTER) {
                            data = typeof data.value != &#x27;undefined&#x27;
                                ? data.value
                                : data;
                            data = data.join(&#x27;, &#x27;);
                        }
                        valueList.push(
                                itemName
                                + (typeof data.value != &#x27;undefined&#x27; ? data.value : data)
                        );
                    }
                    content += (series[i].name || &#x27;-&#x27;) + &#x27; : \n&#x27;;
                    content += valueList.join(
                            series[i].type == ecConfig.CHART_TYPE_SCATTER ? &#x27;\n&#x27;: &#x27;, &#x27;
                    );
                    content += &#x27;\n\n&#x27;;
                }

                return content;
            },

            _save : function () {
                var text = this._textArea.value;
                var customContent = this.query(
                    this.option, &#x27;toolbox.feature.dataView.contentToOption&#x27;
                );
                if (typeof customContent != &#x27;function&#x27;) {
                    text = text.split(&#x27;\n&#x27;);
                    var content = [];
                    for (var i = 0, l = text.length; i &lt; l; i++) {
                        text[i] = this._trim(text[i]);
                        if (text[i] !== &#x27;&#x27;) {
                            content.push(text[i]);
                        }
                    }
                    this._contentToOption(content);
                }
                else {
                    customContent(text, this.option);
                }

                this.hide();

                var self = this;
                setTimeout(
                    function (){
                        self.messageCenter &amp;&amp; self.messageCenter.dispatch(
                            ecConfig.EVENT.DATA_VIEW_CHANGED,
                            null,
                            {option : self.option},
                            self.myChart
                        );
                    },
                    // 有动画，所以高级浏览器时间更长点
                    self.canvasSupported ? 800 : 100
                );
            },

            _contentToOption : function (content) {
                var i;
                var j;
                var k;
                var len;
                var data;
                var axisList = [];

                var contentIdx = 0;
                var contentValueList;
                var value;

                if (this.option.xAxis) {
                    if (this.option.xAxis instanceof Array) {
                        axisList = this.option.xAxis;
                    } else {
                        axisList = [this.option.xAxis];
                    }
                    for (i = 0, len = axisList.length; i &lt; len; i++) {
                        // 横纵默认为类目
                        if ((axisList[i].type || &#x27;category&#x27;) == &#x27;category&#x27;
                            ) {
                            contentValueList = content[contentIdx].split(&#x27;,&#x27;);
                            for (j = 0, k = axisList[i].data.length; j &lt; k; j++) {
                                value = this._trim(contentValueList[j] || &#x27;&#x27;);
                                data = axisList[i].data[j];
                                if (typeof axisList[i].data[j].value != &#x27;undefined&#x27;
                                    ) {
                                    axisList[i].data[j].value = value;
                                }
                                else {
                                    axisList[i].data[j] = value;
                                }
                            }
                            contentIdx++;
                        }
                    }
                }

                if (this.option.yAxis) {
                    if (this.option.yAxis instanceof Array) {
                        axisList = this.option.yAxis;
                    } else {
                        axisList = [this.option.yAxis];
                    }
                    for (i = 0, len = axisList.length; i &lt; len; i++) {
                        if (axisList[i].type  == &#x27;category&#x27;) {
                            contentValueList = content[contentIdx].split(&#x27;,&#x27;);
                            for (j = 0, k = axisList[i].data.length; j &lt; k; j++) {
                                value = this._trim(contentValueList[j] || &#x27;&#x27;);
                                data = axisList[i].data[j];
                                if (typeof axisList[i].data[j].value != &#x27;undefined&#x27;
                                    ) {
                                    axisList[i].data[j].value = value;
                                }
                                else {
                                    axisList[i].data[j] = value;
                                }
                            }
                            contentIdx++;
                        }
                    }
                }

                var series = this.option.series;
                for (i = 0, len = series.length; i &lt; len; i++) {
                    contentIdx++;
                    if (series[i].type == ecConfig.CHART_TYPE_SCATTER) {
                        for (var j = 0, k = series[i].data.length; j &lt; k; j++) {
                            contentValueList = content[contentIdx];
                            value = contentValueList.replace(&#x27; &#x27;,&#x27;&#x27;).split(&#x27;,&#x27;);
                            if (typeof series[i].data[j].value != &#x27;undefined&#x27;
                                ) {
                                series[i].data[j].value = value;
                            }
                            else {
                                series[i].data[j] = value;
                            }
                            contentIdx++;
                        }
                    }
                    else {
                        contentValueList = content[contentIdx].split(&#x27;,&#x27;);
                        for (var j = 0, k = series[i].data.length; j &lt; k; j++) {
                            value = (contentValueList[j] || &#x27;&#x27;).replace(/.*:/,&#x27;&#x27;);
                            value = this._trim(value);
                            value = (value != &#x27;-&#x27; &amp;&amp; value !== &#x27;&#x27;)
                                ? (value - 0)
                                : &#x27;-&#x27;;
                            if (typeof series[i].data[j].value != &#x27;undefined&#x27;
                                ) {
                                series[i].data[j].value = value;
                            }
                            else {
                                series[i].data[j] = value;
                            }
                        }
                        contentIdx++;
                    }
                }
            },

            _trim : function (str){
                var trimer = new RegExp(
                    &#x27;(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+\x24)&#x27;, &#x27;g&#x27;
                );
                return str.replace(trimer, &#x27;&#x27;);
            },

            // 阻塞zrender事件
            _stop : function (e){
                e = e || window.event;
                if (e.stopPropagation) {
                    e.stopPropagation();
                }
                else {
                    e.cancelBubble = true;
                }
            },

            /**
             * zrender事件响应：窗口大小改变
             */
            resize : function () {
                this._zrHeight = this.zr.getHeight();
                this._zrWidth = this.zr.getWidth();
                if (this._tDom.offsetHeight &gt; 10) {
                    this._sizeCssText = &#x27;width:&#x27; + this._zrWidth + &#x27;px;&#x27;
                        + &#x27;height:&#x27; + this._zrHeight + &#x27;px;&#x27;
                        + &#x27;background-color:#fff;&#x27;;
                    this._tDom.style.cssText = this._gCssText + this._sizeCssText;
                    this._textArea.style.cssText = &#x27;display:block;margin:0 0 8px 0;&#x27;
                        + &#x27;padding:4px 6px;overflow:auto;&#x27;
                        + &#x27;width:&#x27; + (this._zrWidth - 15) + &#x27;px;&#x27;
                        + &#x27;height:&#x27; + (this._zrHeight - 100) + &#x27;px;&#x27;;
                }
            },

            /**
             * 释放后实例不可用，重载基类方法
             */
            dispose : function () {
                if (window.removeEventListener) {
                    this._tDom.removeEventListener(&#x27;click&#x27;, this._stop);
                    this._tDom.removeEventListener(&#x27;mousewheel&#x27;, this._stop);
                    this._tDom.removeEventListener(&#x27;mousemove&#x27;, this._stop);
                    this._tDom.removeEventListener(&#x27;mousedown&#x27;, this._stop);
                    this._tDom.removeEventListener(&#x27;mouseup&#x27;, this._stop);

                    // mobile支持
                    this._tDom.removeEventListener(&#x27;touchstart&#x27;, this._stop);
                    this._tDom.removeEventListener(&#x27;touchmove&#x27;, this._stop);
                    this._tDom.removeEventListener(&#x27;touchend&#x27;, this._stop);
                }
                else {
                    this._tDom.detachEvent(&#x27;onclick&#x27;, this._stop);
                    this._tDom.detachEvent(&#x27;onmousewheel&#x27;, this._stop);
                    this._tDom.detachEvent(&#x27;onmousemove&#x27;, this._stop);
                    this._tDom.detachEvent(&#x27;onmousedown&#x27;, this._stop);
                    this._tDom.detachEvent(&#x27;onmouseup&#x27;, this._stop);
                }

                this._buttonRefresh.onclick = null;
                this._buttonClose.onclick = null;

                if (this._hasShow) {
                    this._tDom.removeChild(this._textArea);
                    this._tDom.removeChild(this._buttonRefresh);
                    this._tDom.removeChild(this._buttonClose);
                }

                this._textArea = null;
                this._buttonRefresh = null;
                this._buttonClose = null;

                this.dom.firstChild.removeChild(this._tDom);
                this._tDom = null;
            }
        };

        zrUtil.inherits(DataView, Base);

        require(&#x27;../component&#x27;).define(&#x27;dataView&#x27;, DataView);

        return DataView;
    });
    /**
     * echarts组件：工具箱
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/component/toolbox&#x27;,[&#x27;require&#x27;,&#x27;./base&#x27;,&#x27;zrender/shape/Line&#x27;,&#x27;zrender/shape/Image&#x27;,&#x27;zrender/shape/Rectangle&#x27;,&#x27;../util/shape/Icon&#x27;,&#x27;../config&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/config&#x27;,&#x27;zrender/tool/event&#x27;,&#x27;./dataView&#x27;,&#x27;../component&#x27;],function (require) {
        var Base = require(&#x27;./base&#x27;);

        // 图形依赖
        var LineShape = require(&#x27;zrender/shape/Line&#x27;);
        var ImageShape = require(&#x27;zrender/shape/Image&#x27;);
        var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
        var IconShape = require(&#x27;../util/shape/Icon&#x27;);

        var ecConfig = require(&#x27;../config&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);
        var zrConfig = require(&#x27;zrender/config&#x27;);
        var zrEvent = require(&#x27;zrender/tool/event&#x27;);

        var _MAGICTYPE_STACK = &#x27;stack&#x27;;
        var _MAGICTYPE_TILED = &#x27;tiled&#x27;;

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {HtmlElement} dom 目标对象
         * @param {ECharts} myChart 当前图表实例
         */
        function Toolbox(ecTheme, messageCenter, zr, option, myChart) {
            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            this.dom = myChart.dom;

            this._magicType = {};
            //this._magicMap;
            this._isSilence = false;

            this._iconList;
            this._iconShapeMap = {};
            //this._itemGroupLocation;
            this._featureTitle = {};             // 文字
            this._featureIcon = {};              // 图标
            this._featureColor = {};             // 颜色
            this._enableColor = &#x27;red&#x27;;
            this._disableColor = &#x27;#ccc&#x27;;
            // this._markStart;
            // this._marking;
            // this._markShape;
            // this._zoomStart;
            // this._zooming;
            // this._zoomShape;
            // this._zoomQueue;
            // this._dataView;
            this._markShapeList = [];
            var self = this;
            self._onMark = function (param) {
                self.__onMark(param);
            };
            self._onMarkUndo = function (param) {
                self.__onMarkUndo(param);
            };
            self._onMarkClear = function (param) {
                self.__onMarkClear(param);
            };
            self._onDataZoom = function (param) {
                self.__onDataZoom(param);
            };
            self._onDataZoomReset = function (param) {
                self.__onDataZoomReset(param);
            };
            self._onDataView = function (param) {
                self.__onDataView(param);
            };
            self._onRestore = function (param) {
                self.__onRestore(param);
            };
            self._onSaveAsImage = function (param) {
                self.__onSaveAsImage(param);
            };
            self._onMagicType = function (param) {
                self.__onMagicType(param);
            };
            self._onCustomHandler = function (param) {
                self.__onCustomHandler(param);
            };
            self._onmousemove = function (param) {
                return self.__onmousemove(param);
            };

            self._onmousedown = function (param) {
                return self.__onmousedown(param);
            };

            self._onmouseup = function (param) {
                return self.__onmouseup(param);
            };

            self._onclick = function (param) {
                return self.__onclick(param);
            };
        }

        Toolbox.prototype = {
            type : ecConfig.COMPONENT_TYPE_TOOLBOX,
            _buildShape : function () {
                this._iconList = [];
                var toolboxOption = this.option.toolbox;
                this._enableColor = toolboxOption.effectiveColor
                this._disableColor = toolboxOption.disableColor;
                var feature = toolboxOption.feature;
                var iconName = [];
                for (var key in feature){
                    if (feature[key].show) {
                        switch (key) {
                            case &#x27;mark&#x27; :
                                iconName.push({key : key, name : &#x27;mark&#x27;});
                                iconName.push({key : key, name : &#x27;markUndo&#x27;});
                                iconName.push({key : key, name : &#x27;markClear&#x27;});
                                break;
                            case &#x27;magicType&#x27; :
                                for (var i = 0, l = feature[key].type.length; i &lt; l; i++) {
                                    feature[key].title[feature[key].type[i] + &#x27;Chart&#x27;]
                                        = feature[key].title[feature[key].type[i]];
                                    iconName.push({key : key, name : feature[key].type[i] + &#x27;Chart&#x27;});
                                }
                                break;
                            case &#x27;dataZoom&#x27; :
                                iconName.push({key : key, name : &#x27;dataZoom&#x27;});
                                iconName.push({key : key, name : &#x27;dataZoomReset&#x27;});
                                break;
                            case &#x27;saveAsImage&#x27; :
                                if (this.canvasSupported) {
                                    iconName.push({key : key, name : &#x27;saveAsImage&#x27;});
                                }
                                break;
                            default :
                                iconName.push({key : key, name : key});
                                break;
                        }
                    }
                }
                if (iconName.length &gt; 0) {
                    var name;
                    var key;
                    for (var i = 0, l = iconName.length; i &lt; l; i++) {
                        name = iconName[i].name;
                        key = iconName[i].key;
                        this._iconList.push(name);
                        this._featureTitle[name] = feature[key].title[name] || feature[key].title;
                        if (feature[key].icon) {
                            this._featureIcon[name] = feature[key].icon[name] || feature[key].icon;
                        }
                        if (feature[key].color) {
                            this._featureColor[name] = feature[key].color[name] || feature[key].color;
                        }
                    }
                    this._itemGroupLocation = this._getItemGroupLocation();

                    this._buildBackground();
                    this._buildItem();

                    for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                        this.zr.addShape(this.shapeList[i]);
                    }
                    if (this._iconShapeMap[&#x27;mark&#x27;]) {
                        this._iconDisable(this._iconShapeMap[&#x27;markUndo&#x27;]);
                        this._iconDisable(this._iconShapeMap[&#x27;markClear&#x27;]);
                    }
                    if (this._iconShapeMap[&#x27;dataZoomReset&#x27;] &amp;&amp; this._zoomQueue.length === 0) {
                        this._iconDisable(this._iconShapeMap[&#x27;dataZoomReset&#x27;]);
                    }
                }
            },

            /**
             * 构建所有图例元素
             */
            _buildItem : function () {
                var toolboxOption = this.option.toolbox;
                var iconLength = this._iconList.length;
                var lastX = this._itemGroupLocation.x;
                var lastY = this._itemGroupLocation.y;
                var itemSize = toolboxOption.itemSize;
                var itemGap = toolboxOption.itemGap;
                var itemShape;

                var color = toolboxOption.color instanceof Array
                    ? toolboxOption.color : [toolboxOption.color];

                var textFont = this.getFont(toolboxOption.textStyle);
                var textPosition;
                var textAlign;
                var textBaseline;
                if (toolboxOption.orient == &#x27;horizontal&#x27;) {
                    textPosition = this._itemGroupLocation.y / this.zr.getHeight() &lt; 0.5
                        ? &#x27;bottom&#x27; : &#x27;top&#x27;;
                    textAlign = this._itemGroupLocation.x / this.zr.getWidth() &lt; 0.5
                        ? &#x27;left&#x27; : &#x27;right&#x27;;
                    textBaseline = this._itemGroupLocation.y / this.zr.getHeight() &lt; 0.5
                        ? &#x27;top&#x27; : &#x27;bottom&#x27;;
                }
                else {
                    textPosition = this._itemGroupLocation.x / this.zr.getWidth() &lt; 0.5
                        ? &#x27;right&#x27; : &#x27;left&#x27;;
                    /*
                     textAlign = this._itemGroupLocation.x / this.zr.getWidth() &lt; 0.5
                     ? &#x27;right&#x27; : &#x27;left&#x27;;
                     textBaseline = &#x27;top&#x27;;
                     */
                }

                this._iconShapeMap = {};
                var self = this;

                for (var i = 0; i &lt; iconLength; i++) {
                    // 图形
                    itemShape = {
                        type : &#x27;icon&#x27;,
                        zlevel : this._zlevelBase,
                        style : {
                            x : lastX,
                            y : lastY,
                            width : itemSize,
                            height : itemSize,
                            iconType : this._iconList[i],
                            lineWidth : 1,
                            strokeColor : this._featureColor[this._iconList[i]]
                                || color[i % color.length],
                            brushType: &#x27;stroke&#x27;
                        },
                        highlightStyle : {
                            lineWidth : 1,
                            text : toolboxOption.showTitle
                                ? this._featureTitle[this._iconList[i]]
                                : undefined,
                            textFont : textFont,
                            textPosition : textPosition,
                            strokeColor : this._featureColor[this._iconList[i]]
                                || color[i % color.length]
                        },
                        hoverable : true,
                        clickable : true
                    };

                    if (this._featureIcon[this._iconList[i]]) {
                        itemShape.style.image = this._featureIcon[this._iconList[i]].replace(
                            new RegExp(&#x27;^image:\\/\\/&#x27;), &#x27;&#x27;
                        );
                        itemShape.style.opacity = 0.8;
                        itemShape.highlightStyle.opacity = 1;
                        itemShape.type = &#x27;image&#x27;;
                    }

                    if (toolboxOption.orient == &#x27;horizontal&#x27;) {
                        // 修正左对齐第一个或右对齐最后一个
                        if (i === 0 &amp;&amp; textAlign == &#x27;left&#x27;) {
                            itemShape.highlightStyle.textPosition = &#x27;specific&#x27;;
                            itemShape.highlightStyle.textAlign = textAlign;
                            itemShape.highlightStyle.textBaseline = textBaseline;
                            itemShape.highlightStyle.textX = lastX;
                            itemShape.highlightStyle.textY = textBaseline == &#x27;top&#x27;
                                ? lastY + itemSize + 10
                                : lastY - 10;
                        }
                        if (i == iconLength - 1 &amp;&amp; textAlign == &#x27;right&#x27;) {
                            itemShape.highlightStyle.textPosition = &#x27;specific&#x27;;
                            itemShape.highlightStyle.textAlign = textAlign;
                            itemShape.highlightStyle.textBaseline = textBaseline;
                            itemShape.highlightStyle.textX = lastX + itemSize;
                            itemShape.highlightStyle.textY = textBaseline == &#x27;top&#x27;
                                ? lastY + itemSize + 10
                                : lastY - 10;
                        }
                    }

                    switch(this._iconList[i]) {
                        case &#x27;mark&#x27;:
                            itemShape.onclick = self._onMark;
                            break;
                        case &#x27;markUndo&#x27;:
                            itemShape.onclick = self._onMarkUndo;
                            break;
                        case &#x27;markClear&#x27;:
                            itemShape.onclick = self._onMarkClear;
                            break;
                        case &#x27;dataZoom&#x27;:
                            itemShape.onclick = self._onDataZoom;
                            break;
                        case &#x27;dataZoomReset&#x27;:
                            itemShape.onclick = self._onDataZoomReset;
                            break;
                        case &#x27;dataView&#x27; :
                            if (!this._dataView) {
                                var DataView = require(&#x27;./dataView&#x27;);
                                this._dataView = new DataView(
                                    this.ecTheme, this.messageCenter, this.zr, this.option, this.myChart
                                );
                            }
                            itemShape.onclick = self._onDataView;
                            break;
                        case &#x27;restore&#x27;:
                            itemShape.onclick = self._onRestore;
                            break;
                        case &#x27;saveAsImage&#x27;:
                            itemShape.onclick = self._onSaveAsImage;
                            break;
                        default:
                            if (this._iconList[i].match(&#x27;Chart&#x27;)) {
                                itemShape._name = this._iconList[i].replace(&#x27;Chart&#x27;, &#x27;&#x27;);
                                /*
                                 if (this._magicType[itemShape._name]) {
                                 itemShape.style.strokeColor = this._enableColor;
                                 }
                                 */
                                itemShape.onclick = self._onMagicType;
                            }
                            else {
                                itemShape.onclick = self._onCustomHandler;
                            }
                            break;
                    }

                    if (itemShape.type == &#x27;icon&#x27;) {
                        itemShape = new IconShape(itemShape);
                    }
                    else if (itemShape.type == &#x27;image&#x27;) {
                        itemShape = new ImageShape(itemShape);
                    }
                    this.shapeList.push(itemShape);
                    this._iconShapeMap[this._iconList[i]] = itemShape;

                    if (toolboxOption.orient == &#x27;horizontal&#x27;) {
                        lastX += itemSize + itemGap;
                    }
                    else {
                        lastY += itemSize + itemGap;
                    }
                }
            },

            _buildBackground : function () {
                var toolboxOption = this.option.toolbox;
                var pTop = toolboxOption.padding[0];
                var pRight = toolboxOption.padding[1];
                var pBottom = toolboxOption.padding[2];
                var pLeft = toolboxOption.padding[3];

                this.shapeList.push(new RectangleShape({
                    zlevel : this._zlevelBase,
                    hoverable :false,
                    style : {
                        x : this._itemGroupLocation.x - pLeft,
                        y : this._itemGroupLocation.y - pTop,
                        width : this._itemGroupLocation.width + pLeft + pRight,
                        height : this._itemGroupLocation.height + pTop + pBottom,
                        brushType : toolboxOption.borderWidth === 0
                            ? &#x27;fill&#x27; : &#x27;both&#x27;,
                        color : toolboxOption.backgroundColor,
                        strokeColor : toolboxOption.borderColor,
                        lineWidth : toolboxOption.borderWidth
                    }
                }));
            },

            /**
             * 根据选项计算图例实体的位置坐标
             */
            _getItemGroupLocation : function () {
                var toolboxOption = this.option.toolbox;
                var iconLength = this._iconList.length;
                var itemGap = toolboxOption.itemGap;
                var itemSize = toolboxOption.itemSize;
                var totalWidth = 0;
                var totalHeight = 0;

                if (toolboxOption.orient == &#x27;horizontal&#x27;) {
                    // 水平布局，计算总宽度，别忘减去最后一个的itemGap
                    totalWidth = (itemSize + itemGap) * iconLength - itemGap;
                    totalHeight = itemSize;
                }
                else {
                    // 垂直布局，计算总高度
                    totalHeight = (itemSize + itemGap) * iconLength - itemGap;
                    totalWidth = itemSize;
                }

                var x;
                var zrWidth = this.zr.getWidth();
                switch (toolboxOption.x) {
                    case &#x27;center&#x27; :
                        x = Math.floor((zrWidth - totalWidth) / 2);
                        break;
                    case &#x27;left&#x27; :
                        x = toolboxOption.padding[3] + toolboxOption.borderWidth;
                        break;
                    case &#x27;right&#x27; :
                        x = zrWidth
                            - totalWidth
                            - toolboxOption.padding[1]
                            - toolboxOption.borderWidth;
                        break;
                    default :
                        x = toolboxOption.x - 0;
                        x = isNaN(x) ? 0 : x;
                        break;
                }

                var y;
                var zrHeight = this.zr.getHeight();
                switch (toolboxOption.y) {
                    case &#x27;top&#x27; :
                        y = toolboxOption.padding[0] + toolboxOption.borderWidth;
                        break;
                    case &#x27;bottom&#x27; :
                        y = zrHeight
                            - totalHeight
                            - toolboxOption.padding[2]
                            - toolboxOption.borderWidth;
                        break;
                    case &#x27;center&#x27; :
                        y = Math.floor((zrHeight - totalHeight) / 2);
                        break;
                    default :
                        y = toolboxOption.y - 0;
                        y = isNaN(y) ? 0 : y;
                        break;
                }

                return {
                    x : x,
                    y : y,
                    width : totalWidth,
                    height : totalHeight
                };
            },

            __onmousemove : function (param) {
                if (this._marking) {
                    this._markShape.style.xEnd = zrEvent.getX(param.event);
                    this._markShape.style.yEnd = zrEvent.getY(param.event);
                    this.zr.addHoverShape(this._markShape);
                }
                if (this._zooming) {
                    this._zoomShape.style.width =
                        zrEvent.getX(param.event) - this._zoomShape.style.x;
                    this._zoomShape.style.height =
                        zrEvent.getY(param.event) - this._zoomShape.style.y;
                    this.zr.addHoverShape(this._zoomShape);
                    this.dom.style.cursor = &#x27;crosshair&#x27;;
                }
                if (this._zoomStart
                    &amp;&amp; (this.dom.style.cursor != &#x27;pointer&#x27; &amp;&amp; this.dom.style.cursor != &#x27;move&#x27;)
                    ) {
                    this.dom.style.cursor = &#x27;crosshair&#x27;;
                }
            },

            __onmousedown : function (param) {
                if (param.target) {
                    return;
                }
                this._zooming = true;
                var x = zrEvent.getX(param.event);
                var y = zrEvent.getY(param.event);
                var zoomOption = this.option.dataZoom || {};
                this._zoomShape = new RectangleShape({
                    zlevel : this._zlevelBase,
                    style : {
                        x : x,
                        y : y,
                        width : 1,
                        height : 1,
                        brushType: &#x27;both&#x27;
                    },
                    highlightStyle : {
                        lineWidth : 2,
                        color: zoomOption.fillerColor
                            || ecConfig.dataZoom.fillerColor,
                        strokeColor : zoomOption.handleColor
                            || ecConfig.dataZoom.handleColor,
                        brushType: &#x27;both&#x27;
                    }
                });
                this.zr.addHoverShape(this._zoomShape);
                return true; // 阻塞全局事件
            },

            __onmouseup : function (/*param*/) {
                if (!this._zoomShape
                    || Math.abs(this._zoomShape.style.width) &lt; 10
                    || Math.abs(this._zoomShape.style.height) &lt; 10
                    ) {
                    this._zooming = false;
                    return true;
                }
                if (this._zooming &amp;&amp; this.component.dataZoom) {
                    this._zooming = false;

                    var zoom = this.component.dataZoom.rectZoom(this._zoomShape.style);
                    if (zoom) {
                        this._zoomQueue.push({
                            start : zoom.start,
                            end : zoom.end,
                            start2 : zoom.start2,
                            end2 : zoom.end2
                        });
                        this._iconEnable(this._iconShapeMap[&#x27;dataZoomReset&#x27;]);
                        this.zr.refresh();
                    }
                }
                return true; // 阻塞全局事件
            },

            __onclick : function (param) {
                if (param.target) {
                    return;
                }
                if (this._marking) {
                    this._marking = false;
                    this._markShapeList.push(this._markShape);
                    this._iconEnable(this._iconShapeMap[&#x27;markUndo&#x27;]);
                    this._iconEnable(this._iconShapeMap[&#x27;markClear&#x27;]);
                    this.zr.addShape(this._markShape);
                    this.zr.refresh();
                }
                else if (this._markStart) {
                    this._marking = true;
                    var x = zrEvent.getX(param.event);
                    var y = zrEvent.getY(param.event);
                    this._markShape = new LineShape({
                        zlevel : this._zlevelBase,
                        style : {
                            xStart : x,
                            yStart : y,
                            xEnd : x,
                            yEnd : y,
                            lineWidth : this.query(
                                this.option,
                                &#x27;toolbox.feature.mark.lineStyle.width&#x27;
                            ),
                            strokeColor : this.query(
                                this.option,
                                &#x27;toolbox.feature.mark.lineStyle.color&#x27;
                            ),
                            lineType : this.query(
                                this.option,
                                &#x27;toolbox.feature.mark.lineStyle.type&#x27;
                            )
                        }
                    });
                    this.zr.addHoverShape(this._markShape);
                }
            },

            __onMark : function (param) {
                var target = param.target;
                if (this._marking || this._markStart) {
                    // 取消
                    this._resetMark();
                    this.zr.refresh();
                }
                else {
                    // 启用Mark
                    this._resetZoom();   // mark与dataZoom互斥

                    this.zr.modShape(target.id, {style: {strokeColor: this._enableColor}});
                    this.zr.refresh();
                    this._markStart = true;
                    var self = this;
                    setTimeout(function (){
                        self.zr
                        &amp;&amp; self.zr.on(zrConfig.EVENT.CLICK, self._onclick)
                        &amp;&amp; self.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                    }, 10);
                }
                return true; // 阻塞全局事件
            },

            __onMarkUndo : function () {
                if (this._marking) {
                    this._marking = false;
                } else {
                    var len = this._markShapeList.length;
                    if (len &gt;= 1) {
                        var target = this._markShapeList[len - 1];
                        this.zr.delShape(target.id);
                        this.zr.refresh();
                        this._markShapeList.pop();
                        if (len == 1) {
                            this._iconDisable(this._iconShapeMap[&#x27;markUndo&#x27;]);
                            this._iconDisable(this._iconShapeMap[&#x27;markClear&#x27;]);
                        }
                    }
                }
                return true;
            },

            __onMarkClear : function () {
                if (this._marking) {
                    this._marking = false;
                }
                var len = this._markShapeList.length;
                if (len &gt; 0) {
                    while(len--) {
                        this.zr.delShape(this._markShapeList.pop().id);
                    }
                    this._iconDisable(this._iconShapeMap[&#x27;markUndo&#x27;]);
                    this._iconDisable(this._iconShapeMap[&#x27;markClear&#x27;]);
                    this.zr.refresh();
                }
                return true;
            },

            __onDataZoom : function (param) {
                var target = param.target;
                if (this._zooming || this._zoomStart) {
                    // 取消
                    this._resetZoom();
                    this.zr.refresh();
                    this.dom.style.cursor = &#x27;default&#x27;;
                }
                else {
                    // 启用Zoom
                    this._resetMark();   // mark与dataZoom互斥

                    this.zr.modShape(target.id, {style: {strokeColor: this._enableColor}});
                    this.zr.refresh();
                    this._zoomStart = true;
                    var self = this;
                    setTimeout(function (){
                        self.zr
                        &amp;&amp; self.zr.on(zrConfig.EVENT.MOUSEDOWN, self._onmousedown)
                        &amp;&amp; self.zr.on(zrConfig.EVENT.MOUSEUP, self._onmouseup)
                        &amp;&amp; self.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                    }, 10);

                    this.dom.style.cursor = &#x27;crosshair&#x27;;
                }
                return true; // 阻塞全局事件
            },

            __onDataZoomReset : function () {
                if (this._zooming) {
                    this._zooming = false;
                }
                this._zoomQueue.pop();
                //console.log(this._zoomQueue)
                if (this._zoomQueue.length &gt; 0) {
                    this.component.dataZoom.absoluteZoom(
                        this._zoomQueue[this._zoomQueue.length - 1]
                    );
                }
                else {
                    this.component.dataZoom.rectZoom();
                    this._iconDisable(this._iconShapeMap[&#x27;dataZoomReset&#x27;]);
                    this.zr.refresh();
                }

                return true;
            },

            _resetMark : function () {
                this._marking = false;
                if (this._markStart) {
                    this._markStart = false;
                    if (this._iconShapeMap[&#x27;mark&#x27;]) {
                        // 还原图标为未生效状态
                        this.zr.modShape(
                            this._iconShapeMap[&#x27;mark&#x27;].id,
                            {
                                style: {
                                    strokeColor: this._iconShapeMap[&#x27;mark&#x27;]
                                        .highlightStyle
                                        .strokeColor
                                }
                            }
                        );
                    }

                    this.zr.un(zrConfig.EVENT.CLICK, this._onclick);
                    this.zr.un(zrConfig.EVENT.MOUSEMOVE, this._onmousemove);
                }
            },

            _resetZoom : function () {
                this._zooming = false;
                if (this._zoomStart) {
                    this._zoomStart = false;
                    if (this._iconShapeMap[&#x27;dataZoom&#x27;]) {
                        // 还原图标为未生效状态
                        this.zr.modShape(
                            this._iconShapeMap[&#x27;dataZoom&#x27;].id,
                            {
                                style: {
                                    strokeColor: this._iconShapeMap[&#x27;dataZoom&#x27;]
                                        .highlightStyle
                                        .strokeColor
                                }
                            }
                        );
                    }

                    this.zr.un(zrConfig.EVENT.MOUSEDOWN, this._onmousedown);
                    this.zr.un(zrConfig.EVENT.MOUSEUP, this._onmouseup);
                    this.zr.un(zrConfig.EVENT.MOUSEMOVE, this._onmousemove);
                }
            },

            _iconDisable : function (target) {
                if (target.type != &#x27;image&#x27;) {
                    this.zr.modShape(target.id, {
                        hoverable : false,
                        clickable : false,
                        style : {
                            strokeColor : this._disableColor
                        }
                    });
                }
                else {
                    this.zr.modShape(target.id, {
                        hoverable : false,
                        clickable : false,
                        style : {
                            opacity : 0.3
                        }
                    });
                }
            },

            _iconEnable : function (target) {
                if (target.type != &#x27;image&#x27;) {
                    this.zr.modShape(target.id, {
                        hoverable : true,
                        clickable : true,
                        style : {
                            strokeColor : target.highlightStyle.strokeColor
                        }
                    });
                }
                else {
                    this.zr.modShape(target.id, {
                        hoverable : true,
                        clickable : true,
                        style : {
                            opacity : 0.8
                        }
                    });
                }
            },

            __onDataView : function () {
                this._dataView.show(this.option);
                return true;
            },

            __onRestore : function (){
                this._resetMark();
                this._resetZoom();
                this.messageCenter.dispatch(ecConfig.EVENT.RESTORE, null, null, this.myChart);
                return true;
            },

            __onSaveAsImage : function () {
                var saveOption = this.option.toolbox.feature.saveAsImage;
                var imgType = saveOption.type || &#x27;png&#x27;;
                if (imgType != &#x27;png&#x27; &amp;&amp; imgType != &#x27;jpeg&#x27;) {
                    imgType = &#x27;png&#x27;;
                }

                var image;
                if (!this.myChart.isConnected()) {
                    image = this.zr.toDataURL(
                            &#x27;image/&#x27; + imgType,
                            this.option.backgroundColor
                            &amp;&amp; this.option.backgroundColor.replace(&#x27; &#x27;,&#x27;&#x27;) == &#x27;rgba(0,0,0,0)&#x27;
                            ? &#x27;#fff&#x27; : this.option.backgroundColor
                    );
                }
                else {
                    image = this.myChart.getConnectedDataURL(imgType);
                }

                var downloadDiv = document.createElement(&#x27;div&#x27;);
                downloadDiv.id = &#x27;__echarts_download_wrap__&#x27;;
                downloadDiv.style.cssText = &#x27;position:fixed;&#x27;
                    + &#x27;z-index:99999;&#x27;
                    + &#x27;display:block;&#x27;
                    + &#x27;top:0;left:0;&#x27;
                    + &#x27;background-color:rgba(33,33,33,0.5);&#x27;
                    + &#x27;text-align:center;&#x27;
                    + &#x27;width:100%;&#x27;
                    + &#x27;height:100%;&#x27;
                    + &#x27;line-height:&#x27;
                    + document.documentElement.clientHeight + &#x27;px;&#x27;;

                var downloadLink = document.createElement(&#x27;a&#x27;);
                //downloadLink.onclick = _saveImageForIE;
                downloadLink.href = image;
                downloadLink.setAttribute(
                    &#x27;download&#x27;,
                        (saveOption.name
                            ? saveOption.name
                            : (this.option.title &amp;&amp; (this.option.title.text || this.option.title.subtext))
                            ? (this.option.title.text || this.option.title.subtext)
                            : &#x27;ECharts&#x27;)
                        + &#x27;.&#x27; + imgType
                );
                downloadLink.innerHTML = &#x27;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;&#x27; + image
                    + &#x27;&quot; title=&quot;&#x27;
                    + (!!(window.attachEvent
                        &amp;&amp; navigator.userAgent.indexOf(&#x27;Opera&#x27;) === -1)
                        ? &#x27;右键-&gt;图片另存为&#x27;
                        : (saveOption.lang ? saveOption.lang[0] : &#x27;点击保存&#x27;))
                    + &#x27;&quot;/&gt;&#x27;;

                downloadDiv.appendChild(downloadLink);
                document.body.appendChild(downloadDiv);
                downloadLink = null;
                downloadDiv = null;

                setTimeout(function (){
                    var _d = document.getElementById(&#x27;__echarts_download_wrap__&#x27;);
                    if (_d) {
                        _d.onclick = function () {
                            var d = document.getElementById(
                                &#x27;__echarts_download_wrap__&#x27;
                            );
                            d.onclick = null;
                            d.innerHTML = &#x27;&#x27;;
                            document.body.removeChild(d);
                            d = null;
                        };
                        _d = null;
                    }
                }, 500);

                /*
                 function _saveImageForIE() {
                 window.win = window.open(image);
                 win.document.execCommand(&quot;SaveAs&quot;);
                 win.close()
                 }
                 */
                return;
            },

            __onMagicType : function (param) {
                this._resetMark();
                var itemName = param.target._name;
                if (!this._magicType[itemName]) {
                    // 启用
                    this._magicType[itemName] = true;
                    // 折柱互斥
                    if (itemName == ecConfig.CHART_TYPE_LINE) {
                        this._magicType[ecConfig.CHART_TYPE_BAR] = false;
                    }
                    else if (itemName == ecConfig.CHART_TYPE_BAR) {
                        this._magicType[ecConfig.CHART_TYPE_LINE] = false;
                    }
                    // 堆积平铺互斥
                    if (itemName == _MAGICTYPE_STACK) {
                        this._magicType[_MAGICTYPE_TILED] = false;
                    }
                    else if (itemName == _MAGICTYPE_TILED) {
                        this._magicType[_MAGICTYPE_STACK] = false;
                    }
                    this.messageCenter.dispatch(
                        ecConfig.EVENT.MAGIC_TYPE_CHANGED,
                        param.event,
                        {magicType : this._magicType},
                        this.myChart
                    );
                }

                return true;
            },

            setMagicType : function (magicType) {
                this._resetMark();
                this._magicType = magicType;

                !this._isSilence &amp;&amp; this.messageCenter.dispatch(
                    ecConfig.EVENT.MAGIC_TYPE_CHANGED,
                    null,
                    {magicType : this._magicType},
                    this.myChart
                );
            },

            // 用户自定义扩展toolbox方法
            __onCustomHandler : function (param) {
                var target = param.target.style.iconType;
                var featureHandler = this.option.toolbox.feature[target].onclick;
                if (typeof featureHandler === &#x27;function&#x27;) {
                    featureHandler(this.option);
                }
            },

            // 重置备份还原状态等
            reset : function (newOption, isRestore) {
                isRestore &amp;&amp; this.clear();

                if (this.query(newOption, &#x27;toolbox.show&#x27;)
                    &amp;&amp; this.query(newOption, &#x27;toolbox.feature.magicType.show&#x27;)
                    ) {
                    var magicType = newOption.toolbox.feature.magicType.type;
                    var len = magicType.length;
                    this._magicMap = {};     // 标识可控类型
                    while (len--) {
                        this._magicMap[magicType[len]] = true;
                    }

                    len = newOption.series.length;
                    var oriType;        // 备份还原可控类型
                    var axis;
                    while (len--) {
                        oriType = newOption.series[len].type;
                        if (this._magicMap[oriType]) {
                            axis = newOption.xAxis instanceof Array
                                ? newOption.xAxis[newOption.series[len].xAxisIndex || 0]
                                : newOption.xAxis;
                            if (axis &amp;&amp; (axis.type || &#x27;category&#x27;) == &#x27;category&#x27;) {
                                axis.__boundaryGap = typeof axis.boundaryGap != &#x27;undefined&#x27;
                                    ? axis.boundaryGap : true;
                            }
                            axis = newOption.yAxis instanceof Array
                                ? newOption.yAxis[newOption.series[len].yAxisIndex || 0]
                                : newOption.yAxis;
                            if (axis &amp;&amp; axis.type == &#x27;category&#x27;) {
                                axis.__boundaryGap = typeof axis.boundaryGap != &#x27;undefined&#x27;
                                    ? axis.boundaryGap : true;
                            }
                            newOption.series[len].__type = oriType;
                            // 避免不同类型图表类型的样式污染
                            newOption.series[len].__itemStyle = zrUtil.clone(
                                    newOption.series[len].itemStyle || {}
                            );
                        }

                        if (this._magicMap[_MAGICTYPE_STACK] || this._magicMap[_MAGICTYPE_TILED]) {
                            newOption.series[len].__stack = newOption.series[len].stack;
                        }
                    }
                }

                this._magicType = isRestore ? {} : (this._magicType || {});
                for (var itemName in this._magicType) {
                    if (this._magicType[itemName]) {
                        this.option = newOption;
                        this.getMagicOption();
                        break;
                    }
                }

                // 框选缩放
                var zoomOption = newOption.dataZoom;
                if (zoomOption &amp;&amp; zoomOption.show) {
                    var start = typeof zoomOption.start != &#x27;undefined&#x27;
                        &amp;&amp; zoomOption.start &gt;= 0
                        &amp;&amp; zoomOption.start &lt;= 100
                        ? zoomOption.start : 0;
                    var end = typeof zoomOption.end != &#x27;undefined&#x27;
                        &amp;&amp; zoomOption.end &gt;= 0
                        &amp;&amp; zoomOption.end &lt;= 100
                        ? zoomOption.end : 100;
                    if (start &gt; end) {
                        // 大小颠倒自动翻转
                        start = start + end;
                        end = start - end;
                        start = start - end;
                    }
                    this._zoomQueue = [{
                        start : start,
                        end : end,
                        start2 : 0,
                        end2 : 100
                    }];
                }
                else {
                    this._zoomQueue = [];
                }
            },

            getMagicOption : function (){
                var axis;
                if (this._magicType[ecConfig.CHART_TYPE_LINE]
                    || this._magicType[ecConfig.CHART_TYPE_BAR]
                    ) {
                    // 图表类型有切换
                    var boundaryGap = this._magicType[ecConfig.CHART_TYPE_LINE] ? false : true;
                    for (var i = 0, l = this.option.series.length; i &lt; l; i++) {
                        if (this._magicMap[this.option.series[i].type]) {
                            this.option.series[i].type = this._magicType[ecConfig.CHART_TYPE_LINE]
                                ? ecConfig.CHART_TYPE_LINE
                                : ecConfig.CHART_TYPE_BAR;
                            // 避免不同类型图表类型的样式污染
                            this.option.series[i].itemStyle = zrUtil.clone(
                                this.option.series[i].__itemStyle
                            );

                            axis = this.option.xAxis instanceof Array
                                ? this.option.xAxis[this.option.series[i].xAxisIndex || 0]
                                : this.option.xAxis;
                            if (axis &amp;&amp; (axis.type || &#x27;category&#x27;) == &#x27;category&#x27;) {
                                axis.boundaryGap = boundaryGap ? true : axis.__boundaryGap;
                            }
                            axis = this.option.yAxis instanceof Array
                                ? this.option.yAxis[this.option.series[i].yAxisIndex || 0]
                                : this.option.yAxis;
                            if (axis &amp;&amp; axis.type == &#x27;category&#x27;) {
                                axis.boundaryGap = boundaryGap ? true : axis.__boundaryGap;
                            }
                        }
                    }
                }

                if (this._magicType[_MAGICTYPE_STACK] || this._magicType[_MAGICTYPE_TILED]) {
                    // 有堆积平铺切换
                    for (var i = 0, l = this.option.series.length; i &lt; l; i++) {
                        if (this._magicType[_MAGICTYPE_STACK]) {
                            // 启用堆积
                            this.option.series[i].stack = &#x27;_ECHARTS_STACK_KENER_2014_&#x27;;
                        }
                        else if (this._magicType[_MAGICTYPE_TILED]) {
                            // 启用平铺
                            this.option.series[i].stack = null;
                        }
                    }
                }

                return this.option;
            },

            silence : function (s) {
                this._isSilence = s;
            },

            resize : function () {
                this._resetMark();
                this.clear();
                if (this.option &amp;&amp; this.option.toolbox &amp;&amp; this.option.toolbox.show) {
                    this._buildShape();
                }
                if (this._dataView) {
                    this._dataView.resize();
                }
            },

            hideDataView : function () {
                if (this._dataView) {
                    this._dataView.hide();
                }
            },

            clear : function(notMark) {
                if (this.zr) {
                    this.zr.delShape(this.shapeList);
                    this.shapeList = [];

                    if (!notMark) {
                        this.zr.delShape(this._markShapeList);
                        this._markShapeList = [];
                    }
                }
            },

            /**
             * 释放后实例不可用
             */
            dispose : function () {
                if (this._dataView) {
                    this._dataView.dispose();
                    this._dataView = null;
                }
                this.clear();
                this.shapeList = null;
                this._markShapeList = null;
            },

            /**
             * 刷新
             */
            refresh : function (newOption) {
                if (newOption) {
                    this._resetMark();
                    this._resetZoom();

                    newOption.toolbox = this.reformOption(newOption.toolbox);
                    // 补全padding属性
                    newOption.toolbox.padding = this.reformCssArray(
                        newOption.toolbox.padding
                    );
                    this.option = newOption;

                    this.clear(true);

                    if (newOption.toolbox.show) {
                        this._buildShape();
                    }

                    this.hideDataView();
                }
            }
        };

        zrUtil.inherits(Toolbox, Base);

        require(&#x27;../component&#x27;).define(&#x27;toolbox&#x27;, Toolbox);

        return Toolbox;
    });

    /**
     * echarts组件：图表标题
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/component/title&#x27;,[&#x27;require&#x27;,&#x27;./base&#x27;,&#x27;zrender/shape/Text&#x27;,&#x27;zrender/shape/Rectangle&#x27;,&#x27;../config&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/tool/area&#x27;,&#x27;zrender/tool/color&#x27;,&#x27;../component&#x27;],function (require) {
        var Base = require(&#x27;./base&#x27;);

        // 图形依赖
        var TextShape = require(&#x27;zrender/shape/Text&#x27;);
        var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);

        var ecConfig = require(&#x27;../config&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);
        var zrArea = require(&#x27;zrender/tool/area&#x27;);
        var zrColor = require(&#x27;zrender/tool/color&#x27;);

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 图表参数
         */
        function Title(ecTheme, messageCenter, zr, option, myChart) {
            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            this.refresh(option);
        }

        Title.prototype = {
            type : ecConfig.COMPONENT_TYPE_TITLE,
            _buildShape : function () {
                // 标题元素组的位置参数，通过计算所得x, y, width, height
                this._itemGroupLocation = this._getItemGroupLocation();

                this._buildBackground();
                this._buildItem();

                for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                    this.zr.addShape(this.shapeList[i]);
                }
            },

            /**
             * 构建所有标题元素
             */
            _buildItem : function () {
                var text = this.titleOption.text;
                var link = this.titleOption.link;
                var target = this.titleOption.target;
                var subtext = this.titleOption.subtext;
                var sublink = this.titleOption.sublink;
                var subtarget = this.titleOption.subtarget;
                var font = this.getFont(this.titleOption.textStyle);
                var subfont = this.getFont(this.titleOption.subtextStyle);

                var x = this._itemGroupLocation.x;
                var y = this._itemGroupLocation.y;
                var width = this._itemGroupLocation.width;
                var height = this._itemGroupLocation.height;

                var textShape = {
                    zlevel : this._zlevelBase,
                    style : {
                        y : y,
                        color : this.titleOption.textStyle.color,
                        text: text,
                        textFont: font,
                        textBaseline: &#x27;top&#x27;
                    },
                    highlightStyle: {
                        color : zrColor.lift(this.titleOption.textStyle.color, 1),
                        brushType: &#x27;fill&#x27;
                    },
                    hoverable: false
                };
                if (link) {
                    textShape.hoverable = true;
                    textShape.clickable = true;
                    textShape.onclick = function (){
                        if (!target || target != &#x27;self&#x27;) {
                            window.open(link);
                        }
                        else {
                            window.location = link;
                        }
                    };
                }

                var subtextShape = {
                    zlevel : this._zlevelBase,
                    style : {
                        y : y + height,
                        color : this.titleOption.subtextStyle.color,
                        text: subtext,
                        textFont: subfont,
                        textBaseline: &#x27;bottom&#x27;
                    },
                    highlightStyle: {
                        color : zrColor.lift(this.titleOption.subtextStyle.color, 1),
                        brushType: &#x27;fill&#x27;
                    },
                    hoverable: false
                };
                if (sublink) {
                    subtextShape.hoverable = true;
                    subtextShape.clickable = true;
                    subtextShape.onclick = function (){
                        if (!subtarget || subtarget != &#x27;self&#x27;) {
                            window.open(sublink);
                        }
                        else {
                            window.location = sublink;
                        }
                    };
                }

                switch (this.titleOption.x) {
                    case &#x27;center&#x27; :
                        textShape.style.x = subtextShape.style.x = x + width / 2;
                        textShape.style.textAlign = subtextShape.style.textAlign
                            = &#x27;center&#x27;;
                        break;
                    case &#x27;left&#x27; :
                        textShape.style.x = subtextShape.style.x = x;
                        textShape.style.textAlign = subtextShape.style.textAlign
                            = &#x27;left&#x27;;
                        break;
                    case &#x27;right&#x27; :
                        textShape.style.x = subtextShape.style.x = x + width;
                        textShape.style.textAlign = subtextShape.style.textAlign
                            = &#x27;right&#x27;;
                        break;
                    default :
                        x = this.titleOption.x - 0;
                        x = isNaN(x) ? 0 : x;
                        textShape.style.x = subtextShape.style.x = x;
                        break;
                }

                if (this.titleOption.textAlign) {
                    textShape.style.textAlign = subtextShape.style.textAlign
                        = this.titleOption.textAlign;
                }

                this.shapeList.push(new TextShape(textShape));
                subtext !== &#x27;&#x27; &amp;&amp; this.shapeList.push(new TextShape(subtextShape));
            },

            _buildBackground : function () {
                var pTop = this.titleOption.padding[0];
                var pRight = this.titleOption.padding[1];
                var pBottom = this.titleOption.padding[2];
                var pLeft = this.titleOption.padding[3];

                this.shapeList.push(new RectangleShape({
                    zlevel : this._zlevelBase,
                    hoverable :false,
                    style : {
                        x : this._itemGroupLocation.x - pLeft,
                        y : this._itemGroupLocation.y - pTop,
                        width : this._itemGroupLocation.width + pLeft + pRight,
                        height : this._itemGroupLocation.height + pTop + pBottom,
                        brushType : this.titleOption.borderWidth === 0
                            ? &#x27;fill&#x27; : &#x27;both&#x27;,
                        color : this.titleOption.backgroundColor,
                        strokeColor : this.titleOption.borderColor,
                        lineWidth : this.titleOption.borderWidth
                    }
                }));
            },

            /**
             * 根据选项计算标题实体的位置坐标
             */
            _getItemGroupLocation : function () {
                var text = this.titleOption.text;
                var subtext = this.titleOption.subtext;
                var font = this.getFont(this.titleOption.textStyle);
                var subfont = this.getFont(this.titleOption.subtextStyle);

                var totalWidth = Math.max(
                    zrArea.getTextWidth(text, font),
                    zrArea.getTextWidth(subtext, subfont)
                );
                var totalHeight = zrArea.getTextHeight(text, font)
                    + (subtext === &#x27;&#x27;
                        ? 0
                        : (this.titleOption.itemGap
                        + zrArea.getTextHeight(subtext, subfont))
                        );

                var x;
                var zrWidth = this.zr.getWidth();
                switch (this.titleOption.x) {
                    case &#x27;center&#x27; :
                        x = Math.floor((zrWidth - totalWidth) / 2);
                        break;
                    case &#x27;left&#x27; :
                        x = this.titleOption.padding[3] + this.titleOption.borderWidth;
                        break;
                    case &#x27;right&#x27; :
                        x = zrWidth
                            - totalWidth
                            - this.titleOption.padding[1]
                            - this.titleOption.borderWidth;
                        break;
                    default :
                        x = this.titleOption.x - 0;
                        x = isNaN(x) ? 0 : x;
                        break;
                }

                var y;
                var zrHeight = this.zr.getHeight();
                switch (this.titleOption.y) {
                    case &#x27;top&#x27; :
                        y = this.titleOption.padding[0] + this.titleOption.borderWidth;
                        break;
                    case &#x27;bottom&#x27; :
                        y = zrHeight
                            - totalHeight
                            - this.titleOption.padding[2]
                            - this.titleOption.borderWidth;
                        break;
                    case &#x27;center&#x27; :
                        y = Math.floor((zrHeight - totalHeight) / 2);
                        break;
                    default :
                        y = this.titleOption.y - 0;
                        y = isNaN(y) ? 0 : y;
                        break;
                }

                return {
                    x : x,
                    y : y,
                    width : totalWidth,
                    height : totalHeight
                };
            },

            /**
             * 刷新
             */
            refresh : function (newOption) {
                if (newOption) {
                    this.option = newOption;

                    this.option.title = this.reformOption(this.option.title);
                    // 补全padding属性
                    this.option.title.padding = this.reformCssArray(
                        this.option.title.padding
                    );

                    this.titleOption = this.option.title;
                    this.titleOption.textStyle = zrUtil.merge(
                        this.titleOption.textStyle,
                        this.ecTheme.textStyle
                    );
                    this.titleOption.subtextStyle = zrUtil.merge(
                        this.titleOption.subtextStyle,
                        this.ecTheme.textStyle
                    );
                }

                this.clear();
                this._buildShape();
            }
        };

        zrUtil.inherits(Title, Base);

        require(&#x27;../component&#x27;).define(&#x27;title&#x27;, Title);

        return Title;
    });



    /**
     * zrender
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：十字准星
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;cross&#x27;,       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           rect      : {Object},  // 必须，对角框
           x         : {number},  // 必须，横坐标
           y         : {number},  // 必须，纵坐标
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     */
    define(&#x27;echarts/util/shape/Cross&#x27;,[&#x27;require&#x27;,&#x27;zrender/shape/Base&#x27;,&#x27;zrender/shape/Line&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;./normalIsCover&#x27;],function (require) {
        var Base = require(&#x27;zrender/shape/Base&#x27;);
        var LineShape = require(&#x27;zrender/shape/Line&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);

        function Cross(options) {
            Base.call(this, options);
        }

        Cross.prototype =  {
            type : &#x27;cross&#x27;,

            /**
             * 创建矩形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath : function (ctx, style) {
                var rect = style.rect;
                style.xStart = rect.x;
                style.xEnd = rect.x + rect.width;
                style.yStart = style.yEnd = style.y;
                LineShape.prototype.buildPath(ctx, style);
                style.xStart = style.xEnd = style.x;
                style.yStart = rect.y;
                style.yEnd = rect.y + rect.height;
                LineShape.prototype.buildPath(ctx, style);
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect : function (style) {
                return style.rect;
            },

            isCover : require(&#x27;./normalIsCover&#x27;)
        };

        zrUtil.inherits(Cross, Base);

        return Cross;
    });

    /**
     * echarts组件：提示框
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/component/tooltip&#x27;,[&#x27;require&#x27;,&#x27;./base&#x27;,&#x27;../util/shape/Cross&#x27;,&#x27;zrender/shape/Line&#x27;,&#x27;zrender/shape/Rectangle&#x27;,&#x27;../config&#x27;,&#x27;../util/ecData&#x27;,&#x27;zrender/config&#x27;,&#x27;zrender/tool/event&#x27;,&#x27;zrender/tool/area&#x27;,&#x27;zrender/tool/color&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/shape/Base&#x27;,&#x27;../component&#x27;],function (require) {
        var Base = require(&#x27;./base&#x27;);

        // 图形依赖
        var CrossShape = require(&#x27;../util/shape/Cross&#x27;);
        var LineShape = require(&#x27;zrender/shape/Line&#x27;);
        var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
        var rectangleInstance = new RectangleShape({});

        var ecConfig = require(&#x27;../config&#x27;);
        var ecData = require(&#x27;../util/ecData&#x27;);
        var zrConfig = require(&#x27;zrender/config&#x27;);
        var zrEvent = require(&#x27;zrender/tool/event&#x27;);
        var zrArea = require(&#x27;zrender/tool/area&#x27;);
        var zrColor = require(&#x27;zrender/tool/color&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);
        var zrShapeBase = require(&#x27;zrender/shape/Base&#x27;);

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 提示框参数
         * @param {HtmlElement} dom 目标对象
         * @param {ECharts} myChart 当前图表实例
         */
        function Tooltip(ecTheme, messageCenter, zr, option, myChart) {
            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            this.dom = myChart.dom;

            var self = this;
            self._onmousemove = function (param) {
                return self.__onmousemove(param);
            };
            self._onglobalout = function (param) {
                return self.__onglobalout(param);
            };

            this.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
            this.zr.on(zrConfig.EVENT.GLOBALOUT, self._onglobalout);

            self._hide = function (param) {
                return self.__hide(param);
            };
            self._tryShow = function(param) {
                return self.__tryShow(param);
            };
            self._refixed = function(param) {
                return self.__refixed(param);
            };

            self._setContent = function(ticket, res) {
                return self.__setContent(ticket, res);
            };

            this._tDom = this._tDom || document.createElement(&#x27;div&#x27;);
            // 避免拖拽时页面选中的尴尬
            this._tDom.onselectstart = function() {
                return false;
            };
            this._tDom.style.position = &#x27;absolute&#x27;;  // 不是多余的，别删！
            this.hasAppend = false;

            this._axisLineShape &amp;&amp; this.zr.delShape(this._axisLineShape.id);
            this._axisLineShape = new LineShape({
                zlevel: this._zlevelBase,
                invisible : true,
                hoverable: false
            });
            this.shapeList.push(this._axisLineShape);
            this.zr.addShape(this._axisLineShape);

            this._axisShadowShape &amp;&amp; this.zr.delShape(this._axisShadowShape.id);
            this._axisShadowShape = new LineShape({
                zlevel: 1,                      // grid上，chart下
                invisible : true,
                hoverable: false
            });
            this.shapeList.push(this._axisShadowShape);
            this.zr.addShape(this._axisShadowShape);

            this._axisCrossShape &amp;&amp; this.zr.delShape(this._axisCrossShape.id);
            this._axisCrossShape = new CrossShape({
                zlevel: this._zlevelBase,
                invisible : true,
                hoverable: false
            });
            this.shapeList.push(this._axisCrossShape);
            this.zr.addShape(this._axisCrossShape);

            this.showing = false;
            this.refresh(option);
        }

        Tooltip.prototype = {
            type : ecConfig.COMPONENT_TYPE_TOOLTIP,
            // 通用样式
            _gCssText : &#x27;position:absolute;&#x27;
                + &#x27;display:block;&#x27;
                + &#x27;border-style:solid;&#x27;
                + &#x27;white-space:nowrap;&#x27;,
            /**
             * 根据配置设置dom样式
             */
            _style : function (opt) {
                if (!opt) {
                    return &#x27;&#x27;;
                }
                var cssText = [];
                if (opt.transitionDuration) {
                    var transitionText = &#x27;left &#x27; + opt.transitionDuration + &#x27;s,&#x27;
                        + &#x27;top &#x27; + opt.transitionDuration + &#x27;s&#x27;;
                    cssText.push(
                            &#x27;transition:&#x27; + transitionText
                    );
                    cssText.push(
                            &#x27;-moz-transition:&#x27; + transitionText
                    );
                    cssText.push(
                            &#x27;-webkit-transition:&#x27; + transitionText
                    );
                    cssText.push(
                            &#x27;-o-transition:&#x27; + transitionText
                    );
                }

                if (opt.backgroundColor) {
                    // for sb ie~
                    cssText.push(
                            &#x27;background-Color:&#x27; + zrColor.toHex(
                            opt.backgroundColor
                        )
                    );
                    cssText.push(&#x27;filter:alpha(opacity=70)&#x27;);
                    cssText.push(&#x27;background-Color:&#x27; + opt.backgroundColor);
                }

                if (typeof opt.borderWidth != &#x27;undefined&#x27;) {
                    cssText.push(&#x27;border-width:&#x27; + opt.borderWidth + &#x27;px&#x27;);
                }

                if (typeof opt.borderColor != &#x27;undefined&#x27;) {
                    cssText.push(&#x27;border-color:&#x27; + opt.borderColor);
                }

                if (typeof opt.borderRadius != &#x27;undefined&#x27;) {
                    cssText.push(
                            &#x27;border-radius:&#x27; + opt.borderRadius + &#x27;px&#x27;
                    );
                    cssText.push(
                            &#x27;-moz-border-radius:&#x27; + opt.borderRadius + &#x27;px&#x27;
                    );
                    cssText.push(
                            &#x27;-webkit-border-radius:&#x27; + opt.borderRadius + &#x27;px&#x27;
                    );
                    cssText.push(
                            &#x27;-o-border-radius:&#x27; + opt.borderRadius + &#x27;px&#x27;
                    );
                }

                var textStyle = opt.textStyle;
                if (textStyle) {
                    textStyle.color &amp;&amp; cssText.push(&#x27;color:&#x27; + textStyle.color);
                    textStyle.decoration &amp;&amp; cssText.push(
                            &#x27;text-decoration:&#x27; + textStyle.decoration
                    );
                    textStyle.align &amp;&amp; cssText.push(
                            &#x27;text-align:&#x27; + textStyle.align
                    );
                    textStyle.fontFamily &amp;&amp; cssText.push(
                            &#x27;font-family:&#x27; + textStyle.fontFamily
                    );
                    textStyle.fontSize &amp;&amp; cssText.push(
                            &#x27;font-size:&#x27; + textStyle.fontSize + &#x27;px&#x27;
                    );
                    textStyle.fontSize &amp;&amp; cssText.push(
                            &#x27;line-height:&#x27; + Math.round(textStyle.fontSize*3/2) + &#x27;px&#x27;
                    );
                    textStyle.fontStyle &amp;&amp; cssText.push(
                            &#x27;font-style:&#x27; + textStyle.fontStyle
                    );
                    textStyle.fontWeight &amp;&amp; cssText.push(
                            &#x27;font-weight:&#x27; + textStyle.fontWeight
                    );
                }


                var padding = opt.padding;
                if (typeof padding != &#x27;undefined&#x27;) {
                    padding = this.reformCssArray(padding);
                    cssText.push(
                            &#x27;padding:&#x27; + padding[0] + &#x27;px &#x27;
                            + padding[1] + &#x27;px &#x27;
                            + padding[2] + &#x27;px &#x27;
                            + padding[3] + &#x27;px&#x27;
                    );
                }

                cssText = cssText.join(&#x27;;&#x27;) + &#x27;;&#x27;;

                return cssText;
            },

            __hide : function () {
                if (this._tDom) {
                    this._tDom.style.display = &#x27;none&#x27;;
                }
                var needRefresh = false;
                if (!this._axisLineShape.invisible) {
                    this._axisLineShape.invisible = true;
                    this.zr.modShape(this._axisLineShape.id);
                    needRefresh = true;
                }
                if (!this._axisShadowShape.invisible) {
                    this._axisShadowShape.invisible = true;
                    this.zr.modShape(this._axisShadowShape.id);
                    needRefresh = true;
                }
                if (!this._axisCrossShape.invisible) {
                    this._axisCrossShape.invisible = true;
                    this.zr.modShape(this._axisCrossShape.id);
                    needRefresh = true;
                }
                if (this._lastTipShape &amp;&amp; this._lastTipShape.tipShape.length &gt; 0) {
                    this.zr.delShape(this._lastTipShape.tipShape);
                    this._lastTipShape = false;
                    this.shapeList.length = 2;
                }
                needRefresh &amp;&amp; this.zr.refresh();
                this.showing = false;
            },

            _show : function (position, x, y, specialCssText) {
                var domHeight = this._tDom.offsetHeight;
                var domWidth = this._tDom.offsetWidth;
                if (position) {
                    if (typeof position == &#x27;function&#x27;) {
                        position = position([x, y]);
                    }
                    if (position instanceof Array) {
                        x = position[0];
                        y = position[1];
                    }
                }
                if (x + domWidth &gt; this._zrWidth) {
                    // 太靠右
                    //x = this._zrWidth - domWidth;
                    x -= (domWidth + 40);
                }
                if (y + domHeight &gt; this._zrHeight) {
                    // 太靠下
                    //y = this._zrHeight - domHeight;
                    y -= (domHeight - 20);
                }
                if (y &lt; 20) {
                    y = 0;
                }
                this._tDom.style.cssText = this._gCssText
                    + this._defaultCssText
                    + (specialCssText ? specialCssText : &#x27;&#x27;)
                    + &#x27;left:&#x27; + x + &#x27;px;top:&#x27; + y + &#x27;px;&#x27;;

                if (domHeight &lt; 10 || domWidth &lt; 10) {
                    // this._zrWidth - x &lt; 100 || this._zrHeight - y &lt; 100
                    setTimeout(this._refixed, 20);
                }
                this.showing = true;
            },

            __refixed : function () {
                if (this._tDom) {
                    var cssText = &#x27;&#x27;;
                    var domHeight = this._tDom.offsetHeight;
                    var domWidth = this._tDom.offsetWidth;
                    if (this._tDom.offsetLeft + domWidth &gt; this._zrWidth) {
                        cssText += &#x27;left:&#x27; + (this._zrWidth - domWidth - 20) + &#x27;px;&#x27;;
                    }
                    if (this._tDom.offsetTop + domHeight &gt; this._zrHeight) {
                        cssText += &#x27;top:&#x27; + (this._zrHeight - domHeight - 10) + &#x27;px;&#x27;;
                    }
                    if (cssText !== &#x27;&#x27;) {
                        this._tDom.style.cssText += cssText;
                    }
                }
            },

            __tryShow : function () {
                var needShow;
                var trigger;
                if (!this._curTarget) {
                    // 坐标轴事件
                    this._findPolarTrigger() || this._findAxisTrigger();
                }
                else {
                    // 数据项事件
                    if (this._curTarget._type == &#x27;island&#x27; &amp;&amp; this.option.tooltip.show) {
                        this._showItemTrigger();
                        return;
                    }
                    var serie = ecData.get(this._curTarget, &#x27;series&#x27;);
                    var data = ecData.get(this._curTarget, &#x27;data&#x27;);
                    needShow = this.deepQuery(
                        [data, serie, this.option],
                        &#x27;tooltip.show&#x27;
                    );
                    if (typeof serie == &#x27;undefined&#x27;
                        || typeof data == &#x27;undefined&#x27;
                        || needShow === false
                        ) {
                        // 不响应tooltip的数据对象延时隐藏
                        clearTimeout(this._hidingTicket);
                        clearTimeout(this._showingTicket);
                        this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                    }
                    else {
                        trigger = this.deepQuery(
                            [data, serie, this.option],
                            &#x27;tooltip.trigger&#x27;
                        );

                        trigger == &#x27;axis&#x27;
                            ? this._showAxisTrigger(
                            serie.xAxisIndex, serie.yAxisIndex,
                            ecData.get(this._curTarget, &#x27;dataIndex&#x27;)
                        )
                            : this._showItemTrigger();
                    }
                }
            },

            /**
             * 直角系
             */
            _findAxisTrigger : function () {
                if (!this.component.xAxis || !this.component.yAxis) {
                    this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                    return;
                }
                var series = this.option.series;
                var xAxisIndex;
                var yAxisIndex;
                for (var i = 0, l = series.length; i &lt; l; i++) {
                    // 找到第一个axis触发tooltip的系列
                    if (this.deepQuery(
                        [series[i], this.option], &#x27;tooltip.trigger&#x27;
                    ) == &#x27;axis&#x27;
                        ) {
                        xAxisIndex = series[i].xAxisIndex || 0;
                        yAxisIndex = series[i].yAxisIndex || 0;
                        if (this.component.xAxis.getAxis(xAxisIndex)
                            &amp;&amp; this.component.xAxis.getAxis(xAxisIndex).type
                            == ecConfig.COMPONENT_TYPE_AXIS_CATEGORY
                            ) {
                            // 横轴为类目轴
                            this._showAxisTrigger(xAxisIndex, yAxisIndex,
                                this._getNearestDataIndex(
                                    &#x27;x&#x27;, this.component.xAxis.getAxis(xAxisIndex)
                                )
                            );
                            return;
                        }
                        else if (this.component.yAxis.getAxis(yAxisIndex)
                            &amp;&amp; this.component.yAxis.getAxis(yAxisIndex).type
                            == ecConfig.COMPONENT_TYPE_AXIS_CATEGORY
                            ) {
                            // 纵轴为类目轴
                            this._showAxisTrigger(xAxisIndex, yAxisIndex,
                                this._getNearestDataIndex(
                                    &#x27;y&#x27;, this.component.yAxis.getAxis(yAxisIndex)
                                )
                            );
                            return;
                        }
                        else {
                            // 双数值轴
                            this._showAxisTrigger(xAxisIndex, yAxisIndex, -1);
                            return;
                        }
                    }
                }
                if (this.option.tooltip.axisPointer.type == &#x27;cross&#x27;) {
                    this._showAxisTrigger(-1, -1, -1);
                }
            },

            /**
             * 极坐标
             */
            _findPolarTrigger : function () {
                if (!this.component.polar) {
                    return false;
                }
                var x = zrEvent.getX(this._event);
                var y = zrEvent.getY(this._event);
                var polarIndex = this.component.polar.getNearestIndex([x, y]);
                var valueIndex;
                if (polarIndex) {
                    valueIndex = polarIndex.valueIndex;
                    polarIndex = polarIndex.polarIndex;
                }
                else {
                    polarIndex = -1;
                }

                if (polarIndex != -1) {
                    return this._showPolarTrigger(polarIndex, valueIndex);
                }

                return false;
            },

            /**
             * 根据坐标轴事件带的属性获取最近的axisDataIndex
             */
            _getNearestDataIndex : function (direction, categoryAxis) {
                var dataIndex = -1;
                var x = zrEvent.getX(this._event);
                var y = zrEvent.getY(this._event);
                if (direction == &#x27;x&#x27;) {
                    // 横轴为类目轴
                    var left;
                    var right;
                    var xEnd = this.component.grid.getXend();
                    var curCoord = categoryAxis.getCoordByIndex(dataIndex);
                    while (curCoord &lt; xEnd) {
                        if (curCoord &lt;= x) {
                            left = curCoord;
                        }
                        if (curCoord &gt;= x) {
                            break;
                        }
                        curCoord = categoryAxis.getCoordByIndex(++dataIndex);
                        right = curCoord;
                    }
                    if (x - left &lt; right - x) {
                        dataIndex -= dataIndex !== 0 ? 1 : 0;
                    }
                    else {
                        // 离右边近，看是否为最后一个
                        if (typeof categoryAxis.getNameByIndex(dataIndex)
                            == &#x27;undefined&#x27;
                            ) {
                            dataIndex -= 1;
                        }
                    }
                    return dataIndex;
                }
                else {
                    // 纵轴为类目轴
                    var top;
                    var bottom;
                    var yStart = this.component.grid.getY();
                    var curCoord = categoryAxis.getCoordByIndex(dataIndex);
                    while (curCoord &gt; yStart) {
                        if (curCoord &gt;= y) {
                            bottom = curCoord;
                        }
                        if (curCoord &lt;= y) {
                            break;
                        }
                        curCoord = categoryAxis.getCoordByIndex(++dataIndex);
                        top = curCoord;
                    }

                    if (y - top &gt; bottom - y) {
                        dataIndex -= dataIndex !== 0 ? 1 : 0;
                    }
                    else {
                        // 离上方边近，看是否为最后一个
                        if (typeof categoryAxis.getNameByIndex(dataIndex)
                            == &#x27;undefined&#x27;
                            ) {
                            dataIndex -= 1;
                        }
                    }
                    return dataIndex;
                }
                return -1;
            },

            /**
             * 直角系
             */
            _showAxisTrigger : function (xAxisIndex, yAxisIndex, dataIndex) {
                !this._event.connectTrigger &amp;&amp; this.messageCenter.dispatch(
                    ecConfig.EVENT.TOOLTIP_IN_GRID,
                    this._event,
                    null,
                    this.myChart
                );
                if (typeof this.component.xAxis == &#x27;undefined&#x27;
                    || typeof this.component.yAxis == &#x27;undefined&#x27;
                    || typeof xAxisIndex == &#x27;undefined&#x27;
                    || typeof yAxisIndex == &#x27;undefined&#x27;
                // || dataIndex &lt; 0
                    ) {
                    // 不响应tooltip的数据对象延时隐藏
                    clearTimeout(this._hidingTicket);
                    clearTimeout(this._showingTicket);
                    this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                    return;
                }
                var series = this.option.series;
                var seriesArray = [];
                var seriesIndex = [];
                var categoryAxis;
                var x;
                var y;

                var formatter;
                var position;
                var showContent;
                var specialCssText = &#x27;&#x27;;
                if (this.option.tooltip.trigger == &#x27;axis&#x27;) {
                    if (this.option.tooltip.show === false) {
                        return;
                    }
                    formatter = this.option.tooltip.formatter;
                    position = this.option.tooltip.position;
                }

                if (xAxisIndex != -1
                    &amp;&amp; this.component.xAxis.getAxis(xAxisIndex).type
                    == ecConfig.COMPONENT_TYPE_AXIS_CATEGORY
                    ) {
                    // 横轴为类目轴，找到所有用这条横轴并且axis触发的系列数据
                    categoryAxis = this.component.xAxis.getAxis(xAxisIndex);
                    for (var i = 0, l = series.length; i &lt; l; i++) {
                        if (!this._isSelected(series[i].name)) {
                            continue;
                        }
                        if (series[i].xAxisIndex == xAxisIndex
                            &amp;&amp; this.deepQuery([series[i], this.option], &#x27;tooltip.trigger&#x27;) == &#x27;axis&#x27;
                            ) {
                            showContent = this.query(series[i], &#x27;tooltip.showContent&#x27;)
                                || showContent;
                            formatter = this.query(series[i], &#x27;tooltip.formatter&#x27;)
                                || formatter;
                            position = this.query(series[i], &#x27;tooltip.position&#x27;)
                                || position;

                            specialCssText += this._style(this.query(series[i], &#x27;tooltip&#x27;));
                            seriesArray.push(series[i]);
                            seriesIndex.push(i);
                        }
                    }
                    // 寻找高亮元素
                    this.messageCenter.dispatch(
                        ecConfig.EVENT.TOOLTIP_HOVER,
                        this._event,
                        {
                            seriesIndex : seriesIndex,
                            dataIndex : dataIndex
                        },
                        this.myChart
                    );
                    y = zrEvent.getY(this._event);
                    x = this.subPixelOptimize(
                        categoryAxis.getCoordByIndex(dataIndex),
                        this._axisLineWidth
                    );
                    this._styleAxisPointer(
                        seriesArray,
                        x, this.component.grid.getY(),
                        x, this.component.grid.getYend(),
                        categoryAxis.getGap(), x, y
                    );
                }
                else if (yAxisIndex != -1
                    &amp;&amp; this.component.yAxis.getAxis(yAxisIndex).type
                    == ecConfig.COMPONENT_TYPE_AXIS_CATEGORY
                    ) {
                    // 纵轴为类目轴，找到所有用这条纵轴并且axis触发的系列数据
                    categoryAxis = this.component.yAxis.getAxis(yAxisIndex);
                    for (var i = 0, l = series.length; i &lt; l; i++) {
                        if (!this._isSelected(series[i].name)) {
                            continue;
                        }
                        if (series[i].yAxisIndex == yAxisIndex
                            &amp;&amp; this.deepQuery([series[i], this.option], &#x27;tooltip.trigger&#x27;) == &#x27;axis&#x27;
                            ) {
                            showContent = this.query(series[i], &#x27;tooltip.showContent&#x27;)
                                || showContent;
                            formatter = this.query(series[i], &#x27;tooltip.formatter&#x27;)
                                || formatter;
                            position = this.query(series[i], &#x27;tooltip.position&#x27;)
                                || position;
                            specialCssText += this._style(this.query(series[i], &#x27;tooltip&#x27;));
                            seriesArray.push(series[i]);
                            seriesIndex.push(i);
                        }
                    }
                    // 寻找高亮元素
                    this.messageCenter.dispatch(
                        ecConfig.EVENT.TOOLTIP_HOVER,
                        this._event,
                        {
                            seriesIndex : seriesIndex,
                            dataIndex : dataIndex
                        },
                        this.myChart
                    );
                    x = zrEvent.getX(this._event);
                    y = this.subPixelOptimize(
                        categoryAxis.getCoordByIndex(dataIndex),
                        this._axisLineWidth
                    );
                    this._styleAxisPointer(
                        seriesArray,
                        this.component.grid.getX(), y,
                        this.component.grid.getXend(), y,
                        categoryAxis.getGap(), x, y
                    );
                }
                else {
                    // 双数值轴
                    x = zrEvent.getX(this._event);
                    y = zrEvent.getY(this._event);
                    this._styleAxisPointer(
                        series,
                        this.component.grid.getX(), y,
                        this.component.grid.getXend(), y,
                        0, x, y
                    );
                    if (dataIndex &gt;= 0) {
                        this._showItemTrigger();
                    }
                    else {
                        clearTimeout(this._hidingTicket);
                        clearTimeout(this._showingTicket);
                        this._tDom.style.display = &#x27;none&#x27;;
                    }
                }

                if (seriesArray.length &gt; 0) {
                    var data;
                    if (typeof formatter == &#x27;function&#x27;) {
                        var params = [];
                        for (var i = 0, l = seriesArray.length; i &lt; l; i++) {
                            data = seriesArray[i].data[dataIndex];
                            data = typeof data != &#x27;undefined&#x27;
                                ? (typeof data.value != &#x27;undefined&#x27;
                                ? data.value
                                : data)
                                : &#x27;-&#x27;;

                            params.push([
                                    seriesArray[i].name || &#x27;&#x27;,
                                categoryAxis.getNameByIndex(dataIndex),
                                data
                            ]);
                        }
                        this._curTicket = &#x27;axis:&#x27; + dataIndex;
                        this._tDom.innerHTML = formatter(
                            params, this._curTicket, this._setContent
                        );
                    }
                    else if (typeof formatter == &#x27;string&#x27;) {
                        this._curTicket = NaN;
                        formatter = formatter.replace(&#x27;{a}&#x27;,&#x27;{a0}&#x27;)
                            .replace(&#x27;{b}&#x27;,&#x27;{b0}&#x27;)
                            .replace(&#x27;{c}&#x27;,&#x27;{c0}&#x27;);
                        for (var i = 0, l = seriesArray.length; i &lt; l; i++) {
                            formatter = formatter.replace(
                                    &#x27;{a&#x27; + i + &#x27;}&#x27;,
                                this._encodeHTML(seriesArray[i].name || &#x27;&#x27;)
                            );
                            formatter = formatter.replace(
                                    &#x27;{b&#x27; + i + &#x27;}&#x27;,
                                this._encodeHTML(categoryAxis.getNameByIndex(dataIndex))
                            );
                            data = seriesArray[i].data[dataIndex];
                            data = typeof data != &#x27;undefined&#x27;
                                ? (typeof data.value != &#x27;undefined&#x27;
                                ? data.value
                                : data)
                                : &#x27;-&#x27;;
                            formatter = formatter.replace(
                                    &#x27;{c&#x27; + i + &#x27;}&#x27;,
                                    data instanceof Array
                                    ? data : this.numAddCommas(data)
                            );
                        }
                        this._tDom.innerHTML = formatter;
                    }
                    else {
                        this._curTicket = NaN;
                        formatter = this._encodeHTML(
                            categoryAxis.getNameByIndex(dataIndex)
                        );

                        for (var i = 0, l = seriesArray.length; i &lt; l; i++) {
                            formatter += &#x27;&lt;br/&gt;&#x27;
                                + this._encodeHTML(seriesArray[i].name || &#x27;&#x27;)
                                + &#x27; : &#x27;;
                            data = seriesArray[i].data[dataIndex];
                            data = typeof data != &#x27;undefined&#x27;
                                ? (typeof data.value != &#x27;undefined&#x27;
                                ? data.value
                                : data)
                                : &#x27;-&#x27;;
                            formatter += data instanceof Array
                                ? data : this.numAddCommas(data);
                        }
                        this._tDom.innerHTML = formatter;
                    }

                    if (showContent === false || !this.option.tooltip.showContent) {
                        // 只用tooltip的行为，不显示主体
                        return;
                    }

                    if (!this.hasAppend) {
                        this._tDom.style.left = this._zrWidth / 2 + &#x27;px&#x27;;
                        this._tDom.style.top = this._zrHeight / 2 + &#x27;px&#x27;;
                        this.dom.firstChild.appendChild(this._tDom);
                        this.hasAppend = true;
                    }
                    this._show(position, x + 10, y + 10, specialCssText);
                }
            },

            /**
             * 极坐标
             */
            _showPolarTrigger : function (polarIndex, dataIndex) {
                if (typeof this.component.polar == &#x27;undefined&#x27;
                    || typeof polarIndex == &#x27;undefined&#x27;
                    || typeof dataIndex == &#x27;undefined&#x27;
                    || dataIndex &lt; 0
                    ) {
                    return false;
                }
                var series = this.option.series;
                var seriesArray = [];

                var formatter;
                var position;
                var showContent;
                var specialCssText = &#x27;&#x27;;
                if (this.option.tooltip.trigger == &#x27;axis&#x27;) {
                    if (this.option.tooltip.show === false) {
                        return false;
                    }
                    formatter = this.option.tooltip.formatter;
                    position = this.option.tooltip.position;
                }
                var indicatorName = this.option.polar[polarIndex].indicator[dataIndex].text;

                // 找到所有用这个极坐标并且axis触发的系列数据
                for (var i = 0, l = series.length; i &lt; l; i++) {
                    if (!this._isSelected(series[i].name)) {
                        continue;
                    }
                    if (series[i].polarIndex == polarIndex
                        &amp;&amp; this.deepQuery([series[i], this.option], &#x27;tooltip.trigger&#x27;) == &#x27;axis&#x27;
                        ) {
                        showContent = this.query(series[i], &#x27;tooltip.showContent&#x27;)
                            || showContent;
                        formatter = this.query(series[i], &#x27;tooltip.formatter&#x27;)
                            || formatter;
                        position = this.query(series[i], &#x27;tooltip.position&#x27;)
                            || position;
                        specialCssText += this._style(this.query(series[i], &#x27;tooltip&#x27;));
                        seriesArray.push(series[i]);
                    }
                }
                if (seriesArray.length &gt; 0) {
                    var polarData;
                    var data;
                    var params = [];

                    for (var i = 0, l = seriesArray.length; i &lt; l; i++) {
                        polarData = seriesArray[i].data;
                        for (var j = 0, k = polarData.length; j &lt; k; j++) {
                            data = polarData[j];
                            if (!this._isSelected(data.name)) {
                                continue;
                            }
                            data = typeof data != &#x27;undefined&#x27;
                                ? data
                                : {name:&#x27;&#x27;, value: {dataIndex:&#x27;-&#x27;}};

                            params.push([
                                    seriesArray[i].name || &#x27;&#x27;,
                                data.name,
                                    typeof data.value[dataIndex].value != &#x27;undefined&#x27;
                                    ? data.value[dataIndex].value : data.value[dataIndex],
                                indicatorName
                            ]);
                        }
                    }
                    if (params.length &lt;= 0) {
                        return;
                    }
                    if (typeof formatter == &#x27;function&#x27;) {
                        this._curTicket = &#x27;axis:&#x27; + dataIndex;
                        this._tDom.innerHTML = formatter(
                            params, this._curTicket, this._setContent
                        );
                    }
                    else if (typeof formatter == &#x27;string&#x27;) {
                        formatter = formatter.replace(&#x27;{a}&#x27;,&#x27;{a0}&#x27;)
                            .replace(&#x27;{b}&#x27;,&#x27;{b0}&#x27;)
                            .replace(&#x27;{c}&#x27;,&#x27;{c0}&#x27;)
                            .replace(&#x27;{d}&#x27;,&#x27;{d0}&#x27;);
                        for (var i = 0, l = params.length; i &lt; l; i++) {
                            formatter = formatter.replace(
                                    &#x27;{a&#x27; + i + &#x27;}&#x27;,
                                this._encodeHTML(params[i][0])
                            );
                            formatter = formatter.replace(
                                    &#x27;{b&#x27; + i + &#x27;}&#x27;,
                                this._encodeHTML(params[i][1])
                            );
                            formatter = formatter.replace(
                                    &#x27;{c&#x27; + i + &#x27;}&#x27;,
                                this.numAddCommas(params[i][2])
                            );
                            formatter = formatter.replace(
                                    &#x27;{d&#x27; + i + &#x27;}&#x27;,
                                this._encodeHTML(params[i][3])
                            );
                        }
                        this._tDom.innerHTML = formatter;
                    }
                    else {
                        formatter = this._encodeHTML(params[0][1]) + &#x27;&lt;br/&gt;&#x27;
                            + this._encodeHTML(params[0][3]) + &#x27; : &#x27;
                            + this.numAddCommas(params[0][2]);
                        for (var i = 1, l = params.length; i &lt; l; i++) {
                            formatter += &#x27;&lt;br/&gt;&#x27; + this._encodeHTML(params[i][1])
                                + &#x27;&lt;br/&gt;&#x27;;
                            formatter += this._encodeHTML(params[i][3]) + &#x27; : &#x27;
                                + this.numAddCommas(params[i][2]);
                        }
                        this._tDom.innerHTML = formatter;
                    }

                    if (showContent === false || !this.option.tooltip.showContent) {
                        // 只用tooltip的行为，不显示主体
                        return;
                    }

                    if (!this.hasAppend) {
                        this._tDom.style.left = this._zrWidth / 2 + &#x27;px&#x27;;
                        this._tDom.style.top = this._zrHeight / 2 + &#x27;px&#x27;;
                        this.dom.firstChild.appendChild(this._tDom);
                        this.hasAppend = true;
                    }
                    this._show(
                        position,
                        zrEvent.getX(this._event),
                        zrEvent.getY(this._event),
                        specialCssText
                    );
                    return true;
                }
            },

            _showItemTrigger : function () {
                if (!this._curTarget) {
                    return;
                }
                var serie = ecData.get(this._curTarget, &#x27;series&#x27;);
                var data = ecData.get(this._curTarget, &#x27;data&#x27;);
                var name = ecData.get(this._curTarget, &#x27;name&#x27;);
                var value = ecData.get(this._curTarget, &#x27;value&#x27;);
                var special = ecData.get(this._curTarget, &#x27;special&#x27;);
                var special2 = ecData.get(this._curTarget, &#x27;special2&#x27;);
                // 从低优先级往上找到trigger为item的formatter和样式
                var formatter;
                var position;
                var showContent;
                var specialCssText = &#x27;&#x27;;
                var indicator;
                var html = &#x27;&#x27;;
                if (this._curTarget._type != &#x27;island&#x27;) {
                    // 全局
                    if (this.option.tooltip.trigger == &#x27;item&#x27;) {
                        formatter = this.option.tooltip.formatter;
                        position = this.option.tooltip.position;
                    }
                    // 系列
                    if (this.query(serie, &#x27;tooltip.trigger&#x27;) == &#x27;item&#x27;) {
                        showContent = this.query(serie, &#x27;tooltip.showContent&#x27;)
                            || showContent;
                        formatter = this.query(serie, &#x27;tooltip.formatter&#x27;)
                            || formatter;
                        position = this.query(serie, &#x27;tooltip.position&#x27;)
                            || position;
                        specialCssText += this._style(this.query(serie, &#x27;tooltip&#x27;));
                    }
                    // 数据项
                    showContent = this.query(data, &#x27;tooltip.showContent&#x27;)
                        || showContent;
                    formatter = this.query(data, &#x27;tooltip.formatter&#x27;)
                        || formatter;
                    position = this.query(data, &#x27;tooltip.position&#x27;)
                        || position;
                    specialCssText += this._style(this.query(data, &#x27;tooltip&#x27;));
                }
                else {
                    showContent = this.deepQuery([data, serie, this.option], &#x27;tooltip.showContent&#x27;);
                    formatter = this.deepQuery([data, serie, this.option], &#x27;tooltip.islandFormatter&#x27;);
                    position = this.deepQuery([data, serie, this.option], &#x27;tooltip.islandPosition&#x27;);
                }

                if (typeof formatter == &#x27;function&#x27;) {
                    this._curTicket = (serie.name || &#x27;&#x27;)
                        + &#x27;:&#x27;
                        + ecData.get(this._curTarget, &#x27;dataIndex&#x27;);
                    this._tDom.innerHTML = formatter(
                        [
                                serie.name || &#x27;&#x27;,
                            name,
                            value,
                            special,
                            special2
                        ],
                        this._curTicket,
                        this._setContent
                    );
                }
                else if (typeof formatter == &#x27;string&#x27;) {
                    this._curTicket = NaN;
                    formatter = formatter.replace(&#x27;{a}&#x27;,&#x27;{a0}&#x27;)
                        .replace(&#x27;{b}&#x27;,&#x27;{b0}&#x27;)
                        .replace(&#x27;{c}&#x27;,&#x27;{c0}&#x27;);
                    formatter = formatter.replace(&#x27;{a0}&#x27;, this._encodeHTML(serie.name || &#x27;&#x27;))
                        .replace(&#x27;{b0}&#x27;, this._encodeHTML(name))
                        .replace(
                        &#x27;{c0}&#x27;,
                            value instanceof Array ? value : this.numAddCommas(value)
                    );

                    formatter = formatter.replace(&#x27;{d}&#x27;,&#x27;{d0}&#x27;)
                        .replace(&#x27;{d0}&#x27;, special || &#x27;&#x27;);
                    formatter = formatter.replace(&#x27;{e}&#x27;,&#x27;{e0}&#x27;)
                        .replace(&#x27;{e0}&#x27;, ecData.get(this._curTarget, &#x27;special2&#x27;) || &#x27;&#x27;);

                    this._tDom.innerHTML = formatter;
                }
                else {
                    this._curTicket = NaN;
                    if (serie.type == ecConfig.CHART_TYPE_SCATTER) {
                        this._tDom.innerHTML = (typeof serie.name != &#x27;undefined&#x27;
                            ? (this._encodeHTML(serie.name) + &#x27;&lt;br/&gt;&#x27;)
                            : &#x27;&#x27;
                            )
                            + (name === &#x27;&#x27; ? &#x27;&#x27; : (this._encodeHTML(name) + &#x27; : &#x27;))
                            + value
                            + (typeof special == &#x27;undefined&#x27;
                                ? &#x27;&#x27; : (&#x27; (&#x27; + special + &#x27;)&#x27;)
                                );
                    }
                    else if (serie.type == ecConfig.CHART_TYPE_RADAR &amp;&amp; special) {
                        indicator = special;
                        html += this._encodeHTML(name === &#x27;&#x27; ? (serie.name || &#x27;&#x27;) : name);
                        html += html === &#x27;&#x27; ? &#x27;&#x27; : &#x27;&lt;br /&gt;&#x27;;
                        for (var i = 0 ; i &lt; indicator.length; i ++) {
                            html += this._encodeHTML(indicator[i].text) + &#x27; : &#x27;
                                + this.numAddCommas(value[i]) + &#x27;&lt;br /&gt;&#x27;;
                        }
                        this._tDom.innerHTML = html;
                    }
                    else if (serie.type == ecConfig.CHART_TYPE_CHORD) {
                        if (typeof special2 == &#x27;undefined&#x27;) {
                            // 外环上
                            this._tDom.innerHTML = this._encodeHTML(name) + &#x27; (&#x27;
                                + this.numAddCommas(value) + &#x27;)&#x27;;
                        }
                        else {
                            var name1 = this._encodeHTML(name);
                            var name2 = this._encodeHTML(special);
                            // 内部弦上
                            this._tDom.innerHTML = (typeof serie.name != &#x27;undefined&#x27;
                                ? (this._encodeHTML(serie.name) + &#x27;&lt;br/&gt;&#x27;) : &#x27;&#x27;
                                )
                                + name1 + &#x27; -&gt; &#x27; + name2
                                + &#x27; (&#x27; + this.numAddCommas(value) + &#x27;)&#x27;
                                + &#x27;&lt;br /&gt;&#x27;
                                + name2 + &#x27; -&gt; &#x27; + name1
                                + &#x27; (&#x27; + this.numAddCommas(special2) + &#x27;)&#x27;;
                        }
                    }
                    else {
                        this._tDom.innerHTML = (typeof serie.name != &#x27;undefined&#x27;
                            ? (this._encodeHTML(serie.name) + &#x27;&lt;br/&gt;&#x27;) : &#x27;&#x27;
                            )
                            + this._encodeHTML(name) + &#x27; : &#x27;
                            + this.numAddCommas(value) +
                            (typeof special == &#x27;undefined&#x27;
                                ? &#x27;&#x27; : (&#x27; (&#x27;+ this.numAddCommas(special) +&#x27;)&#x27;)
                                );
                    }
                }

                if (!this._axisLineShape.invisible
                    || !this._axisShadowShape.invisible
                    ) {
                    this._axisLineShape.invisible = true;
                    this.zr.modShape(this._axisLineShape.id);
                    this._axisShadowShape.invisible = true;
                    this.zr.modShape(this._axisShadowShape.id);
                    this.zr.refresh();
                }

                if (showContent === false || !this.option.tooltip.showContent) {
                    // 只用tooltip的行为，不显示主体
                    return;
                }

                if (!this.hasAppend) {
                    this._tDom.style.left = this._zrWidth / 2 + &#x27;px&#x27;;
                    this._tDom.style.top = this._zrHeight / 2 + &#x27;px&#x27;;
                    this.dom.firstChild.appendChild(this._tDom);
                    this.hasAppend = true;
                }

                this._show(
                    position,
                        zrEvent.getX(this._event) + 20,
                        zrEvent.getY(this._event) - 20,
                    specialCssText
                );
            },

            /**
             * 设置坐标轴指示器样式
             */
            _styleAxisPointer : function (seriesArray, xStart, yStart, xEnd, yEnd, gap, x, y) {
                if (seriesArray.length &gt; 0) {
                    var queryTarget;
                    var curType;
                    var axisPointer = this.option.tooltip.axisPointer;
                    var pointType = axisPointer.type;
                    var style = {
                        line : {},
                        cross : {},
                        shadow : {}
                    };
                    for (var pType in style) {
                        style[pType].color = axisPointer[pType + &#x27;Style&#x27;].color;
                        style[pType].width = axisPointer[pType + &#x27;Style&#x27;].width;
                        style[pType].type = axisPointer[pType + &#x27;Style&#x27;].type;
                    }
                    for (var i = 0, l = seriesArray.length; i &lt; l; i++) {
                        if (this.deepQuery(
                            [seriesArray[i], this.option], &#x27;tooltip.trigger&#x27;
                        ) == &#x27;axis&#x27;
                            ) {
                            queryTarget = seriesArray[i];
                            curType = this.query(queryTarget, &#x27;tooltip.axisPointer.type&#x27;);
                            pointType = curType || pointType;
                            if (curType) {
                                style[curType].color = this.query(
                                    queryTarget,
                                        &#x27;tooltip.axisPointer.&#x27; + curType + &#x27;Style.color&#x27;
                                ) || style[curType].color;
                                style[curType].width = this.query(
                                    queryTarget,
                                        &#x27;tooltip.axisPointer.&#x27; + curType + &#x27;Style.width&#x27;
                                ) || style[curType].width;
                                style[curType].type = this.query(
                                    queryTarget,
                                        &#x27;tooltip.axisPointer.&#x27; + curType + &#x27;Style.type&#x27;
                                ) || style[curType].type;
                            }
                        }
                    }

                    if (pointType == &#x27;line&#x27;) {
                        this._axisLineShape.style = {
                            xStart : xStart,
                            yStart : yStart,
                            xEnd : xEnd,
                            yEnd : yEnd,
                            strokeColor : style.line.color,
                            lineWidth : style.line.width,
                            lineType : style.line.type
                        };
                        this._axisLineShape.invisible = false;
                        this.zr.modShape(this._axisLineShape.id);
                    }
                    else if (pointType == &#x27;cross&#x27;) {
                        this._axisCrossShape.style = {
                            brushType: &#x27;stroke&#x27;,
                            rect : this.component.grid.getArea(),
                            x : x,
                            y : y,
                            text : (&#x27;( &#x27;
                                + this.component.xAxis.getAxis(0).getValueFromCoord(x)
                                + &#x27; , &#x27;
                                + this.component.yAxis.getAxis(0).getValueFromCoord(y)
                                + &#x27; )&#x27;
                                ).replace(&#x27;  , &#x27;, &#x27; &#x27;).replace(&#x27; ,  &#x27;, &#x27; &#x27;),
                            textPosition : &#x27;specific&#x27;,
                            strokeColor : style.cross.color,
                            lineWidth : style.cross.width,
                            lineType : style.cross.type
                        };
                        if (this.component.grid.getXend() - x &gt; 100) {          // 右侧有空间
                            this._axisCrossShape.style.textAlign = &#x27;left&#x27;;
                            this._axisCrossShape.style.textX = x + 10;
                        }
                        else {
                            this._axisCrossShape.style.textAlign = &#x27;right&#x27;;
                            this._axisCrossShape.style.textX = x - 10;
                        }
                        if (y - this.component.grid.getY() &gt; 50) {             // 上方有空间
                            this._axisCrossShape.style.textBaseline = &#x27;bottom&#x27;;
                            this._axisCrossShape.style.textY = y - 10;
                        }
                        else {
                            this._axisCrossShape.style.textBaseline = &#x27;top&#x27;;
                            this._axisCrossShape.style.textY = y + 10;
                        }
                        this._axisCrossShape.invisible = false;
                        this.zr.modShape(this._axisCrossShape.id);
                    }
                    else if (pointType == &#x27;shadow&#x27;) {
                        if (typeof style.shadow.width == &#x27;undefined&#x27;
                            || style.shadow.width == &#x27;auto&#x27;
                            || isNaN(style.shadow.width)
                            ) {
                            style.shadow.width = gap;
                        }
                        if (xStart == xEnd) {
                            // 纵向
                            if (Math.abs(this.component.grid.getX() - xStart) &lt; 2) {
                                // 最左边
                                style.shadow.width /= 2;
                                xStart = xEnd = xEnd + style.shadow.width / 2;
                            }
                            else if (Math.abs(this.component.grid.getXend() - xStart) &lt; 2) {
                                // 最右边
                                style.shadow.width /= 2;
                                xStart = xEnd = xEnd - style.shadow.width / 2;
                            }
                        }
                        else if (yStart == yEnd) {
                            // 横向
                            if (Math.abs(this.component.grid.getY() - yStart) &lt; 2) {
                                // 最上边
                                style.shadow.width /= 2;
                                yStart = yEnd = yEnd + style.shadow.width / 2;
                            }
                            else if (Math.abs(this.component.grid.getYend() - yStart) &lt; 2) {
                                // 最右边
                                style.shadow.width /= 2;
                                yStart = yEnd = yEnd - style.shadow.width / 2;
                            }
                        }
                        this._axisShadowShape.style = {
                            xStart : xStart,
                            yStart : yStart,
                            xEnd : xEnd,
                            yEnd : yEnd,
                            strokeColor : style.shadow.color,
                            lineWidth : style.shadow.width
                        };
                        this._axisShadowShape.invisible = false;
                        this.zr.modShape(this._axisShadowShape.id);
                    }
                    this.zr.refresh();
                }
            },

            __onmousemove : function (param) {
                clearTimeout(this._hidingTicket);
                clearTimeout(this._showingTicket);
                var target = param.target;
                var mx = zrEvent.getX(param.event);
                var my = zrEvent.getY(param.event);
                if (!target) {
                    // 判断是否落到直角系里，axis触发的tooltip
                    this._curTarget = false;
                    this._event = param.event;
                    this._event._target = this._event.target || this._event.toElement;
                    this._event.zrenderX = mx;
                    this._event.zrenderY = my;
                    if (this._needAxisTrigger
                        &amp;&amp; this.component.grid
                        &amp;&amp; zrArea.isInside(rectangleInstance, this.component.grid.getArea(), mx, my)
                        ) {
                        this._showingTicket = setTimeout(this._tryShow, this._showDelay);
                    }
                    else if (this._needAxisTrigger
                        &amp;&amp; this.component.polar
                        &amp;&amp; this.component.polar.isInside([mx, my]) != -1
                        ) {
                        this._showingTicket = setTimeout(this._tryShow, this._showDelay);
                    }
                    else {
                        !this._event.connectTrigger &amp;&amp; this.messageCenter.dispatch(
                            ecConfig.EVENT.TOOLTIP_OUT_GRID,
                            this._event,
                            null,
                            this.myChart
                        );
                        this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                    }
                }
                else {
                    this._curTarget = target;
                    this._event = param.event;
                    this._event._target = this._event.target || this._event.toElement;
                    this._event.zrenderX = mx;
                    this._event.zrenderY = my;
                    var polarIndex;
                    if (this._needAxisTrigger
                        &amp;&amp; this.component.polar
                        &amp;&amp; (polarIndex = this.component.polar.isInside([mx, my])) != -1
                        ) {
                        // 看用这个polar的系列数据是否是axis触发，如果是设置_curTarget为nul
                        var series = this.option.series;
                        for (var i = 0, l = series.length; i &lt; l; i++) {
                            if (series[i].polarIndex == polarIndex
                                &amp;&amp; this.deepQuery(
                                [series[i], this.option], &#x27;tooltip.trigger&#x27;
                            ) == &#x27;axis&#x27;
                                ) {
                                this._curTarget = null;
                                break;
                            }
                        }

                    }
                    this._showingTicket = setTimeout(this._tryShow, this._showDelay);
                }
            },

            /**
             * zrender事件响应：鼠标离开绘图区域
             */
            __onglobalout : function () {
                clearTimeout(this._hidingTicket);
                clearTimeout(this._showingTicket);
                this._hidingTicket = setTimeout(this._hide, this._hideDelay);
            },

            /**
             * 异步回调填充内容
             */
            __setContent : function (ticket, content) {
                if (!this._tDom) {
                    return;
                }
                if (ticket == this._curTicket) {
                    this._tDom.innerHTML = content;
                }

                setTimeout(this._refixed, 20);
            },

            ontooltipHover : function (param, tipShape) {
                if (!this._lastTipShape // 不存在或者存在但dataIndex发生变化才需要重绘
                    || (this._lastTipShape &amp;&amp; this._lastTipShape.dataIndex != param.dataIndex)
                    ) {
                    if (this._lastTipShape &amp;&amp; this._lastTipShape.tipShape.length &gt; 0) {
                        this.zr.delShape(this._lastTipShape.tipShape);
                        this.shapeList.length = 2;
                    }
                    for (var i = 0, l = tipShape.length; i &lt; l; i++) {
                        tipShape[i].zlevel = this._zlevelBase;
                        tipShape[i].style = zrShapeBase.prototype.getHighlightStyle(
                            tipShape[i].style,
                            tipShape[i].highlightStyle
                        );
                        tipShape[i].draggable = false;
                        tipShape[i].hoverable = false;
                        tipShape[i].clickable = false;
                        tipShape[i].ondragend = null;
                        tipShape[i].ondragover = null;
                        tipShape[i].ondrop = null;
                        this.shapeList.push(tipShape[i]);
                        this.zr.addShape(tipShape[i]);
                    }
                    this._lastTipShape = {
                        dataIndex : param.dataIndex,
                        tipShape : tipShape
                    };
                }
            },

            ondragend : function () {
                this._hide();
            },

            /**
             * 图例选择
             */
            onlegendSelected : function (param) {
                this._selectedMap = param.selected;
            },

            _setSelectedMap : function () {
                if (this.component.legend) {
                    this._selectedMap = zrUtil.clone(this.component.legend.getSelectedMap());
                }
                else {
                    this._selectedMap = {};
                }
            },

            _isSelected : function (itemName) {
                if (typeof this._selectedMap[itemName] != &#x27;undefined&#x27;) {
                    return this._selectedMap[itemName];
                }
                else {
                    return true; // 没在legend里定义的都为true啊~
                }
            },

            /**
             * 模拟tooltip hover方法
             * {object} params  参数
             *          {seriesIndex: 0, seriesName:&#x27;&#x27;, dataInex:0} line、bar、scatter、k、radar
             *          {seriesIndex: 0, seriesName:&#x27;&#x27;, name:&#x27;&#x27;} map、pie、chord
             */
            showTip : function (params) {
                if (!params) {
                    return;
                }

                var seriesIndex;
                var series = this.option.series;
                if (typeof params.seriesIndex != &#x27;undefined&#x27;) {
                    seriesIndex = params.seriesIndex;
                }
                else {
                    var seriesName = params.seriesName;
                    for (var i = 0, l = series.length; i &lt; l; i++) {
                        if (series[i].name == seriesName) {
                            seriesIndex = i;
                            break;
                        }
                    }
                }

                var serie = series[seriesIndex];
                if (typeof serie == &#x27;undefined&#x27;) {
                    return;
                }
                var chart = myChart.chart[serie.type];
                var isAxisTrigger = this.deepQuery(
                    [serie, this.option], &#x27;tooltip.trigger&#x27;
                ) == &#x27;axis&#x27;;

                if (!chart) {
                    return;
                }

                if (isAxisTrigger) {
                    // axis trigger
                    var dataIndex = params.dataIndex;
                    switch (chart.type) {
                        case ecConfig.CHART_TYPE_LINE :
                        case ecConfig.CHART_TYPE_BAR :
                        case ecConfig.CHART_TYPE_K :
                            if (typeof this.component.xAxis == &#x27;undefined&#x27;
                                || typeof this.component.yAxis == &#x27;undefined&#x27;
                                || serie.data.length &lt;= dataIndex
                                ) {
                                return;
                            }
                            var xAxisIndex = serie.xAxisIndex || 0;
                            var yAxisIndex = serie.yAxisIndex || 0;
                            if (this.component.xAxis.getAxis(xAxisIndex).type
                                == ecConfig.COMPONENT_TYPE_AXIS_CATEGORY
                                ) {
                                // 横轴是类目
                                this._event = {
                                    zrenderX : this.component.xAxis.getAxis(xAxisIndex)
                                        .getCoordByIndex(dataIndex),
                                    zrenderY : this.component.grid.getY()
                                        + (this.component.grid.getYend()
                                        - this.component.grid.getY()
                                        ) / 4
                                };
                            }
                            else {
                                // 纵轴是类目
                                this._event = {
                                    zrenderX : this.component.grid.getX()
                                        + (this.component.grid.getXend()
                                        - this.component.grid.getX()
                                        ) / 4,
                                    zrenderY : this.component.yAxis.getAxis(yAxisIndex)
                                        .getCoordByIndex(dataIndex)
                                };
                            }
                            this._showAxisTrigger(
                                xAxisIndex,
                                yAxisIndex,
                                dataIndex
                            );
                            break;
                        case ecConfig.CHART_TYPE_RADAR :
                            if (typeof this.component.polar == &#x27;undefined&#x27;
                                || serie.data[0].value.length &lt;= dataIndex
                                ) {
                                return;
                            }
                            var polarIndex = serie.polarIndex || 0;
                            var vector = this.component.polar.getVector(
                                polarIndex, dataIndex, &#x27;max&#x27;
                            );
                            this._event = {
                                zrenderX : vector[0],
                                zrenderY : vector[1]
                            };
                            this._showPolarTrigger(
                                polarIndex,
                                dataIndex
                            );
                            break;
                    }
                }
                else {
                    // item trigger
                    var shapeList = chart.shapeList;
                    var x;
                    var y;
                    switch (chart.type) {
                        case ecConfig.CHART_TYPE_LINE :
                        case ecConfig.CHART_TYPE_BAR :
                        case ecConfig.CHART_TYPE_K :
                        case ecConfig.CHART_TYPE_SCATTER :
                            var dataIndex = params.dataIndex;
                            for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                                if (ecData.get(shapeList[i], &#x27;seriesIndex&#x27;) == seriesIndex
                                    &amp;&amp; ecData.get(shapeList[i], &#x27;dataIndex&#x27;) == dataIndex
                                    ) {
                                    this._curTarget = shapeList[i];
                                    x = shapeList[i].style.x;
                                    y = chart.type != ecConfig.CHART_TYPE_K
                                        ? shapeList[i].style.y : shapeList[i].style.y[0];
                                    break;
                                }
                            }
                            break;
                        case ecConfig.CHART_TYPE_RADAR :
                            var dataIndex = params.dataIndex;
                            for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                                if (shapeList[i].type == &#x27;polygon&#x27;
                                    &amp;&amp; ecData.get(shapeList[i], &#x27;seriesIndex&#x27;) == seriesIndex
                                    &amp;&amp; ecData.get(shapeList[i], &#x27;dataIndex&#x27;) == dataIndex
                                    ) {
                                    this._curTarget = shapeList[i];
                                    var vector = this.component.polar.getCenter(
                                            serie.polarIndex || 0
                                    );
                                    x = vector[0];
                                    y = vector[1];
                                    break;
                                }
                            }
                            break;
                        case ecConfig.CHART_TYPE_PIE :
                            var name = params.name;
                            for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                                if (shapeList[i].type == &#x27;sector&#x27;
                                    &amp;&amp; ecData.get(shapeList[i], &#x27;seriesIndex&#x27;) == seriesIndex
                                    &amp;&amp; ecData.get(shapeList[i], &#x27;name&#x27;) == name
                                    ) {
                                    this._curTarget = shapeList[i];
                                    var style = this._curTarget.style;
                                    var midAngle = (style.startAngle + style.endAngle)
                                        / 2 * Math.PI / 180;
                                    x = this._curTarget.style.x + Math.cos(midAngle) * style.r / 1.5;
                                    y = this._curTarget.style.y - Math.sin(midAngle) * style.r / 1.5;
                                    break;
                                }
                            }
                            break;
                        case ecConfig.CHART_TYPE_MAP :
                            var name = params.name;
                            var mapType = serie.mapType;
                            for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                                if (shapeList[i].type == &#x27;text&#x27;
                                    &amp;&amp; shapeList[i]._mapType == mapType
                                    &amp;&amp; shapeList[i].style._name == name
                                    ) {
                                    this._curTarget = shapeList[i];
                                    x = this._curTarget.style.x + this._curTarget.position[0];
                                    y = this._curTarget.style.y + this._curTarget.position[1];
                                    break;
                                }
                            }
                            break;
                        case ecConfig.CHART_TYPE_CHORD:
                            var name = params.name;
                            for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                                if (shapeList[i].type == &#x27;sector&#x27;
                                    &amp;&amp; ecData.get(shapeList[i], &#x27;name&#x27;) == name
                                    ) {
                                    this._curTarget = shapeList[i];
                                    var style = this._curTarget.style;
                                    var midAngle = (style.startAngle + style.endAngle)
                                        / 2 * Math.PI / 180;
                                    x = this._curTarget.style.x + Math.cos(midAngle) * (style.r - 2);
                                    y = this._curTarget.style.y - Math.sin(midAngle) * (style.r - 2);
                                    this.zr.trigger(
                                        zrConfig.EVENT.MOUSEMOVE,
                                        {
                                            zrenderX : x,
                                            zrenderY : y
                                        }
                                    );
                                    return;
                                }
                            }
                            break;
                        case ecConfig.CHART_TYPE_FORCE:
                            var name = params.name;
                            for (var i = 0, l = shapeList.length; i &lt; l; i++) {
                                if (shapeList[i].type == &#x27;circle&#x27;
                                    &amp;&amp; ecData.get(shapeList[i], &#x27;name&#x27;) == name
                                    ) {
                                    this._curTarget = shapeList[i];
                                    x = this._curTarget.position[0];
                                    y = this._curTarget.position[1];
                                    break;
                                }
                            }
                            break;
                    }
                    if (typeof x != &#x27;undefined&#x27; &amp;&amp; typeof y != &#x27;undefined&#x27;) {
                        this._event = {
                            zrenderX : x,
                            zrenderY : y
                        };
                        this.zr.addHoverShape(this._curTarget);
                        this.zr.refreshHover();
                        this._showItemTrigger();
                    }
                }
            },

            /**
             * 关闭，公开接口
             */
            hideTip : function () {
                this._hide();
            },

            /**
             * 刷新
             */
            refresh : function (newOption) {
                // this._selectedMap;
                // this._defaultCssText;    // css样式缓存
                // this._needAxisTrigger;   // 坐标轴触发
                // this._curTarget;
                // this._event;
                // this._curTicket;         // 异步回调标识，用来区分多个请求

                // 缓存一些高宽数据
                this._zrHeight = this.zr.getHeight();
                this._zrWidth = this.zr.getWidth();

                if (this._lastTipShape &amp;&amp; this._lastTipShape.tipShape.length &gt; 0) {
                    this.zr.delShape(this._lastTipShape.tipShape);
                }
                this._lastTipShape = false;
                this.shapeList.length = 2;

                if (newOption) {
                    this.option = newOption;
                    this.option.tooltip = this.reformOption(this.option.tooltip);
                    this.option.tooltip.textStyle = zrUtil.merge(
                        this.option.tooltip.textStyle,
                        this.ecTheme.textStyle
                    );
                    // 补全padding属性
                    this.option.tooltip.padding = this.reformCssArray(
                        this.option.tooltip.padding
                    );

                    this._needAxisTrigger = false;
                    if (this.option.tooltip.trigger == &#x27;axis&#x27;) {
                        this._needAxisTrigger = true;
                    }

                    var series = this.option.series;
                    for (var i = 0, l = series.length; i &lt; l; i++) {
                        if (this.query(series[i], &#x27;tooltip.trigger&#x27;) == &#x27;axis&#x27;) {
                            this._needAxisTrigger = true;
                            break;
                        }
                    }
                    // this._hidingTicket;
                    // this._showingTicket;
                    this._showDelay = this.option.tooltip.showDelay; // 显示延迟
                    this._hideDelay = this.option.tooltip.hideDelay; // 隐藏延迟
                    this._defaultCssText = this._style(this.option.tooltip);

                    this._setSelectedMap();
                    this._axisLineWidth = this.option.tooltip.axisPointer.lineStyle.width;
                }
                if (this.showing) {
                    this._tryShow();
                }
            },

            /**
             * 释放后实例不可用，重载基类方法
             */
            dispose : function () {
                if (this._lastTipShape &amp;&amp; this._lastTipShape.tipShape.length &gt; 0) {
                    this.zr.delShape(this._lastTipShape.tipShape);
                }
                this.clear();
                this.shapeList = null;

                clearTimeout(this._hidingTicket);
                clearTimeout(this._showingTicket);
                this.zr.un(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                this.zr.un(zrConfig.EVENT.GLOBALOUT, self._onglobalout);

                if (this.hasAppend) {
                    this.dom.firstChild.removeChild(this._tDom);
                }
                this._tDom = null;
            },

            /**
             * html转码的方法
             */
            _encodeHTML : function (source) {
                return String(source)
                    .replace(/&amp;/g, &#x27;&amp;amp;&#x27;)
                    .replace(/&lt;/g, &#x27;&amp;lt;&#x27;)
                    .replace(/&gt;/g, &#x27;&amp;gt;&#x27;)
                    .replace(/&quot;/g, &#x27;&amp;quot;&#x27;)
                    .replace(/&#x27;/g, &#x27;&amp;#39;&#x27;);
            }
        };

        zrUtil.inherits(Tooltip, Base);

        require(&#x27;../component&#x27;).define(&#x27;tooltip&#x27;, Tooltip);

        return Tooltip;
    });
    /**
     * zrender
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：圆环
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;ring&#x27;,         // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           x             : {number},  // 必须，圆心横坐标
           y             : {number},  // 必须，圆心纵坐标
           r0            : {number},  // 必须，内圆半径
           r             : {number},  // 必须，外圆半径
           brushType     : {string},  // 默认为fill，绘画方式
                                      // fill(填充) | stroke(描边) | both(填充+描边)
           color         : {color},   // 默认为&#x27;#000&#x27;，填充颜色，支持rgba
           strokeColor   : {color},   // 默认为&#x27;#000&#x27;，描边颜色（轮廓），支持rgba
           lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

           opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
           shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
           shadowColor   : {color},   // 默认为&#x27;#000&#x27;，阴影色彩，支持rgba
           shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
           shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

           text          : {string},  // 默认为null，附加文本
           textFont      : {string},  // 默认为null，附加文本样式，eg:&#x27;bold 18px verdana&#x27;
           textPosition  : {string},  // 默认为outside，附加文本位置。
                                      // outside | inside
           textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                      // start | end | left | right | center
           textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                      // top | bottom | middle |
                                      // alphabetic | hanging | ideographic
           textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                      // &#x27;inside&#x27; ? &#x27;#fff&#x27; : color
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     例子：
     {
       shape  : &#x27;ring&#x27;,
       id     : &#x27;123456&#x27;,
       zlevel : 1,
       style  : {
           x : 200,
           y : 100,
           r : 50,
           color : &#x27;#eee&#x27;,
           text : &#x27;Baidu&#x27;
       },
       myName : &#x27;kener&#x27;,  // 可自带任何有效自定义属性

       clickable : true,
       onClick : function(eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
     */
    define(
        &#x27;zrender/shape/Ring&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;],function (require) {
            var Base = require(&#x27;./Base&#x27;);

            function Ring(options) {
                Base.call(this, options);
            }

            Ring.prototype = {
                type: &#x27;ring&#x27;,

                /**
                 * 创建圆环路径，依赖扇形路径
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                buildPath : function(ctx, style) {
                    // 非零环绕填充优化
                    ctx.arc(style.x, style.y, style.r, 0, Math.PI * 2, false);
                    ctx.moveTo(style.x + style.r0, style.y);
                    ctx.arc(style.x, style.y, style.r0, 0, Math.PI * 2, true);
                    return;
                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect : function(style) {
                    if (style.__rect) {
                        return style.__rect;
                    }

                    var lineWidth;
                    if (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;fill&#x27;) {
                        lineWidth = style.lineWidth || 1;
                    }
                    else {
                        lineWidth = 0;
                    }
                    style.__rect = {
                        x : Math.round(style.x - style.r - lineWidth / 2),
                        y : Math.round(style.y - style.r - lineWidth / 2),
                        width : style.r * 2 + lineWidth,
                        height : style.r * 2 + lineWidth
                    };

                    return style.__rect;
                }
            };

            require(&#x27;../tool/util&#x27;).inherits(Ring, Base);
            return Ring;
        }
    );
    /**
     * zrender
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：扇形
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;sector&#x27;,       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           x             : {number},  // 必须，圆心横坐标
           y             : {number},  // 必须，圆心纵坐标
           r0            : {number},  // 默认为0，内圆半径，指定后将出现内弧，同时扇边长度 = r - r0
           r             : {number},  // 必须，外圆半径
           startAngle    : {number},  // 必须，起始角度[0, 360)
           endAngle      : {number},  // 必须，结束角度(0, 360]
           brushType     : {string},  // 默认为fill，绘画方式
                                      // fill(填充) | stroke(描边) | both(填充+描边)
           color         : {color},   // 默认为&#x27;#000&#x27;，填充颜色，支持rgba
           strokeColor   : {color},   // 默认为&#x27;#000&#x27;，描边颜色（轮廓），支持rgba
           lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

           opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
           shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
           shadowColor   : {color},   // 默认为&#x27;#000&#x27;，阴影色彩，支持rgba
           shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
           shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

           text          : {string},  // 默认为null，附加文本
           textFont      : {string},  // 默认为null，附加文本样式，eg:&#x27;bold 18px verdana&#x27;
           textPosition  : {string},  // 默认为outside，附加文本位置。
                                      // outside | inside
           textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                      // start | end | left | right | center
           textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                      // top | bottom | middle |
                                      // alphabetic | hanging | ideographic
           textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                      // &#x27;inside&#x27; ? &#x27;#fff&#x27; : color
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     例子：
     {
       shape  : &#x27;sector&#x27;,
       id     : &#x27;123456&#x27;,
       zlevel : 1,
       style  : {
           x : 200,
           y : 100,
           r : 50,
           color : &#x27;#eee&#x27;,
           text : &#x27;Baidu&#x27;
       },
       myName : &#x27;kener&#x27;,  // 可自带任何有效自定义属性

       clickable : true,
       onClick : function(eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
     */
    define(
        &#x27;zrender/shape/Sector&#x27;,[&#x27;require&#x27;,&#x27;../tool/math&#x27;,&#x27;./Base&#x27;,&#x27;./Ring&#x27;,&#x27;./Polygon&#x27;,&#x27;../tool/util&#x27;],function (require) {
            var math = require(&#x27;../tool/math&#x27;);
            var Base = require(&#x27;./Base&#x27;);

            function Sector(options) {
                Base.call(this, options);
            }

            Sector.prototype = {
                type: &#x27;sector&#x27;,

                /**
                 * 创建扇形路径
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                buildPath : function(ctx, style) {
                    var x = style.x;   // 圆心x
                    var y = style.y;   // 圆心y
                    var r0 = typeof style.r0 == &#x27;undefined&#x27;     // 形内半径[0,r)
                        ? 0 : style.r0;
                    var r = style.r;                            // 扇形外半径(0,r]
                    var startAngle = style.startAngle;          // 起始角度[0,360)
                    var endAngle = style.endAngle;              // 结束角度(0,360]

                    if (Math.abs(endAngle - startAngle) &gt;= 360) {
                        // 大于360度的扇形简化为圆环画法
                        ctx.arc(x, y, r, 0, Math.PI * 2, false);
                        if (r0 !== 0) {
                            ctx.moveTo(x + r0, y);
                            ctx.arc(x, y, r0, 0, Math.PI * 2, true);
                        }
                        return;
                    }

                    startAngle = math.degreeToRadian(startAngle);
                    endAngle = math.degreeToRadian(endAngle);

                    var PI2 = Math.PI * 2;
                    var cosStartAngle = math.cos(startAngle);
                    var sinStartAngle = math.sin(startAngle);
                    ctx.moveTo(
                            cosStartAngle * r0 + x,
                            y - sinStartAngle * r0
                    );

                    ctx.lineTo(
                            cosStartAngle * r + x,
                            y - sinStartAngle * r
                    );

                    ctx.arc(x, y, r, PI2 - startAngle, PI2 - endAngle, true);

                    ctx.lineTo(
                            math.cos(endAngle) * r0 + x,
                            y - math.sin(endAngle) * r0
                    );

                    if (r0 !== 0) {
                        ctx.arc(x, y, r0, PI2 - endAngle, PI2 - startAngle, false);
                    }

                    return;
                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect : function(style) {
                    if (style.__rect) {
                        return style.__rect;
                    }

                    var x = style.x;   // 圆心x
                    var y = style.y;   // 圆心y
                    var r0 = typeof style.r0 == &#x27;undefined&#x27;     // 形内半径[0,r)
                        ? 0 : style.r0;
                    var r = style.r;                            // 扇形外半径(0,r]
                    var startAngle = style.startAngle;          // 起始角度[0,360)
                    var endAngle = style.endAngle;              // 结束角度(0,360]

                    if (Math.abs(endAngle - startAngle) &gt;= 360) {
                        // 大于360度的扇形简化为圆环bbox
                        style.__rect = require(&#x27;./Ring&#x27;).prototype.getRect(style);
                        return style.__rect;
                    }

                    startAngle = (720 + startAngle) % 360;
                    endAngle = (720 + endAngle) % 360;
                    if (endAngle &lt;= startAngle) {
                        endAngle += 360;
                    }
                    var pointList = [];
                    if (startAngle &lt;= 90 &amp;&amp; endAngle &gt;= 90) {
                        pointList.push([
                            x, y - r
                        ]);
                    }
                    if (startAngle &lt;= 180 &amp;&amp; endAngle &gt;= 180) {
                        pointList.push([
                                x - r, y
                        ]);
                    }
                    if (startAngle &lt;= 270 &amp;&amp; endAngle &gt;= 270) {
                        pointList.push([
                            x, y + r
                        ]);
                    }
                    if (startAngle &lt;= 360 &amp;&amp; endAngle &gt;= 360) {
                        pointList.push([
                                x + r, y
                        ]);
                    }

                    startAngle = math.degreeToRadian(startAngle);
                    endAngle = math.degreeToRadian(endAngle);


                    pointList.push([
                            math.cos(startAngle) * r0 + x,
                            y - math.sin(startAngle) * r0
                    ]);

                    pointList.push([
                            math.cos(startAngle) * r + x,
                            y - math.sin(startAngle) * r
                    ]);

                    pointList.push([
                            math.cos(endAngle) * r + x,
                            y - math.sin(endAngle) * r
                    ]);

                    pointList.push([
                            math.cos(endAngle) * r0 + x,
                            y - math.sin(endAngle) * r0
                    ]);

                    style.__rect = require(&#x27;./Polygon&#x27;).prototype.getRect({
                        brushType : style.brushType,
                        lineWidth : style.lineWidth,
                        pointList : pointList
                    });

                    return style.__rect;
                }
            };


            require(&#x27;../tool/util&#x27;).inherits(Sector, Base);
            return Sector;
        }
    );

    /**
     * echarts组件：图例
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/component/legend&#x27;,[&#x27;require&#x27;,&#x27;./base&#x27;,&#x27;zrender/shape/Text&#x27;,&#x27;zrender/shape/Rectangle&#x27;,&#x27;zrender/shape/Sector&#x27;,&#x27;../util/shape/Icon&#x27;,&#x27;../config&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/tool/area&#x27;,&#x27;../component&#x27;],function (require) {
        var Base = require(&#x27;./base&#x27;);

        // 图形依赖
        var TextShape = require(&#x27;zrender/shape/Text&#x27;);
        var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
        var SectorShape = require(&#x27;zrender/shape/Sector&#x27;);
        //var BeziercurveShape = require(&#x27;zrender/shape/Beziercurve&#x27;);
        var IconShape = require(&#x27;../util/shape/Icon&#x27;);

        var ecConfig = require(&#x27;../config&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);
        var zrArea = require(&#x27;zrender/tool/area&#x27;);

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 图表参数
         */
        function Legend(ecTheme, messageCenter, zr, option, myChart) {
            if (!this.query(option, &#x27;legend.data&#x27;)) {
                console.error(&#x27;option.legend.data has not been defined.&#x27;);
                return;
            }

            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            var self = this;
            self._legendSelected = function (param) {
                self.__legendSelected(param);
            };

            this._colorIndex = 0;
            this._colorMap = {};
            this._selectedMap = {};

            this.refresh(option);
        }

        Legend.prototype = {
            type : ecConfig.COMPONENT_TYPE_LEGEND,
            _buildShape : function () {
                // 图例元素组的位置参数，通过计算所得x, y, width, height
                this._itemGroupLocation = this._getItemGroupLocation();

                this._buildBackground();
                this._buildItem();

                for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                    this.zr.addShape(this.shapeList[i]);
                }
            },

            /**
             * 构建所有图例元素
             */
            _buildItem : function () {
                var data = this.legendOption.data;
                var dataLength = data.length;
                var itemName;
                var itemType;
                var itemShape;
                var textShape;
                var textStyle  = this.legendOption.textStyle;
                var dataTextStyle;
                var dataFont;

                var zrWidth = this.zr.getWidth();
                var zrHeight = this.zr.getHeight();
                var lastX = this._itemGroupLocation.x;
                var lastY = this._itemGroupLocation.y;
                var itemWidth = this.legendOption.itemWidth;
                var itemHeight = this.legendOption.itemHeight;
                var itemGap = this.legendOption.itemGap;
                var color;

                if (this.legendOption.orient == &#x27;vertical&#x27; &amp;&amp; this.legendOption.x == &#x27;right&#x27;) {
                    lastX = this._itemGroupLocation.x
                        + this._itemGroupLocation.width
                        - itemWidth;
                }

                for (var i = 0; i &lt; dataLength; i++) {
                    dataTextStyle = zrUtil.merge(
                            data[i].textStyle || {},
                        textStyle
                    );
                    dataFont = this.getFont(dataTextStyle);

                    itemName = this._getName(data[i]);
                    if (itemName === &#x27;&#x27;) {
                        if (this.legendOption.orient == &#x27;horizontal&#x27;) {
                            lastX = this._itemGroupLocation.x;
                            lastY += itemHeight + itemGap;
                        }
                        else {
                            this.legendOption.x == &#x27;right&#x27;
                                ? lastX -= this._itemGroupLocation.maxWidth + itemGap
                                : lastX += this._itemGroupLocation.maxWidth + itemGap;
                            lastY = this._itemGroupLocation.y;
                        }
                        continue;
                    }
                    itemType = data[i].icon || this._getSomethingByName(itemName).type;

                    color = this.getColor(itemName);

                    if (this.legendOption.orient == &#x27;horizontal&#x27;) {
                        if (zrWidth - lastX &lt; 200   // 最后200px做分行预判
                            &amp;&amp; (itemWidth + 5 + zrArea.getTextWidth(itemName, dataFont)
                            // 分行的最后一个不用算itemGap
                            + (i == dataLength - 1 || data[i+1] === &#x27;&#x27; ? 0 : itemGap)
                            ) &gt;= zrWidth - lastX
                            ) {
                            lastX = this._itemGroupLocation.x;
                            lastY += itemHeight + itemGap;
                        }
                    }
                    else {
                        if (zrHeight - lastY &lt; 200   // 最后200px做分行预判
                            &amp;&amp; (itemHeight
                            // 分行的最后一个不用算itemGap
                            + (i == dataLength - 1 || data[i+1] === &#x27;&#x27; ? 0 : itemGap)
                            ) &gt;= zrHeight - lastY
                            ) {
                            this.legendOption.x == &#x27;right&#x27;
                                ? lastX -= this._itemGroupLocation.maxWidth + itemGap
                                : lastX += this._itemGroupLocation.maxWidth + itemGap;
                            lastY = this._itemGroupLocation.y;
                        }
                    }

                    // 图形
                    itemShape = this._getItemShapeByType(
                        lastX, lastY,
                        itemWidth, itemHeight,
                        (this._selectedMap[itemName] ? color : &#x27;#ccc&#x27;),
                        itemType,
                        color
                    );
                    itemShape._name = itemName;
                    itemShape = new IconShape(itemShape);

                    // 文字
                    textShape = {
                        // shape : &#x27;text&#x27;,
                        zlevel : this._zlevelBase,
                        style : {
                            x : lastX + itemWidth + 5,
                            y : lastY + itemHeight / 2,
                            color : this._selectedMap[itemName]
                                ? (dataTextStyle.color === &#x27;auto&#x27; ? color : dataTextStyle.color)
                                : &#x27;#ccc&#x27;,
                            text: itemName,
                            textFont: dataFont,
                            textBaseline: &#x27;middle&#x27;
                        },
                        highlightStyle : {
                            color : color,
                            brushType: &#x27;fill&#x27;
                        },
                        hoverable : !!this.legendOption.selectedMode,
                        clickable : !!this.legendOption.selectedMode
                    };

                    if (this.legendOption.orient == &#x27;vertical&#x27;
                        &amp;&amp; this.legendOption.x == &#x27;right&#x27;
                        ) {
                        textShape.style.x -= (itemWidth + 10);
                        textShape.style.textAlign = &#x27;right&#x27;;
                    }

                    textShape._name = itemName;
                    textShape = new TextShape(textShape);

                    if (this.legendOption.selectedMode) {
                        itemShape.onclick = textShape.onclick = this._legendSelected;
                        itemShape.onmouseover =  textShape.onmouseover = this.hoverConnect;
                        itemShape.hoverConnect = textShape.id;
                        textShape.hoverConnect = itemShape.id;
                    }
                    this.shapeList.push(itemShape);
                    this.shapeList.push(textShape);

                    if (this.legendOption.orient == &#x27;horizontal&#x27;) {
                        lastX += itemWidth + 5
                            + zrArea.getTextWidth(itemName, dataFont)
                            + itemGap;
                    }
                    else {
                        lastY += itemHeight + itemGap;
                    }
                }

                if (this.legendOption.orient == &#x27;horizontal&#x27;
                    &amp;&amp; this.legendOption.x == &#x27;center&#x27;
                    &amp;&amp; lastY != this._itemGroupLocation.y
                    ) {
                    // 多行橫排居中优化
                    this._mLineOptimize();
                }
            },

            _getName : function(data) {
                return typeof data.name != &#x27;undefined&#x27; ? data.name : data;
            },

            // 多行橫排居中优化
            _mLineOptimize : function () {
                var lineOffsetArray = []; // 每行宽度
                var lastX = this._itemGroupLocation.x;
                for (var i = 2, l = this.shapeList.length; i &lt; l; i++) {
                    if (this.shapeList[i].style.x == lastX) {
                        lineOffsetArray.push(
                                (
                                    this._itemGroupLocation.width
                                    - (
                                    this.shapeList[i - 1].style.x
                                    + zrArea.getTextWidth(
                                    this.shapeList[i - 1].style.text,
                                    this.shapeList[i - 1].style.textFont
                                )
                                    - lastX
                                    )
                                    ) / 2
                        );
                    }
                    else if (i == l - 1) {
                        lineOffsetArray.push(
                                (
                                    this._itemGroupLocation.width
                                    - (
                                    this.shapeList[i].style.x
                                    + zrArea.getTextWidth(
                                    this.shapeList[i].style.text,
                                    this.shapeList[i].style.textFont
                                )
                                    - lastX
                                    )
                                    ) / 2
                        );
                    }
                }
                var curLineIndex = -1;
                for (var i = 1, l = this.shapeList.length; i &lt; l; i++) {
                    if (this.shapeList[i].style.x == lastX) {
                        curLineIndex++;
                    }
                    if (lineOffsetArray[curLineIndex] === 0) {
                        continue;
                    }
                    else {
                        this.shapeList[i].style.x += lineOffsetArray[curLineIndex];
                    }
                }
            },

            _buildBackground : function () {
                var pTop = this.legendOption.padding[0];
                var pRight = this.legendOption.padding[1];
                var pBottom = this.legendOption.padding[2];
                var pLeft = this.legendOption.padding[3];

                this.shapeList.push(new RectangleShape({
                    zlevel : this._zlevelBase,
                    hoverable :false,
                    style : {
                        x : this._itemGroupLocation.x - pLeft,
                        y : this._itemGroupLocation.y - pTop,
                        width : this._itemGroupLocation.width + pLeft + pRight,
                        height : this._itemGroupLocation.height + pTop + pBottom,
                        brushType : this.legendOption.borderWidth === 0 ? &#x27;fill&#x27; : &#x27;both&#x27;,
                        color : this.legendOption.backgroundColor,
                        strokeColor : this.legendOption.borderColor,
                        lineWidth : this.legendOption.borderWidth
                    }
                }));
            },

            /**
             * 根据选项计算图例实体的位置坐标
             */
            _getItemGroupLocation : function () {
                var data = this.legendOption.data;
                var dataLength = data.length;
                var itemGap = this.legendOption.itemGap;
                var itemWidth = this.legendOption.itemWidth + 5; // 5px是图形和文字的间隔，不可配
                var itemHeight = this.legendOption.itemHeight;
                var textStyle  = this.legendOption.textStyle;
                var font = this.getFont(textStyle);
                var totalWidth = 0;
                var totalHeight = 0;
                var padding = this.legendOption.padding;
                var zrWidth = this.zr.getWidth() - padding[1] - padding[3];
                var zrHeight = this.zr.getHeight() - padding[0] - padding[2];

                var temp = 0; // 宽高计算，用于多行判断
                var maxWidth = 0; // 垂直布局有用
                if (this.legendOption.orient == &#x27;horizontal&#x27;) {
                    // 水平布局，计算总宽度
                    totalHeight = itemHeight;
                    for (var i = 0; i &lt; dataLength; i++) {
                        if (this._getName(data[i]) === &#x27;&#x27;) {
                            temp -= itemGap;
                            if (temp &gt; zrWidth) {
                                totalWidth = zrWidth;
                                totalHeight += itemHeight + itemGap;
                            }
                            else {
                                totalWidth = Math.max(totalWidth, temp);
                            }
                            totalHeight += itemHeight + itemGap;
                            temp = 0;
                            continue;
                        }
                        dataTextStyle = zrUtil.merge(
                                data[i].textStyle || {},
                            textStyle
                        );
                        temp += itemWidth
                            + zrArea.getTextWidth(
                                this._getName(data[i]),
                                data[i].textStyle
                                    ? this.getFont(zrUtil.merge(
                                        data[i].textStyle || {},
                                    textStyle
                                ))
                                    : font
                            )
                            + itemGap;
                    }
                    totalHeight = Math.max(totalHeight, itemHeight);
                    temp -= itemGap;    // 减去最后一个的itemGap
                    if (temp &gt; zrWidth) {
                        totalWidth = zrWidth;
                        totalHeight += itemHeight + itemGap;
                    } else {
                        totalWidth = Math.max(totalWidth, temp);
                    }
                }
                else {
                    // 垂直布局，计算总高度
                    for (var i = 0; i &lt; dataLength; i++) {
                        maxWidth = Math.max(
                            maxWidth,
                            zrArea.getTextWidth(
                                this._getName(data[i]),
                                data[i].textStyle
                                    ? this.getFont(zrUtil.merge(
                                        data[i].textStyle || {},
                                    textStyle
                                ))
                                    : font
                            )
                        );
                    }
                    maxWidth += itemWidth;
                    totalWidth = maxWidth;
                    for (var i = 0; i &lt; dataLength; i++) {
                        if (this._getName(data[i]) === &#x27;&#x27;) {
                            temp -= itemGap;
                            if (temp &gt; zrHeight) {
                                totalHeight = zrHeight;
                                totalWidth += maxWidth + itemGap;
                            }
                            else {
                                totalHeight = Math.max(totalHeight, temp);
                            }
                            totalWidth += maxWidth + itemGap;
                            temp = 0;
                            continue;
                        }
                        temp += itemHeight + itemGap;
                    }
                    totalWidth = Math.max(totalWidth, maxWidth);
                    temp -= itemGap;    // 减去最后一个的itemGap
                    if (temp &gt; zrHeight) {
                        totalHeight = zrHeight;
                        totalWidth += maxWidth + itemGap;
                    } else {
                        totalHeight = Math.max(totalHeight, temp);
                    }
                }

                zrWidth = this.zr.getWidth();
                zrHeight = this.zr.getHeight();
                var x;
                switch (this.legendOption.x) {
                    case &#x27;center&#x27; :
                        x = Math.floor((zrWidth - totalWidth) / 2);
                        break;
                    case &#x27;left&#x27; :
                        x = this.legendOption.padding[3] + this.legendOption.borderWidth;
                        break;
                    case &#x27;right&#x27; :
                        x = zrWidth
                            - totalWidth
                            - this.legendOption.padding[1]
                            - this.legendOption.padding[3]
                            - this.legendOption.borderWidth * 2;
                        break;
                    default :
                        x = this.parsePercent(this.legendOption.x, zrWidth);
                        break;
                }

                var y;
                switch (this.legendOption.y) {
                    case &#x27;top&#x27; :
                        y = this.legendOption.padding[0] + this.legendOption.borderWidth;
                        break;
                    case &#x27;bottom&#x27; :
                        y = zrHeight
                            - totalHeight
                            - this.legendOption.padding[0]
                            - this.legendOption.padding[2]
                            - this.legendOption.borderWidth * 2;
                        break;
                    case &#x27;center&#x27; :
                        y = Math.floor((zrHeight - totalHeight) / 2);
                        break;
                    default :
                        y = this.parsePercent(this.legendOption.y, zrHeight);
                        break;
                }

                return {
                    x : x,
                    y : y,
                    width : totalWidth,
                    height : totalHeight,
                    maxWidth : maxWidth
                };
            },

            /**
             * 根据名称返回series数据或data
             */
            _getSomethingByName : function (name) {
                var series = this.option.series;
                var data;
                for (var i = 0, l = series.length; i &lt; l; i++) {
                    if (series[i].name == name) {
                        // 系列名称优先
                        return {
                            type : series[i].type,
                            series : series[i],
                            seriesIndex : i,
                            data : null,
                            dataIndex : -1
                        };
                    }

                    if (
                        series[i].type == ecConfig.CHART_TYPE_PIE
                        || series[i].type == ecConfig.CHART_TYPE_RADAR
                        || series[i].type == ecConfig.CHART_TYPE_CHORD
                        || series[i].type == ecConfig.CHART_TYPE_FORCE
                        || series[i].type == ecConfig.CHART_TYPE_FUNNEL
                        ) {
                        data = series[i].type != ecConfig.CHART_TYPE_FORCE
                            ? series[i].data         // 饼图、雷达图、和弦图得查找里面的数据名字
                            : series[i].categories;  // 力导布局查找categories配置
                        for (var j = 0, k = data.length; j &lt; k; j++) {
                            if (data[j].name == name) {
                                return {
                                    type : series[i].type,
                                    series : series[i],
                                    seriesIndex : i,
                                    data : data[j],
                                    dataIndex : j
                                };
                            }
                        }
                    }
                }
                return {
                    type : &#x27;bar&#x27;,
                    series : null,
                    seriesIndex : -1,
                    data : null,
                    dataIndex : -1
                };
            },

            _getItemShapeByType : function (x, y, width, height, color, itemType, defaultColor) {
                var highlightColor = color === &#x27;#ccc&#x27; ? defaultColor : color;
                var itemShape = {
                    zlevel : this._zlevelBase,
                    style : {
                        iconType : &#x27;legendicon&#x27; + itemType,
                        x : x,
                        y : y,
                        width : width,
                        height : height,
                        color : color,
                        strokeColor : color,
                        lineWidth : 2
                    },
                    highlightStyle: {
                        color : highlightColor,
                        strokeColor : highlightColor,
                        lineWidth : 1
                    },
                    hoverable : this.legendOption.selectedMode,
                    clickable : this.legendOption.selectedMode
                };

                var imageLocation;
                if (itemType.match(&#x27;image&#x27;)) {
                    var imageLocation = itemType.replace(
                        new RegExp(&#x27;^image:\\/\\/&#x27;), &#x27;&#x27;
                    );
                    itemType = &#x27;image&#x27;;
                }
                // 特殊设置
                switch (itemType) {
                    case &#x27;line&#x27; :
                        itemShape.style.brushType = &#x27;stroke&#x27;;
                        itemShape.highlightStyle.lineWidth = 3;
                        break;
                    case &#x27;radar&#x27; :
                    case &#x27;scatter&#x27; :
                        itemShape.highlightStyle.lineWidth = 3;
                        break;
                    case &#x27;k&#x27; :
                        itemShape.style.brushType = &#x27;both&#x27;;
                        itemShape.highlightStyle.lineWidth = 3;
                        itemShape.highlightStyle.color =
                            itemShape.style.color = this.query(this.ecTheme, &#x27;k.itemStyle.normal.color&#x27;)
                                || &#x27;#fff&#x27;;
                        itemShape.style.strokeColor = color != &#x27;#ccc&#x27;
                            ? (this.query(this.ecTheme, &#x27;k.itemStyle.normal.lineStyle.color&#x27;)
                            || &#x27;#ff3200&#x27;)
                            : color;
                        break;
                    case &#x27;image&#x27; :
                        itemShape.style.iconType = &#x27;image&#x27;;
                        itemShape.style.image = imageLocation;
                        if (color === &#x27;#ccc&#x27;) {
                            itemShape.style.opacity = 0.5;
                        }
                        break;
                }
                return itemShape;
            },

            __legendSelected : function (param) {
                var itemName = param.target._name;
                if (this.legendOption.selectedMode === &#x27;single&#x27;) {
                    for (var k in this._selectedMap) {
                        this._selectedMap[k] = false;
                    }
                }
                this._selectedMap[itemName] = !this._selectedMap[itemName];
                this.messageCenter.dispatch(
                    ecConfig.EVENT.LEGEND_SELECTED,
                    param.event,
                    {
                        selected : this._selectedMap,
                        target : itemName
                    },
                    this.myChart
                );
            },

            /**
             * 刷新
             */
            refresh : function (newOption) {
                if (newOption) {
                    this.option = newOption || this.option;
                    this.option.legend = this.reformOption(this.option.legend);
                    // 补全padding属性
                    this.option.legend.padding = this.reformCssArray(
                        this.option.legend.padding
                    );
                    this.legendOption = this.option.legend;

                    var data = this.legendOption.data || [];
                    var itemName;
                    var something;
                    var color;
                    var queryTarget;
                    if (this.legendOption.selected) {
                        for (var k in this.legendOption.selected) {
                            this._selectedMap[k] = typeof this._selectedMap[k] != &#x27;undefined&#x27;
                                ? this._selectedMap[k]
                                : this.legendOption.selected[k];
                        }
                    }
                    for (var i = 0, dataLength = data.length; i &lt; dataLength; i++) {
                        itemName = this._getName(data[i]);
                        if (itemName === &#x27;&#x27;) {
                            continue;
                        }
                        something = this._getSomethingByName(itemName);
                        if (!something.series) {
                            this._selectedMap[itemName] = false;
                        }
                        else {
                            if (something.data
                                &amp;&amp; (something.type == ecConfig.CHART_TYPE_PIE
                                    || something.type == ecConfig.CHART_TYPE_FORCE
                                    || something.type == ecConfig.CHART_TYPE_FUNNEL)
                                ) {
                                queryTarget = [something.data, something.series];
                            }
                            else {
                                queryTarget = [something.series];
                            }

                            color = this.getItemStyleColor(
                                this.deepQuery(queryTarget, &#x27;itemStyle.normal.color&#x27;),
                                something.seriesIndex,
                                something.dataIndex,
                                something.data
                            );
                            if (color &amp;&amp; something.type != ecConfig.CHART_TYPE_K) {
                                this.setColor(itemName, color);
                            }
                            this._selectedMap[itemName] =
                                    typeof this._selectedMap[itemName] != &#x27;undefined&#x27;
                                ? this._selectedMap[itemName] : true;
                        }
                    }
                }
                this.clear();
                this._buildShape();
            },

            getRelatedAmount : function(name) {
                var amount = 0;
                var series = this.option.series;
                var data;
                for (var i = 0, l = series.length; i &lt; l; i++) {
                    if (series[i].name == name) {
                        // 系列名称优先
                        amount++;
                    }

                    if (
                        series[i].type == ecConfig.CHART_TYPE_PIE
                        || series[i].type == ecConfig.CHART_TYPE_RADAR
                        || series[i].type == ecConfig.CHART_TYPE_CHORD
                        || series[i].type == ecConfig.CHART_TYPE_FORCE
                        || series[i].type == ecConfig.CHART_TYPE_FUNNEL
                        ) {
                        data = series[i].type != ecConfig.CHART_TYPE_FORCE
                            ? series[i].data         // 饼图、雷达图、和弦图得查找里面的数据名字
                            : series[i].categories;  // 力导布局查找categories配置
                        for (var j = 0, k = data.length; j &lt; k; j++) {
                            if (data[j].name == name &amp;&amp; data[j].value != &#x27;-&#x27;) {
                                amount++
                            }
                        }
                    }
                }
                return amount;
            },

            setColor : function (legendName, color) {
                this._colorMap[legendName] = color;
            },

            getColor : function (legendName) {
                if (!this._colorMap[legendName]) {
                    this._colorMap[legendName] = this.zr.getColor(this._colorIndex++);
                }
                return this._colorMap[legendName];
            },

            hasColor : function (legendName) {
                return this._colorMap[legendName] ? this._colorMap[legendName] : false;
            },

            add : function (name, color){
                var data = this.legendOption.data;
                for (var i = 0, dataLength = data.length; i &lt; dataLength; i++) {
                    if (this._getName(data[i]) == name) {
                        // 已有就不重复加了
                        return;
                    }
                }
                this.legendOption.data.push(name);
                this.setColor(name,color);
                this._selectedMap[name] = true;
            },

            del : function (name){
                var data = this.legendOption.data;
                for (var i = 0, dataLength = data.length; i &lt; dataLength; i++) {
                    if (this._getName(data[i]) == name) {
                        return this.legendOption.data.splice(i, 1);
                    }
                }
            },

            /**
             * 特殊图形元素回调设置
             * @param {Object} name
             * @param {Object} itemShape
             */
            getItemShape : function (name) {
                if (typeof name == &#x27;undefined&#x27;) {
                    return;
                }
                var shape;
                for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                    shape = this.shapeList[i];
                    if (shape._name == name &amp;&amp; shape.type != &#x27;text&#x27;) {
                        return shape;
                    }
                }
            },

            /**
             * 特殊图形元素回调设置
             * @param {Object} name
             * @param {Object} itemShape
             */
            setItemShape : function (name, itemShape) {
                var shape;
                for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                    shape = this.shapeList[i];
                    if (shape._name == name &amp;&amp; shape.type != &#x27;text&#x27;) {
                        if (!this._selectedMap[name]) {
                            itemShape.style.color = &#x27;#ccc&#x27;;
                            itemShape.style.strokeColor = &#x27;#ccc&#x27;;
                        }
                        this.zr.modShape(shape.id, itemShape);
                    }
                }
            },

            isSelected : function (itemName) {
                if (typeof this._selectedMap[itemName] != &#x27;undefined&#x27;) {
                    return this._selectedMap[itemName];
                }
                else {
                    // 没在legend里定义的都为true啊~
                    return true;
                }
            },

            getSelectedMap : function () {
                return this._selectedMap;
            },

            setSelected : function(itemName, selectStatus) {
                if (this.legendOption.selectedMode === &#x27;single&#x27;) {
                    for (var k in this._selectedMap) {
                        this._selectedMap[k] = false;
                    }
                }
                this._selectedMap[itemName] = selectStatus;
                this.messageCenter.dispatch(
                    ecConfig.EVENT.LEGEND_SELECTED,
                    null,
                    {
                        selected : this._selectedMap,
                        target : itemName
                    },
                    this.myChart
                );
            },

            /**
             * 图例选择
             */
            onlegendSelected : function (param, status) {
                var legendSelected = param.selected;
                for (var itemName in legendSelected) {
                    if (this._selectedMap[itemName] != legendSelected[itemName]) {
                        // 有一项不一致都需要重绘
                        status.needRefresh = true;
                    }
                    this._selectedMap[itemName] = legendSelected[itemName];
                }
                return;
            }
        };

        var legendIcon = {
            line : function (ctx, style) {
                var dy = style.height / 2;
                ctx.moveTo(style.x,     style.y + dy);
                ctx.lineTo(style.x + style.width,style.y + dy);
            },

            pie : function (ctx, style) {
                var x = style.x;
                var y = style.y;
                var width = style.width;
                var height = style.height;
                SectorShape.prototype.buildPath(ctx, {
                    x : x + width / 2,
                    y : y + height + 2,
                    r : height + 2,
                    r0 : 6,
                    startAngle : 45,
                    endAngle : 135
                });
            },
            /*
             chord : function (ctx, style) {
             var x = style.x;
             var y = style.y;
             var width = style.width;
             var height = style.height;
             ctx.moveTo(x, y + height);
             BeziercurveShape.prototype.buildPath(ctx, {
             xStart : x,
             yStart : y + height,
             cpX1 : x + width,
             cpY1 : y + height,
             cpX2 : x,
             cpY2 : y + 4,
             xEnd : x + width,
             yEnd : y + 4
             });
             ctx.lineTo(x + width, y);
             BeziercurveShape.prototype.buildPath(ctx, {
             xStart : x + width,
             yStart : y,
             cpX1 : x,
             cpY1 : y,
             cpX2 : x + width,
             cpY2 : y + height - 4,
             xEnd : x,
             yEnd : y + height - 4
             });
             ctx.lineTo(x, y + height);
             },
             */
            k : function (ctx, style) {
                var x = style.x;
                var y = style.y;
                var width = style.width;
                var height = style.height;
            },

            bar : function (ctx, style) {
                var x = style.x;
                var y = style.y +1;
                var width = style.width;
                var height = style.height - 2;
                var r = 3;

                ctx.moveTo(x + r, y);
                ctx.lineTo(x + width - r, y);
                ctx.quadraticCurveTo(
                        x + width, y, x + width, y + r
                );
                ctx.lineTo(x + width, y + height - r);
                ctx.quadraticCurveTo(
                        x + width, y + height, x + width - r, y + height
                );
                ctx.lineTo(x + r, y + height);
                ctx.quadraticCurveTo(
                    x, y + height, x, y + height - r
                );
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
            },

            force : function (ctx, style) {
                IconShape.prototype.iconLibrary.circle(ctx, style);
            },

            radar: function (ctx, style) {
                var n = 6;
                var x = style.x + style.width / 2;
                var y = style.y + style.height / 2;
                var r = style.height / 2;

                var dStep = 2 * Math.PI / n;
                var deg = -Math.PI / 2;
                var xStart = x + r * Math.cos(deg);
                var yStart = y + r * Math.sin(deg);

                ctx.moveTo(xStart, yStart);
                deg += dStep;
                for (var i = 0, end = n - 1; i &lt; end; i ++) {
                    ctx.lineTo(x + r * Math.cos(deg), y + r * Math.sin(deg));
                    deg += dStep;
                }
                ctx.lineTo(xStart, yStart);
            }
        };
        legendIcon.chord = legendIcon.pie;
        legendIcon.map = legendIcon.bar;

        for (var k in legendIcon) {
            IconShape.prototype.iconLibrary[&#x27;legendicon&#x27; + k] = legendIcon[k];
        }

        zrUtil.inherits(Legend, Base);

        require(&#x27;../component&#x27;).define(&#x27;legend&#x27;, Legend);

        return Legend;
    });



    /**
     * zrender
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：时间轴线
     */
    define(&#x27;echarts/util/shape/Chain&#x27;,[&#x27;require&#x27;,&#x27;zrender/shape/Base&#x27;,&#x27;./Icon&#x27;,&#x27;zrender/shape/util/dashedLineTo&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/tool/matrix&#x27;],function (require) {
        var Base = require(&#x27;zrender/shape/Base&#x27;);
        var IconShape = require(&#x27;./Icon&#x27;);

        var dashedLineTo = require(&#x27;zrender/shape/util/dashedLineTo&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);
        var matrix = require(&#x27;zrender/tool/matrix&#x27;);

        function Chain(options) {
            Base.call(this, options);
        }

        Chain.prototype =  {
            type : &#x27;chain&#x27;,

            /**
             * 画刷
             * @param ctx       画布句柄
             * @param e         形状实体
             * @param isHighlight   是否为高亮状态
             * @param updateCallback 需要异步加载资源的shape可以通过这个callback(e)
             *                       让painter更新视图，base.brush没用，需要的话重载brush
             */
            brush : function (ctx, isHighlight) {
                var style = this.style;

                if (isHighlight) {
                    // 根据style扩展默认高亮样式
                    style = this.getHighlightStyle(
                        style,
                            this.highlightStyle || {}
                    );
                }

                ctx.save();
                this.setContext(ctx, style);

                // 设置transform
                this.updateTransform(ctx);

                ctx.beginPath();
                this.buildLinePath(ctx, style);
                ctx.stroke();

                this.brushSymbol(ctx, style);

                ctx.restore();
                return;
            },

            /**
             * 创建线条路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildLinePath : function (ctx, style) {
                var x = style.x;
                var y = style.y + 5;
                var width = style.width;
                var height = style.height / 2 - 10;

                ctx.moveTo(x, y);
                ctx.lineTo(x, y + height);
                ctx.moveTo(x + width, y);
                ctx.lineTo(x + width, y + height);

                ctx.moveTo(x, y + height / 2);
                if (!style.lineType || style.lineType == &#x27;solid&#x27;) {
                    ctx.lineTo(x + width, y + height / 2);
                }
                else if (style.lineType == &#x27;dashed&#x27; || style.lineType == &#x27;dotted&#x27;) {
                    var dashLength = (style.lineWidth || 1)
                        * (style.lineType == &#x27;dashed&#x27; ? 5 : 1);
                    dashedLineTo(ctx, x, y + height / 2, x + width, y + height / 2, dashLength);
                }
            },

            /**
             * 标线始末标注
             */
            brushSymbol : function (ctx, style) {
                var y = style.y + style.height / 4;
                ctx.save();

                var chainPoint = style.chainPoint;
                var curPoint;
                for (var idx = 0, l = chainPoint.length; idx &lt; l; idx++) {
                    curPoint = chainPoint[idx];
                    if (curPoint.symbol != &#x27;none&#x27;) {
                        ctx.beginPath();
                        var symbolSize = curPoint.symbolSize;
                        IconShape.prototype.buildPath(
                            ctx,
                            {
                                iconType : curPoint.symbol,
                                x : curPoint.x - symbolSize,
                                y : y - symbolSize,
                                width : symbolSize * 2,
                                height : symbolSize * 2,
                                n : curPoint.n
                            }
                        );
                        ctx.fillStyle = curPoint.isEmpty ? &#x27;#fff&#x27; : style.strokeColor;
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    }

                    if (curPoint.showLabel) {
                        ctx.font = curPoint.textFont;
                        ctx.fillStyle = curPoint.textColor;
                        ctx.textAlign = curPoint.textAlign;
                        ctx.textBaseline = curPoint.textBaseline;
                        if (curPoint.rotation) {
                            ctx.save();
                            this._updateTextTransform(ctx, curPoint.rotation);
                            ctx.fillText(curPoint.name, curPoint.textX, curPoint.textY);
                            ctx.restore();
                        }
                        else {
                            ctx.fillText(curPoint.name, curPoint.textX, curPoint.textY);
                        }
                    }
                }

                ctx.restore();
            },

            _updateTextTransform : function (ctx, rotation) {
                var _transform = matrix.create();
                matrix.identity(_transform);

                if (rotation[0] !== 0) {
                    var originX = rotation[1] || 0;
                    var originY = rotation[2] || 0;
                    if (originX || originY) {
                        matrix.translate(
                            _transform, _transform, [-originX, -originY]
                        );
                    }
                    matrix.rotate(_transform, _transform, rotation[0]);
                    if (originX || originY) {
                        matrix.translate(
                            _transform, _transform, [originX, originY]
                        );
                    }
                }

                // 保存这个变换矩阵
                ctx.transform.apply(ctx, _transform);
            },

            isCover : function (x, y) {
                var rect = this.style;
                if (x &gt;= rect.x
                    &amp;&amp; x &lt;= (rect.x + rect.width)
                    &amp;&amp; y &gt;= rect.y
                    &amp;&amp; y &lt;= (rect.y + rect.height)
                    ) {
                    // 矩形内
                    return true;
                }
                else {
                    return false;
                }
            }
        };

        zrUtil.inherits(Chain, Base);

        return Chain;
    });

    /**
     * echarts组件：时间轴组件
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/component/timeline&#x27;,[&#x27;require&#x27;,&#x27;./base&#x27;,&#x27;zrender/shape/Rectangle&#x27;,&#x27;../util/shape/Icon&#x27;,&#x27;../util/shape/Chain&#x27;,&#x27;../config&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/tool/area&#x27;,&#x27;zrender/tool/event&#x27;,&#x27;../component&#x27;],function (require) {
        var Base = require(&#x27;./base&#x27;);

        // 图形依赖
        var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
        var IconShape = require(&#x27;../util/shape/Icon&#x27;);
        var ChainShape = require(&#x27;../util/shape/Chain&#x27;);

        var ecConfig = require(&#x27;../config&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);
        var zrArea = require(&#x27;zrender/tool/area&#x27;);
        var zrEvent = require(&#x27;zrender/tool/event&#x27;);

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 图表参数
         */
        function Timeline(ecTheme, messageCenter, zr, option, myChart) {
            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            var self = this;
            self._onclick = function(param) {
                return self.__onclick(param);
            };
            self._ondrift = function (dx, dy) {
                return self.__ondrift(this, dx, dy);
            };
            self._ondragend = function () {
                return self.__ondragend();
            };
            self._setCurrentOption = function() {
                var timelineOption = self.timelineOption;
                self.currentIndex %= timelineOption.data.length;
                // console.log(self.currentIndex);
                var curOption = self.options[self.currentIndex] || {};
                self.myChart.setOption(curOption, timelineOption.notMerge);

                self.messageCenter.dispatch(
                    ecConfig.EVENT.TIMELINE_CHANGED,
                    null,
                    {
                        currentIndex: self.currentIndex,
                        data : typeof timelineOption.data[self.currentIndex].name != &#x27;undefined&#x27;
                            ? timelineOption.data[self.currentIndex].name
                            : timelineOption.data[self.currentIndex]
                    },
                    self.myChart
                );
            };
            self._onFrame = function() {
                self._setCurrentOption();
                self._syncHandleShape();

                if (self.timelineOption.autoPlay) {
                    self.playTicket = setTimeout(
                        function() {
                            self.currentIndex += 1;
                            if (!self.timelineOption.loop
                                &amp;&amp; self.currentIndex &gt;= self.timelineOption.data.length
                                ) {
                                self.currentIndex = self.timelineOption.data.length - 1;
                                self.stop();
                                return;
                            }
                            self._onFrame();
                        },
                        self.timelineOption.playInterval
                    );
                }
            };

            this.setTheme(false);
            this.options = this.option.options;
            this.currentIndex = this.timelineOption.currentIndex % this.timelineOption.data.length;

            /*
             if (!this.timelineOption.notMerge) {
             for (var i = 1, l = this.timelineOption.data.length; i &lt; l; i++) {
             this.options[i] = zrUtil.merge(
             this.options[i], this.options[i - 1]
             );
             }
             }
             */

            if (this.timelineOption.show) {
                this._buildShape();
                this._syncHandleShape();
            }

            this._setCurrentOption();

            if (this.timelineOption.autoPlay) {
                var self = this;
                this.playTicket = setTimeout(
                    function() {
                        self.play();
                    },
                    this.ecTheme.animationDuration
                );
            }
        }

        Timeline.prototype = {
            type : ecConfig.COMPONENT_TYPE_TIMELINE,
            _buildShape : function () {
                // 位置参数，通过计算所得x, y, width, height
                this._location = this._getLocation();
                this._buildBackground();
                this._buildControl();
                this._chainPoint = this._getChainPoint();
                if (this.timelineOption.label.show) {
                    // 标签显示的挑选间隔
                    var interval = this._getInterval();
                    for (var i = 0, len = this._chainPoint.length; i &lt; len; i += interval) {
                        this._chainPoint[i].showLabel = true;
                    }
                }
                this._buildChain();
                this._buildHandle();

                for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                    this.zr.addShape(this.shapeList[i]);
                }
            },

            /**
             * 根据选项计算实体的位置坐标
             */
            _getLocation : function () {
                var timelineOption = this.timelineOption;
                var padding = timelineOption.padding;

                // 水平布局
                var zrWidth = this.zr.getWidth();
                var x = this.parsePercent(timelineOption.x, zrWidth);
                var x2 = this.parsePercent(timelineOption.x2, zrWidth);
                var width;
                if (typeof timelineOption.width == &#x27;undefined&#x27;) {
                    width = zrWidth - x - x2;
                    x2 = zrWidth - x2;
                }
                else {
                    width = this.parsePercent(timelineOption.width, zrWidth);
                    x2 = x + width;
                }

                var zrHeight = this.zr.getHeight();
                var height = this.parsePercent(timelineOption.height, zrHeight);
                var y;
                var y2;
                if (typeof timelineOption.y != &#x27;undefined&#x27;) {
                    y = this.parsePercent(timelineOption.y, zrHeight);
                    y2 = y + height;
                }
                else {
                    y2 = zrHeight - this.parsePercent(timelineOption.y2, zrHeight);
                    y = y2 - height;
                }

                return {
                    x : x + padding[3],
                    y : y + padding[0],
                    x2 : x2 - padding[1],
                    y2 : y2 - padding[2],
                    width : width - padding[1] - padding[3],
                    height : height - padding[0] - padding[2]
                };
            },

            _getReformedLabel : function (idx) {
                var timelineOption = this.timelineOption;
                var data = typeof timelineOption.data[idx].name != &#x27;undefined&#x27;
                    ? timelineOption.data[idx].name
                    : timelineOption.data[idx];
                var formatter = timelineOption.data[idx].formatter
                    || timelineOption.label.formatter;
                if (formatter) {
                    if (typeof formatter == &#x27;function&#x27;) {
                        data = formatter(data);
                    }
                    else if (typeof formatter == &#x27;string&#x27;) {
                        data = formatter.replace(&#x27;{value}&#x27;, data);
                    }
                }
                return data;
            },

            /**
             * 计算标签显示挑选间隔
             */
            _getInterval : function () {
                var chainPoint = this._chainPoint;
                var timelineOption = this.timelineOption;
                var interval   = timelineOption.label.interval;
                if (interval == &#x27;auto&#x27;) {
                    // 麻烦的自适应计算
                    var fontSize = timelineOption.label.textStyle.fontSize;
                    var data = timelineOption.data;
                    var dataLength = timelineOption.data.length;

                    // 横向
                    if (dataLength &gt; 3) {
                        var isEnough = false;
                        var labelSpace;
                        var labelSize;
                        interval = 0;
                        while (!isEnough &amp;&amp; interval &lt; dataLength) {
                            interval++;
                            isEnough = true;
                            for (var i = interval; i &lt; dataLength; i += interval) {
                                labelSpace = chainPoint[i].x - chainPoint[i - interval].x;
                                if (timelineOption.label.rotate !== 0) {
                                    // 有旋转
                                    labelSize = fontSize;
                                }
                                else if (data[i].textStyle) {
                                    labelSize = zrArea.getTextWidth(
                                        chainPoint[i].name,
                                        chainPoint[i].textFont
                                    );
                                }
                                else {
                                    // 不定义data级特殊文本样式，用fontSize优化getTextWidth
                                    var label = chainPoint[i].name + &#x27;&#x27;;
                                    var wLen = (label.match(/\w/g) || &#x27;&#x27;).length;
                                    var oLen = label.length - wLen;
                                    labelSize = wLen * fontSize * 2 / 3 + oLen * fontSize;
                                }

                                if (labelSpace &lt; labelSize) {
                                    // 放不下，中断循环让interval++
                                    isEnough = false;
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        // 少于3个则全部显示
                        interval = 1;
                    }
                }
                else {
                    // 用户自定义间隔
                    interval = interval - 0 + 1;
                }

                return interval;
            },

            /**
             * 根据选项计算时间链条上的坐标及symbolList
             */
            _getChainPoint : function() {
                var timelineOption = this.timelineOption;
                var symbol = timelineOption.symbol.toLowerCase();
                var symbolSize = timelineOption.symbolSize;
                var rotate = timelineOption.label.rotate;
                var textStyle = timelineOption.label.textStyle;
                var textFont = this.getFont(textStyle);
                var dataTextStyle;
                var data = timelineOption.data;
                var x = this._location.x;
                var y = this._location.y + this._location.height / 4 * 3;
                var width = this._location.x2 - this._location.x;
                var len = data.length;

                function _getName(i) {
                    return typeof data[i].name != &#x27;undefined&#x27; ? data[i].name : data[i];
                }
                var xList = [];
                if (len &gt; 1) {
                    var boundaryGap = width / len;
                    boundaryGap = boundaryGap &gt; 50 ? 50 : (boundaryGap &lt; 20 ? 5 : boundaryGap);
                    width -= boundaryGap * 2;
                    if (timelineOption.type == &#x27;number&#x27;) {
                        // 平均分布
                        for (var i = 0; i &lt; len; i++) {
                            xList.push(x + boundaryGap + width / (len - 1) * i);
                        }
                    }
                    else {
                        // 时间比例
                        xList[0] = new Date(_getName(0).replace(/-/g, &#x27;/&#x27;));
                        xList[len - 1] = new Date(_getName(len - 1).replace(/-/g, &#x27;/&#x27;)) - xList[0];
                        for (var i = 1; i &lt; len; i++) {
                            xList[i] =  x + boundaryGap
                                + width
                                * (new Date(_getName(i).replace(/-/g, &#x27;/&#x27;)) - xList[0])
                                / xList[len - 1];
                        }
                        xList[0] = x + boundaryGap;
                    }
                }
                else {
                    xList.push(x + width / 2);
                }

                var list = [];
                var curSymbol;
                var n;
                var isEmpty;
                var textAlign;
                var rotation;
                for (var i = 0; i &lt; len; i++) {
                    x = xList[i];
                    curSymbol = (data[i].symbol &amp;&amp; data[i].symbol.toLowerCase()) || symbol;
                    if (curSymbol.match(&#x27;empty&#x27;)) {
                        curSymbol = curSymbol.replace(&#x27;empty&#x27;, &#x27;&#x27;);
                        isEmpty = true;
                    }
                    else {
                        isEmpty = false;
                    }
                    if (curSymbol.match(&#x27;star&#x27;)) {
                        n = (curSymbol.replace(&#x27;star&#x27;,&#x27;&#x27;) - 0) || 5;
                        curSymbol = &#x27;star&#x27;;
                    }

                    dataTextStyle = data[i].textStyle
                        ? zrUtil.merge(data[i].textStyle || {}, textStyle)
                        : textStyle;

                    textAlign = dataTextStyle.align || &#x27;center&#x27;;

                    if (rotate) {
                        textAlign = rotate &gt; 0 ? &#x27;right&#x27; : &#x27;left&#x27;;
                        rotation = [rotate * Math.PI / 180, x, y - 5];
                    }
                    else {
                        rotation = false;
                    }

                    list.push({
                        x : x,
                        n : n,
                        isEmpty : isEmpty,
                        symbol : curSymbol,
                        symbolSize : data[i].symbolSize || symbolSize,
                        color : data[i].color,
                        borderColor : data[i].borderColor,
                        borderWidth : data[i].borderWidth,
                        name : this._getReformedLabel(i),
                        textColor : dataTextStyle.color,
                        textAlign : textAlign,
                        textBaseline : dataTextStyle.baseline || &#x27;middle&#x27;,
                        textX : x,
                        textY : y - (rotate ? 5 : 0),
                        textFont : data[i].textStyle ? this.getFont(dataTextStyle) : textFont,
                        rotation : rotation,
                        showLabel : false
                    });
                }

                return list;
            },

            _buildBackground : function () {
                var timelineOption = this.timelineOption;
                var padding = timelineOption.padding;
                var width = this._location.width;
                var height = this._location.height;

                if (timelineOption.borderWidth !== 0
                    || timelineOption.backgroundColor.replace(/\s/g,&#x27;&#x27;) != &#x27;rgba(0,0,0,0)&#x27;
                    ) {
                    // 背景
                    this.shapeList.push(new RectangleShape({
                        zlevel : this._zlevelBase,
                        hoverable :false,
                        style : {
                            x : this._location.x - padding[3],
                            y : this._location.y - padding[0],
                            width : width + padding[1] + padding[3],
                            height : height + padding[0] + padding[2],
                            brushType : timelineOption.borderWidth === 0
                                ? &#x27;fill&#x27; : &#x27;both&#x27;,
                            color : timelineOption.backgroundColor,
                            strokeColor : timelineOption.borderColor,
                            lineWidth : timelineOption.borderWidth
                        }
                    }));
                }
            },

            _buildControl : function() {
                var self = this;
                var timelineOption = this.timelineOption;
                var lineStyle = timelineOption.lineStyle;
                var controlStyle = timelineOption.controlStyle;
                if (timelineOption.controlPosition == &#x27;none&#x27;) {
                    return;
                }
                var iconSize = 15;
                var iconGap = 5;
                var x;
                if (timelineOption.controlPosition == &#x27;left&#x27;) {
                    x = this._location.x;
                    this._location.x += (iconSize + iconGap) * 3;
                }
                else {
                    x = this._location.x2 - ((iconSize + iconGap) * 3 - iconGap);
                    this._location.x2 -= (iconSize + iconGap) * 3;
                }

                var y = this._location.y;
                var iconStyle = {
                    zlevel : this._zlevelBase + 1,
                    style : {
                        iconType : &#x27;timelineControl&#x27;,
                        symbol : &#x27;last&#x27;,
                        x : x,
                        y : y,
                        width : iconSize,
                        height : iconSize,
                        brushType : &#x27;stroke&#x27;,
                        color: controlStyle.normal.color,
                        strokeColor : controlStyle.normal.color,
                        lineWidth : lineStyle.width
                    },
                    highlightStyle : {
                        color : controlStyle.emphasis.color,
                        strokeColor : controlStyle.emphasis.color,
                        lineWidth : lineStyle.width + 1
                    },
                    clickable : true
                };

                this._ctrLastShape = new IconShape(iconStyle);
                this._ctrLastShape.onclick = function() {
                    self.last();
                };
                this.shapeList.push(this._ctrLastShape);

                x += iconSize + iconGap;
                this._ctrPlayShape = new IconShape(zrUtil.clone(iconStyle));
                this._ctrPlayShape.style.brushType = &#x27;fill&#x27;;
                this._ctrPlayShape.style.symbol = &#x27;play&#x27;;
                this._ctrPlayShape.style.status = this.timelineOption.autoPlay ? &#x27;playing&#x27; : &#x27;stop&#x27;;
                this._ctrPlayShape.style.x = x;
                this._ctrPlayShape.onclick = function() {
                    if (self._ctrPlayShape.style.status == &#x27;stop&#x27;) {
                        self.play();
                    }
                    else {
                        self.stop();
                    }
                };
                this.shapeList.push(this._ctrPlayShape);

                x += iconSize + iconGap;
                this._ctrNextShape = new IconShape(zrUtil.clone(iconStyle));
                this._ctrNextShape.style.symbol = &#x27;next&#x27;;
                this._ctrNextShape.style.x = x;
                this._ctrNextShape.onclick = function() {
                    self.next();
                };
                this.shapeList.push(this._ctrNextShape);
            },

            /**
             * 构建时间轴
             */
            _buildChain : function () {
                var timelineOption = this.timelineOption;
                var lineStyle = timelineOption.lineStyle;
                this._timelineShae = {
                    zlevel : this._zlevelBase,
                    style : {
                        x : this._location.x,
                        y : this.subPixelOptimize(this._location.y, lineStyle.width),
                        width : this._location.x2 - this._location.x,
                        height : this._location.height,
                        chainPoint : this._chainPoint,
                        brushType:&#x27;both&#x27;,
                        strokeColor : lineStyle.color,
                        lineWidth : lineStyle.width,
                        lineType : lineStyle.type
                    },
                    hoverable : false,
                    clickable : true,
                    onclick : this._onclick
                };

                this._timelineShae = new ChainShape(this._timelineShae);
                this.shapeList.push(this._timelineShae);
            },

            /**
             * 构建拖拽手柄
             */
            _buildHandle : function () {
                var curPoint = this._chainPoint[this.currentIndex];
                var symbolSize = curPoint.symbolSize + 1;
                symbolSize = symbolSize &lt; 5 ? 5 : symbolSize;

                this._handleShape = {
                    zlevel : this._zlevelBase + 1,
                    hoverable : false,
                    draggable : true,
                    style : {
                        iconType : &#x27;diamond&#x27;,
                        n : curPoint.n,
                        x : curPoint.x - symbolSize,
                        y : this._location.y + this._location.height / 4 - symbolSize,
                        width : symbolSize * 2,
                        height : symbolSize * 2,
                        brushType:&#x27;both&#x27;,
                        textPosition : &#x27;specific&#x27;,
                        textX : curPoint.x,
                        textY : this._location.y - this._location.height / 4,
                        textAlign : &#x27;center&#x27;,
                        textBaseline : &#x27;middle&#x27;
                    },
                    highlightStyle : {},
                    ondrift : this._ondrift,
                    ondragend : this._ondragend
                };

                this._handleShape = new IconShape(this._handleShape);
                this.shapeList.push(this._handleShape);
            },

            /**
             * 同步拖拽图形样式
             */
            _syncHandleShape : function() {
                if (!this.timelineOption.show) {
                    return;
                }

                var timelineOption = this.timelineOption;
                var cpStyle = timelineOption.checkpointStyle;
                var curPoint = this._chainPoint[this.currentIndex];

                this._handleShape.style.text = cpStyle.label.show ? curPoint.name : &#x27;&#x27;;
                this._handleShape.style.textFont = curPoint.textFont;

                this._handleShape.style.n = curPoint.n;
                if (cpStyle.symbol == &#x27;auto&#x27;) {
                    this._handleShape.style.iconType = curPoint.symbol != &#x27;none&#x27;
                        ? curPoint.symbol : &#x27;diamond&#x27;;
                }
                else {
                    this._handleShape.style.iconType = cpStyle.symbol;
                    if (cpStyle.symbol.match(&#x27;star&#x27;)) {
                        this._handleShape.style.n = (cpStyle.symbol.replace(&#x27;star&#x27;,&#x27;&#x27;) - 0) || 5;
                        this._handleShape.style.iconType = &#x27;star&#x27;;
                    }
                }

                var symbolSize;
                if (cpStyle.symbolSize == &#x27;auto&#x27;) {
                    symbolSize = curPoint.symbolSize + 2;
                    symbolSize = symbolSize &lt; 5 ? 5 : symbolSize;
                }
                else {
                    symbolSize = cpStyle.symbolSize - 0;
                }

                this._handleShape.style.color = cpStyle.color == &#x27;auto&#x27;
                    ? (curPoint.color
                    ? curPoint.color
                    : timelineOption.controlStyle.emphasis.color
                    )
                    : cpStyle.color;
                this._handleShape.style.textColor = cpStyle.label.textStyle.color == &#x27;auto&#x27;
                    ? this._handleShape.style.color
                    : cpStyle.label.textStyle.color;
                this._handleShape.highlightStyle.strokeColor =
                    this._handleShape.style.strokeColor = cpStyle.borderColor == &#x27;auto&#x27;
                        ? (curPoint.borderColor ? curPoint.borderColor : &#x27;#fff&#x27;)
                        : cpStyle.borderColor;
                this._handleShape.style.lineWidth = cpStyle.borderWidth == &#x27;auto&#x27;
                    ? (curPoint.borderWidth ? curPoint.borderWidth : 0)
                    : (cpStyle.borderWidth - 0);
                this._handleShape.highlightStyle.lineWidth = this._handleShape.style.lineWidth + 1;

                this.zr.animate(this._handleShape.id, &#x27;style&#x27;)
                    .when(
                    500,
                    {
                        x : curPoint.x - symbolSize,
                        textX : curPoint.x,
                        y : this._location.y + this._location.height / 4 - symbolSize,
                        width : symbolSize * 2,
                        height : symbolSize * 2
                    }
                )
                    .start(&#x27;ExponentialOut&#x27;);
            },

            _findChainIndex : function(x) {
                var chainPoint = this._chainPoint;
                var len = chainPoint.length;
                if (x &lt;= chainPoint[0].x) {
                    return 0;
                }
                else if (x &gt;= chainPoint[len - 1].x) {
                    return len - 1;
                }
                for (var i = 0; i &lt; len - 1; i++) {
                    if (x &gt;= chainPoint[i].x &amp;&amp; x &lt;= chainPoint[i + 1].x) {
                        // catch you！
                        return (Math.abs(x - chainPoint[i].x) &lt; Math.abs(x - chainPoint[i + 1].x))
                            ? i : (i + 1);
                    }
                }
            },

            __onclick : function(param) {
                var x = zrEvent.getX(param.event);
                var newIndex =  this._findChainIndex(x);
                if (newIndex == this.currentIndex) {
                    return true; // 啥事都没发生
                }

                this.currentIndex = newIndex;
                this.timelineOption.autoPlay &amp;&amp; this.stop(); // 停止自动播放
                clearTimeout(this.playTicket);
                this._onFrame();
            },

            /**
             * 拖拽范围控制
             */
            __ondrift : function (shape, dx) {
                this.timelineOption.autoPlay &amp;&amp; this.stop(); // 停止自动播放

                var chainPoint = this._chainPoint;
                var len = chainPoint.length;
                var newIndex;
                if (shape.style.x + dx &lt;= chainPoint[0].x - chainPoint[0].symbolSize) {
                    shape.style.x = chainPoint[0].x - chainPoint[0].symbolSize;
                    newIndex = 0;
                }
                else if (shape.style.x + dx &gt;= chainPoint[len - 1].x - chainPoint[len - 1].symbolSize) {
                    shape.style.x = chainPoint[len - 1].x - chainPoint[len - 1].symbolSize;
                    newIndex = len - 1;
                }
                else {
                    shape.style.x += dx;
                    newIndex = this._findChainIndex(shape.style.x);
                }
                var curPoint = chainPoint[newIndex];
                var symbolSize = curPoint.symbolSize + 2;
                shape.style.iconType = curPoint.symbol;
                shape.style.n = curPoint.n;
                shape.style.textX = shape.style.x + symbolSize / 2;
                shape.style.y = this._location.y + this._location.height / 4 - symbolSize;
                shape.style.width = symbolSize * 2;
                shape.style.height = symbolSize * 2;
                shape.style.text = curPoint.name;

                //console.log(newIndex)
                if (newIndex == this.currentIndex) {
                    return true; // 啥事都没发生
                }

                this.currentIndex = newIndex;
                if (this.timelineOption.realtime) {
                    clearTimeout(this.playTicket);
                    var self = this;
                    this.playTicket = setTimeout(function() {
                        self._setCurrentOption();
                    },200);
                }

                return true;
            },

            __ondragend : function () {
                this.isDragend = true;
            },

            /**
             * 数据项被拖拽出去
             */
            ondragend : function (param, status) {
                if (!this.isDragend || !param.target) {
                    // 没有在当前实例上发生拖拽行为则直接返回
                    return;
                }
                !this.timelineOption.realtime &amp;&amp; this._setCurrentOption();

                // 别status = {}赋值啊！！
                status.dragOut = true;
                status.dragIn = true;
                status.needRefresh = false; // 会有消息触发fresh，不用再刷一遍
                // 处理完拖拽事件后复位
                this.isDragend = false;
                this._syncHandleShape();
                return;
            },

            last : function () {
                this.timelineOption.autoPlay &amp;&amp; this.stop(); // 停止自动播放

                this.currentIndex -= 1;
                if (this.currentIndex &lt; 0) {
                    this.currentIndex = this.timelineOption.data.length - 1;
                }
                this._onFrame();

                return this.currentIndex;
            },

            next : function () {
                this.timelineOption.autoPlay &amp;&amp; this.stop(); // 停止自动播放

                this.currentIndex += 1;
                if (this.currentIndex &gt;= this.timelineOption.data.length) {
                    this.currentIndex = 0;
                }
                this._onFrame();

                return this.currentIndex;
            },

            play : function (targetIndex, autoPlay) {
                if (this._ctrPlayShape &amp;&amp; this._ctrPlayShape.style.status != &#x27;playing&#x27;) {
                    this._ctrPlayShape.style.status = &#x27;playing&#x27;;
                    this.zr.modShape(this._ctrPlayShape.id);
                    this.zr.refresh();
                }


                this.timelineOption.autoPlay = typeof autoPlay != &#x27;undefined&#x27;
                    ? autoPlay : true;

                if (!this.timelineOption.autoPlay) {
                    clearTimeout(this.playTicket);
                }

                this.currentIndex = typeof targetIndex != &#x27;undefined&#x27;
                    ? targetIndex : (this.currentIndex + 1);
                if (this.currentIndex &gt;= this.timelineOption.data.length) {
                    this.currentIndex = 0;
                }
                this._onFrame();

                return this.currentIndex;
            },

            stop : function () {
                if (this._ctrPlayShape &amp;&amp; this._ctrPlayShape.style.status != &#x27;stop&#x27;) {
                    this._ctrPlayShape.style.status = &#x27;stop&#x27;;
                    this.zr.modShape(this._ctrPlayShape.id);
                    this.zr.refresh();
                }

                this.timelineOption.autoPlay = false;

                clearTimeout(this.playTicket);

                return this.currentIndex;
            },

            /**
             * 避免dataZoom带来两次refresh，不设refresh接口，resize重复一下buildshape逻辑
             */
            resize : function () {
                if (this.timelineOption.show) {
                    this.clear();
                    this._buildShape();
                    this._syncHandleShape();
                }
            },

            setTheme : function(needRefresh) {
                this.timelineOption = this.reformOption(zrUtil.clone(this.option.timeline));
                // 补全padding属性
                this.timelineOption.padding = this.reformCssArray(
                    this.timelineOption.padding
                );
                // 通用字体设置
                this.timelineOption.label.textStyle = zrUtil.merge(
                        this.timelineOption.label.textStyle || {},
                    this.ecTheme.textStyle
                );
                this.timelineOption.checkpointStyle.label.textStyle = zrUtil.merge(
                        this.timelineOption.checkpointStyle.label.textStyle || {},
                    this.ecTheme.textStyle
                );

                if (this.timelineOption.show &amp;&amp; needRefresh) {
                    this.clear();
                    this._buildShape();
                    this._syncHandleShape();
                }
            },

            /**
             * 释放后实例不可用，重载基类方法
             */
            dispose : function () {
                this.clear();
                this.shapeList = null;

                clearTimeout(this.playTicket);
            }
        };

        function timelineControl(ctx, style) {
            var lineWidth = 2;//style.lineWidth;
            var x = style.x + lineWidth;
            var y = style.y + lineWidth + 2;
            var width = style.width - lineWidth;
            var height = style.height - lineWidth;


            var symbol = style.symbol;
            if (symbol == &#x27;last&#x27;) {
                ctx.moveTo(x + width - 2, y + height / 3);
                ctx.lineTo(x + width - 2, y);
                ctx.lineTo(x + 2, y + height / 2);
                ctx.lineTo(x + width - 2, y + height);
                ctx.lineTo(x + width - 2, y + height / 3 * 2);
                ctx.moveTo(x, y);
                ctx.lineTo(x, y);
            }
            else if (symbol == &#x27;next&#x27;) {
                ctx.moveTo(x + 2, y + height / 3);
                ctx.lineTo(x + 2, y);
                ctx.lineTo(x + width - 2, y + height / 2);
                ctx.lineTo(x + 2, y + height);
                ctx.lineTo(x + 2, y + height / 3 * 2);
                ctx.moveTo(x, y);
                ctx.lineTo(x, y);
            }
            else if (symbol == &#x27;play&#x27;) {
                if (style.status == &#x27;stop&#x27;) {
                    ctx.moveTo(x + 2, y);
                    ctx.lineTo(x + width - 2, y + height / 2);
                    ctx.lineTo(x + 2, y + height);
                    ctx.lineTo(x + 2, y);
                }
                else {
                    var delta = style.brushType == &#x27;both&#x27; ? 2 : 3;
                    ctx.rect(x + 2, y, delta, height);
                    ctx.rect(x + width - delta - 2, y, delta, height);
                }
            }
            else if (symbol.match(&#x27;image&#x27;)) {
                var imageLocation = &#x27;&#x27;;
                imageLocation = symbol.replace(
                    new RegExp(&#x27;^image:\\/\\/&#x27;), &#x27;&#x27;
                );
                symbol = IconShape.prototype.iconLibrary.image;
                symbol(ctx, {
                    x : x,
                    y : y,
                    width : width,
                    height : height,
                    image : imageLocation
                });
            }
        }
        IconShape.prototype.iconLibrary[&#x27;timelineControl&#x27;] = timelineControl;

        zrUtil.inherits(Timeline, Base);

        require(&#x27;../component&#x27;).define(&#x27;timeline&#x27;, Timeline);

        return Timeline;
    });

    define(
        &#x27;zrender/loadingEffect/Bar&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;,&#x27;../tool/color&#x27;,&#x27;../shape/Rectangle&#x27;],function (require) {
            var Base = require(&#x27;./Base&#x27;);
            var util = require(&#x27;../tool/util&#x27;);
            var zrColor = require(&#x27;../tool/color&#x27;);
            var RectangleShape = require(&#x27;../shape/Rectangle&#x27;);

            function Bar(options) {
                Base.call(this, options);
            }
            util.inherits(Bar, Base);


            /**
             * 进度条
             *
             * @param {Object} addShapeHandle
             * @param {Object} refreshHandle
             */
            Bar.prototype._start = function (addShapeHandle, refreshHandle) {
                // 特效默认配置
                var options = util.merge(
                    this.options,
                    {
                        textStyle : {
                            color : &#x27;#888&#x27;
                        },
                        backgroundColor : &#x27;rgba(250, 250, 250, 0.8)&#x27;,
                        effectOption : {
                            x : 0,
                            y : this.canvasHeight / 2 - 30,
                            width : this.canvasWidth,
                            height : 5,
                            brushType : &#x27;fill&#x27;,
                            timeInterval : 100
                        }
                    }
                );

                var textShape = this.createTextShape(options.textStyle);
                var background = this.createBackgroundShape(options.backgroundColor);

                var effectOption = options.effectOption;

                // 初始化动画元素
                var barShape = new RectangleShape({
                    highlightStyle : util.clone(effectOption)
                });

                barShape.highlightStyle.color =
                    effectOption.color
                    || zrColor.getLinearGradient(
                    effectOption.x,
                    effectOption.y,
                        effectOption.x + effectOption.width,
                        effectOption.y + effectOption.height,
                    [[0, &#x27;#ff6400&#x27;], [0.5, &#x27;#ffe100&#x27;], [1, &#x27;#b1ff00&#x27;]]
                );

                if (options.progress != null) {
                    // 指定进度
                    addShapeHandle(background);

                    barShape.highlightStyle.width =
                        _adjust(options.progress, [0,1])
                        * options.effectOption.width;

                    addShapeHandle(barShape);
                    addShapeHandle(textShape);

                    refreshHandle();
                    return;
                }
                else {
                    // 循环显示
                    barShape.highlightStyle.width = 0;
                    return setInterval(
                        function() {
                            addShapeHandle(background);

                            if (barShape.highlightStyle.width &lt; effectOption.width) {
                                barShape.highlightStyle.width += 8;
                            }
                            else {
                                barShape.highlightStyle.width = 0;
                            }
                            addShapeHandle(barShape);
                            addShapeHandle(textShape);
                            refreshHandle();
                        },
                        effectOption.timeInterval
                    );
                }
            };

            return Bar;
        }
    );


    define(
        &#x27;zrender/loadingEffect/Bubble&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;,&#x27;../tool/color&#x27;,&#x27;../shape/Circle&#x27;],function (require) {
            var Base = require(&#x27;./Base&#x27;);
            var util = require(&#x27;../tool/util&#x27;);
            var zrColor = require(&#x27;../tool/color&#x27;);
            var CircleShape = require(&#x27;../shape/Circle&#x27;);

            function Bubble(options) {
                Base.call(this, options);
            }
            util.inherits(Bubble, Base);

            /**
             * 泡泡
             *
             * @param {Object} addShapeHandle
             * @param {Object} refreshHandle
             */
            Bubble.prototype._start = function (addShapeHandle, refreshHandle) {

                // 特效默认配置
                var options = util.merge(
                    this.options,
                    {
                        textStyle : {
                            color : &#x27;#888&#x27;
                        },
                        backgroundColor : &#x27;rgba(250, 250, 250, 0.8)&#x27;,
                        effect : {
                            n : 50,
                            lineWidth : 2,
                            brushType : &#x27;stroke&#x27;,
                            color : &#x27;random&#x27;,
                            timeInterval : 100
                        }
                    }
                );

                var textShape = this.createTextShape(options.textStyle);
                var background = this.createBackgroundShape(options.backgroundColor);

                var effectOption = options.effect;
                var n = effectOption.n;
                var brushType = effectOption.brushType;
                var lineWidth = effectOption.lineWidth;

                var shapeList = [];

                // 初始化动画元素
                for(var i = 0; i &lt; n; i++) {
                    var color = effectOption.color == &#x27;random&#x27;
                        ? zrColor.alpha(zrColor.random(), 0.3)
                        : effectOption.color;

                    shapeList[i] = new CircleShape({
                        highlightStyle : {
                            x : Math.ceil(Math.random() * this.canvasWidth),
                            y : Math.ceil(Math.random() * this.canvasHeight),
                            r : Math.ceil(Math.random() * 40),
                            brushType : brushType,
                            color : color,
                            strokeColor : color,
                            lineWidth : lineWidth
                        },
                        animationY : Math.ceil(Math.random() * 20)
                    });
                }

                return setInterval(
                    function () {
                        addShapeHandle(background);

                        for(var i = 0; i &lt; n; i++) {
                            var style = shapeList[i].highlightStyle;

                            if (style.y - shapeList[i].animationY + style.r &lt;= 0){
                                shapeList[i].highlightStyle.y = this.canvasHeight + style.r;
                                shapeList[i].highlightStyle.x = Math.ceil(
                                        Math.random() * this.canvasWidth
                                );
                            }
                            shapeList[i].highlightStyle.y -=
                                shapeList[i].animationY;

                            addShapeHandle(shapeList[i]);
                        }

                        addShapeHandle(textShape);
                        refreshHandle();
                    },
                    effectOption.timeInterval
                );
            };

            return Bubble;
        }
    );


    define(
        &#x27;zrender/loadingEffect/DynamicLine&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;,&#x27;../tool/color&#x27;,&#x27;../shape/Line&#x27;],function (require) {
            var Base = require(&#x27;./Base&#x27;);
            var util = require(&#x27;../tool/util&#x27;);
            var zrColor = require(&#x27;../tool/color&#x27;);
            var LineShape = require(&#x27;../shape/Line&#x27;);

            function DynamicLine(options) {
                Base.call(this, options);
            }
            util.inherits(DynamicLine, Base);


            /**
             * 动态线
             *
             * @param {Object} addShapeHandle
             * @param {Object} refreshHandle
             */
            DynamicLine.prototype._start = function (addShapeHandle, refreshHandle) {
                // 特效默认配置
                var options = util.merge(
                    this.options,
                    {
                        textStyle : {
                            color : &#x27;#fff&#x27;
                        },
                        backgroundColor : &#x27;rgba(0, 0, 0, 0.8)&#x27;,
                        effectOption : {
                            n : 30,
                            lineWidth : 1,
                            color : &#x27;random&#x27;,
                            timeInterval : 100
                        }
                    }
                );

                var textShape = this.createTextShape(options.textStyle);
                var background = this.createBackgroundShape(options.backgroundColor);

                var effectOption = options.effectOption;
                var n = effectOption.n;
                var lineWidth = effectOption.lineWidth;

                var shapeList = [];

                // 初始化动画元素
                for(var i = 0; i &lt; n; i++) {
                    var xStart = -Math.ceil(Math.random() * 1000);
                    var len = Math.ceil(Math.random() * 400);
                    var pos = Math.ceil(Math.random() * this.canvasHeight);

                    var color = effectOption.color == &#x27;random&#x27;
                        ? zrColor.random()
                        : effectOption.color;

                    shapeList[i] = new LineShape({
                        highlightStyle : {
                            xStart : xStart,
                            yStart : pos,
                            xEnd : xStart + len,
                            yEnd : pos,
                            strokeColor : color,
                            lineWidth : lineWidth
                        },
                        animationX : Math.ceil(Math.random() * 100),
                        len : len
                    });
                }

                return setInterval(
                    function() {
                        addShapeHandle(background);

                        for(var i = 0; i &lt; n; i++) {
                            var style = shapeList[i].highlightStyle;

                            if (style.xStart &gt;= this.canvasWidth){
                                shapeList[i].len = Math.ceil(Math.random() * 400);
                                style.xStart = -400;
                                style.xEnd = -400 + shapeList[i].len;
                                style.yStart = Math.ceil(Math.random() * this.canvasHeight);
                                style.yEnd = style.yStart;
                            }

                            style.xStart += shapeList[i].animationX;
                            style.xEnd += shapeList[i].animationX;

                            addShapeHandle(shapeList[i]);
                        }

                        addShapeHandle(textShape);
                        refreshHandle();
                    },
                    effectOption.timeInterval
                );
            };

            return DynamicLine;
        }
    );


    define(
        &#x27;zrender/loadingEffect/Ring&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;,&#x27;../tool/color&#x27;,&#x27;../shape/Ring&#x27;,&#x27;../shape/Sector&#x27;],function (require) {
            var Base = require(&#x27;./Base&#x27;);
            var util = require(&#x27;../tool/util&#x27;);
            var zrColor = require(&#x27;../tool/color&#x27;);
            var RingShape = require(&#x27;../shape/Ring&#x27;);
            var SectorShape = require(&#x27;../shape/Sector&#x27;);

            function Ring(options) {
                Base.call(this, options);
            }
            util.inherits(Ring, Base);


            /**
             * 圆环
             *
             * @param {Object} addShapeHandle
             * @param {Object} refreshHandle
             */
            Ring.prototype._start = function (addShapeHandle, refreshHandle) {

                // 特效默认配置
                var options = util.merge(
                    this.options,
                    {
                        textStyle : {
                            color : &#x27;#07a&#x27;
                        },
                        backgroundColor : &#x27;rgba(250, 250, 250, 0.8)&#x27;,
                        effect : {
                            x : this.canvasWidth / 2,
                            y : this.canvasHeight / 2,
                            r0 : 60,
                            r : 100,
                            color : &#x27;#bbdcff&#x27;,
                            brushType: &#x27;fill&#x27;,
                            textPosition : &#x27;inside&#x27;,
                            textFont : &#x27;normal 30px verdana&#x27;,
                            textColor : &#x27;rgba(30, 144, 255, 0.6)&#x27;,
                            timeInterval : 100
                        }
                    }
                );

                var effectOption = options.effect;

                var textStyle = options.textStyle;
                if (textStyle.x == null) {
                    textStyle.x = effectOption.x;
                }
                if (textStyle.y == null) {
                    textStyle.y = (effectOption.y + (effectOption.r0 + effectOption.r) / 2 - 5);
                }

                var textShape = this.createTextShape(options.textStyle);
                var background = this.createBackgroundShape(options.backgroundColor);

                var x = effectOption.x;
                var y = effectOption.y;
                var r0 = effectOption.r0 + 6;
                var r = effectOption.r - 6;
                var color = effectOption.color;
                var darkColor = zrColor.lift(color, 0.1);

                var shapeRing = new RingShape({
                    highlightStyle : util.clone(effectOption)
                });

                // 初始化动画元素
                var shapeList = [];
                var clolrList = zrColor.getGradientColors(
                    [&#x27;#ff6400&#x27;, &#x27;#ffe100&#x27;, &#x27;#97ff00&#x27;], 25
                );
                var preAngle = 15;
                var endAngle = 240;

                for(var i = 0; i &lt; 16; i++) {
                    shapeList.push(new SectorShape({
                        highlightStyle  : {
                            x : x,
                            y : y,
                            r0 : r0,
                            r : r,
                            startAngle : endAngle - preAngle,
                            endAngle : endAngle,
                            brushType: &#x27;fill&#x27;,
                            color : darkColor
                        },
                        _color : zrColor.getLinearGradient(
                                x + r0 * Math.cos(endAngle, true),
                                y - r0 * Math.sin(endAngle, true),
                                x + r0 * Math.cos(endAngle - preAngle, true),
                                y - r0 * Math.sin(endAngle - preAngle, true),
                            [
                                [0, clolrList[i * 2]],
                                [1, clolrList[i * 2 + 1]]
                            ]
                        )
                    }));
                    endAngle -= preAngle;
                }
                endAngle = 360;
                for(var i = 0; i &lt; 4; i++) {
                    shapeList.push(new SectorShape({
                        highlightStyle  : {
                            x : x,
                            y : y,
                            r0 : r0,
                            r : r,
                            startAngle : endAngle - preAngle,
                            endAngle : endAngle,
                            brushType: &#x27;fill&#x27;,
                            color : darkColor
                        },
                        _color : zrColor.getLinearGradient(
                                x + r0 * Math.cos(endAngle, true),
                                y - r0 * Math.sin(endAngle, true),
                                x + r0 * Math.cos(endAngle - preAngle, true),
                                y - r0 * Math.sin(endAngle - preAngle, true),
                            [
                                [0, clolrList[i * 2 + 32]],
                                [1, clolrList[i * 2 + 33]]
                            ]
                        )
                    }));
                    endAngle -= preAngle;
                }

                var n = 0;
                if (options.progress != null) {
                    // 指定进度
                    addShapeHandle(background);

                    n = _adjust(options.progress, [0,1]).toFixed(2) * 100 / 5;
                    shapeRing.highlightStyle.text = n * 5 + &#x27;%&#x27;;
                    addShapeHandle(shapeRing);

                    for(var i = 0; i &lt; 20; i++) {
                        shapeList[i].highlightStyle.color = i &lt; n
                            ? shapeList[i]._color : darkColor;
                        addShapeHandle(shapeList[i]);
                    }

                    addShapeHandle(textShape);
                    refreshHandle();
                    return;
                }

                // 循环显示
                return setInterval(
                    function() {
                        addShapeHandle(background);

                        n += n &gt;= 20 ? -20 : 1;

                        //shapeRing.highlightStyle.text = n * 5 + &#x27;%&#x27;;
                        addShapeHandle(shapeRing);

                        for(var i = 0; i &lt; 20; i++) {
                            shapeList[i].highlightStyle.color = i &lt; n
                                ? shapeList[i]._color : darkColor;
                            addShapeHandle(shapeList[i]);
                        }

                        addShapeHandle(textShape);
                        refreshHandle();
                    },
                    effectOption.timeInterval
                );
            };

            return Ring;
        }
    );


    define(
        &#x27;zrender/loadingEffect/Spin&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;,&#x27;../tool/color&#x27;,&#x27;../shape/Sector&#x27;],function (require) {
            var Base = require(&#x27;./Base&#x27;);
            var util = require(&#x27;../tool/util&#x27;);
            var zrColor = require(&#x27;../tool/color&#x27;);
            var SectorShape = require(&#x27;../shape/Sector&#x27;);

            function Spin(options) {
                Base.call(this, options);
            }
            util.inherits(Spin, Base);

            /**
             * 旋转
             *
             * @param {Object} addShapeHandle
             * @param {Object} refreshHandle
             */
            Spin.prototype._start = function (addShapeHandle, refreshHandle) {
                // 特效默认配置
                var effectOption =  util.merge(
                        this.options.effect || {},
                    {
                        x : this.canvasWidth / 2 - 80,
                        y : this.canvasHeight / 2,
                        r0 : 9,
                        r : 15,
                        n : 18,
                        color : &#x27;#fff&#x27;,
                        timeInterval : 100
                    }
                );

                var options = util.merge(
                    this.options,
                    {
                        textStyle : {
                            color : &#x27;#fff&#x27;,
                            x : effectOption.x + effectOption.r + 10,
                            y : effectOption.y,
                            textAlign : &#x27;start&#x27;
                        },
                        backgroundColor : &#x27;rgba(0, 0, 0, 0.8)&#x27;
                    }
                );

                var textShape = this.createTextShape(options.textStyle);
                var background = this.createBackgroundShape(options.backgroundColor);

                var n = effectOption.n;
                var x = effectOption.x;
                var y = effectOption.y;
                var r0 = effectOption.r0;
                var r = effectOption.r;
                var color = effectOption.color;

                // 初始化动画元素
                var shapeList = [];
                var preAngle = Math.round(180 / n);
                for(var i = 0; i &lt; n; i++) {
                    shapeList[i] = new SectorShape({
                        highlightStyle  : {
                            x : x,
                            y : y,
                            r0 : r0,
                            r : r,
                            startAngle : preAngle * i * 2,
                            endAngle : preAngle * i * 2 + preAngle,
                            color : zrColor.alpha(color, (i + 1) / n),
                            brushType: &#x27;fill&#x27;
                        }
                    });
                }

                var pos = [0, x, y];

                return setInterval(
                    function() {
                        addShapeHandle(background);
                        pos[0] -= 0.3;
                        for(var i = 0; i &lt; n; i++) {
                            shapeList[i].rotation = pos;
                            addShapeHandle(shapeList[i]);
                        }

                        addShapeHandle(textShape);
                        refreshHandle();
                    },
                    effectOption.timeInterval
                );
            };

            return Spin;
        }
    );


    define(
        &#x27;zrender/loadingEffect/Whirling&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;,&#x27;../shape/Ring&#x27;,&#x27;../shape/Droplet&#x27;,&#x27;../shape/Circle&#x27;],function (require) {
            var Base = require(&#x27;./Base&#x27;);
            var util = require(&#x27;../tool/util&#x27;);
            var RingShape = require(&#x27;../shape/Ring&#x27;);
            var DropletShape = require(&#x27;../shape/Droplet&#x27;);
            var CircleShape = require(&#x27;../shape/Circle&#x27;);

            function Whirling(options) {
                Base.call(this, options);
            }
            util.inherits(Whirling, Base);

            /**
             * 旋转水滴
             *
             * @param {Object} addShapeHandle
             * @param {Object} refreshHandle
             */
            Whirling.prototype._start = function (addShapeHandle, refreshHandle) {
                // 特效默认配置
                var effectOption = util.merge(
                        this.options.effect || {},
                    {
                        x : this.canvasWidth / 2 - 80,
                        y : this.canvasHeight / 2,
                        r : 18,
                        colorIn : &#x27;#fff&#x27;,
                        colorOut : &#x27;#555&#x27;,
                        colorWhirl : &#x27;#6cf&#x27;,
                        timeInterval : 50
                    }
                );

                var options = util.merge(
                    this.options,
                    {
                        textStyle : {
                            color : &#x27;#888&#x27;,
                            x : effectOption.x + effectOption.r + 10,
                            y : effectOption.y,
                            textAlign : &#x27;start&#x27;
                        },
                        backgroundColor : &#x27;rgba(250, 250, 250, 0.8)&#x27;
                    }
                );

                var textShape = this.createTextShape(options.textStyle);
                var background = this.createBackgroundShape(options.backgroundColor);

                // 初始化动画元素
                var droplet = new DropletShape({
                    highlightStyle : {
                        a : Math.round(effectOption.r / 2),
                        b : Math.round(effectOption.r - effectOption.r / 6),
                        brushType : &#x27;fill&#x27;,
                        color : effectOption.colorWhirl
                    }
                });
                var circleIn = new CircleShape({
                    highlightStyle : {
                        r : Math.round(effectOption.r / 6),
                        brushType : &#x27;fill&#x27;,
                        color : effectOption.colorIn
                    }
                });
                var circleOut = new RingShape({
                    highlightStyle : {
                        r0 : Math.round(effectOption.r - effectOption.r / 3),
                        r : effectOption.r,
                        brushType : &#x27;fill&#x27;,
                        color : effectOption.colorOut
                    }
                });

                var pos = [0, effectOption.x, effectOption.y];

                droplet.highlightStyle.x
                    = circleIn.highlightStyle.x
                    = circleOut.highlightStyle.x
                    = pos[1];
                droplet.highlightStyle.y
                    = circleIn.highlightStyle.y
                    = circleOut.highlightStyle.y
                    = pos[2];

                return setInterval(
                    function() {
                        addShapeHandle(background);
                        addShapeHandle(circleOut);
                        pos[0] -= 0.3;
                        droplet.rotation = pos;
                        addShapeHandle(droplet);
                        addShapeHandle(circleIn);
                        addShapeHandle(textShape);
                        refreshHandle();
                    },
                    effectOption.timeInterval
                );
            };

            return Whirling;
        }
    );

    /**
     * echarts默认主题，开发中
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/theme/default&#x27;,[],function() {
        var config = {
        };

        return config;
    });
    /*!
     * ECharts, a javascript interactive chart library.
     *  
     * Copyright (c) 2014, Baidu Inc.
     * All rights reserved.
     * 
     * LICENSE
     * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt
     */

    /**
     * echarts
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/echarts&#x27;,[&#x27;require&#x27;,&#x27;./config&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/tool/env&#x27;,&#x27;zrender&#x27;,&#x27;zrender/config&#x27;,&#x27;zrender&#x27;,&#x27;zrender/tool/event&#x27;,&#x27;./chart/island&#x27;,&#x27;./component/toolbox&#x27;,&#x27;./component&#x27;,&#x27;./component/title&#x27;,&#x27;./component/tooltip&#x27;,&#x27;./component/legend&#x27;,&#x27;./util/ecData&#x27;,&#x27;./chart&#x27;,&#x27;./component&#x27;,&#x27;zrender/tool/color&#x27;,&#x27;./component/timeline&#x27;,&#x27;zrender&#x27;,&#x27;zrender/shape/Image&#x27;,&#x27;zrender/loadingEffect/Bar&#x27;,&#x27;zrender/loadingEffect/Bubble&#x27;,&#x27;zrender/loadingEffect/DynamicLine&#x27;,&#x27;zrender/loadingEffect/Ring&#x27;,&#x27;zrender/loadingEffect/Spin&#x27;,&#x27;zrender/loadingEffect/Whirling&#x27;,&#x27;./theme/default&#x27;],function (require) {
        var ecConfig = require(&#x27;./config&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);

        var self = {};

        var _canvasSupported = require(&#x27;zrender/tool/env&#x27;).canvasSupported;
        var _idBase = new Date() - 0;
        var _instances = {};    // ECharts实例map索引
        var DOM_ATTRIBUTE_KEY = &#x27;_echarts_instance_&#x27;;

        self.version = &#x27;2.0.0&#x27;;
        self.dependencies = {
            zrender : &#x27;2.0.0&#x27;
        };
        /**
         * 入口方法
         */
        self.init = function (dom, theme) {
            var zrender = require(&#x27;zrender&#x27;);
            if (((zrender.version || &#x27;1.0.3&#x27;).replace(&#x27;.&#x27;, &#x27;&#x27;) - 0)
                &lt; (self.dependencies.zrender.replace(&#x27;.&#x27;, &#x27;&#x27;) - 0)
                ) {
                console.error(
                        &#x27;ZRender &#x27; + (zrender.version || &#x27;1.0.3-&#x27;)
                        + &#x27; is too old for ECharts &#x27; + self.version
                        + &#x27;. Current version need ZRender &#x27;
                        + self.dependencies.zrender + &#x27;+&#x27;
                );
            }

            dom = dom instanceof Array ? dom[0] : dom;

            // dom与echarts实例映射索引
            var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
            if (!key) {
                key = _idBase++;
                dom.setAttribute(DOM_ATTRIBUTE_KEY, key);
            }

            if (_instances[key]) {
                // 同一个dom上多次init，自动释放已有实例
                _instances[key].dispose();
            }
            _instances[key] = new Echarts(dom);
            _instances[key].id = key;
            _instances[key].setTheme(theme);

            return  _instances[key];
        };

        /**
         * 通过id获得ECharts实例，id可在实例化后读取
         */
        self.getInstanceById = function (key) {
            return _instances[key];
        };

        /**
         * 基于zrender实现Echarts接口层
         * @param {HtmlElement} dom 必要
         */
        function Echarts(dom) {
            this._themeConfig = zrUtil.clone(ecConfig);

            this.dom = dom;
            // this._zr;
            // this._option;                    // curOption clone
            // this._optionRestore;             // for restore;
            // this._island;
            // this._toolbox;
            // this._timeline;
            // this._refreshInside;             // 内部刷新标志位

            this._connected = false;
            this._status = {                    // 用于图表间通信
                dragIn : false,
                dragOut : false,
                needRefresh : false
            };
            this._curEventType = false;         // 破循环信号灯
            this._chartList = [];               // 图表实例
            this._messageCenter = {};           // Echarts层的消息中心，做zrender原始事件转换
            this._messageCenterOutSide = {};    // Echarts层的外部消息中心，做Echarts层的消息转发

            // resize方法经常被绑定到window.resize上，闭包一个this
            this.resize = this.resize();

            // 初始化::构造函数
            this._init();
        }

        /**
         * ZRender EVENT
         *
         * @inner
         * @const
         * @type {Object}
         */
        var ZR_EVENT = require(&#x27;zrender/config&#x27;).EVENT;

        /**
         * 要绑定监听的zrender事件列表
         *
         * @const
         * @inner
         * @type {Array}
         */
        var ZR_EVENT_LISTENS = [
            &#x27;CLICK&#x27;, &#x27;MOUSEOVER&#x27;,
            &#x27;DRAGSTART&#x27;, &#x27;DRAGEND&#x27;, &#x27;DRAGENTER&#x27;, &#x27;DRAGOVER&#x27;, &#x27;DRAGLEAVE&#x27;, &#x27;DROP&#x27;
        ];

        /**
         * 对echarts的实例中的chartList属性成员，逐个进行方法调用，遍历顺序为逆序
         * 由于在事件触发的默认行为处理中，多次用到相同逻辑，所以抽象了该方法
         * 由于所有的调用场景里，最多只有两个参数，基于性能和体积考虑，这里就不使用call或者apply了
         *
         * @inner
         * @param {ECharts} ecInstance ECharts实例
         * @param {string} methodName 要调用的方法名
         * @param {*} arg0 调用参数1
         * @param {*} arg1 调用参数2
         * @param {*} arg2 调用参数3
         */
        function callChartListMethodReverse(ecInstance, methodName, arg0, arg1, arg2) {
            var chartList = ecInstance._chartList;
            var len = chartList.length;

            while (len--) {
                var chart = chartList[len];
                if (typeof chart[methodName] === &#x27;function&#x27;) {
                    chart[methodName](arg0, arg1, arg2);
                }
            }
        }

        Echarts.prototype = {
            /**
             * 初始化::构造函数
             */
            _init : function () {
                var self = this;
                var _zr = require(&#x27;zrender&#x27;).init(this.dom);
                this._zr = _zr;

                // 添加消息中心的事件分发器特性
                var zrEvent = require(&#x27;zrender/tool/event&#x27;);
                zrEvent.Dispatcher.call(this._messageCenter);
                zrEvent.Dispatcher.call(this._messageCenterOutSide);

                // wrap: n,e,d,t for name event data this
                this._messageCenter._dispatch = this._messageCenter.dispatch;
                this._messageCenter.dispatch = function(n,e,d,t) {
                    self._messageCenter._dispatch(n, e, d, t);
                    if (n != &#x27;HOVER&#x27;) {
                        setTimeout(function(){
                            self._messageCenterOutSide.dispatch(n,e,d,t)
                        },50);
                    }
                    else {
                        self._messageCenterOutSide.dispatch(n, e, d, t);
                    }
                }

                this._onevent = function(param){
                    return self.__onevent(param);
                };
                for (var e in ecConfig.EVENT) {
                    if (e != &#x27;CLICK&#x27; &amp;&amp; e != &#x27;HOVER&#x27; &amp;&amp; e != &#x27;MAP_ROAM&#x27;) {
                        this._messageCenter.bind(ecConfig.EVENT[e], this._onevent);
                    }
                }


                var eventBehaviors = {};
                this._onzrevent = function (param) {
                    return self[eventBehaviors[ param.type ]](param);
                };

                // 挂载关心的事件
                for (var i = 0, len = ZR_EVENT_LISTENS.length; i &lt; len; i++) {
                    var eventName = ZR_EVENT_LISTENS[i]
                    var eventValue = ZR_EVENT[eventName];
                    eventBehaviors[eventValue] = &#x27;_on&#x27; + eventName.toLowerCase();
                    _zr.on(eventValue, this._onzrevent);
                }

                this.chart = {};            // 图表索引
                this.component = {};        // 组件索引

                // 内置图表
                // 孤岛
                var Island = require(&#x27;./chart/island&#x27;);
                this._island = new Island(this._themeConfig, this._messageCenter, _zr, {}, this);
                this.chart.island = this._island;

                // 内置通用组件
                // 工具箱
                var Toolbox = require(&#x27;./component/toolbox&#x27;);
                this._toolbox = new Toolbox(this._themeConfig, this._messageCenter, _zr, {}, this);
                this.component.toolbox = this._toolbox;

                var componentLibrary = require(&#x27;./component&#x27;);
                componentLibrary.define(&#x27;title&#x27;, require(&#x27;./component/title&#x27;));
                componentLibrary.define(&#x27;tooltip&#x27;, require(&#x27;./component/tooltip&#x27;));
                componentLibrary.define(&#x27;legend&#x27;, require(&#x27;./component/legend&#x27;));
            },

            /**
             * ECharts事件处理中心
             */
            __onevent : function (param){
                param.__echartsId = param.__echartsId || this.id;

                // 来自其他联动图表的事件
                var fromMyself = (param.__echartsId == this.id);

                if (!this._curEventType) {
                    this._curEventType = param.type;
                }

                switch (param.type) {
                    case ecConfig.EVENT.LEGEND_SELECTED :
                        this._onlegendSelected(param);
                        break;
                    case ecConfig.EVENT.DATA_ZOOM :
                        if (!fromMyself) {
                            var dz = this.component.dataZoom;
                            if (dz) {
                                dz.silence(true);
                                dz.absoluteZoom(param.zoom);
                                dz.silence(false);
                            }
                        }
                        this._ondataZoom(param);
                        break;
                    case ecConfig.EVENT.DATA_RANGE :
                        fromMyself &amp;&amp; this._ondataRange(param);
                        break;
                    case ecConfig.EVENT.MAGIC_TYPE_CHANGED :
                        if (!fromMyself) {
                            var tb = this.component.toolbox;
                            if (tb) {
                                tb.silence(true);
                                tb.setMagicType(param.magicType);
                                tb.silence(false);
                            }
                        }
                        this._onmagicTypeChanged(param);
                        break;
                    case ecConfig.EVENT.DATA_VIEW_CHANGED :
                        fromMyself &amp;&amp; this._ondataViewChanged(param);
                        break;
                    case ecConfig.EVENT.TOOLTIP_HOVER :
                        fromMyself &amp;&amp; this._tooltipHover(param);
                        break;
                    case ecConfig.EVENT.RESTORE :
                        this._onrestore();
                        break;
                    case ecConfig.EVENT.REFRESH :
                        fromMyself &amp;&amp; this._onrefresh(param);
                        break;
                    // 鼠标同步
                    case ecConfig.EVENT.TOOLTIP_IN_GRID :
                    case ecConfig.EVENT.TOOLTIP_OUT_GRID :
                        if (!fromMyself) {
                            // 只处理来自外部的鼠标同步
                            var grid = this.component.grid;
                            if (grid) {
                                this._zr.trigger(
                                    &#x27;mousemove&#x27;,
                                    {
                                        connectTrigger : true,
                                        zrenderX : grid.getX() + param.x * grid.getWidth(),
                                        zrenderY : grid.getY() + param.y * grid.getHeight()
                                    }
                                );
                            }
                        }
                        else if (this._connected) {
                            // 来自自己，并且存在多图联动，空间坐标映射修改参数分发
                            var grid = this.component.grid;
                            if (grid) {
                                param.x = (param.event.zrenderX - grid.getX()) / grid.getWidth();
                                param.y = (param.event.zrenderY - grid.getY()) / grid.getHeight();
                            }
                        }
                        break;
                    /*
                     case ecConfig.EVENT.RESIZE :
                     case ecConfig.EVENT.DATA_CHANGED :
                     case ecConfig.EVENT.PIE_SELECTED :
                     case ecConfig.EVENT.MAP_SELECTED :
                     break;
                     */
                }

                // 多图联动，只做自己的一级事件分发，避免级联事件循环
                if (this._connected &amp;&amp; fromMyself &amp;&amp; this._curEventType == param.type) {
                    for (var c in this._connected) {
                        this._connected[c].connectedEventHandler(param);
                    }
                    // 分发完毕后复位
                    this._curEventType = null;
                }

                if (!fromMyself || (!this._connected &amp;&amp; fromMyself)) {  // 处理了完联动事件复位
                    this._curEventType = null;
                }
            },

            /**
             * 点击事件，响应zrender事件，包装后分发到Echarts层
             */
            _onclick : function (param) {
                callChartListMethodReverse(this, &#x27;onclick&#x27;, param);

                if (param.target) {
                    var ecData = this._eventPackage(param.target);
                    if (ecData &amp;&amp; ecData.seriesIndex != null) {
                        this._messageCenter.dispatch(
                            ecConfig.EVENT.CLICK,
                            param.event,
                            ecData,
                            this
                        );
                    }
                }
            },

            /**
             * 鼠标移入事件，响应zrender事件，包装后分发到Echarts层
             */
            _onmouseover : function (param) {
                if (param.target) {
                    var ecData = this._eventPackage(param.target);
                    if (ecData &amp;&amp; ecData.seriesIndex != null) {
                        this._messageCenter.dispatch(
                            ecConfig.EVENT.HOVER,
                            param.event,
                            ecData,
                            this
                        );
                    }
                }
            },

            /**
             * dragstart回调，可计算特性实现
             */
            _ondragstart : function (param) {
                // 复位用于图表间通信拖拽标识
                this._status = {
                    dragIn : false,
                    dragOut : false,
                    needRefresh : false
                };

                callChartListMethodReverse(this, &#x27;ondragstart&#x27;, param);
            },

            /**
             * dragging回调，可计算特性实现
             */
            _ondragenter : function (param) {
                callChartListMethodReverse(this, &#x27;ondragenter&#x27;, param);
            },

            /**
             * dragstart回调，可计算特性实现
             */
            _ondragover : function (param) {
                callChartListMethodReverse(this, &#x27;ondragover&#x27;, param);
            },

            /**
             * dragstart回调，可计算特性实现
             */
            _ondragleave : function (param) {
                callChartListMethodReverse(this, &#x27;ondragleave&#x27;, param);
            },

            /**
             * dragstart回调，可计算特性实现
             */
            _ondrop : function (param) {
                callChartListMethodReverse(this, &#x27;ondrop&#x27;, param, this._status);
                this._island.ondrop(param, this._status);
            },

            /**
             * dragdone回调 ，可计算特性实现
             */
            _ondragend : function (param) {
                callChartListMethodReverse(this, &#x27;ondragend&#x27;, param, this._status);

                this._timeline &amp;&amp; this._timeline.ondragend(param, this._status);
                this._island.ondragend(param, this._status);

                // 发生过重计算
                if (this._status.needRefresh) {
                    this._syncBackupData(this._option);

                    var messageCenter = this._messageCenter;
                    messageCenter.dispatch(
                        ecConfig.EVENT.DATA_CHANGED,
                        param.event,
                        this._eventPackage(param.target),
                        this
                    );
                    messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
                }
            },

            /**
             * 图例选择响应
             */
            _onlegendSelected : function (param) {
                // 用于图表间通信
                this._status.needRefresh = false;
                callChartListMethodReverse(this, &#x27;onlegendSelected&#x27;, param, this._status);

                if (this._status.needRefresh) {
                    this._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
                }
            },

            /**
             * 数据区域缩放响应
             */
            _ondataZoom : function (param) {
                // 用于图表间通信
                this._status.needRefresh = false;
                callChartListMethodReverse(this, &#x27;ondataZoom&#x27;, param, this._status);

                if (this._status.needRefresh) {
                    this._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
                }
            },

            /**
             * 值域漫游响应
             */
            _ondataRange : function (param) {
                this._clearEffect();
                // 用于图表间通信
                this._status.needRefresh = false;
                callChartListMethodReverse(this, &#x27;ondataRange&#x27;, param, this._status);

                // 没有相互影响，直接刷新即可
                if (this._status.needRefresh) {
                    this._zr.refresh();
                }
            },

            /**
             * 动态类型切换响应
             */
            _onmagicTypeChanged : function () {
                this._clearEffect();
                this._render(this._toolbox.getMagicOption());
            },

            /**
             * 数据视图修改响应
             */
            _ondataViewChanged : function (param) {
                this._syncBackupData(param.option);
                this._messageCenter.dispatch(
                    ecConfig.EVENT.DATA_CHANGED,
                    null,
                    param,
                    this
                );
                this._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
            },

            /**
             * tooltip与图表间通信
             */
            _tooltipHover : function (param) {
                var tipShape = [];
                callChartListMethodReverse(this, &#x27;ontooltipHover&#x27;, param, tipShape);
            },

            /**
             * 还原
             */
            _onrestore : function () {
                this.restore();
            },

            /**
             * 刷新
             */
            _onrefresh : function (param) {
                this._refreshInside = true;
                this.refresh(param);
                this._refreshInside = false;
            },

            /**
             * 数据修改后的反向同步dataZoom持有的备份数据
             */
            _syncBackupData : function (curOption) {
                this.component.dataZoom &amp;&amp; this.component.dataZoom.syncBackupData(curOption);
            },

            /**
             * 打包Echarts层的事件附件
             */
            _eventPackage : function (target) {
                if (target) {
                    var ecData = require(&#x27;./util/ecData&#x27;);

                    var seriesIndex = ecData.get(target, &#x27;seriesIndex&#x27;);
                    var dataIndex = ecData.get(target, &#x27;dataIndex&#x27;);

                    dataIndex = seriesIndex != -1 &amp;&amp; this.component.dataZoom
                        ? this.component.dataZoom.getRealDataIndex(
                        seriesIndex,
                        dataIndex
                    )
                        : dataIndex;
                    return {
                        seriesIndex : seriesIndex,
                        dataIndex : dataIndex,
                        data : ecData.get(target, &#x27;data&#x27;),
                        name : ecData.get(target, &#x27;name&#x27;),
                        value : ecData.get(target, &#x27;value&#x27;),
                        special : ecData.get(target, &#x27;special&#x27;)
                    };
                }
                return;
            },

            /**
             * 图表渲染
             */
            _render : function (magicOption) {
                this._mergeGlobalConifg(magicOption);

                var bgColor = magicOption.backgroundColor;
                if (bgColor) {
                    if (!_canvasSupported
                        &amp;&amp; bgColor.indexOf(&#x27;rgba&#x27;) != -1
                        ) {
                        // IE6~8对RGBA的处理，filter会带来其他颜色的影响
                        var cList = bgColor.split(&#x27;,&#x27;);
                        this.dom.style.filter = &#x27;alpha(opacity=&#x27; +
                            cList[3].substring(0, cList[3].lastIndexOf(&#x27;)&#x27;)) * 100
                            + &#x27;)&#x27;;
                        cList.length = 3;
                        cList[0] = cList[0].replace(&#x27;a&#x27;, &#x27;&#x27;);
                        this.dom.style.backgroundColor = cList.join(&#x27;,&#x27;) + &#x27;)&#x27;;
                    }
                    else {
                        this.dom.style.backgroundColor = bgColor;
                    }
                }

                this._zr.clearAnimation();
                this._chartList = [];

                var chartLibrary = require(&#x27;./chart&#x27;);
                var componentLibrary = require(&#x27;./component&#x27;);

                if (magicOption.xAxis || magicOption.yAxis) {
                    magicOption.grid = magicOption.grid || {};
                    magicOption.dataZoom = magicOption.dataZoom || {};
                }

                var componentList = [
                    &#x27;title&#x27;, &#x27;legend&#x27;, &#x27;tooltip&#x27;, &#x27;dataRange&#x27;,
                    &#x27;grid&#x27;, &#x27;dataZoom&#x27;, &#x27;xAxis&#x27;, &#x27;yAxis&#x27;, &#x27;polar&#x27;
                ];

                var ComponentClass;
                var componentType;
                var component;
                for (var i = 0, l = componentList.length; i &lt; l; i++) {
                    componentType = componentList[i];
                    component = this.component[componentType];

                    if (magicOption[componentType]) {
                        if (component) {
                            component.refresh &amp;&amp; component.refresh(magicOption);
                        }
                        else {
                            ComponentClass = componentLibrary.get(
                                /^[xy]Axis$/.test(componentType) ? &#x27;axis&#x27; : componentType
                            );
                            component = new ComponentClass(
                                this._themeConfig, this._messageCenter, this._zr,
                                magicOption, this, componentType
                            );
                            this.component[componentType] = component;
                        }
                        this._chartList.push(component);
                    }
                    else if (component) {
                        component.dispose();
                        this.component[componentType] = null;
                        delete this.component[componentType];
                    }
                }

                var ChartClass;
                var chartType;
                var chart;
                var chartMap = {};      // 记录已经初始化的图表
                for (var i = 0, l = magicOption.series.length; i &lt; l; i++) {
                    chartType = magicOption.series[i].type;
                    if (!chartType) {
                        console.error(&#x27;series[&#x27; + i + &#x27;] chart type has not been defined.&#x27;);
                        continue;
                    }

                    if (!chartMap[chartType]) {
                        chartMap[chartType] = true;
                        ChartClass = chartLibrary.get(chartType);
                        if (ChartClass) {
                            if (this.chart[chartType]) {
                                chart = this.chart[chartType];
                                chart.refresh(magicOption);
                            }
                            else {
                                chart = new ChartClass(
                                    this._themeConfig, this._messageCenter, this._zr,
                                    magicOption, this
                                );
                            }
                            this._chartList.push(chart);
                            this.chart[chartType] = chart;
                        }
                        else {
                            console.error(chartType + &#x27; has not been required.&#x27;);
                        }
                    }
                }

                // 已有实例但新option不带这类图表的实例释放
                for (chartType in this.chart) {
                    if (chartType != ecConfig.CHART_TYPE_ISLAND  &amp;&amp; !chartMap[chartType]) {
                        this.chart[chartType].dispose();
                        this.chart[chartType] = null;
                        delete this.chart[chartType];
                    }
                }

                this.component.grid &amp;&amp; this.component.grid.refixAxisShape(this.component);

                this._island.refresh(magicOption);
                this._toolbox.refresh(magicOption);

                magicOption.animation &amp;&amp; !magicOption.renderAsImage
                    ? this._zr.refresh()
                    : this._zr.render();

                var imgId = &#x27;IMG&#x27; + this.id;
                var img = document.getElementById(imgId);
                if (magicOption.renderAsImage &amp;&amp; _canvasSupported) {
                    // IE8- 不支持图片渲染形式
                    if (img) {
                        // 已经渲染过则更新显示
                        img.src = this.getDataURL(magicOption.renderAsImage);
                    }
                    else {
                        // 没有渲染过插入img dom
                        img = this.getImage(magicOption.renderAsImage);
                        img.id = imgId;
                        img.style.position = &#x27;absolute&#x27;;
                        img.style.left = 0;
                        img.style.top = 0;
                        this.dom.firstChild.appendChild(img);
                    }
                    this.un();
                    this._zr.un();
                    this._disposeChartList();
                    this._zr.clear();
                }
                else if (img) {
                    // 删除可能存在的img
                    img.parentNode.removeChild(img);
                }
                img = null;

                this._option = magicOption;
            },

            /**
             * 还原
             */
            restore : function () {
                this._clearEffect();
                this._option = zrUtil.clone(this._optionRestore);
                this._disposeChartList();
                this._island.clear();
                this._toolbox.reset(this._option, true);
                this._render(this._option);
            },

            /**
             * 刷新
             * @param {Object=} param，可选参数，用于附带option，内部同步用，外部不建议带入数据修改，无法同步
             */
            refresh : function (param) {
                this._clearEffect();
                param = param || {};
                var magicOption = param.option;

                // 外部调用的refresh且有option带入
                if (!this._refreshInside &amp;&amp; magicOption) {
                    // 做简单的差异合并去同步内部持有的数据克隆，不建议带入数据
                    // 开启数据区域缩放、拖拽重计算、数据视图可编辑模式情况下，当用户产生了数据变化后无法同步
                    // 如有带入option存在数据变化，请重新setOption
                    magicOption = this.getOption();
                    zrUtil.merge(magicOption, param.option, true);
                    zrUtil.merge(this._optionRestore, param.option, true);
                    this._toolbox.reset(magicOption);
                }

                this._island.refresh(magicOption);
                this._toolbox.refresh(magicOption);

                // 停止动画
                this._zr.clearAnimation();
                // 先来后到，安顺序刷新各种图表，图表内部refresh优化检查magicOption，无需更新则不更新~
                for (var i = 0, l = this._chartList.length; i &lt; l; i++) {
                    this._chartList[i].refresh &amp;&amp; this._chartList[i].refresh(magicOption);
                }
                this.component.grid &amp;&amp; this.component.grid.refixAxisShape(this.component);
                this._zr.refresh();
            },

            /**
             * 释放图表实例
             */
            _disposeChartList : function () {
                this._clearEffect();

                // 停止动画
                this._zr.clearAnimation();

                var len = this._chartList.length;
                while (len--) {
                    var chart = this._chartList[len];

                    if (chart) {
                        var chartType = chart.type;
                        this.chart[chartType] &amp;&amp; delete this.chart[chartType];
                        this.component[chartType] &amp;&amp; delete this.component[chartType];
                        chart.dispose &amp;&amp; chart.dispose();
                    }
                }

                this._chartList = [];
            },

            /**
             * 非图表全局属性merge~~
             */
            _mergeGlobalConifg : function (magicOption) {
                var mergeList = [
                    // 背景颜色
                    &#x27;backgroundColor&#x27;,

                    // 拖拽重计算相关
                    &#x27;calculable&#x27;, &#x27;calculableColor&#x27;, &#x27;calculableHolderColor&#x27;,

                    // 孤岛显示连接符
                    &#x27;nameConnector&#x27;, &#x27;valueConnector&#x27;,

                    // 动画相关
                    &#x27;animation&#x27;, &#x27;animationThreshold&#x27;, &#x27;animationDuration&#x27;,
                    &#x27;animationEasing&#x27;, &#x27;addDataAnimation&#x27;,

                    // 默认标志图形类型列表
                    &#x27;symbolList&#x27;,

                    // 降低图表内元素拖拽敏感度，单位ms，不建议外部干预
                    &#x27;DRAG_ENABLE_TIME&#x27;
                ];

                var len = mergeList.length;
                while (len--) {
                    var mergeItem = mergeList[len];
                    if (magicOption[mergeItem] == null) {
                        magicOption[mergeItem] = this._themeConfig[mergeItem];
                    }
                }

                // 数值系列的颜色列表，不传则采用内置颜色，可配数组，借用zrender实例注入，会有冲突风险，先这样
                var themeColor = magicOption.color;
                if (!(themeColor &amp;&amp; themeColor.length)) {
                    themeColor = this._themeConfig.color;
                }

                this._zr.getColor = function (idx) {
                    var zrColor = require(&#x27;zrender/tool/color&#x27;);
                    return zrColor.getColor(idx, themeColor);
                };
            },

            /**
             * 万能接口，配置图表实例任何可配置选项，多次调用时option选项做merge处理
             * @param {Object} option
             * @param {boolean=} notMerge 多次调用时option选项是默认是合并（merge）的，
             *                   如果不需求，可以通过notMerger参数为true阻止与上次option的合并
             */
            setOption : function (option, notMerge) {
                if (!option.timeline) {
                    return this._setOption(option, notMerge);
                }
                else {
                    return this._setTimelineOption(option);
                }
            },

            /**
             * 万能接口，配置图表实例任何可配置选项，多次调用时option选项做merge处理
             * @param {Object} option
             * @param {boolean=} notMerge 多次调用时option选项是默认是合并（merge）的，
             *                   如果不需求，可以通过notMerger参数为true阻止与上次option的合并
             */
            _setOption : function (option, notMerge) {
                if (!notMerge &amp;&amp; this._option) {
                    this._option = zrUtil.merge(
                        this.getOption(),
                        zrUtil.clone(option),
                        true
                    );
                }
                else {
                    this._option = zrUtil.clone(option);
                }

                this._optionRestore = zrUtil.clone(this._option);

                if (!this._option.series || this._option.series.length === 0) {
                    this._zr.clear();
                    return;
                }

                if (this.component.dataZoom                         // 存在dataZoom控件
                    &amp;&amp; (this._option.dataZoom                       // 并且新option也存在
                        || (this._option.toolbox
                            &amp;&amp; this._option.toolbox.feature
                            &amp;&amp; this._option.toolbox.feature.dataZoom
                            &amp;&amp; this._option.toolbox.feature.dataZoom.show
                            )
                        )
                    ) {
                    // dataZoom同步数据
                    this.component.dataZoom.syncOption(this._option);
                }
                this._toolbox.reset(this._option);

                this._render(this._option);

                return this;
            },

            /**
             * 返回内部持有的当前显示option克隆
             */
            getOption : function () {
                var magicOption = zrUtil.clone(this._option);

                var self = this;
                function restoreOption(prop) {
                    var restoreSource = self._optionRestore[prop];

                    if (restoreSource) {
                        if (restoreSource instanceof Array) {
                            var len = restoreSource.length;
                            while (len--) {
                                magicOption[prop][len].data = zrUtil.clone(
                                    restoreSource[len].data
                                );
                            }
                        }
                        else {
                            magicOption[prop].data = zrUtil.clone(restoreSource.data);
                        }
                    }
                }

                // 横轴数据还原
                restoreOption(&#x27;xAxis&#x27;);

                // 纵轴数据还原
                restoreOption(&#x27;yAxis&#x27;);

                // 系列数据还原
                restoreOption(&#x27;series&#x27;);

                return magicOption;
            },

            /**
             * 数据设置快捷接口
             * @param {Array} series
             * @param {boolean=} notMerge 多次调用时option选项是默认是合并（merge）的，
             *                   如果不需求，可以通过notMerger参数为true阻止与上次option的合并。
             */
            setSeries : function (series, notMerge) {
                if (!notMerge) {
                    this.setOption({series: series});
                }
                else {
                    this._option.series = series;
                    this.setOption(this._option, notMerge);
                }
                return this;
            },

            /**
             * 返回内部持有的当前显示series克隆
             */
            getSeries : function () {
                return this.getOption().series;
            },

            /**
             * timelineOption接口，配置图表实例任何可配置选项
             * @param {Object} option
             */
            _setTimelineOption : function(option) {
                this._timeline &amp;&amp; this._timeline.dispose();
                var Timeline = require(&#x27;./component/timeline&#x27;);
                var timeline = new Timeline(
                    this._themeConfig, this._messageCenter, this._zr, option, this
                );
                this._timeline = timeline;
                this.component.timeline = this._timeline;

                return this;
            },

            /**
             * 动态数据添加
             * 形参为单组数据参数，多组时为数据，内容同[seriesIdx, data, isShift, additionData]
             * @param {number} seriesIdx 系列索引
             * @param {number | Object} data 增加数据
             * @param {boolean=} isHead 是否队头加入，默认，不指定或false时为队尾插入
             * @param {boolean=} dataGrow 是否增长数据队列长度，默认，不指定或false时移出目标数组对位数据
             * @param {string=} additionData 是否增加类目轴(饼图为图例)数据，附加操作同isHead和dataGrow
             */
            addData : function (seriesIdx, data, isHead, dataGrow, additionData) {
                var params = seriesIdx instanceof Array
                    ? seriesIdx
                    : [[seriesIdx, data, isHead, dataGrow, additionData]];

                //this._optionRestore 和 magicOption 都要同步
                var magicOption = this.getOption();
                var optionRestore = this._optionRestore;
                for (var i = 0, l = params.length; i &lt; l; i++) {
                    seriesIdx = params[i][0];
                    data = params[i][1];
                    isHead = params[i][2];
                    dataGrow = params[i][3];
                    additionData = params[i][4];


                    var seriesItem = optionRestore.series[seriesIdx];
                    var inMethod = isHead ? &#x27;unshift&#x27; : &#x27;push&#x27;;
                    var outMethod = isHead ? &#x27;pop&#x27; : &#x27;shift&#x27;;
                    if (seriesItem) {
                        var seriesItemData = seriesItem.data;
                        var mSeriesItemData = magicOption.series[seriesIdx].data;

                        seriesItemData[inMethod](data);
                        mSeriesItemData[inMethod](data);
                        if (!dataGrow) {
                            seriesItemData[outMethod]();
                            data = mSeriesItemData[outMethod]();
                        }


                        if (additionData != null) {
                            var legend;
                            var legendData;

                            if (seriesItem.type == ecConfig.CHART_TYPE_PIE
                                &amp;&amp; (legend = optionRestore.legend)
                                &amp;&amp; (legendData = legend.data)
                                ) {
                                var mLegendData = magicOption.legend.data;
                                legendData[inMethod](additionData);
                                mLegendData[inMethod](additionData);

                                if (!dataGrow) {
                                    var legendDataIdx = zrUtil.indexOf(legendData, data.name);
                                    legendDataIdx != -1 &amp;&amp; legendData.splice(legendDataIdx, 1);

                                    legendDataIdx = zrUtil.indexOf(mLegendData, data.name);
                                    legendDataIdx != -1 &amp;&amp; mLegendData.splice(legendDataIdx, 1);
                                }
                            }
                            else if (optionRestore.xAxis != null &amp;&amp; optionRestore.yAxis != null) {
                                // x轴类目
                                var axisData;
                                var mAxisData;
                                var axisIdx = seriesItem.xAxisIndex || 0;

                                if (typeof optionRestore.xAxis[axisIdx].type == &#x27;undefined&#x27;
                                    || optionRestore.xAxis[axisIdx].type == &#x27;category&#x27;
                                    ) {
                                    axisData = optionRestore.xAxis[axisIdx].data;
                                    mAxisData = magicOption.xAxis[axisIdx].data;

                                    axisData[inMethod](additionData);
                                    mAxisData[inMethod](additionData);
                                    if (!dataGrow) {
                                        axisData[outMethod]();
                                        mAxisData[outMethod]();
                                    }
                                }

                                // y轴类目
                                axisIdx = seriesItem.yAxisIndex || 0;
                                if (optionRestore.yAxis[axisIdx].type == &#x27;category&#x27;) {
                                    axisData = optionRestore.yAxis[axisIdx].data;
                                    mAxisData = magicOption.yAxis[axisIdx].data;

                                    axisData[inMethod](additionData);
                                    mAxisData[inMethod](additionData);
                                    if (!dataGrow) {
                                        axisData[outMethod]();
                                        mAxisData[outMethod]();
                                    }
                                }
                            }
                        }

                        // 同步图表内状态，动画需要
                        this._option.series[seriesIdx].data = magicOption.series[seriesIdx].data;
                    }
                }

                this._zr.clearAnimation();
                var chartList = this._chartList;
                for (var i = 0, l = chartList.length; i &lt; l; i++) {
                    if (magicOption.addDataAnimation &amp;&amp; chartList[i].addDataAnimation) {
                        chartList[i].addDataAnimation(params);
                    }
                }

                // dataZoom同步数据
                this.component.dataZoom &amp;&amp; this.component.dataZoom.syncOption(magicOption);

                this._option = magicOption;
                var self = this;
                setTimeout(function (){
                    if (!self._zr) {
                        return; // 已经被释放
                    }
                    self._zr.clearAnimation();
                    for (var i = 0, l = chartList.length; i &lt; l; i++) {
                        // 有addData动画就去掉过渡动画
                        chartList[i].motionlessOnce =
                            magicOption.addDataAnimation &amp;&amp; chartList[i].addDataAnimation;
                    }
                    self._messageCenter.dispatch(
                        ecConfig.EVENT.REFRESH,
                        null,
                        {option: magicOption},
                        self
                    );
                }, magicOption.addDataAnimation ? 500 : 0);
                return this;
            },

            /**
             * 动态[标注 | 标线]添加
             * @param {number} seriesIdx 系列索引
             * @param {Object} markData [标注 | 标线]对象，支持多个
             */
            addMarkPoint : function (seriesIdx, markData) {
                return this._addMark(seriesIdx, markData, &#x27;markPoint&#x27;);
            },

            addMarkLine : function (seriesIdx, markData) {
                return this._addMark(seriesIdx, markData, &#x27;markLine&#x27;);
            },

            _addMark : function (seriesIdx, markData, markType) {
                var series = this._option.series;
                var seriesItem;

                if (series &amp;&amp; (seriesItem = series[seriesIdx])) {
                    var seriesR = this._optionRestore.series;
                    var seriesRItem = seriesR[seriesIdx];
                    var markOpt = seriesItem[markType];
                    var markOptR = seriesRItem[markType];

                    markOpt = seriesItem[markType] = markOpt || {data: []};
                    markOptR = seriesRItem[markType] = markOptR || {data: []};

                    for (var key in markData) {
                        if (key == &#x27;data&#x27;) {
                            // 数据concat
                            markOpt.data = markOpt.data.concat(markData.data);
                            markOptR.data = markOptR.data.concat(markData.data);
                        }
                        else if (typeof markData[key] != &#x27;object&#x27;
                            || typeof markOpt[key] == &#x27;undefined&#x27;
                            ) {
                            // 简单类型或新值直接赋值
                            markOpt[key] = markOptR[key] = markData[key];
                        }
                        else {
                            // 非数据的复杂对象merge
                            zrUtil.merge(markOpt[key], markData[key], true);
                            zrUtil.merge(markOptR[key], markData[key], true);
                        }
                    }

                    var chart = this.chart[seriesItem.type];
                    chart &amp;&amp; chart.addMark(seriesIdx, markData, markType);
                }

                return this;
            },

            /**
             * 动态[标注 | 标线]删除
             * @param {number} seriesIdx 系列索引
             * @param {string} markName [标注 | 标线]名称
             */
            delMarkPoint : function (seriesIdx, markName) {
                return this._delMark(seriesIdx, markName, &#x27;markPoint&#x27;);
            },

            delMarkLine : function (seriesIdx, markName) {
                return this._delMark(seriesIdx, markName, &#x27;markLine&#x27;);
            },

            _delMark : function (seriesIdx, markName, markType) {
                var series = this._option.series;
                var seriesItem;
                var mark;
                var dataArray;

                if (!(
                    series
                    &amp;&amp; (seriesItem = series[seriesIdx])
                    &amp;&amp; (mark = seriesItem[markType])
                    &amp;&amp; (dataArray = mark.data)
                    )
                    ) {
                    return this;
                }

                markName = markName.split(&#x27; &gt; &#x27;);
                var targetIndex = -1;

                for (var i = 0, l = dataArray.length; i &lt; l; i++) {
                    var dataItem = dataArray[i];
                    if (dataItem instanceof Array) {
                        if (dataItem[0].name == markName[0]
                            &amp;&amp; dataItem[1].name == markName[1]
                            ) {
                            targetIndex = i;
                            break;
                        }
                    }
                    else if (dataItem.name == markName[0]) {
                        targetIndex = i;
                        break;
                    }
                }

                if (targetIndex &gt; -1) {
                    dataArray.splice(targetIndex, 1);
                    this._optionRestore.series[seriesIdx][markType].data.splice(targetIndex, 1);

                    var chart = this.chart[seriesItem.type];
                    chart &amp;&amp; chart.delMark(seriesIdx, markName.join(&#x27; &gt; &#x27;), markType);
                }

                return this;
            },

            /**
             * 获取当前dom
             */
            getDom : function () {
                return this.dom;
            },

            /**
             * 获取当前zrender实例，可用于添加额为的shape和深度控制
             */
            getZrender : function () {
                return this._zr;
            },

            /**
             * 获取Base64图片dataURL
             * @param {string} imgType 图片类型，支持png|jpeg，默认为png
             * @return imgDataURL
             */
            getDataURL : function (imgType) {
                if (!_canvasSupported) {
                    return &#x27;&#x27;;
                }

                if (this._chartList.length === 0) {
                    // 渲染为图片
                    var imgId = &#x27;IMG&#x27; + this.id;
                    var img = document.getElementById(imgId);
                    if (img) {
                        return img.src;
                    }
                }

                // 清除可能存在的tooltip元素
                var tooltip = this.component.tooltip;
                tooltip &amp;&amp; tooltip.hideTip();

                switch (imgType) {
                    case &#x27;jpeg&#x27;:
                        break;
                    default:
                        imgType = &#x27;png&#x27;;
                }

                var bgColor = this._option.backgroundColor;
                if (bgColor &amp;&amp; bgColor.replace(&#x27; &#x27;,&#x27;&#x27;) == &#x27;rgba(0,0,0,0)&#x27;) {
                    bgColor = &#x27;#fff&#x27;;
                }

                return this._zr.toDataURL(&#x27;image/&#x27; + imgType, bgColor);
            },

            /**
             * 获取img
             * @param {string} imgType 图片类型，支持png|jpeg，默认为png
             * @return img dom
             */
            getImage : function (imgType) {
                var title = this._optionRestore.title;
                var imgDom = document.createElement(&#x27;img&#x27;);
                imgDom.src = this.getDataURL(imgType);
                imgDom.title = (title &amp;&amp; title.text) || &#x27;ECharts&#x27;;
                return imgDom;
            },

            /**
             * 获取多图联动的Base64图片dataURL
             * @param {string} imgType 图片类型，支持png|jpeg，默认为png
             * @return imgDataURL
             */
            getConnectedDataURL : function (imgType) {
                if (!this.isConnected()) {
                    return this.getDataURL(imgType);
                }

                var tempDom = this.dom;
                var imgList = {
                    &#x27;self&#x27; : {
                        img : this.getDataURL(imgType),
                        left : tempDom.offsetLeft,
                        top : tempDom.offsetTop,
                        right : tempDom.offsetLeft + tempDom.offsetWidth,
                        bottom : tempDom.offsetTop + tempDom.offsetHeight
                    }
                };

                var minLeft = imgList.self.left;
                var minTop = imgList.self.top;
                var maxRight = imgList.self.right;
                var maxBottom = imgList.self.bottom;

                for (var c in this._connected) {
                    tempDom = this._connected[c].getDom();
                    imgList[c] = {
                        img : this._connected[c].getDataURL(imgType),
                        left : tempDom.offsetLeft,
                        top : tempDom.offsetTop,
                        right : tempDom.offsetLeft + tempDom.offsetWidth,
                        bottom : tempDom.offsetTop + tempDom.offsetHeight
                    };

                    minLeft = Math.min(minLeft, imgList[c].left);
                    minTop = Math.min(minTop, imgList[c].top);
                    maxRight = Math.max(maxRight, imgList[c].right);
                    maxBottom = Math.max(maxBottom, imgList[c].bottom);
                }

                var zrDom = document.createElement(&#x27;div&#x27;);
                zrDom.style.position = &#x27;absolute&#x27;;
                zrDom.style.left = &#x27;-4000px&#x27;;
                zrDom.style.width = (maxRight - minLeft) + &#x27;px&#x27;;
                zrDom.style.height = (maxBottom - minTop) + &#x27;px&#x27;;
                document.body.appendChild(zrDom);

                var zrImg = require(&#x27;zrender&#x27;).init(zrDom);

                var ImageShape = require(&#x27;zrender/shape/Image&#x27;);
                for (var c in imgList) {
                    zrImg.addShape(new ImageShape({
                        style : {
                            x : imgList[c].left - minLeft,
                            y : imgList[c].top - minTop,
                            image : imgList[c].img
                        }
                    }));
                }

                zrImg.render();
                var bgColor = this._option.backgroundColor;
                if (bgColor &amp;&amp; bgColor.replace(/ /g, &#x27;&#x27;) == &#x27;rgba(0,0,0,0)&#x27;) {
                    bgColor = &#x27;#fff&#x27;;
                }

                var image = zrImg.toDataURL(&#x27;image/png&#x27;, bgColor);

                setTimeout(function () {
                    zrImg.dispose();
                    zrDom.parentNode.removeChild(zrDom);
                    zrDom = null;
                }, 100);

                return image;
            },

            /**
             * 获取多图联动的img
             * @param {string} imgType 图片类型，支持png|jpeg，默认为png
             * @return img dom
             */
            getConnectedImage : function (imgType) {
                var title = this._optionRestore.title;
                var imgDom = document.createElement(&#x27;img&#x27;);
                imgDom.src = this.getConnectedDataURL(imgType);
                imgDom.title = (title &amp;&amp; title.text) || &#x27;ECharts&#x27;;
                return imgDom;
            },

            /**
             * 外部接口绑定事件
             * @param {Object} eventName 事件名称
             * @param {Object} eventListener 事件响应函数
             */
            on : function (eventName, eventListener) {
                this._messageCenterOutSide.bind(eventName, eventListener);
                return this;
            },

            /**
             * 外部接口解除事件绑定
             * @param {Object} eventName 事件名称
             * @param {Object} eventListener 事件响应函数
             */
            un : function (eventName, eventListener) {
                this._messageCenterOutSide.unbind(eventName, eventListener);
                return this;
            },

            /**
             * 多图联动
             * @param connectTarget{ECharts | Array &lt;ECharts&gt;} connectTarget 联动目标
             */
            connect : function (connectTarget) {
                if (!connectTarget) {
                    return this;
                }

                if (!this._connected) {
                    this._connected = {};
                }

                if (connectTarget instanceof Array) {
                    for (var i = 0, l = connectTarget.length; i &lt; l; i++) {
                        this._connected[connectTarget[i].id] = connectTarget[i];
                    }
                }
                else {
                    this._connected[connectTarget.id] = connectTarget;
                }

                return this;
            },

            /**
             * 解除多图联动
             * @param connectTarget{ECharts | Array &lt;ECharts&gt;} connectTarget 解除联动目标
             */
            disConnect : function (connectTarget) {
                if (!connectTarget || !this._connected) {
                    return this;
                }

                if (connectTarget instanceof Array) {
                    for (var i = 0, l = connectTarget.length; i &lt; l; i++) {
                        delete this._connected[connectTarget[i].id];
                    }
                }
                else {
                    delete this._connected[connectTarget.id];
                }

                for (var k in this._connected) {
                    return k, this; // 非空
                }

                // 空，转为标志位
                this._connected = false;
                return this;
            },

            /**
             * 联动事件响应
             */
            connectedEventHandler : function (param) {
                if (param.__echartsId != this.id) {
                    // 来自其他联动图表的事件
                    this._onevent(param);
                }
            },

            /**
             * 是否存在多图联动
             */
            isConnected : function () {
                return !!this._connected;
            },

            /**
             * 显示loading过渡
             * @param {Object} loadingOption
             */
            showLoading : function (loadingOption) {
                var effectList = {
                    bar : require(&#x27;zrender/loadingEffect/Bar&#x27;),
                    bubble : require(&#x27;zrender/loadingEffect/Bubble&#x27;),
                    dynamicLine : require(&#x27;zrender/loadingEffect/DynamicLine&#x27;),
                    ring : require(&#x27;zrender/loadingEffect/Ring&#x27;),
                    spin : require(&#x27;zrender/loadingEffect/Spin&#x27;),
                    whirling : require(&#x27;zrender/loadingEffect/Whirling&#x27;)
                };
                this._toolbox.hideDataView();

                loadingOption = loadingOption || {};

                var textStyle = loadingOption.textStyle || {};
                loadingOption.textStyle = textStyle;

                var finalTextStyle = zrUtil.merge(
                    zrUtil.clone(textStyle),
                    this._themeConfig.textStyle
                );
                textStyle.textFont = finalTextStyle.fontStyle + &#x27; &#x27;
                    + finalTextStyle.fontWeight + &#x27; &#x27;
                    + finalTextStyle.fontSize + &#x27;px &#x27;
                    + finalTextStyle.fontFamily;

                textStyle.text = loadingOption.text || this._themeConfig.loadingText;

                if (loadingOption.x != null) {
                    textStyle.x = loadingOption.x;
                }
                if (loadingOption.y != null) {
                    textStyle.y = loadingOption.y;
                }

                loadingOption.effectOption = loadingOption.effectOption || {};
                loadingOption.effectOption.textStyle = textStyle;

                var Effect = loadingOption.effect;
                if (typeof Effect == &#x27;string&#x27; || Effect == null) {
                    Effect =  effectList[loadingOption.effect || &#x27;spin&#x27;];
                }
                this._zr.showLoading(new Effect(loadingOption.effectOption));
                return this;
            },

            /**
             * 隐藏loading过渡
             */
            hideLoading : function () {
                this._zr.hideLoading();
                return this;
            },

            /**
             * 主题设置
             */
            setTheme : function (theme) {
                if (theme) {
                    if (typeof theme === &#x27;string&#x27;) {
                        // 默认主题
                        switch (theme) {
                            // case &#x27;themename&#x27;:
                            //     theme = require(&#x27;./theme/themename&#x27;);
                            default:
                                theme = require(&#x27;./theme/default&#x27;);
                        }
                    }
                    else {
                        theme = theme || {};
                    }

                    // 复位默认配置
                    // this._themeConfig会被别的对象引用持有
                    // 所以不能改成this._themeConfig = {};
                    for (var key in this._themeConfig) {
                        delete this._themeConfig[key];
                    }
                    for (var key in ecConfig) {
                        this._themeConfig[key] = zrUtil.clone(ecConfig[key]);
                    }

                    // 颜色数组随theme，不merge
                    theme.color &amp;&amp; (this._themeConfig.color = []);

                    // 默认标志图形类型列表，不merge
                    theme.symbolList &amp;&amp; (this._themeConfig.symbolList = []);

                    // 应用新主题
                    zrUtil.merge(this._themeConfig, zrUtil.clone(theme), true);
                }

                if (!_canvasSupported) {   // IE8-
                    this._themeConfig.textStyle.fontFamily = this._themeConfig.textStyle.fontFamily2;
                }

                this._timeline &amp;&amp; this._timeline.setTheme(true);
                this._optionRestore &amp;&amp; this.restore();
            },

            /**
             * 视图区域大小变化更新，不默认绑定，供使用方按需调用
             */
            resize : function () {
                var self = this;
                return function(){
                    self._clearEffect();
                    self._zr.resize();
                    if (self._option.renderAsImage &amp;&amp; _canvasSupported) {
                        // 渲染为图片重走render模式
                        self._render(self._option);
                        return self;
                    }
                    // 停止动画
                    self._zr.clearAnimation();
                    self._island.resize();
                    self._toolbox.resize();
                    self._timeline &amp;&amp; self._timeline.resize();
                    // 先来后到，不能仅刷新自己，也不能在上一个循环中刷新，如坐标系数据改变会影响其他图表的大小
                    // 所以安顺序刷新各种图表，图表内部refresh优化无需更新则不更新~
                    for (var i = 0, l = self._chartList.length; i &lt; l; i++) {
                        self._chartList[i].resize &amp;&amp; self._chartList[i].resize();
                    }
                    self.component.grid &amp;&amp; self.component.grid.refixAxisShape(self.component);
                    self._zr.refresh();
                    self._messageCenter.dispatch(ecConfig.EVENT.RESIZE, null, null, self);
                    return self;
                };
            },

            _clearEffect : function() {
                this._zr.modLayer(ecConfig.EFFECT_ZLEVEL, {motionBlur : false});
                this._zr.painter.clearLayer(ecConfig.EFFECT_ZLEVEL);
            },

            /**
             * 清除已渲染内容 ，clear后echarts实例可用
             */
            clear : function () {
                this._disposeChartList();
                this._zr.clear();
                this._option = {};
                this._optionRestore = {};
                return this;
            },

            /**
             * 释放，dispose后echarts实例不可用
             */
            dispose : function () {
                var key = this.dom.getAttribute(DOM_ATTRIBUTE_KEY);
                key &amp;&amp; delete _instances[key];

                this._island.dispose();
                this._toolbox.dispose();
                this._timeline &amp;&amp; this._timeline.dispose();
                this._messageCenter.unbind();
                this.clear();
                this._zr.dispose();
                this._zr = null;
            }
        };

        return self;
    });
    define(&#x27;echarts&#x27;, [&#x27;echarts/echarts&#x27;], function (main) { return main; });


    /**
     * echarts组件： 类目轴
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/component/categoryAxis&#x27;,[&#x27;require&#x27;,&#x27;./base&#x27;,&#x27;zrender/shape/Text&#x27;,&#x27;zrender/shape/Line&#x27;,&#x27;zrender/shape/Rectangle&#x27;,&#x27;../config&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/tool/area&#x27;,&#x27;../component&#x27;],function (require) {
        var Base = require(&#x27;./base&#x27;);

        // 图形依赖
        var TextShape = require(&#x27;zrender/shape/Text&#x27;);
        var LineShape = require(&#x27;zrender/shape/Line&#x27;);
        var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);

        var ecConfig = require(&#x27;../config&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);
        var zrArea = require(&#x27;zrender/tool/area&#x27;);

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 类目轴参数
         * @param {Grid} component 组件
         */
        function CategoryAxis(ecTheme, messageCenter, zr, option, myChart, axisBase) {
            if (option.data.length &lt; 1) {
                console.error(&#x27;option.data.length &lt; 1.&#x27;);
                return;
            }

            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            this.grid = this.component.grid;

            for (var method in axisBase) {
                this[method] = axisBase[method];
            }

            this.refresh(option);
        }

        CategoryAxis.prototype = {
            type : ecConfig.COMPONENT_TYPE_AXIS_CATEGORY,
            _getReformedLabel : function (idx) {
                var data = typeof this.option.data[idx].value != &#x27;undefined&#x27;
                    ? this.option.data[idx].value
                    : this.option.data[idx];
                var formatter = this.option.data[idx].formatter
                    || this.option.axisLabel.formatter;
                if (formatter) {
                    if (typeof formatter == &#x27;function&#x27;) {
                        data = formatter(data);
                    }
                    else if (typeof formatter == &#x27;string&#x27;) {
                        data = formatter.replace(&#x27;{value}&#x27;, data);
                    }
                }
                return data;
            },

            /**
             * 计算标签显示挑选间隔
             */
            _getInterval : function () {
                var interval   = this.option.axisLabel.interval;
                if (interval == &#x27;auto&#x27;) {
                    // 麻烦的自适应计算
                    var fontSize = this.option.axisLabel.textStyle.fontSize;
                    var data = this.option.data;
                    var dataLength = this.option.data.length;

                    if (this.isHorizontal()) {
                        // 横向
                        if (dataLength &gt; 3) {
                            var gap = this.getGap();
                            var isEnough = false;
                            var labelSpace;
                            var labelSize;
                            var step = Math.floor(0.5 / gap);
                            step = step &lt; 1 ? 1 : step;
                            interval = Math.floor(15 / gap);
                            while (!isEnough &amp;&amp; interval &lt; dataLength) {
                                interval += step;
                                isEnough = true;
                                labelSpace = Math.floor(gap * interval); // 标签左右至少间隔为3px
                                for (var i = Math.floor((dataLength - 1)/ interval) * interval;
                                     i &gt;= 0; i -= interval
                                    ) {
                                    if (this.option.axisLabel.rotate !== 0) {
                                        // 有旋转
                                        labelSize = fontSize;
                                    }
                                    else if (data[i].textStyle) {
                                        labelSize = zrArea.getTextWidth(
                                            this._getReformedLabel(i),
                                            this.getFont(
                                                zrUtil.merge(
                                                    data[i].textStyle,
                                                    this.option.axisLabel.textStyle
                                                )
                                            )
                                        );
                                    }
                                    else {
                                        /*
                                         labelSize = zrArea.getTextWidth(
                                         this._getReformedLabel(i),
                                         font
                                         );
                                         */
                                        // 不定义data级特殊文本样式，用fontSize优化getTextWidth
                                        var label = this._getReformedLabel(i) + &#x27;&#x27;;
                                        var wLen = (label.match(/\w/g) || &#x27;&#x27;).length;
                                        var oLen = label.length - wLen;
                                        labelSize = wLen * fontSize * 2 / 3 + oLen * fontSize;
                                    }

                                    if (labelSpace &lt; labelSize) {
                                        // 放不下，中断循环让interval++
                                        isEnough = false;
                                        break;
                                    }
                                }
                            }
                        }
                        else {
                            // 少于3个则全部显示
                            interval = 1;
                        }
                    }
                    else {
                        // 纵向
                        if (dataLength &gt; 3) {
                            var gap = this.getGap();
                            interval = Math.floor(11 / gap);
                            // 标签上下至少间隔为3px
                            while ((gap * interval - 6) &lt; fontSize
                                &amp;&amp; interval &lt; dataLength
                                ) {
                                interval++;
                            }
                        }
                        else {
                            // 少于3个则全部显示
                            interval = 1;
                        }
                    }
                }
                else {
                    // 用户自定义间隔
                    interval = interval - 0 + 1;
                }

                return interval;
            },

            /**
             * 绘制图形
             */
            _buildShape : function () {
                // 标签显示的挑选间隔
                this._interval = this._getInterval();

                this.option.splitArea.show &amp;&amp; this._buildSplitArea();
                this.option.splitLine.show &amp;&amp; this._buildSplitLine();
                this.option.axisLine.show &amp;&amp; this._buildAxisLine();
                this.option.axisTick.show &amp;&amp; this._buildAxisTick();
                this.option.axisLabel.show &amp;&amp; this._buildAxisLabel();

                for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                    this.zr.addShape(this.shapeList[i]);
                }
            },

            // 小标记
            _buildAxisTick : function () {
                var axShape;
                //var data       = this.option.data;
                var dataLength = this.option.data.length;
                var tickOption = this.option.axisTick;
                var length     = tickOption.length;
                var color      = tickOption.lineStyle.color;
                var lineWidth  = tickOption.lineStyle.width;
                var interval   = tickOption.interval == &#x27;auto&#x27;
                    ? this._interval : (tickOption.interval - 0 + 1);
                var onGap      = tickOption.onGap;
                var optGap     = onGap
                    ? (this.getGap() / 2)
                    : typeof onGap == &#x27;undefined&#x27;
                    ? (this.option.boundaryGap ? (this.getGap() / 2) : 0)
                    : 0;
                var startIndex = optGap &gt; 0 ? -interval : 0;
                if (this.isHorizontal()) {
                    // 横向
                    var yPosition = this.option.position == &#x27;bottom&#x27;
                        ? (tickOption.inside
                        ? (this.grid.getYend() - length - 1) : (this.grid.getYend() + 1))
                        : (tickOption.inside
                        ? (this.grid.getY() + 1) : (this.grid.getY() - length - 1));
                    var x;
                    for (var i = startIndex; i &lt; dataLength; i += interval) {
                        // 亚像素优化
                        x = this.subPixelOptimize(
                                this.getCoordByIndex(i) + (i &gt;= 0 ? optGap : 0), lineWidth
                        );
                        axShape = {
                            _axisShape : &#x27;axisTick&#x27;,
                            zlevel : this._zlevelBase,
                            hoverable : false,
                            style : {
                                xStart : x,
                                yStart : yPosition,
                                xEnd : x,
                                yEnd : yPosition + length,
                                strokeColor : color,
                                lineWidth : lineWidth
                            }
                        };
                        this.shapeList.push(new LineShape(axShape));
                    }
                }
                else {
                    // 纵向
                    var xPosition = this.option.position == &#x27;left&#x27;
                        ? (tickOption.inside
                        ? (this.grid.getX() + 1) : (this.grid.getX() - length - 1))
                        : (tickOption.inside
                        ? (this.grid.getXend() - length - 1) : (this.grid.getXend() + 1));

                    var y;
                    for (var i = startIndex; i &lt; dataLength; i += interval) {
                        // 亚像素优化
                        y = this.subPixelOptimize(
                                this.getCoordByIndex(i) - (i &gt;= 0 ? optGap : 0), lineWidth
                        );
                        axShape = {
                            _axisShape : &#x27;axisTick&#x27;,
                            zlevel : this._zlevelBase,
                            hoverable : false,
                            style : {
                                xStart : xPosition,
                                yStart : y,
                                xEnd : xPosition + length,
                                yEnd : y,
                                strokeColor : color,
                                lineWidth : lineWidth
                            }
                        };
                        this.shapeList.push(new LineShape(axShape));
                    }
                }
            },

            // 坐标轴文本
            _buildAxisLabel : function () {
                var axShape;
                var data       = this.option.data;
                var dataLength = this.option.data.length;
                var rotate     = this.option.axisLabel.rotate;
                var margin     = this.option.axisLabel.margin;
                var clickable  = this.option.axisLabel.clickable;
                var textStyle  = this.option.axisLabel.textStyle;
                var dataTextStyle;

                if (this.isHorizontal()) {
                    // 横向
                    var yPosition;
                    var baseLine;
                    if (this.option.position == &#x27;bottom&#x27;) {
                        yPosition = this.grid.getYend() + margin;
                        baseLine = &#x27;top&#x27;;
                    }
                    else {
                        yPosition = this.grid.getY() - margin;
                        baseLine = &#x27;bottom&#x27;;
                    }

                    for (var i = 0; i &lt; dataLength; i += this._interval) {
                        if (this._getReformedLabel(i) === &#x27;&#x27;) {
                            // 空文本优化
                            continue;
                        }
                        dataTextStyle = zrUtil.merge(
                                data[i].textStyle || {},
                            textStyle
                        );
                        axShape = {
                            // shape : &#x27;text&#x27;,
                            zlevel : this._zlevelBase,
                            hoverable : false,
                            style : {
                                x : this.getCoordByIndex(i),
                                y : yPosition,
                                color : dataTextStyle.color,
                                text : this._getReformedLabel(i),
                                textFont : this.getFont(dataTextStyle),
                                textAlign : dataTextStyle.align || &#x27;center&#x27;,
                                textBaseline : dataTextStyle.baseline || baseLine
                            }
                        };
                        if (rotate) {
                            axShape.style.textAlign = rotate &gt; 0
                                ? (this.option.position == &#x27;bottom&#x27;
                                ? &#x27;right&#x27; : &#x27;left&#x27;)
                                : (this.option.position == &#x27;bottom&#x27;
                                ? &#x27;left&#x27; : &#x27;right&#x27;);
                            axShape.rotation = [
                                    rotate * Math.PI / 180,
                                axShape.style.x,
                                axShape.style.y
                            ];
                        }
                        this.shapeList.push(new TextShape(
                            this._axisLabelClickable(clickable, axShape)
                        ));
                    }
                }
                else {
                    // 纵向
                    var xPosition;
                    var align;
                    if (this.option.position == &#x27;left&#x27;) {
                        xPosition = this.grid.getX() - margin;
                        align = &#x27;right&#x27;;
                    }
                    else {
                        xPosition = this.grid.getXend() + margin;
                        align = &#x27;left&#x27;;
                    }

                    for (var i = 0; i &lt; dataLength; i += this._interval) {
                        if (this._getReformedLabel(i) === &#x27;&#x27;) {
                            // 空文本优化
                            continue;
                        }
                        dataTextStyle = zrUtil.merge(
                                data[i].textStyle || {},
                            textStyle
                        );
                        axShape = {
                            // shape : &#x27;text&#x27;,
                            zlevel : this._zlevelBase,
                            hoverable : false,
                            style : {
                                x : xPosition,
                                y : this.getCoordByIndex(i),
                                color : dataTextStyle.color,
                                text : this._getReformedLabel(i),
                                textFont : this.getFont(dataTextStyle),
                                textAlign : dataTextStyle.align || align,
                                textBaseline : dataTextStyle.baseline
                                    || (i === 0 &amp;&amp; this.option.name !== &#x27;&#x27;)
                                    ? &#x27;bottom&#x27;
                                    : (i == (dataLength - 1)
                                    &amp;&amp; this.option.name !== &#x27;&#x27;)
                                    ? &#x27;top&#x27;
                                    : &#x27;middle&#x27;
                            }
                        };

                        if (rotate) {
                            axShape.rotation = [
                                    rotate * Math.PI / 180,
                                axShape.style.x,
                                axShape.style.y
                            ];
                        }
                        this.shapeList.push(new TextShape(
                            this._axisLabelClickable(clickable, axShape)
                        ));
                    }
                }
            },

            _buildSplitLine : function () {
                var axShape;
                //var data       = this.option.data;
                var dataLength  = this.option.data.length;
                var sLineOption = this.option.splitLine;
                var lineType    = sLineOption.lineStyle.type;
                var lineWidth   = sLineOption.lineStyle.width;
                var color       = sLineOption.lineStyle.color;
                color = color instanceof Array ? color : [color];
                var colorLength = color.length;

                var onGap      = sLineOption.onGap;
                var optGap     = onGap
                    ? (this.getGap() / 2)
                    : typeof onGap == &#x27;undefined&#x27;
                    ? (this.option.boundaryGap ? (this.getGap() / 2) : 0)
                    : 0;
                dataLength -= (onGap || (typeof onGap == &#x27;undefined&#x27; &amp;&amp; this.option.boundaryGap))
                    ? 1 : 0;
                if (this.isHorizontal()) {
                    // 横向
                    var sy = this.grid.getY();
                    var ey = this.grid.getYend();
                    var x;

                    for (var i = 0; i &lt; dataLength; i += this._interval) {
                        // 亚像素优化
                        x = this.subPixelOptimize(
                                this.getCoordByIndex(i) + optGap, lineWidth
                        );
                        axShape = {
                            // shape : &#x27;line&#x27;,
                            zlevel : this._zlevelBase,
                            hoverable : false,
                            style : {
                                xStart : x,
                                yStart : sy,
                                xEnd : x,
                                yEnd : ey,
                                strokeColor : color[(i / this._interval) % colorLength],
                                lineType : lineType,
                                lineWidth : lineWidth
                            }
                        };
                        this.shapeList.push(new LineShape(axShape));
                    }

                }
                else {
                    // 纵向
                    var sx = this.grid.getX();
                    var ex = this.grid.getXend();
                    var y;

                    for (var i = 0; i &lt; dataLength; i += this._interval) {
                        // 亚像素优化
                        y = this.subPixelOptimize(
                                this.getCoordByIndex(i) - optGap, lineWidth
                        );
                        axShape = {
                            // shape : &#x27;line&#x27;,
                            zlevel : this._zlevelBase,
                            hoverable : false,
                            style : {
                                xStart : sx,
                                yStart : y,
                                xEnd : ex,
                                yEnd : y,
                                strokeColor : color[(i / this._interval) % colorLength],
                                linetype : lineType,
                                lineWidth : lineWidth
                            }
                        };
                        this.shapeList.push(new LineShape(axShape));
                    }
                }
            },

            _buildSplitArea : function () {
                var axShape;
                var sAreaOption = this.option.splitArea;
                var color = sAreaOption.areaStyle.color;
                if (!(color instanceof Array)) {
                    // 非数组一律认为是单一颜色的字符串，单一颜色则用一个背景，颜色错误不负责啊！！！
                    axShape = {
                        // shape : &#x27;rectangle&#x27;,
                        zlevel : this._zlevelBase,
                        hoverable : false,
                        style : {
                            x : this.grid.getX(),
                            y : this.grid.getY(),
                            width : this.grid.getWidth(),
                            height : this.grid.getHeight(),
                            color : color
                            // type : this.option.splitArea.areaStyle.type,
                        }
                    };
                    this.shapeList.push(new RectangleShape(axShape));
                }
                else {
                    // 多颜色
                    var colorLength = color.length;
                    var dataLength  = this.option.data.length;

                    var onGap      = sAreaOption.onGap;
                    var optGap     = onGap
                        ? (this.getGap() / 2)
                        : typeof onGap == &#x27;undefined&#x27;
                        ? (this.option.boundaryGap ? (this.getGap() / 2) : 0)
                        : 0;
                    if (this.isHorizontal()) {
                        // 横向
                        var y = this.grid.getY();
                        var height = this.grid.getHeight();
                        var lastX = this.grid.getX();
                        var curX;

                        for (var i = 0; i &lt;= dataLength; i += this._interval) {
                            curX = i &lt; dataLength
                                ? (this.getCoordByIndex(i) + optGap)
                                : this.grid.getXend();
                            axShape = {
                                // shape : &#x27;rectangle&#x27;,
                                zlevel : this._zlevelBase,
                                hoverable : false,
                                style : {
                                    x : lastX,
                                    y : y,
                                    width : curX - lastX,
                                    height : height,
                                    color : color[(i / this._interval) % colorLength]
                                    // type : this.option.splitArea.areaStyle.type,
                                }
                            };
                            this.shapeList.push(new RectangleShape(axShape));
                            lastX = curX;
                        }
                    }
                    else {
                        // 纵向
                        var x = this.grid.getX();
                        var width = this.grid.getWidth();
                        var lastYend = this.grid.getYend();
                        var curY;

                        for (var i = 0; i &lt;= dataLength; i += this._interval) {
                            curY = i &lt; dataLength
                                ? (this.getCoordByIndex(i) - optGap)
                                : this.grid.getY();
                            axShape = {
                                // shape : &#x27;rectangle&#x27;,
                                zlevel : this._zlevelBase,
                                hoverable : false,
                                style : {
                                    x : x,
                                    y : curY,
                                    width : width,
                                    height : lastYend - curY,
                                    color : color[(i / this._interval) % colorLength]
                                    // type : this.option.splitArea.areaStyle.type
                                }
                            };
                            this.shapeList.push(new RectangleShape(axShape));
                            lastYend = curY;
                        }
                    }
                }
            },

            /**
             * 刷新
             */
            refresh : function (newOption) {
                if (newOption) {
                    this.option = this.reformOption(newOption);
                    // 通用字体设置
                    this.option.axisLabel.textStyle = zrUtil.merge(
                            this.option.axisLabel.textStyle || {},
                        this.ecTheme.textStyle
                    );
                }
                this.clear();
                this._buildShape();
            },

            /**
             * 返回间隔
             */
            getGap : function () {
                var dataLength = this.option.data.length;
                var total = this.isHorizontal()
                    ? this.grid.getWidth()
                    : this.grid.getHeight();
                if (this.option.boundaryGap) {              // 留空
                    return total / dataLength;
                }
                else {                                      // 顶头
                    return total / (dataLength &gt; 1 ? (dataLength - 1) : 1);
                }
            },

            // 根据值换算位置
            getCoord : function (value) {
                var data = this.option.data;
                var dataLength = data.length;
                var gap = this.getGap();
                var position = this.option.boundaryGap ? (gap / 2) : 0;

                for (var i = 0; i &lt; dataLength; i++) {
                    if (data[i] == value
                        || (typeof data[i].value != &#x27;undefined&#x27;
                            &amp;&amp; data[i].value == value)
                        ) {
                        if (this.isHorizontal()) {
                            // 横向
                            position = this.grid.getX() + position;
                        }
                        else {
                            // 纵向
                            position = this.grid.getYend() - position;
                        }

                        return position;
                        // Math.floor可能引起一些偏差，但性能会更好
                        /* 准确更重要
                         return (i === 0 || i == dataLength - 1)
                         ? position
                         : Math.floor(position);
                         */
                    }
                    position += gap;
                }
            },

            // 根据类目轴数据索引换算位置
            getCoordByIndex : function (dataIndex) {
                if (dataIndex &lt; 0) {
                    if (this.isHorizontal()) {
                        return this.grid.getX();
                    }
                    else {
                        return this.grid.getYend();
                    }
                }
                else if (dataIndex &gt; this.option.data.length - 1) {
                    if (this.isHorizontal()) {
                        return this.grid.getXend();
                    }
                    else {
                        return this.grid.getY();
                    }
                }
                else {
                    var gap = this.getGap();
                    var position = this.option.boundaryGap ? (gap / 2) : 0;
                    position += dataIndex * gap;

                    if (this.isHorizontal()) {
                        // 横向
                        position = this.grid.getX() + position;
                    }
                    else {
                        // 纵向
                        position = this.grid.getYend() - position;
                    }

                    return position;
                    /* 准确更重要
                     return (dataIndex === 0 || dataIndex == this.option.data.length - 1)
                     ? position
                     : Math.floor(position);
                     */
                }
            },

            // 根据类目轴数据索引换算类目轴名称
            getNameByIndex : function (dataIndex) {
                var data = this.option.data[dataIndex];
                if (typeof data != &#x27;undefined&#x27; &amp;&amp; typeof data.value != &#x27;undefined&#x27;)
                {
                    return data.value;
                }
                else {
                    return data;
                }
            },

            // 根据类目轴名称换算类目轴数据索引
            getIndexByName : function (name) {
                var data = this.option.data;
                var dataLength = data.length;

                for (var i = 0; i &lt; dataLength; i++) {
                    if (data[i] == name
                        || (typeof data[i].value != &#x27;undefined&#x27;
                            &amp;&amp; data[i].value == name)
                        ) {
                        return i;
                    }
                }

                return -1;
            },

            // 根据位置换算值
            getValueFromCoord : function() {
                return &#x27;&#x27;;
            },

            /**
             * 根据类目轴数据索引返回是否为主轴线
             * @param {number} dataIndex 类目轴数据索引
             * @return {boolean} 是否为主轴
             */
            isMainAxis : function (dataIndex) {
                return dataIndex % this._interval === 0;
            }
        };

        zrUtil.inherits(CategoryAxis, Base);

        require(&#x27;../component&#x27;).define(&#x27;categoryAxis&#x27;, CategoryAxis);

        return CategoryAxis;
    });
    /**
     * echarts组件： 数值轴
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/component/valueAxis&#x27;,[&#x27;require&#x27;,&#x27;./base&#x27;,&#x27;zrender/shape/Text&#x27;,&#x27;zrender/shape/Line&#x27;,&#x27;zrender/shape/Rectangle&#x27;,&#x27;../config&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;../component&#x27;],function (require) {
        var Base = require(&#x27;./base&#x27;);

        // 图形依赖
        var TextShape = require(&#x27;zrender/shape/Text&#x27;);
        var LineShape = require(&#x27;zrender/shape/Line&#x27;);
        var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);

        var ecConfig = require(&#x27;../config&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 类目轴参数
         * @param {Object} component 组件
         * @param {Array} series 数据对象
         */
        function ValueAxis(ecTheme, messageCenter, zr, option, myChart, axisBase, series) {
            if (!series || series.length === 0) {
                console.err(&#x27;option.series.length == 0.&#x27;);
                return;
            }

            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            this.series = series;
            this.grid = this.component.grid;

            for (var method in axisBase) {
                this[method] = axisBase[method];
            }

            this.refresh(option, series);
        }

        ValueAxis.prototype = {
            type : ecConfig.COMPONENT_TYPE_AXIS_VALUE,
            _buildShape : function () {
                this._hasData = false;
                this._calculateValue();
                if (!this._hasData) {
                    return;
                }
                this.option.splitArea.show &amp;&amp; this._buildSplitArea();
                this.option.splitLine.show &amp;&amp; this._buildSplitLine();
                this.option.axisLine.show &amp;&amp; this._buildAxisLine();
                this.option.axisTick.show &amp;&amp; this._buildAxisTick();
                this.option.axisLabel.show &amp;&amp; this._buildAxisLabel();

                for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                    this.zr.addShape(this.shapeList[i]);
                }
            },

            // 小标记
            _buildAxisTick : function () {
                var axShape;
                var data       = this._valueList;
                var dataLength = this._valueList.length;
                var tickOption = this.option.axisTick;
                var length     = tickOption.length;
                var color      = tickOption.lineStyle.color;
                var lineWidth  = tickOption.lineStyle.width;

                if (this.isHorizontal()) {
                    // 横向
                    var yPosition = this.option.position == &#x27;bottom&#x27;
                        ? (tickOption.inside
                        ? (this.grid.getYend() - length - 1) : (this.grid.getYend()) + 1)
                        : (tickOption.inside
                        ? (this.grid.getY() + 1) : (this.grid.getY() - length - 1));
                    var x;
                    for (var i = 0; i &lt; dataLength; i++) {
                        // 亚像素优化
                        x = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                        axShape = {
                            _axisShape : &#x27;axisTick&#x27;,
                            zlevel : this._zlevelBase,
                            hoverable : false,
                            style : {
                                xStart : x,
                                yStart : yPosition,
                                xEnd : x,
                                yEnd : yPosition + length,
                                strokeColor : color,
                                lineWidth : lineWidth
                            }
                        };
                        this.shapeList.push(new LineShape(axShape));
                    }
                }
                else {
                    // 纵向
                    var xPosition = this.option.position == &#x27;left&#x27;
                        ? (tickOption.inside
                        ? (this.grid.getX() + 1) : (this.grid.getX() - length - 1))
                        : (tickOption.inside
                        ? (this.grid.getXend() - length - 1) : (this.grid.getXend() + 1));

                    var y;
                    for (var i = 0; i &lt; dataLength; i++) {
                        // 亚像素优化
                        y = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                        axShape = {
                            _axisShape : &#x27;axisTick&#x27;,
                            zlevel : this._zlevelBase,
                            hoverable : false,
                            style : {
                                xStart : xPosition,
                                yStart : y,
                                xEnd : xPosition + length,
                                yEnd : y,
                                strokeColor : color,
                                lineWidth : lineWidth
                            }
                        };
                        this.shapeList.push(new LineShape(axShape));
                    }
                }
            },

            // 坐标轴文本
            _buildAxisLabel : function () {
                var axShape;
                var data       = this._valueList;
                var dataLength = this._valueList.length;
                var rotate     = this.option.axisLabel.rotate;
                var margin     = this.option.axisLabel.margin;
                var clickable  = this.option.axisLabel.clickable;
                var textStyle  = this.option.axisLabel.textStyle;

                if (this.isHorizontal()) {
                    // 横向
                    var yPosition;
                    var baseLine;
                    if (this.option.position == &#x27;bottom&#x27;) {
                        yPosition = this.grid.getYend() + margin;
                        baseLine = &#x27;top&#x27;;
                    }
                    else {
                        yPosition = this.grid.getY() - margin;
                        baseLine = &#x27;bottom&#x27;;
                    }

                    for (var i = 0; i &lt; dataLength; i++) {
                        axShape = {
                            zlevel : this._zlevelBase,
                            hoverable : false,
                            style : {
                                x : this.getCoord(data[i]),
                                y : yPosition,
                                color : typeof textStyle.color == &#x27;function&#x27;
                                    ? textStyle.color(data[i]) : textStyle.color,
                                text : this._valueLabel[i],
                                textFont : this.getFont(textStyle),
                                textAlign : textStyle.align || &#x27;center&#x27;,
                                textBaseline : textStyle.baseline || baseLine
                            }
                        };
                        if (rotate) {
                            axShape.style.textAlign = rotate &gt; 0
                                ? (this.option.position == &#x27;bottom&#x27;
                                ? &#x27;right&#x27; : &#x27;left&#x27;)
                                : (this.option.position == &#x27;bottom&#x27;
                                ? &#x27;left&#x27; : &#x27;right&#x27;);
                            axShape.rotation = [
                                    rotate * Math.PI / 180,
                                axShape.style.x,
                                axShape.style.y
                            ];
                        }
                        this.shapeList.push(new TextShape(
                            this._axisLabelClickable(clickable, axShape)
                        ));
                    }
                }
                else {
                    // 纵向
                    var xPosition;
                    var align;
                    if (this.option.position == &#x27;left&#x27;) {
                        xPosition = this.grid.getX() - margin;
                        align = &#x27;right&#x27;;
                    }
                    else {
                        xPosition = this.grid.getXend() + margin;
                        align = &#x27;left&#x27;;
                    }

                    for (var i = 0; i &lt; dataLength; i++) {
                        axShape = {
                            zlevel : this._zlevelBase,
                            hoverable : false,
                            style : {
                                x : xPosition,
                                y : this.getCoord(data[i]),
                                color : typeof textStyle.color == &#x27;function&#x27;
                                    ? textStyle.color(data[i]) : textStyle.color,
                                text : this._valueLabel[i],
                                textFont : this.getFont(textStyle),
                                textAlign : textStyle.align || align,
                                textBaseline : textStyle.baseline
                                    || (i === 0 &amp;&amp; this.option.name !== &#x27;&#x27;)
                                    ? &#x27;bottom&#x27;
                                    : (i == (dataLength - 1)
                                    &amp;&amp; this.option.name !== &#x27;&#x27;)
                                    ? &#x27;top&#x27;
                                    : &#x27;middle&#x27;
                            }
                        };

                        if (rotate) {
                            axShape.rotation = [
                                    rotate * Math.PI / 180,
                                axShape.style.x,
                                axShape.style.y
                            ];
                        }
                        this.shapeList.push(new TextShape(
                            this._axisLabelClickable(clickable, axShape)
                        ));
                    }
                }
            },

            _buildSplitLine : function () {
                var axShape;
                var data        = this._valueList;
                var dataLength  = this._valueList.length;
                var sLineOption = this.option.splitLine;
                var lineType    = sLineOption.lineStyle.type;
                var lineWidth   = sLineOption.lineStyle.width;
                var color       = sLineOption.lineStyle.color;
                color = color instanceof Array ? color : [color];
                var colorLength = color.length;

                if (this.isHorizontal()) {
                    // 横向
                    var sy = this.grid.getY();
                    var ey = this.grid.getYend();
                    var x;

                    for (var i = 0; i &lt; dataLength; i++) {
                        // 亚像素优化
                        x = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                        axShape = {
                            zlevel : this._zlevelBase,
                            hoverable : false,
                            style : {
                                xStart : x,
                                yStart : sy,
                                xEnd : x,
                                yEnd : ey,
                                strokeColor : color[i % colorLength],
                                lineType : lineType,
                                lineWidth : lineWidth
                            }
                        };
                        this.shapeList.push(new LineShape(axShape));
                    }

                }
                else {
                    // 纵向
                    var sx = this.grid.getX();
                    var ex = this.grid.getXend();
                    var y;

                    for (var i = 0; i &lt; dataLength; i++) {
                        // 亚像素优化
                        y = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                        axShape = {
                            zlevel : this._zlevelBase,
                            hoverable : false,
                            style : {
                                xStart : sx,
                                yStart : y,
                                xEnd : ex,
                                yEnd : y,
                                strokeColor : color[i % colorLength],
                                lineType : lineType,
                                lineWidth : lineWidth
                            }
                        };
                        this.shapeList.push(new LineShape(axShape));
                    }
                }
            },

            _buildSplitArea : function () {
                var axShape;
                var color = this.option.splitArea.areaStyle.color;

                if (!(color instanceof Array)) {
                    // 非数组一律认为是单一颜色的字符串，单一颜色则用一个背景，颜色错误不负责啊！！！
                    axShape = {
                        zlevel : this._zlevelBase,
                        hoverable : false,
                        style : {
                            x : this.grid.getX(),
                            y : this.grid.getY(),
                            width : this.grid.getWidth(),
                            height : this.grid.getHeight(),
                            color : color
                            // type : this.option.splitArea.areaStyle.type,
                        }
                    };
                    this.shapeList.push(new RectangleShape(axShape));
                }
                else {
                    // 多颜色
                    var colorLength = color.length;
                    var data        = this._valueList;
                    var dataLength  = this._valueList.length;

                    if (this.isHorizontal()) {
                        // 横向
                        var y = this.grid.getY();
                        var height = this.grid.getHeight();
                        var lastX = this.grid.getX();
                        var curX;

                        for (var i = 0; i &lt;= dataLength; i++) {
                            curX = i &lt; dataLength
                                ? this.getCoord(data[i])
                                : this.grid.getXend();
                            axShape = {
                                zlevel : this._zlevelBase,
                                hoverable : false,
                                style : {
                                    x : lastX,
                                    y : y,
                                    width : curX - lastX,
                                    height : height,
                                    color : color[i % colorLength]
                                    // type : this.option.splitArea.areaStyle.type,
                                }
                            };
                            this.shapeList.push(new RectangleShape(axShape));
                            lastX = curX;
                        }
                    }
                    else {
                        // 纵向
                        var x = this.grid.getX();
                        var width = this.grid.getWidth();
                        var lastYend = this.grid.getYend();
                        var curY;

                        for (var i = 0; i &lt;= dataLength; i++) {
                            curY = i &lt; dataLength
                                ? this.getCoord(data[i])
                                : this.grid.getY();
                            axShape = {
                                zlevel : this._zlevelBase,
                                hoverable : false,
                                style : {
                                    x : x,
                                    y : curY,
                                    width : width,
                                    height : lastYend - curY,
                                    color : color[i % colorLength]
                                    // type : this.option.splitArea.areaStyle.type
                                }
                            };
                            this.shapeList.push(new RectangleShape(axShape));
                            lastYend = curY;
                        }
                    }
                }
            },

            /**
             * 极值计算
             */
            _calculateValue : function () {
                if (isNaN(this.option.min - 0) || isNaN(this.option.max - 0)) {
                    // 有一个没指定都得算
                    // 数据整形
                    var oriData;            // 原始数据
                    var data = {};          // 整形后数据抽取
                    var value;
                    var xIdx;
                    var yIdx;
                    var legend = this.component.legend;
                    for (var i = 0, l = this.series.length; i &lt; l; i++) {
                        if (this.series[i].type != ecConfig.CHART_TYPE_LINE
                            &amp;&amp; this.series[i].type != ecConfig.CHART_TYPE_BAR
                            &amp;&amp; this.series[i].type != ecConfig.CHART_TYPE_SCATTER
                            &amp;&amp; this.series[i].type != ecConfig.CHART_TYPE_K
                            ) {
                            // 非坐标轴支持的不算极值
                            continue;
                        }
                        // 请允许我写开，跟上面一个不是一样东西
                        if (legend &amp;&amp; !legend.isSelected(this.series[i].name)){
                            continue;
                        }

                        // 不指定默认为第一轴线
                        xIdx = this.series[i].xAxisIndex || 0;
                        yIdx = this.series[i].yAxisIndex || 0;
                        if ((this.option.xAxisIndex != xIdx)
                            &amp;&amp; (this.option.yAxisIndex != yIdx)
                            ) {
                            // 不是自己的数据不计算极值
                            continue;
                        }

                        var key = this.series[i].name || &#x27;kener&#x27;;
                        if (!this.series[i].stack) {
                            data[key] = data[key] || [];
                            oriData = this.series[i].data;
                            for (var j = 0, k = oriData.length; j &lt; k; j++) {
                                value = typeof oriData[j].value != &#x27;undefined&#x27;
                                    ? oriData[j].value
                                    : oriData[j];
                                if (this.series[i].type == ecConfig.CHART_TYPE_SCATTER) {
                                    if (this.option.xAxisIndex != -1) {
                                        data[key].push(value[0]);
                                    }
                                    if (this.option.yAxisIndex != -1) {
                                        data[key].push(value[1]);
                                    }
                                }
                                else if (this.series[i].type == ecConfig.CHART_TYPE_K) {
                                    data[key].push(value[0]);
                                    data[key].push(value[1]);
                                    data[key].push(value[2]);
                                    data[key].push(value[3]);
                                }
                                else {
                                    data[key].push(value);
                                }
                            }
                        }
                        else {
                            // 堆积数据，需要区分正负向堆积
                            var keyP = &#x27;__Magic_Key_Positive__&#x27; + this.series[i].stack;
                            var keyN = &#x27;__Magic_Key_Negative__&#x27; + this.series[i].stack;
                            data[keyP] = data[keyP] || [];
                            data[keyN] = data[keyN] || [];
                            data[key] = data[key] || [];  // scale下还需要记录每一个量
                            oriData = this.series[i].data;
                            for (var j = 0, k = oriData.length; j &lt; k; j++) {
                                value = typeof oriData[j].value != &#x27;undefined&#x27;
                                    ? oriData[j].value
                                    : oriData[j];
                                if (value == &#x27;-&#x27;) {
                                    continue;
                                }
                                value = value - 0;
                                if (value &gt;= 0) {
                                    if (typeof data[keyP][j] != &#x27;undefined&#x27;) {
                                        data[keyP][j] += value;
                                    }
                                    else {
                                        data[keyP][j] = value;
                                    }
                                }
                                else {
                                    if (typeof data[keyN][j] != &#x27;undefined&#x27;) {
                                        data[keyN][j] += value;
                                    }
                                    else {
                                        data[keyN][j] = value;
                                    }
                                }
                                if (this.option.scale) {
                                    data[key].push(value);
                                }
                            }
                        }
                    }
                    // 找极值
                    for (var i in data){
                        oriData = data[i];
                        for (var j = 0, k = oriData.length; j &lt; k; j++) {
                            if (!isNaN(oriData[j])){
                                this._hasData = true;
                                this._min = oriData[j];
                                this._max = oriData[j];
                                break;
                            }
                        }
                        if (this._hasData) {
                            break;
                        }
                    }
                    for (var i in data){
                        oriData = data[i];
                        for (var j = 0, k = oriData.length; j &lt; k; j++) {
                            if (!isNaN(oriData[j])){
                                this._min = Math.min(this._min, oriData[j]);
                                this._max = Math.max(this._max, oriData[j]);
                            }
                        }
                    }

                    //console.log(this._min,this._max,&#x27;vvvvv111111&#x27;)
                    this._min = isNaN(this.option.min - 0)
                        ? (this._min - Math.abs(this._min * this.option.boundaryGap[0]))
                        : (this.option.min - 0);    // 指定min忽略boundaryGay[0]

                    this._max = isNaN(this.option.max - 0)
                        ? (this._max + Math.abs(this._max * this.option.boundaryGap[1]))
                        : (this.option.max - 0);    // 指定max忽略boundaryGay[1]
                    if (this._min == this._max) {
                        if (this._max === 0) {
                            // 修复全0数据
                            this._max = this.option.power &gt; 0 ? this.option.power : 1;
                        }
                        // 修复最大值==最小值时数据整形
                        else if (this._max &gt; 0) {
                            this._min = this._max / this.option.splitNumber;
                        }
                        else { // this._max &lt; 0
                            this._max = this._max / this.option.splitNumber;
                        }
                    }
                    this._reformValue(this.option.scale);
                }
                else {
                    this._hasData = true;
                    // 用户指定min max就不多管闲事了
                    this._min = this.option.min - 0;    // 指定min忽略boundaryGay[0]
                    this._max = this.option.max - 0;    // 指定max忽略boundaryGay[1]
                    customerDefine = true;
                    this._customerValue();
                }
            },

            /**
             * 找到原始数据的极值后根据选项整形最终 this._min / this._max / this._valueList
             * 如果你不知道这个“整形”的用义，请不要试图去理解和修改这个方法！找我也没用，我相信我已经记不起来！
             * 如果你有更简洁的数学推导欢迎重写，后果自负~
             * 一旦你不得不遇到了需要修改或重写的厄运，希望下面的脚手架能帮助你
             * ps:其实我是想说别搞砸了！升级后至少得保证这些case通过！！
             *
             * by linzhifeng@baidu.com 2013-1-8
             * --------
             this._valueList = [];
             this.option = {splitNumber:5,power:100,precision:0};
             this._min = 1; this._max = 123; console.log(this._min, this._max); this._reformValue();
             console.log(&#x27;result is :&#x27;, this._min, this._max, this._valueList);
             console.log(&#x27;should be : 0 150 [0, 30, 60, 90, 120, 150]&#x27;,
             (this._min == 0 &amp;&amp; this._max == 150) ? &#x27;success&#x27; : &#x27;failed&#x27;);

             this._min = 10; this._max = 1923; console.log(this._min, this._max); this._reformValue();
             console.log(&#x27;result is :&#x27;, this._min, this._max, this._valueList);
             console.log(&#x27;should be : 0 2000 [0, 400, 800, 1200, 1600, 2000]&#x27;,
             (this._min == 0 &amp;&amp; this._max == 2000) ? &#x27;success&#x27; : &#x27;failed&#x27;);

             this._min = 10; this._max = 78; console.log(this._min, this._max); this._reformValue();
             console.log(&#x27;result is :&#x27;, this._min, this._max, this._valueList);
             console.log(&#x27;should be : 0 100 [0, 20, 40, 60, 80, 100]&#x27;,
             (this._min == 0 &amp;&amp; this._max == 100) ? &#x27;success&#x27; : &#x27;failed&#x27;);

             this._min = -31; this._max = -3; console.log(this._min, this._max); this._reformValue();
             console.log(&#x27;result is :&#x27;, this._min, this._max, this._valueList);
             console.log(&#x27;should be : -35 0 [-35, -28, -21, -14, -7, 0]&#x27;,
             (this._min == -35 &amp;&amp; this._max == 0) ? &#x27;success&#x27; : &#x27;failed&#x27;);

             this._min = -51; this._max = 203; console.log(this._min, this._max); this._reformValue();
             console.log(&#x27;result is :&#x27;, this._min, this._max, this._valueList);
             console.log(&#x27;should be : -60 240 [-60, 0, 60, 120, 180, 240]&#x27;,
             (this._min == -60 &amp;&amp; this._max == 240) ? &#x27;success&#x27; : &#x27;failed&#x27;);

             this._min = -251; this._max = 23; console.log(this._min, this._max); this._reformValue();
             console.log(&#x27;result is :&#x27;, this._min, this._max, this._valueList);
             console.log(&#x27;should be : -280 70 [-280, -210, -140, -70, 0, 70]&#x27;,
             (this._min == -280 &amp;&amp; this._max == 70) ? &#x27;success&#x27; : &#x27;failed&#x27;);

             this.option.precision = 2;
             this._min = 0.23; this._max = 0.78; console.log(this._min, this._max); this._reformValue();
             console.log(&#x27;result is :&#x27;, this._min, this._max, this._valueList);
             console.log(&#x27;should be : 0.00 1.00&#x27;
             + &#x27;[&quot;0.00&quot;, &quot;0.20&quot;, &quot;0.40&quot;, &quot;0.60&quot;, &quot;0.80&quot;, &quot;1.00&quot;]&#x27;,
             (this._min == 0.00 &amp;&amp; this._max == 1.00) ? &#x27;success&#x27; : &#x27;failed&#x27;);

             this._min = -12.23; this._max = -0.78; console.log(this._min, this._max);
             this._reformValue();
             console.log(&#x27;result is :&#x27;, this._min, this._max, this._valueList);
             console.log(&#x27;should be : -15.00 0.00&#x27;
             + &#x27;[&quot;-15.00&quot;, &quot;-12.00&quot;, &quot;-9.00&quot;, &quot;-6.00&quot;, &quot;-3.00&quot;, &quot;0.00&quot;]&#x27;,
             (this._min == -15.00 &amp;&amp; this._max == 0.00) ? &#x27;success&#x27; : &#x27;failed&#x27;);

             this._min = -0.23; this._max = 0.78; console.log(this._min, this._max); this._reformValue()
             console.log(&#x27;result is :&#x27;, this._min, this._max, this._valueList);
             console.log(&#x27;should be : -0.30 1.20&#x27;
             + &#x27;[&quot;-0.30&quot;, &quot;0.00&quot;, &quot;0.30&quot;, &quot;0.60&quot;, &quot;0.90&quot;, &quot;1.20&quot;]&#x27;,
             (this._min == -0.30 &amp;&amp; this._max == 1.20) ? &#x27;success&#x27; : &#x27;failed&#x27;);

             this._min = -1.23; this._max = 0.78; console.log(this._min, this._max); _reformValue();
             console.log(&#x27;result is :&#x27;, this._min, this._max, this._valueList);
             console.log(&#x27;should be : -1.50 1.00&#x27;
             + &#x27;[&quot;-1.50&quot;, &quot;-1.00&quot;, &quot;-0.50&quot;, &quot;0.00&quot;, &quot;0.50&quot;, &quot;1.00&quot;]&#x27;,
             (this._min == -1.50 &amp;&amp; this._max == 1.00) ? &#x27;success&#x27; : &#x27;failed&#x27;);

             this.option.precision = 1;
             this._min = -2.3; this._max = 0.5; console.log(this._min, this._max); _reformValue();
             console.log(&#x27;result is :&#x27;, this._min, this._max, this._valueList);
             console.log(&#x27;should be : -2.4 0.6&#x27;
             + &#x27;[&quot;-2.4&quot;, &quot;-1.8&quot;, &quot;-1.2&quot;, &quot;-0.6&quot;, &quot;0.0&quot;, &quot;0.6&quot;]&#x27;,
             (this._min == -2.4 &amp;&amp; this._max == 0.6) ? &#x27;success&#x27; : &#x27;failed&#x27;);
             * --------
             */
            _reformValue : function (scale) {
                var splitNumber = this.option.splitNumber;
                var precision = this.option.precision;
                var splitGap;
                var power;
                if (precision === 0) {    // 整数
                    power = this.option.power &gt; 1 ? this.option.power : 1;
                }
                else {                          // 小数
                    // 放大倍数后复用整数逻辑，最后再缩小回去
                    power = Math.pow(10, precision);
                    this._min *= power;
                    this._max *= power;
                    power = this.option.power;
                }
                // console.log(this._min,this._max)
                var total;
                if (this._min &gt;= 0 &amp;&amp; this._max &gt;= 0) {
                    // 双正
                    if (!scale) {
                        // power自动降级
                        while ((this._max / power &lt; splitNumber) &amp;&amp; power != 1) {
                            power = power / 10;
                        }
                        this._min = 0;
                    }
                    else {
                        // power自动降级
                        while (this._min &lt; power &amp;&amp; power != 1) {
                            power = power / 10;
                        }
                        if (precision === 0) {    // 整数
                            // 满足power
                            this._min = Math.floor(this._min / power) * power;
                            this._max = Math.ceil(this._max / power) * power;
                        }
                    }
                    power = power &gt; 1 ? power / 10 : 1;
                    total = this._max - this._min;
                    splitGap = Math.ceil((total / splitNumber) / power) * power;
                    this._max = this._min + splitGap * splitNumber;
                }
                else if (this._min &lt;= 0 &amp;&amp; this._max &lt;= 0) {
                    // 双负
                    power = -power;
                    if (!scale) {
                        // power自动降级
                        while ((this._min / power &lt; splitNumber) &amp;&amp; power != -1) {
                            power = power / 10;
                        }
                        this._max = 0;
                    }
                    else {
                        // power自动降级
                        while (this._max &gt; power &amp;&amp; power != -1) {
                            power = power / 10;
                        }
                        if (precision === 0) {    // 整数
                            // 满足power
                            this._min = Math.ceil(this._min / power) * power;
                            this._max = Math.floor(this._max / power) * power;
                        }
                    }
                    power = power &lt; -1 ? power / 10 : -1;
                    total = this._min - this._max;
                    splitGap = -Math.ceil((total / splitNumber) / power) * power;
                    this._min = -splitGap * splitNumber + this._max;
                }
                else {
                    // 一正一负，确保0被选中
                    total = this._max - this._min;
                    // power自动降级
                    while ((total / power &lt; splitNumber) &amp;&amp; power != 1) {
                        power = power/10;
                    }
                    // 正数部分的分隔数
                    var partSplitNumber = Math.round(this._max / total * splitNumber);
                    // 修正数据范围极度偏正向，留给负数一个
                    partSplitNumber -= (partSplitNumber == splitNumber ? 1 : 0);
                    // 修正数据范围极度偏负向，留给正数一个
                    partSplitNumber += partSplitNumber === 0 ? 1 : 0;
                    splitGap = (Math.ceil(Math.max(
                            this._max / partSplitNumber,
                            this._min / (partSplitNumber - splitNumber)
                    )
                        / power))
                        * power;

                    this._max = splitGap * partSplitNumber;
                    this._min = splitGap * (partSplitNumber - splitNumber);
                }
                //console.log(this._min,this._max,&#x27;vvvvvrrrrrr&#x27;)
                this._valueList = [];
                for (var i = 0; i &lt;= splitNumber; i++) {
                    this._valueList.push(this._min + splitGap * i);
                }

                if (precision !== 0) {    // 小数
                    // 放大倍数后复用整数逻辑，最后再缩小回去
                    power = Math.pow(10, precision);
                    this._min = (this._min / power).toFixed(precision) - 0;
                    this._max = (this._max / power).toFixed(precision) - 0;
                    for (var i = 0; i &lt;= splitNumber; i++) {
                        this._valueList[i] =
                            (this._valueList[i] / power).toFixed(precision) - 0;
                    }
                }
                this._reformLabelData();
            },

            _customerValue : function () {
                var splitNumber = this.option.splitNumber;
                var precision = this.option.precision;
                var splitGap = (this._max - this._min) / splitNumber;

                this._valueList = [];
                for (var i = 0; i &lt;= splitNumber; i++) {
                    this._valueList.push((this._min + splitGap * i).toFixed(precision) - 0);
                }
                this._reformLabelData();
            },

            _reformLabelData : function () {
                this._valueLabel = [];
                var formatter = this.option.axisLabel.formatter;
                if (formatter) {
                    for (var i = 0, l = this._valueList.length; i &lt; l; i++) {
                        if (typeof formatter == &#x27;function&#x27;) {
                            this._valueLabel.push(formatter(this._valueList[i]));
                        }
                        else if (typeof formatter == &#x27;string&#x27;) {
                            this._valueLabel.push(
                                formatter.replace(&#x27;{value}&#x27;,this._valueList[i])
                            );
                        }
                    }
                }
                else {
                    // 每三位默认加,格式化
                    for (var i = 0, l = this._valueList.length; i &lt; l; i++) {
                        this._valueLabel.push(this.numAddCommas(this._valueList[i]));
                    }
                }

            },

            getExtremum : function () {
                this._calculateValue();
                return {
                    min: this._min,
                    max: this._max
                };
            },

            /**
             * 刷新
             */
            refresh : function (newOption, newSeries) {
                if (newOption) {
                    this.option = this.reformOption(newOption);
                    // 通用字体设置
                    this.option.axisLabel.textStyle = zrUtil.merge(
                            this.option.axisLabel.textStyle || {},
                        this.ecTheme.textStyle
                    );
                    this.series = newSeries;
                }
                if (this.zr) {   // 数值轴的另外一个功能只是用来计算极值
                    this.clear();
                    this._buildShape();
                }
            },

            // 根据值换算位置
            getCoord : function (value) {
                value = value &lt; this._min ? this._min : value;
                value = value &gt; this._max ? this._max : value;

                var result;
                if (!this.isHorizontal()) {
                    // 纵向
                    result = this.grid.getYend()
                        - (value - this._min)
                        / (this._max - this._min)
                        * this.grid.getHeight();
                }
                else {
                    // 横向
                    result = this.grid.getX()
                        + (value - this._min)
                        / (this._max - this._min)
                        * this.grid.getWidth();
                }

                return result;
                // Math.floor可能引起一些偏差，但性能会更好
                /* 准确更重要
                 return (value == this._min || value == this._max)
                 ? result
                 : Math.floor(result);
                 */
            },

            // 根据值换算绝对大小
            getCoordSize : function (value) {
                if (!this.isHorizontal()) {
                    // 纵向
                    return Math.abs(value / (this._max - this._min) * this.grid.getHeight());
                }
                else {
                    // 横向
                    return Math.abs(value / (this._max - this._min) * this.grid.getWidth());
                }
            },

            // 根据位置换算值
            getValueFromCoord : function(coord) {
                var result;
                if (!this.isHorizontal()) {
                    // 纵向
                    coord = coord &lt; this.grid.getY() ? this.grid.getY() : coord;
                    coord = coord &gt; this.grid.getYend() ? this.grid.getYend() : coord;
                    result = this._max
                        - (coord - this.grid.getY())
                        / this.grid.getHeight()
                        * (this._max - this._min);
                }
                else {
                    // 横向
                    coord = coord &lt; this.grid.getX() ? this.grid.getX() : coord;
                    coord = coord &gt; this.grid.getXend() ? this.grid.getXend() : coord;
                    result = this._min
                        + (coord - this.grid.getX())
                        / this.grid.getWidth()
                        * (this._max - this._min);
                }

                return result.toFixed(2) - 0;
            }
        };

        zrUtil.inherits(ValueAxis, Base);

        require(&#x27;../component&#x27;).define(&#x27;valueAxis&#x27;, ValueAxis);

        return ValueAxis;
    });


    /**
     * echarts组件类： 坐标轴
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * 直角坐标系中坐标轴数组，数组中每一项代表一条横轴（纵轴）坐标轴。
     * 标准（1.0）中规定最多同时存在2条横轴和2条纵轴
     *    单条横轴时可指定安放于grid的底部（默认）或顶部，2条同时存在时则默认第一条安放于底部，第二天安放于顶部
     *    单条纵轴时可指定安放于grid的左侧（默认）或右侧，2条同时存在时则默认第一条安放于左侧，第二天安放于右侧。
     * 坐标轴有两种类型，类目型和数值型（区别详见axis）：
     *    横轴通常为类目型，但条形图时则横轴为数值型，散点图时则横纵均为数值型
     *    纵轴通常为数值型，但条形图时则纵轴为类目型。
     *
     */
    define(&#x27;echarts/component/axis&#x27;,[&#x27;require&#x27;,&#x27;./base&#x27;,&#x27;zrender/shape/Line&#x27;,&#x27;../config&#x27;,&#x27;../util/ecData&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/tool/color&#x27;,&#x27;./categoryAxis&#x27;,&#x27;./valueAxis&#x27;,&#x27;../component&#x27;],function (require) {
        var Base = require(&#x27;./base&#x27;);

        var LineShape = require(&#x27;zrender/shape/Line&#x27;);

        var ecConfig = require(&#x27;../config&#x27;);
        var ecData = require(&#x27;../util/ecData&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);
        var zrColor = require(&#x27;zrender/tool/color&#x27;);

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 图表选项
         *     @param {string=} option.xAxis.type 坐标轴类型，横轴默认为类目型&#x27;category&#x27;
         *     @param {string=} option.yAxis.type 坐标轴类型，纵轴默认为类目型&#x27;value&#x27;
         * @param {Object} component 组件
         * @param {string} axisType 横走or纵轴
         */
        function Axis(ecTheme, messageCenter, zr, option, myChart, axisType) {
            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            this.axisType = axisType;
            this._axisList = [];

            this.refresh(option);
        }

        Axis.prototype = {
            type : ecConfig.COMPONENT_TYPE_AXIS,
            axisBase : {
                // 轴线
                _buildAxisLine : function () {
                    var lineWidth = this.option.axisLine.lineStyle.width;
                    var halfLineWidth = lineWidth / 2;
                    var axShape = {
                        _axisShape : &#x27;axisLine&#x27;,
                        zlevel : this._zlevelBase + 1,
                        hoverable : false
                    };
                    switch (this.option.position) {
                        case &#x27;left&#x27; :
                            axShape.style = {
                                xStart : this.grid.getX() - halfLineWidth,
                                yStart : this.grid.getYend(),
                                xEnd : this.grid.getX() - halfLineWidth,
                                yEnd : this.grid.getY(),
                                lineCap : &#x27;round&#x27;
                            };
                            break;
                        case &#x27;right&#x27; :
                            axShape.style = {
                                xStart : this.grid.getXend() + halfLineWidth,
                                yStart : this.grid.getYend(),
                                xEnd : this.grid.getXend() + halfLineWidth,
                                yEnd : this.grid.getY(),
                                lineCap : &#x27;round&#x27;
                            };
                            break;
                        case &#x27;bottom&#x27; :
                            axShape.style = {
                                xStart : this.grid.getX(),
                                yStart : this.grid.getYend() + halfLineWidth,
                                xEnd : this.grid.getXend(),
                                yEnd : this.grid.getYend() + halfLineWidth,
                                lineCap : &#x27;round&#x27;
                            };
                            break;
                        case &#x27;top&#x27; :
                            axShape.style = {
                                xStart : this.grid.getX(),
                                yStart : this.grid.getY() - halfLineWidth,
                                xEnd : this.grid.getXend(),
                                yEnd : this.grid.getY() - halfLineWidth,
                                lineCap : &#x27;round&#x27;
                            };
                            break;
                    }
                    if (this.option.name !== &#x27;&#x27;) {
                        axShape.style.text = this.option.name;
                        axShape.style.textPosition = this.option.nameLocation;
                        axShape.style.textFont = this.getFont(this.option.nameTextStyle);
                        if (this.option.nameTextStyle.align) {
                            axShape.style.textAlign = this.option.nameTextStyle.align;
                        }
                        if (this.option.nameTextStyle.baseline) {
                            axShape.style.textBaseline = this.option.nameTextStyle.baseline;
                        }
                        if (this.option.nameTextStyle.color) {
                            axShape.style.textColor = this.option.nameTextStyle.color;
                        }
                    }
                    axShape.style.strokeColor = this.option.axisLine.lineStyle.color;

                    axShape.style.lineWidth = lineWidth;
                    // 亚像素优化
                    if (this.isHorizontal()) {
                        // 横向布局，优化y
                        axShape.style.yStart
                            = axShape.style.yEnd
                            = this.subPixelOptimize(axShape.style.yEnd, lineWidth);
                    }
                    else {
                        // 纵向布局，优化x
                        axShape.style.xStart
                            = axShape.style.xEnd
                            = this.subPixelOptimize(axShape.style.xEnd, lineWidth);
                    }

                    axShape.style.lineType = this.option.axisLine.lineStyle.type;

                    axShape = new LineShape(axShape);
                    this.shapeList.push(axShape);
                },

                _axisLabelClickable : function(clickable, axShape) {
                    if (clickable) {
                        ecData.pack(
                            axShape, undefined, -1, undefined, -1, axShape.style.text
                        );
                        axShape.hoverable = true;
                        axShape.clickable = true;
                        axShape.highlightStyle = {
                            color : zrColor.lift(axShape.style.color, 1),
                            brushType: &#x27;fill&#x27;
                        };
                        return axShape;
                    }
                    else {
                        return axShape;
                    }
                },

                refixAxisShape : function(zeroX, zeroY) {
                    if (!this.option.axisLine.onZero) {
                        return;
                    }
                    var tickLength;
                    if (this.isHorizontal() &amp;&amp; typeof zeroY != &#x27;undefined&#x27;) {
                        // 横向布局调整纵向y
                        for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                            if (this.shapeList[i]._axisShape == &#x27;axisLine&#x27;) {
                                this.shapeList[i].style.yStart
                                    = this.shapeList[i].style.yEnd
                                    = this.subPixelOptimize(
                                    zeroY, this.shapeList[i].stylelineWidth
                                );
                                this.zr.modShape(this.shapeList[i].id);
                            }
                            else if (this.shapeList[i]._axisShape == &#x27;axisTick&#x27;) {
                                tickLength = this.shapeList[i].style.yEnd
                                    - this.shapeList[i].style.yStart;
                                this.shapeList[i].style.yStart = zeroY - tickLength;
                                this.shapeList[i].style.yEnd = zeroY;
                                this.zr.modShape(this.shapeList[i].id);
                            }
                        }
                    }
                    if (!this.isHorizontal() &amp;&amp; typeof zeroX != &#x27;undefined&#x27;) {
                        // 纵向布局调整横向x
                        for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                            if (this.shapeList[i]._axisShape == &#x27;axisLine&#x27;) {
                                this.shapeList[i].style.xStart
                                    = this.shapeList[i].style.xEnd
                                    = this.subPixelOptimize(
                                    zeroX, this.shapeList[i].stylelineWidth
                                );
                                this.zr.modShape(this.shapeList[i].id);
                            }
                            else if (this.shapeList[i]._axisShape == &#x27;axisTick&#x27;) {
                                tickLength = this.shapeList[i].style.xEnd
                                    - this.shapeList[i].style.xStart;
                                this.shapeList[i].style.xStart = zeroX;
                                this.shapeList[i].style.xEnd = zeroX + tickLength;
                                this.zr.modShape(this.shapeList[i].id);
                            }
                        }
                    }
                },

                getPosition : function () {
                    return this.option.position;
                },

                isHorizontal : function() {
                    return this.option.position == &#x27;bottom&#x27; || this.option.position == &#x27;top&#x27;;
                }
            },
            /**
             * 参数修正&amp;默认值赋值，重载基类方法
             * @param {Object} opt 参数
             */
            reformOption : function (opt) {
                // 不写或传了个空数值默认为数值轴
                if (!opt || (opt instanceof Array &amp;&amp; opt.length === 0)) {
                    opt = [{type : ecConfig.COMPONENT_TYPE_AXIS_VALUE}];
                }
                else if (!(opt instanceof Array)){
                    opt = [opt];
                }

                // 最多两条，其他参数忽略
                if (opt.length &gt; 2) {
                    opt = [opt[0],opt[1]];
                }

                if (this.axisType == &#x27;xAxis&#x27;) {
                    // 横轴位置默认配置
                    if (!opt[0].position            // 没配置或配置错
                        || (opt[0].position != &#x27;bottom&#x27;
                            &amp;&amp; opt[0].position != &#x27;top&#x27;)
                        ) {
                        opt[0].position = &#x27;bottom&#x27;;
                    }
                    if (opt.length &gt; 1) {
                        opt[1].position = opt[0].position == &#x27;bottom&#x27;
                            ? &#x27;top&#x27; : &#x27;bottom&#x27;;
                    }

                    for (var i = 0, l = opt.length; i &lt; l; i++) {
                        // 坐标轴类型，横轴默认为类目型&#x27;category&#x27;
                        opt[i].type = opt[i].type || &#x27;category&#x27;;
                        // 标识轴类型&amp;索引
                        opt[i].xAxisIndex = i;
                        opt[i].yAxisIndex = -1;
                    }
                }
                else {
                    // 纵轴位置默认配置
                    if (!opt[0].position            // 没配置或配置错
                        || (opt[0].position != &#x27;left&#x27;
                            &amp;&amp; opt[0].position != &#x27;right&#x27;)
                        ) {
                        opt[0].position = &#x27;left&#x27;;
                    }

                    if (opt.length &gt; 1) {
                        opt[1].position = opt[0].position == &#x27;left&#x27;
                            ? &#x27;right&#x27; : &#x27;left&#x27;;
                    }

                    for (var i = 0, l = opt.length; i &lt; l; i++) {
                        // 坐标轴类型，纵轴默认为数值型&#x27;value&#x27;
                        opt[i].type = opt[i].type || &#x27;value&#x27;;
                        // 标识轴类型&amp;索引
                        opt[i].xAxisIndex = -1;
                        opt[i].yAxisIndex = i;
                    }
                }

                return opt;
            },

            /**
             * 刷新
             */
            refresh : function (newOption) {
                var axisOption;
                if (newOption) {
                    this.option = newOption;
                    if (this.axisType == &#x27;xAxis&#x27;) {
                        this.option.xAxis = this.reformOption(newOption.xAxis);
                        axisOption = this.option.xAxis;
                    }
                    else {
                        this.option.yAxis = this.reformOption(newOption.yAxis);
                        axisOption = this.option.yAxis;
                    }
                    this.series = newOption.series;
                }

                var CategoryAxis = require(&#x27;./categoryAxis&#x27;);
                var ValueAxis = require(&#x27;./valueAxis&#x27;);
                var len = Math.max((axisOption &amp;&amp; axisOption.length || 0), this._axisList.length);
                for (var i = 0; i &lt; len; i++) {
                    if (this._axisList[i]   // 已有实例
                        &amp;&amp; newOption        // 非空刷新
                        &amp;&amp; (!axisOption[i] || this._axisList[i].type != axisOption[i].type) // 类型不匹配
                        ) {
                        this._axisList[i].dispose &amp;&amp; this._axisList[i].dispose();
                        this._axisList[i] = false;
                    }

                    if (this._axisList[i]) {
                        this._axisList[i].refresh &amp;&amp; this._axisList[i].refresh(
                            axisOption ? axisOption[i] : false,
                            this.series
                        );
                    }
                    else if (axisOption &amp;&amp; axisOption[i]) {
                        this._axisList[i] =  axisOption[i].type == &#x27;category&#x27;
                            ? new CategoryAxis(
                            this.ecTheme, this.messageCenter, this.zr,
                            axisOption[i], this.myChart, this.axisBase
                        )
                            : new ValueAxis(
                            this.ecTheme, this.messageCenter, this.zr,
                            axisOption[i], this.myChart, this.axisBase,
                            this.series
                        );

                    }
                }
            },

            /**
             * 根据值换算位置
             * @param {number} idx 坐标轴索引0~1
             */
            getAxis : function (idx) {
                return this._axisList[idx];
            },

            clear : function () {
                for (var i = 0, l = this._axisList.length; i &lt; l; i++) {
                    this._axisList[i].dispose &amp;&amp; this._axisList[i].dispose();
                }
                this._axisList = [];
            }
        };

        zrUtil.inherits(Axis, Base);

        require(&#x27;../component&#x27;).define(&#x27;axis&#x27;, Axis);

        return Axis;
    });
    /**
     * echarts组件： 网格
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/component/grid&#x27;,[&#x27;require&#x27;,&#x27;./base&#x27;,&#x27;zrender/shape/Rectangle&#x27;,&#x27;../config&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;../component&#x27;],function (require) {
        var Base = require(&#x27;./base&#x27;);

        // 图形依赖
        var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);

        var ecConfig = require(&#x27;../config&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 图表选项
         *      @param {number=} option.grid.x 直角坐标系内绘图网格起始横坐标，数值单位px
         *      @param {number=} option.grid.y 直角坐标系内绘图网格起始纵坐标，数值单位px
         *      @param {number=} option.grid.width 直角坐标系内绘图网格宽度，数值单位px
         *      @param {number=} option.grid.height 直角坐标系内绘图网格高度，数值单位px
         */
        function Grid(ecTheme, messageCenter, zr, option, myChart) {
            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            this.refresh(option);
        }

        Grid.prototype = {
            type : ecConfig.COMPONENT_TYPE_GRID,

            getX : function () {
                return this._x;
            },

            getY : function () {
                return this._y;
            },

            getWidth : function () {
                return this._width;
            },

            getHeight : function () {
                return this._height;
            },

            getXend : function () {
                return this._x + this._width;
            },

            getYend : function () {
                return this._y + this._height;
            },

            getArea : function () {
                return {
                    x : this._x,
                    y : this._y,
                    width : this._width,
                    height : this._height
                };
            },

            /**
             * 实在找不到合适的地方做了，各种粗暴的写法~ -_-
             */
            refixAxisShape : function(component) {
                var zeroX;
                var zeroY;
                var axisList = component.xAxis._axisList.concat(component.yAxis._axisList);
                var len = axisList.length;
                var axis;
                while (len--) {
                    axis = axisList[len];
                    if (axis.type == ecConfig.COMPONENT_TYPE_AXIS_VALUE
                        &amp;&amp; axis._min &lt; 0
                        &amp;&amp; axis._max &gt;= 0
                        ) {
                        axis.isHorizontal()
                            ? (zeroX = axis.getCoord(0))
                            : (zeroY = axis.getCoord(0));
                    }
                }
                if (typeof zeroX != &#x27;undefined&#x27; || typeof zeroY != &#x27;undefined&#x27;) {
                    len = axisList.length;
                    while (len--) {
                        axisList[len].refixAxisShape(zeroX, zeroY);
                    }
                }
            },

            refresh : function (newOption) {
                if (newOption
                    || this._zrWidth != this.zr.getWidth()
                    || this._zrHeight != this.zr.getHeight()
                    ) {
                    this.clear();
                    this.option = newOption || this.option;
                    this.option.grid = this.reformOption(this.option.grid);

                    var gridOption = this.option.grid;
                    this._zrWidth = this.zr.getWidth();
                    this._zrHeight = this.zr.getHeight();
                    this._x = this.parsePercent(gridOption.x, this._zrWidth);
                    this._y = this.parsePercent(gridOption.y, this._zrHeight);
                    var x2 = this.parsePercent(gridOption.x2, this._zrWidth);
                    var y2 = this.parsePercent(gridOption.y2, this._zrHeight);


                    if (typeof gridOption.width == &#x27;undefined&#x27;) {
                        this._width = this._zrWidth - this._x - x2;
                    }
                    else {
                        this._width = this.parsePercent(gridOption.width, this._zrWidth);
                    }

                    if (typeof gridOption.height == &#x27;undefined&#x27;) {
                        this._height = this._zrHeight - this._y - y2;
                    }
                    else {
                        this._height = this.parsePercent(gridOption.height, this._zrHeight);
                    }

                    this._x = this.subPixelOptimize(this._x, gridOption.borderWidth);
                    this._y = this.subPixelOptimize(this._y, gridOption.borderWidth);

                    this.shapeList.push(new RectangleShape({
                        zlevel : this._zlevelBase,
                        hoverable : false,
                        style : {
                            x : this._x,
                            y : this._y,
                            width : this._width,
                            height : this._height,
                            brushType : gridOption.borderWidth &gt; 0 ? &#x27;both&#x27; : &#x27;fill&#x27;,
                            color : gridOption.backgroundColor,
                            strokeColor: gridOption.borderColor,
                            lineWidth : gridOption.borderWidth
                            // type : this.option.splitArea.areaStyle.type,
                        }
                    }));
                    this.zr.addShape(this.shapeList[0]);
                }
            }
        };

        zrUtil.inherits(Grid, Base);

        require(&#x27;../component&#x27;).define(&#x27;grid&#x27;, Grid);

        return Grid;
    });
    /**
     * echarts组件：数据区域缩放
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/component/dataZoom&#x27;,[&#x27;require&#x27;,&#x27;./base&#x27;,&#x27;zrender/shape/Rectangle&#x27;,&#x27;zrender/shape/Polygon&#x27;,&#x27;../util/shape/Icon&#x27;,&#x27;../config&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;../component&#x27;,&#x27;../component&#x27;],function (require) {
        var Base = require(&#x27;./base&#x27;);

        // 图形依赖
        var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
        var PolygonShape = require(&#x27;zrender/shape/Polygon&#x27;);
        var IconShape = require(&#x27;../util/shape/Icon&#x27;);

        var ecConfig = require(&#x27;../config&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 图表参数
         * @param {Object} component 组件
         */
        function DataZoom(ecTheme, messageCenter, zr, option, myChart) {
            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            var self = this;
            self._ondrift = function (dx, dy) {
                return self.__ondrift(this, dx, dy);
            };
            self._ondragend = function () {
                return self.__ondragend();
            };

            this._fillerSize = 28;       // 控件大小，水平布局为高，纵向布局为宽
            this._handleSize = 8;        // 手柄大小
            // this._fillerShae;            // 填充
            // this._startShape;            // 起始手柄
            // this._endShape;              // 结束手柄
            // this._startFrameShape;       // 起始特效边框
            // this._endFrameShape;         // 结束特效边框
            // this._syncTicket;
            this._isSilence = false;
            this._zoom = {};
            // this._originalData;

            this.option.dataZoom = this.reformOption(this.option.dataZoom);
            this.zoomOption = this.option.dataZoom;

            // 位置参数，通过计算所得x, y, width, height
            this._location = this._getLocation();
            // 缩放参数
            this._zoom =  this._getZoom();
            this._backupData();

            if (this.option.dataZoom.show) {
                this._buildShape();
            }
            this._syncData();
        }

        DataZoom.prototype = {
            type : ecConfig.COMPONENT_TYPE_DATAZOOM,
            _buildShape : function () {
                this._buildBackground();
                this._buildFiller();
                this._buildHandle();
                this._buildFrame();

                for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                    this.zr.addShape(this.shapeList[i]);
                }
                this._syncFrameShape();
            },

            /**
             * 根据选项计算实体的位置坐标
             */
            _getLocation : function () {
                var x;
                var y;
                var width;
                var height;
                var grid = this.component.grid;

                // 不指定则根据grid适配
                if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                    // 水平布局
                    width = this.zoomOption.width || grid.getWidth();
                    height = this.zoomOption.height || this._fillerSize;
                    x = typeof this.zoomOption.x != &#x27;undefined&#x27;
                        ? this.zoomOption.x : grid.getX();
                    y = typeof this.zoomOption.y != &#x27;undefined&#x27;
                        ? this.zoomOption.y : (this.zr.getHeight() - height - 2);
                }
                else {
                    // 垂直布局
                    width = this.zoomOption.width || this._fillerSize;
                    height = this.zoomOption.height || grid.getHeight();
                    x = typeof this.zoomOption.x != &#x27;undefined&#x27;
                        ? this.zoomOption.x : 2;
                    y = typeof this.zoomOption.y != &#x27;undefined&#x27;
                        ? this.zoomOption.y : grid.getY();
                }

                return {
                    x : x,
                    y : y,
                    width : width,
                    height : height
                };
            },

            /**
             * 计算缩放参数
             * 修正单坐标轴只传对象为数组。
             */
            _getZoom : function () {
                var series = this.option.series;
                var xAxis = this.option.xAxis;
                if (xAxis &amp;&amp; !(xAxis instanceof Array)) {
                    xAxis = [xAxis];
                    this.option.xAxis = xAxis;
                }
                var yAxis = this.option.yAxis;
                if (yAxis &amp;&amp; !(yAxis instanceof Array)) {
                    yAxis = [yAxis];
                    this.option.yAxis = yAxis;
                }

                var zoomSeriesIndex = [];
                var xAxisIndex;
                var yAxisIndex;

                var zOptIdx = this.zoomOption.xAxisIndex;
                if (xAxis &amp;&amp; typeof zOptIdx == &#x27;undefined&#x27;) {
                    xAxisIndex = [];
                    for (var i = 0, l = xAxis.length; i &lt; l; i++) {
                        // 横纵默认为类目轴
                        if (xAxis[i].type == &#x27;category&#x27;
                            || typeof xAxis[i].type == &#x27;undefined&#x27;
                            ) {
                            xAxisIndex.push(i);
                        }
                    }
                }
                else {
                    if (zOptIdx instanceof Array) {
                        xAxisIndex = zOptIdx;
                    }
                    else if (typeof zOptIdx != &#x27;undefined&#x27;) {
                        xAxisIndex = [zOptIdx];
                    }
                    else {
                        xAxisIndex = [];
                    }
                }

                zOptIdx = this.zoomOption.yAxisIndex;
                if (yAxis &amp;&amp; typeof zOptIdx == &#x27;undefined&#x27;) {
                    yAxisIndex = [];
                    for (var i = 0, l = yAxis.length; i &lt; l; i++) {
                        if (yAxis[i].type == &#x27;category&#x27;) {
                            yAxisIndex.push(i);
                        }
                    }
                }
                else {
                    if (zOptIdx instanceof Array) {
                        yAxisIndex = zOptIdx;
                    }
                    else if (typeof zOptIdx != &#x27;undefined&#x27;) {
                        yAxisIndex = [zOptIdx];
                    }
                    else {
                        yAxisIndex = [];
                    }
                }

                // 找到缩放控制的所有series
                for (var i = 0, l = series.length; i &lt; l; i++) {
                    if (series[i].type != ecConfig.CHART_TYPE_LINE
                        &amp;&amp; series[i].type != ecConfig.CHART_TYPE_BAR
                        &amp;&amp; series[i].type != ecConfig.CHART_TYPE_SCATTER
                        &amp;&amp; series[i].type != ecConfig.CHART_TYPE_K
                        ) {
                        continue;
                    }
                    for (var j = 0, k = xAxisIndex.length; j &lt; k; j++) {
                        if (xAxisIndex[j] == (series[i].xAxisIndex || 0)) {
                            zoomSeriesIndex.push(i);
                            break;
                        }
                    }
                    for (var j = 0, k = yAxisIndex.length; j &lt; k; j++) {
                        if (yAxisIndex[j] == (series[i].yAxisIndex || 0)) {
                            zoomSeriesIndex.push(i);
                            break;
                        }
                    }
                    // 不指定接管坐标轴，则散点图被纳入接管范围
                    if (series[i].type == ecConfig.CHART_TYPE_SCATTER
                        &amp;&amp; typeof this.zoomOption.xAxisIndex == &#x27;undefined&#x27;
                        &amp;&amp; typeof this.zoomOption.yAxisIndex == &#x27;undefined&#x27;
                        ) {
                        zoomSeriesIndex.push(i);
                    }
                }

                var start = typeof this._zoom.start != &#x27;undefined&#x27;
                    ? this._zoom.start
                    : (typeof this.zoomOption.start != &#x27;undefined&#x27; ? this.zoomOption.start : 0);
                var end = typeof this._zoom.end != &#x27;undefined&#x27;
                    ? this._zoom.end
                    : (typeof this.zoomOption.end != &#x27;undefined&#x27; ? this.zoomOption.end : 100);
                /*
                 var start = typeof this.zoomOption.start != &#x27;undefined&#x27;
                 &amp;&amp; this.zoomOption.start &gt;= 0
                 &amp;&amp; this.zoomOption.start &lt;= 100
                 ? this.zoomOption.start : 0;
                 var end = typeof this.zoomOption.end != &#x27;undefined&#x27;
                 &amp;&amp; this.zoomOption.end &gt;= 0
                 &amp;&amp; this.zoomOption.end &lt;= 100
                 ? this.zoomOption.end : 100;
                 */
                if (start &gt; end) {
                    // 大小颠倒自动翻转
                    start = start + end;
                    end = start - end;
                    start = start - end;
                }
                var size = Math.round(
                        (end - start) / 100
                        * (this.zoomOption.orient == &#x27;horizontal&#x27;
                        ? this._location.width : this._location.height)
                );
                return {
                    start : start,
                    end : end,
                    start2 : 0,
                    end2 : 100,
                    size : size,
                    xAxisIndex : xAxisIndex,
                    yAxisIndex : yAxisIndex,
                    seriesIndex : zoomSeriesIndex,
                    scatterMap : this._zoom.scatterMap || {}
                };
            },

            _backupData : function () {
                this._originalData = {
                    xAxis : {},
                    yAxis : {},
                    series : {}
                };
                var xAxis = this.option.xAxis;
                var xAxisIndex = this._zoom.xAxisIndex;
                for (var i = 0, l = xAxisIndex.length; i &lt; l; i++) {
                    this._originalData.xAxis[xAxisIndex[i]] = xAxis[xAxisIndex[i]].data;
                }

                var yAxis = this.option.yAxis;
                var yAxisIndex = this._zoom.yAxisIndex;
                for (var i = 0, l = yAxisIndex.length; i &lt; l; i++) {
                    this._originalData.yAxis[yAxisIndex[i]] = yAxis[yAxisIndex[i]].data;
                }

                var series = this.option.series;
                var seriesIndex = this._zoom.seriesIndex;
                var serie;
                for (var i = 0, l = seriesIndex.length; i &lt; l; i++) {
                    serie = series[seriesIndex[i]];
                    this._originalData.series[seriesIndex[i]] = serie.data;
                    if (serie.type == ecConfig.CHART_TYPE_SCATTER) {
                        this._calculScatterMap(seriesIndex[i]);
                    }
                }
            },

            _calculScatterMap : function (seriesIndex) {
                this._zoom.scatterMap = this._zoom.scatterMap || {};
                this._zoom.scatterMap[seriesIndex] = this._zoom.scatterMap[seriesIndex] || {};
                var componentLibrary = require(&#x27;../component&#x27;);
                // x轴极值
                var Axis = componentLibrary.get(&#x27;axis&#x27;);
                var axisOption = zrUtil.clone(this.option.xAxis);
                if (axisOption instanceof Array) {
                    axisOption[0].type = &#x27;value&#x27;;
                    axisOption[0].boundary = [0, 0];
                    axisOption[1] &amp;&amp; (axisOption[1].type = &#x27;value&#x27;, axisOption[1].boundary = [0, 0]);
                }
                else {
                    axisOption.type = &#x27;value&#x27;;
                    axisOption.boundary = [0, 0];
                }
                var vAxis = new Axis(
                    this.ecTheme,
                    null,   // messageCenter
                    false,  // this.zr
                    {
                        xAxis: axisOption,
                        series : this.option.series
                    },
                    this,
                    &#x27;xAxis&#x27;
                );
                var axisIndex = this.option.series[seriesIndex].xAxisIndex || 0;
                this._zoom.scatterMap[seriesIndex].x = vAxis.getAxis(axisIndex).getExtremum();
                vAxis.dispose();

                // y轴极值
                axisOption = zrUtil.clone(this.option.yAxis);
                if (axisOption instanceof Array) {
                    axisOption[0].type = &#x27;value&#x27;;
                    axisOption[1] &amp;&amp; (axisOption[1].type = &#x27;value&#x27;, axisOption[1].boundary = [0, 0]);
                }
                else {
                    axisOption.type = &#x27;value&#x27;;
                    axisOption.boundary = [0, 0];
                }
                vAxis = new Axis(
                    this.ecTheme,
                    null,   // messageCenter
                    false,  // this.zr
                    {
                        yAxis: axisOption,
                        series : this.option.series
                    },
                    this,
                    &#x27;yAxis&#x27;
                );
                axisIndex = this.option.series[seriesIndex].yAxisIndex || 0;
                this._zoom.scatterMap[seriesIndex].y = vAxis.getAxis(axisIndex).getExtremum();
                vAxis.dispose();
                // console.log(this._zoom.scatterMap);
            },

            _buildBackground : function () {
                var width = this._location.width;
                var height = this._location.height;

                // 背景
                this.shapeList.push(new RectangleShape({
                    zlevel : this._zlevelBase,
                    hoverable :false,
                    style : {
                        x : this._location.x,
                        y : this._location.y,
                        width : width,
                        height : height,
                        color : this.zoomOption.backgroundColor
                    }
                }));

                // 数据阴影
                var maxLength = 0;
                var xAxis = this._originalData.xAxis;
                var xAxisIndex = this._zoom.xAxisIndex;
                for (var i = 0, l = xAxisIndex.length; i &lt; l; i++) {
                    maxLength = Math.max(
                        maxLength, xAxis[xAxisIndex[i]].length
                    );
                }
                var yAxis = this._originalData.yAxis;
                var yAxisIndex = this._zoom.yAxisIndex;
                for (var i = 0, l = yAxisIndex.length; i &lt; l; i++) {
                    maxLength = Math.max(
                        maxLength, yAxis[yAxisIndex[i]].length
                    );
                }

                var seriesIndex = this._zoom.seriesIndex[0];
                var data = this._originalData.series[seriesIndex];
                var maxValue = Number.MIN_VALUE;
                var minValue = Number.MAX_VALUE;
                var value;
                for (var i = 0, l = data.length; i &lt; l; i++) {
                    value = typeof data[i] != &#x27;undefined&#x27;
                        ? (typeof data[i].value != &#x27;undefined&#x27; ? data[i].value : data[i])
                        : 0;
                    if (this.option.series[seriesIndex].type == ecConfig.CHART_TYPE_K) {
                        value = value[1];   // 收盘价
                    }
                    if (isNaN(value)) {
                        value = 0;
                    }
                    maxValue = Math.max(maxValue, value);
                    minValue = Math.min(minValue, value);
                }
                var valueRange = maxValue - minValue;

                var pointList = [];
                var x = width / (maxLength - (maxLength &gt; 1 ? 1 : 0));
                var y = height / (maxLength - (maxLength &gt; 1 ? 1 : 0));
                var step = 1;
                if (this.zoomOption.orient == &#x27;horizontal&#x27; &amp;&amp; x &lt; 1) {
                    step = Math.floor(maxLength * 3 / width);
                }
                else if (this.zoomOption.orient == &#x27;vertical&#x27; &amp;&amp; y &lt; 1){
                    step = Math.floor(maxLength * 3 / height);
                }

                for (var i = 0, l = maxLength; i &lt; l; i += step) {
                    value = typeof data[i] != &#x27;undefined&#x27;
                        ? (typeof data[i].value != &#x27;undefined&#x27;
                        ? data[i].value : data[i])
                        : 0;
                    if (this.option.series[seriesIndex].type == ecConfig.CHART_TYPE_K) {
                        value = value[1];   // 收盘价
                    }
                    if (isNaN(value)) {
                        value = 0;
                    }
                    if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                        pointList.push([
                                this._location.x + x * i,
                                this._location.y + height - 5 - Math.round(
                                    (value - minValue) / valueRange * (height - 10)
                            )
                        ]);
                    }
                    else {
                        pointList.push([
                                this._location.x + 5 + Math.round(
                                    (value - minValue) / valueRange * (width - 10)
                            ),
                                this._location.y + y * i
                        ]);
                    }
                }
                if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                    pointList.push([
                            this._location.x + width,
                            this._location.y + height
                    ]);
                    pointList.push([
                        this._location.x, this._location.y + height
                    ]);
                }
                else {
                    pointList.push([
                        this._location.x, this._location.y + height
                    ]);
                    pointList.push([
                        this._location.x, this._location.y
                    ]);
                }

                this.shapeList.push(new PolygonShape({
                    zlevel : this._zlevelBase,
                    style : {
                        pointList : pointList,
                        color : this.zoomOption.dataBackgroundColor
                    },
                    hoverable : false
                }));
            },

            /**
             * 构建填充物
             */
            _buildFiller : function () {
                this._fillerShae = {
                    zlevel : this._zlevelBase,
                    draggable : true,
                    ondrift : this._ondrift,
                    ondragend : this._ondragend,
                    _type : &#x27;filler&#x27;
                };

                if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                    // 横向
                    this._fillerShae.style = {
                        x : this._location.x
                            + Math.round(this._zoom.start / 100 * this._location.width)
                            + this._handleSize,
                        y : this._location.y,
                        width : this._zoom.size - this._handleSize * 2,
                        height : this._location.height,
                        color : this.zoomOption.fillerColor,
                        // strokeColor : &#x27;#fff&#x27;, // this.zoomOption.handleColor,
                        // lineWidth: 2,
                        text : &#x27;:::&#x27;,
                        textPosition : &#x27;inside&#x27;
                    };
                }
                else {
                    // 纵向
                    this._fillerShae.style ={
                        x : this._location.x,
                        y : this._location.y
                            + Math.round(this._zoom.start / 100 * this._location.height)
                            + this._handleSize,
                        width :  this._location.width,
                        height : this._zoom.size - this._handleSize * 2,
                        color : this.zoomOption.fillerColor,
                        // strokeColor : &#x27;#fff&#x27;, // this.zoomOption.handleColor,
                        // lineWidth: 2,
                        text : &#x27;::&#x27;,
                        textPosition : &#x27;inside&#x27;
                    };
                }

                this._fillerShae.highlightStyle = {
                    brushType: &#x27;fill&#x27;,
                    color : &#x27;rgba(0,0,0,0)&#x27;
                    /*
                     color : require(&#x27;zrender/tool/color&#x27;).alpha(
                     this._fillerShae.style.color, 0
                     )
                     */
                };
                this._fillerShae = new RectangleShape(this._fillerShae);
                this.shapeList.push(this._fillerShae);
            },

            /**
             * 构建拖拽手柄
             */
            _buildHandle : function () {
                this._startShape = {
                    zlevel : this._zlevelBase,
                    draggable : true,
                    style : {
                        iconType: &#x27;rectangle&#x27;,
                        x : this._location.x,
                        y : this._location.y,
                        width : this._handleSize,
                        height : this._handleSize,
                        color : this.zoomOption.handleColor,
                        text : &#x27;=&#x27;,
                        textPosition : &#x27;inside&#x27;
                    },
                    highlightStyle : {
                        brushType: &#x27;fill&#x27;
                    },
                    ondrift : this._ondrift,
                    ondragend : this._ondragend
                };

                if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                    this._startShape.style.height = this._location.height;
                    this._endShape = zrUtil.clone(this._startShape);

                    this._startShape.style.x = this._fillerShae.style.x - this._handleSize,
                        this._endShape.style.x = this._fillerShae.style.x
                            + this._fillerShae.style.width;
                }
                else {
                    this._startShape.style.width = this._location.width;
                    this._endShape = zrUtil.clone(this._startShape);

                    this._startShape.style.y = this._fillerShae.style.y - this._handleSize;
                    this._endShape.style.y = this._fillerShae.style.y
                        + this._fillerShae.style.height;
                }
                this._startShape = new IconShape(this._startShape);
                this._endShape = new IconShape(this._endShape);
                this.shapeList.push(this._startShape);
                this.shapeList.push(this._endShape);
            },

            /**
             * 构建特效边框
             */
            _buildFrame : function () {
                // 特效框线，亚像素优化
                var x = this.subPixelOptimize(this._location.x, 1);
                var y = this.subPixelOptimize(this._location.y, 1);
                this._startFrameShape = {
                    zlevel : this._zlevelBase,
                    hoverable :false,
                    style : {
                        x : x,
                        y : y,
                        width : this._location.width - (x &gt; this._location.x ? 1 : 0),
                        height : this._location.height - (y &gt; this._location.y ? 1 : 0),
                        lineWidth: 1,
                        brushType: &#x27;stroke&#x27;,
                        strokeColor : this.zoomOption.handleColor
                    }
                };
                this._endFrameShape = zrUtil.clone(this._startFrameShape);

                this._startFrameShape = new RectangleShape(this._startFrameShape);
                this._endFrameShape = new RectangleShape(this._endFrameShape);
                this.shapeList.push(this._startFrameShape);
                this.shapeList.push(this._endFrameShape);
                return;
            },

            _syncHandleShape : function () {
                if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                    this._startShape.style.x = this._fillerShae.style.x - this._handleSize;
                    this._endShape.style.x = this._fillerShae.style.x
                        + this._fillerShae.style.width;

                    this._zoom.start = Math.floor(
                            (this._startShape.style.x - this._location.x)
                            / this._location.width * 100
                    );
                    this._zoom.end = Math.ceil(
                            (this._endShape.style.x + this._handleSize - this._location.x)
                            / this._location.width * 100
                    );
                }
                else {
                    this._startShape.style.y = this._fillerShae.style.y - this._handleSize;
                    this._endShape.style.y = this._fillerShae.style.y
                        + this._fillerShae.style.height;
                    this._zoom.start = Math.floor(
                            (this._startShape.style.y - this._location.y)
                            / this._location.height * 100
                    );
                    this._zoom.end = Math.ceil(
                            (this._endShape.style.y + this._handleSize - this._location.y)
                            / this._location.height * 100
                    );
                }

                this.zr.modShape(this._startShape.id);
                this.zr.modShape(this._endShape.id);

                // 同步边框
                this._syncFrameShape();

                this.zr.refresh();
            },

            _syncFillerShape : function () {
                var a;
                var b;
                if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                    a = this._startShape.style.x;
                    b = this._endShape.style.x;
                    this._fillerShae.style.x = Math.min(a, b) + this._handleSize;
                    this._fillerShae.style.width = Math.abs(a - b) - this._handleSize;
                    this._zoom.start = Math.floor(
                            (Math.min(a, b) - this._location.x)
                            / this._location.width * 100
                    );
                    this._zoom.end = Math.ceil(
                            (Math.max(a, b) + this._handleSize - this._location.x)
                            / this._location.width * 100
                    );
                }
                else {
                    a = this._startShape.style.y;
                    b = this._endShape.style.y;
                    this._fillerShae.style.y = Math.min(a, b) + this._handleSize;
                    this._fillerShae.style.height = Math.abs(a - b) - this._handleSize;
                    this._zoom.start = Math.floor(
                            (Math.min(a, b) - this._location.y)
                            / this._location.height * 100
                    );
                    this._zoom.end = Math.ceil(
                            (Math.max(a, b) + this._handleSize - this._location.y)
                            / this._location.height * 100
                    );
                }

                this.zr.modShape(this._fillerShae.id);

                // 同步边框
                this._syncFrameShape();

                this.zr.refresh();
            },

            _syncFrameShape : function () {
                if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                    this._startFrameShape.style.width =
                        this._fillerShae.style.x - this._location.x;
                    this._endFrameShape.style.x =
                        this._fillerShae.style.x + this._fillerShae.style.width;
                    this._endFrameShape.style.width =
                        this._location.x + this._location.width - this._endFrameShape.style.x;
                }
                else {
                    this._startFrameShape.style.height =
                        this._fillerShae.style.y - this._location.y;
                    this._endFrameShape.style.y =
                        this._fillerShae.style.y + this._fillerShae.style.height;
                    this._endFrameShape.style.height =
                        this._location.y + this._location.height - this._endFrameShape.style.y;
                }

                this.zr.modShape(this._startFrameShape.id);
                this.zr.modShape(this._endFrameShape.id);
            },

            _syncShape : function () {
                if (!this.zoomOption.show) {
                    // 没有伸缩控件
                    return;
                }
                if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                    this._startShape.style.x = this._location.x
                        + this._zoom.start / 100 * this._location.width;
                    this._endShape.style.x = this._location.x
                        + this._zoom.end / 100 * this._location.width
                        - this._handleSize;

                    this._fillerShae.style.x = this._startShape.style.x + this._handleSize;
                    this._fillerShae.style.width = this._endShape.style.x
                        - this._startShape.style.x
                        - this._handleSize;
                }
                else {
                    this._startShape.style.y = this._location.y
                        + this._zoom.start / 100 * this._location.height;
                    this._endShape.style.y = this._location.y
                        + this._zoom.end / 100 * this._location.height
                        - this._handleSize;

                    this._fillerShae.style.y = this._startShape.style.y + this._handleSize;
                    this._fillerShae.style.height = this._endShape.style.y
                        - this._startShape.style.y
                        - this._handleSize;
                }

                this.zr.modShape(this._startShape.id);
                this.zr.modShape(this._endShape.id);
                this.zr.modShape(this._fillerShae.id);
                // 同步边框
                this._syncFrameShape();
                this.zr.refresh();
            },

            _syncData : function (dispatchNow) {
                var target;
                var start;
                var end;
                var length;
                var data;

                for (var key in this._originalData) {
                    target = this._originalData[key];
                    for (var idx in target) {
                        data = target[idx];
                        if (typeof data == &#x27;undefined&#x27;) {
                            continue;
                        }
                        length = data.length;
                        start = Math.floor(this._zoom.start / 100 * length);
                        end = Math.ceil(this._zoom.end / 100 * length);
                        if (this.option[key][idx].type != ecConfig.CHART_TYPE_SCATTER) {
                            this.option[key][idx].data = data.slice(start, end);
                        }
                        else {
                            // 散点图特殊处理
                            this.option[key][idx].data = this._synScatterData(idx, data);
                        }
                    }
                }

                if (!this._isSilence &amp;&amp; (this.zoomOption.realtime || dispatchNow)) {
                    this.messageCenter.dispatch(
                        ecConfig.EVENT.DATA_ZOOM,
                        null,
                        {zoom: this._zoom},
                        this.myChart
                    );
                }

                //this.zoomOption.start = this._zoom.start;
                //this.zoomOption.end = this._zoom.end;
            },

            _synScatterData : function (seriesIndex, data) {
                if (this._zoom.start === 0
                    &amp;&amp; this._zoom.end == 100
                    &amp;&amp; this._zoom.start2 === 0
                    &amp;&amp; this._zoom.end2 == 100
                    ) {
                    return data;
                }
                var newData = [];
                var scale = this._zoom.scatterMap[seriesIndex];
                var total;
                var xStart;
                var xEnd;
                var yStart;
                var yEnd;

                if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                    total = scale.x.max - scale.x.min;
                    xStart = this._zoom.start / 100 * total + scale.x.min;
                    xEnd = this._zoom.end / 100 * total + scale.x.min;

                    total = scale.y.max - scale.y.min;
                    yStart = this._zoom.start2 / 100 * total + scale.y.min;
                    yEnd = this._zoom.end2 / 100 * total + scale.y.min;
                }
                else {
                    total = scale.x.max - scale.x.min;
                    xStart = this._zoom.start2 / 100 * total + scale.x.min;
                    xEnd = this._zoom.end2 / 100 * total + scale.x.min;

                    total = scale.y.max - scale.y.min;
                    yStart = this._zoom.start / 100 * total + scale.y.min;
                    yEnd = this._zoom.end / 100 * total + scale.y.min;
                }

                // console.log(xStart,xEnd,yStart,yEnd);
                var value;
                for (var i = 0, l = data.length; i &lt; l; i++) {
                    value = data[i].value || data[i];
                    if (value[0] &gt;= xStart
                        &amp;&amp; value[0] &lt;= xEnd
                        &amp;&amp; value[1] &gt;= yStart
                        &amp;&amp; value[1] &lt;= yEnd
                        ) {
                        newData.push(data[i]);
                    }
                }

                return newData;
            },
            /**
             * 拖拽范围控制
             */
            __ondrift : function (shape, dx, dy) {
                if (this.zoomOption.zoomLock) {
                    // zoomLock时把handle转成filler的拖拽
                    shape = this._fillerShae;
                }

                var detailSize = shape._type == &#x27;filler&#x27; ? this._handleSize : 0;
                if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                    if (shape.style.x + dx - detailSize &lt;= this._location.x) {
                        shape.style.x = this._location.x + detailSize;
                    }
                    else if (shape.style.x + dx + shape.style.width + detailSize
                        &gt;= this._location.x + this._location.width
                        ) {
                        shape.style.x = this._location.x + this._location.width
                            - shape.style.width - detailSize;
                    }
                    else {
                        shape.style.x += dx;
                    }
                }
                else {
                    if (shape.style.y + dy - detailSize &lt;= this._location.y) {
                        shape.style.y = this._location.y + detailSize;
                    }
                    else if (shape.style.y + dy + shape.style.height + detailSize
                        &gt;= this._location.y + this._location.height
                        ) {
                        shape.style.y = this._location.y + this._location.height
                            - shape.style.height - detailSize;
                    }
                    else {
                        shape.style.y += dy;
                    }
                }

                if (shape._type == &#x27;filler&#x27;) {
                    this._syncHandleShape();
                }
                else {
                    this._syncFillerShape();
                }

                if (this.zoomOption.realtime) {
                    this._syncData();
                }

                return true;
            },

            __ondragend : function () {
                this.isDragend = true;
            },

            /**
             * 数据项被拖拽出去
             */
            ondragend : function (param, status) {
                if (!this.isDragend || !param.target) {
                    // 没有在当前实例上发生拖拽行为则直接返回
                    return;
                }

                !this.zoomOption.realtime &amp;&amp; this._syncData();

                // 别status = {}赋值啊！！
                status.dragOut = true;
                status.dragIn = true;
                if (!this._isSilence &amp;&amp; !this.zoomOption.realtime) {
                    this.messageCenter.dispatch(
                        ecConfig.EVENT.DATA_ZOOM,
                        null,
                        {zoom: this._zoom},
                        this.myChart
                    );
                }
                status.needRefresh = false; // 会有消息触发fresh，不用再刷一遍
                // 处理完拖拽事件后复位
                this.isDragend = false;

                return;
            },

            ondataZoom : function (param, status) {
                status.needRefresh = true;
                return;
            },

            absoluteZoom : function (param) {
                //this.zoomOption.start = 
                this._zoom.start = param.start;
                //this.zoomOption.end = 
                this._zoom.end = param.end;
                //this.zoomOption.start2 = 
                this._zoom.start2 = param.start2;
                //this.zoomOption.end2 = 
                this._zoom.end2 = param.end2;
                this._syncShape();
                this._syncData(true);
                return;
            },

            rectZoom : function (param) {
                if (!param) {
                    // 重置拖拽
                    //this.zoomOption.start = 
                    //this.zoomOption.start2 = 
                    this._zoom.start =
                        this._zoom.start2 = 0;

                    //this.zoomOption.end =
                    //this.zoomOption.end2 = 
                    this._zoom.end =
                        this._zoom.end2 = 100;

                    this._syncShape();
                    this._syncData(true);
                    return this._zoom;
                }
                var gridArea = this.component.grid.getArea();
                var rect = {
                    x : param.x,
                    y : param.y,
                    width : param.width,
                    height : param.height
                };
                // 修正方向框选
                if (rect.width &lt; 0) {
                    rect.x += rect.width;
                    rect.width = -rect.width;
                }
                if (rect.height &lt; 0) {
                    rect.y += rect.height;
                    rect.height = -rect.height;
                }
                // console.log(rect,this._zoom);

                // 剔除无效缩放
                if (rect.x &gt; gridArea.x + gridArea.width
                    || rect.y &gt; gridArea.y + gridArea.height
                    ) {
                    return false; // 无效缩放
                }

                // 修正框选超出
                if (rect.x &lt; gridArea.x) {
                    rect.x = gridArea.x;
                }
                if (rect.x + rect.width &gt; gridArea.x + gridArea.width) {
                    rect.width = gridArea.x + gridArea.width - rect.x;
                }
                if (rect.y + rect.height &gt; gridArea.y + gridArea.height) {
                    rect.height = gridArea.y + gridArea.height - rect.y;
                }

                var total;
                var sdx = (rect.x - gridArea.x) / gridArea.width;
                var edx = 1 - (rect.x + rect.width - gridArea.x) / gridArea.width;
                var sdy = 1 - (rect.y + rect.height - gridArea.y) / gridArea.height;
                var edy = (rect.y - gridArea.y) / gridArea.height;
                //console.log(&#x27;this&#x27;,sdy,edy,this._zoom.start,this._zoom.end)
                if (this.zoomOption.orient == &#x27;horizontal&#x27;) {
                    total = this._zoom.end - this._zoom.start;
                    this._zoom.start += total * sdx;
                    this._zoom.end -= total * edx;

                    total = this._zoom.end2 - this._zoom.start2;
                    this._zoom.start2 += total * sdy;
                    this._zoom.end2 -= total * edy;
                }
                else {
                    total = this._zoom.end - this._zoom.start;
                    this._zoom.start += total * sdy;
                    this._zoom.end -= total * edy;

                    total = this._zoom.end2 - this._zoom.start2;
                    this._zoom.start2 += total * sdx;
                    this._zoom.end2 -= total * edx;
                }
                //console.log(this._zoom.start,this._zoom.end,this._zoom.start2,this._zoom.end2)
                //this.zoomOption.start = this._zoom.start;
                //this.zoomOption.end = this._zoom.end;
                //this.zoomOption.start2 = this._zoom.start2;
                //this.zoomOption.end2 = this._zoom.end2;
                //console.log(rect,gridArea,this._zoom,total)
                this._syncShape();
                this._syncData(true);
                return this._zoom;
            },

            syncBackupData : function (curOption) {
                var start;
                var target = this._originalData[&#x27;series&#x27;];
                var curSeries = curOption.series;
                var curData;
                for (var i = 0, l = curSeries.length; i &lt; l; i++) {
                    curData = curSeries[i].data;
                    if (target[i]) {
                        // dataZoom接管的
                        start = Math.floor(this._zoom.start / 100 * target[i].length);
                    }
                    else {
                        // 非dataZoom接管
                        start = 0;
                    }
                    for (var j = 0, k = curData.length; j &lt; k; j++) {
                        //optionBackup.series[i].data[j + start] = curData[j];
                        if (target[i]) {
                            // 同步内部备份
                            target[i][j + start] = curData[j];
                        }
                    }
                }
            },

            syncOption : function(magicOption) {
                this.silence(true);
                this.option = magicOption;

                this.clear();
                // 位置参数，通过计算所得x, y, width, height
                this._location = this._getLocation();
                // 缩放参数
                this._zoom =  this._getZoom();

                this._backupData();
                if (this.option.dataZoom &amp;&amp; this.option.dataZoom.show) {
                    this._buildShape();
                }
                this._syncData();

                this.silence(false);
            },

            silence : function (s) {
                this._isSilence = s;
            },

            getRealDataIndex : function (sIdx, dIdx) {
                if (!this._originalData || (this._zoom.start === 0 &amp;&amp; this._zoom.end == 100)) {
                    return dIdx;
                }
                var sreies = this._originalData.series;
                if (sreies[sIdx]) {
                    return Math.floor(this._zoom.start / 100 * sreies[sIdx].length) + dIdx;
                }
                return -1;
            },

            /**
             * 避免dataZoom带来两次refresh，不设refresh接口，resize重复一下buildshape逻辑
             */
            resize : function () {
                this.clear();

                // 位置参数，通过计算所得x, y, width, height
                this._location = this._getLocation();
                // 缩放参数
                this._zoom =  this._getZoom();

                if (this.option.dataZoom.show) {
                    this._buildShape();
                }
            }
        };

        zrUtil.inherits(DataZoom, Base);

        require(&#x27;../component&#x27;).define(&#x27;dataZoom&#x27;, DataZoom);

        return DataZoom;
    });
    /**
     * zrender
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：handlePolygon，dataRange手柄
     */
    define(&#x27;echarts/util/shape/HandlePolygon&#x27;,[&#x27;require&#x27;,&#x27;zrender/shape/Base&#x27;,&#x27;zrender/shape/Polygon&#x27;,&#x27;zrender/tool/util&#x27;],function (require) {
        var Base = require(&#x27;zrender/shape/Base&#x27;);
        var PolygonShape = require(&#x27;zrender/shape/Polygon&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);

        function HandlePolygon(options) {
            Base.call(this, options);
        }

        HandlePolygon.prototype = {
            type : &#x27;handle-polygon&#x27;,
            /**
             * 创建多边形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath : function (ctx, style) {
                PolygonShape.prototype.buildPath(
                    ctx, style
                );
            },
            isCover : function (x, y) {
                var originPos = this.getTansform(x, y);
                x = originPos[0];
                y = originPos[1];

                // 不能缓存rect！
                var rect = this.style.rect;
                if (x &gt;= rect.x
                    &amp;&amp; x &lt;= (rect.x + rect.width)
                    &amp;&amp; y &gt;= rect.y
                    &amp;&amp; y &lt;= (rect.y + rect.height)
                    ) {
                    // 矩形内
                    return true;
                }
                else {
                    return false;
                }
            }
        };
        zrUtil.inherits(HandlePolygon, Base);

        return HandlePolygon;
    });

    /**
     * echarts组件：值域
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/component/dataRange&#x27;,[&#x27;require&#x27;,&#x27;./base&#x27;,&#x27;zrender/shape/Text&#x27;,&#x27;zrender/shape/Rectangle&#x27;,&#x27;../util/shape/HandlePolygon&#x27;,&#x27;../config&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/tool/area&#x27;,&#x27;zrender/tool/color&#x27;,&#x27;zrender/tool/color&#x27;,&#x27;../component&#x27;],function (require) {
        var Base = require(&#x27;./base&#x27;);

        // 图形依赖
        var TextShape = require(&#x27;zrender/shape/Text&#x27;);
        var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
        var HandlePolygonShape = require(&#x27;../util/shape/HandlePolygon&#x27;);

        var ecConfig = require(&#x27;../config&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);
        var zrArea = require(&#x27;zrender/tool/area&#x27;);
        var zrColor = require(&#x27;zrender/tool/color&#x27;);

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} option 图表参数
         * @param {Object=} selected 用于状态保持
         */
        function DataRange(ecTheme, messageCenter, zr, option, myChart) {
            if (typeof this.query(option, &#x27;dataRange.min&#x27;) == &#x27;undefined&#x27;
                || typeof this.query(option, &#x27;dataRange.max&#x27;) == &#x27;undefined&#x27;
                ) {
                console.error(&#x27;option.dataRange.min or option.dataRange.max has not been defined.&#x27;);
                return;
            }

            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            var self = this;
            self._ondrift = function(dx, dy) {
                return self.__ondrift(this, dx, dy);
            };
            self._ondragend = function() {
                return self.__ondragend();
            };
            self._dataRangeSelected = function(param) {
                return self.__dataRangeSelected(param);
            };
            this._selectedMap = {};
            this._range = {};

            this.refresh(option);
        }

        DataRange.prototype = {
            type : ecConfig.COMPONENT_TYPE_DATARANGE,
            _textGap : 10, // 非值文字间隔
            _buildShape : function () {
                // 值域元素组的位置参数，通过计算所得x, y, width, height
                this._itemGroupLocation = this._getItemGroupLocation();
                this._buildBackground();
                if (this.dataRangeOption.splitNumber &lt;= 0
                    || this.dataRangeOption.calculable
                    ) {
                    this._buildGradient();
                }
                else {
                    this._buildItem();
                }

                for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                    this.zr.addShape(this.shapeList[i]);
                }

                this._syncShapeFromRange();
            },

            /**
             * 构建图例型的值域元素
             */
            _buildItem : function () {
                var data = this._valueTextList;
                var dataLength = data.length;
                var itemName;
                var itemShape;
                var textShape;
                var font = this.getFont(this.dataRangeOption.textStyle);

                var lastX = this._itemGroupLocation.x;
                var lastY = this._itemGroupLocation.y;
                var itemWidth = this.dataRangeOption.itemWidth;
                var itemHeight = this.dataRangeOption.itemHeight;
                var itemGap = this.dataRangeOption.itemGap;
                var textHeight = zrArea.getTextHeight(&#x27;国&#x27;, font);
                var color;

                if (this.dataRangeOption.orient == &#x27;vertical&#x27;
                    &amp;&amp; this.dataRangeOption.x == &#x27;right&#x27;
                    ) {
                    lastX = this._itemGroupLocation.x
                        + this._itemGroupLocation.width
                        - itemWidth;
                }
                var needValueText = true;
                if (this.dataRangeOption.text) {
                    needValueText = false;
                    // 第一个文字
                    if (this.dataRangeOption.text[0]) {
                        textShape = this._getTextShape(
                            lastX, lastY, this.dataRangeOption.text[0]
                        );
                        if (this.dataRangeOption.orient == &#x27;horizontal&#x27;) {
                            lastX += zrArea.getTextWidth(
                                this.dataRangeOption.text[0],
                                font
                            )
                                + this._textGap;
                        }
                        else {
                            lastY += textHeight + this._textGap;
                            textShape.style.y += textHeight / 2 + this._textGap;
                            textShape.style.textBaseline = &#x27;bottom&#x27;;
                        }
                        this.shapeList.push(new TextShape(textShape));
                    }
                }

                for (var i = 0; i &lt; dataLength; i++) {
                    itemName = data[i];
                    color = this.getColor((dataLength - i) * this._gap + this.dataRangeOption.min);
                    // 图形
                    itemShape = this._getItemShape(
                        lastX, lastY,
                        itemWidth, itemHeight,
                        (this._selectedMap[i] ? color : &#x27;#ccc&#x27;)
                    );
                    itemShape._idx = i;
                    itemShape.onclick = this._dataRangeSelected;
                    this.shapeList.push(new RectangleShape(itemShape));

                    if (needValueText) {
                        // 文字
                        textShape = {
                            zlevel : this._zlevelBase,
                            style : {
                                x : lastX + itemWidth + 5,
                                y : lastY,
                                color : this._selectedMap[i]
                                    ? this.dataRangeOption.textStyle.color
                                    : &#x27;#ccc&#x27;,
                                text: data[i],
                                textFont: font,
                                textBaseline: &#x27;top&#x27;
                            },
                            highlightStyle:{
                                brushType: &#x27;fill&#x27;
                            },
                            clickable : true
                        };
                        if (this.dataRangeOption.orient == &#x27;vertical&#x27;
                            &amp;&amp; this.dataRangeOption.x == &#x27;right&#x27;
                            ) {
                            textShape.style.x -= (itemWidth + 10);
                            textShape.style.textAlign = &#x27;right&#x27;;
                        }
                        textShape._idx = i;
                        textShape.onclick = this._dataRangeSelected;
                        this.shapeList.push(new TextShape(textShape));
                    }

                    if (this.dataRangeOption.orient == &#x27;horizontal&#x27;) {
                        lastX += itemWidth
                            + (needValueText ? 5 : 0)
                            + (needValueText
                                ? zrArea.getTextWidth(itemName, font)
                                : 0)
                            + itemGap;
                    }
                    else {
                        lastY += itemHeight + itemGap;
                    }
                }

                if (!needValueText &amp;&amp; this.dataRangeOption.text[1]) {
                    if (this.dataRangeOption.orient == &#x27;horizontal&#x27;) {
                        lastX = lastX - itemGap + this._textGap;
                    }
                    else {
                        lastY = lastY - itemGap + this._textGap;
                    }
                    // 最后一个文字
                    textShape = this._getTextShape(
                        lastX, lastY, this.dataRangeOption.text[1]
                    );

                    if (this.dataRangeOption.orient != &#x27;horizontal&#x27;) {
                        textShape.style.y -= 5;
                        textShape.style.textBaseline = &#x27;top&#x27;;
                    }

                    this.shapeList.push(new TextShape(textShape));
                }
            },

            /**
             * 构建渐变型的值域元素
             */
            _buildGradient : function () {
                var itemShape;
                var textShape;
                var font = this.getFont(this.dataRangeOption.textStyle);

                var lastX = this._itemGroupLocation.x;
                var lastY = this._itemGroupLocation.y;
                var itemWidth = this.dataRangeOption.itemWidth;
                var itemHeight = this.dataRangeOption.itemHeight;
                var textHeight = zrArea.getTextHeight(&#x27;国&#x27;, font);


                var needValueText = true;
                if (this.dataRangeOption.text) {
                    needValueText = false;
                    // 第一个文字
                    if (this.dataRangeOption.text[0]) {
                        textShape = this._getTextShape(
                            lastX, lastY, this.dataRangeOption.text[0]
                        );
                        if (this.dataRangeOption.orient == &#x27;horizontal&#x27;) {
                            lastX += zrArea.getTextWidth(
                                this.dataRangeOption.text[0],
                                font
                            )
                                + this._textGap;
                        }
                        else {
                            lastY += textHeight + this._textGap;
                            textShape.style.y += textHeight / 2 + this._textGap;
                            textShape.style.textBaseline = &#x27;bottom&#x27;;
                        }
                        this.shapeList.push(new TextShape(textShape));
                    }
                }

                var zrColor = require(&#x27;zrender/tool/color&#x27;);
                var per = 1 / (this.dataRangeOption.color.length - 1);
                var colorList = [];
                for (var i = 0, l = this.dataRangeOption.color.length; i &lt; l; i++) {
                    colorList.push([i * per, this.dataRangeOption.color[i]]);
                }
                if (this.dataRangeOption.orient == &#x27;horizontal&#x27;) {
                    itemShape = {
                        zlevel : this._zlevelBase,
                        style : {
                            x : lastX,
                            y : lastY,
                            width : itemWidth * 10,
                            height : itemHeight,
                            color : zrColor.getLinearGradient(
                                lastX, lastY, lastX + itemWidth * 10, lastY,
                                colorList
                            )
                        },
                        hoverable : false
                    };
                    lastX += itemWidth * 10 + this._textGap;
                }
                else {
                    itemShape = {
                        zlevel : this._zlevelBase,
                        style : {
                            x : lastX,
                            y : lastY,
                            width : itemWidth,
                            height : itemHeight * 10,
                            color : zrColor.getLinearGradient(
                                lastX, lastY, lastX, lastY + itemHeight * 10,
                                colorList
                            )
                        },
                        hoverable : false
                    };
                    lastY += itemHeight * 10 + this._textGap;
                }
                this.shapeList.push(new RectangleShape(itemShape));
                if (this.dataRangeOption.calculable) {
                    // 可计算元素的位置缓存
                    this._calculableLocation = itemShape.style;
                    this._buildFiller();
                    this._bulidMask();
                    this._bulidHandle();
                }

                if (!needValueText &amp;&amp; this.dataRangeOption.text[1]) {
                    // 最后一个文字
                    textShape = this._getTextShape(
                        lastX, lastY, this.dataRangeOption.text[1]
                    );

                    this.shapeList.push(new TextShape(textShape));
                }
            },

            /**
             * 构建填充物
             */
            _buildFiller : function () {
                this._fillerShae = {
                    zlevel : this._zlevelBase + 1,
                    style : {
                        x : this._calculableLocation.x,
                        y : this._calculableLocation.y,
                        width : this._calculableLocation.width,
                        height : this._calculableLocation.height,
                        color : &#x27;rgba(255,255,255,0)&#x27;
                    },
                    highlightStyle : {
                        strokeColor : &#x27;rgba(255,255,255,0.5)&#x27;,
                        lineWidth : 1
                    },
                    draggable : true,
                    ondrift : this._ondrift,
                    ondragend : this._ondragend,
                    _type : &#x27;filler&#x27;
                };
                this._fillerShae = new RectangleShape(this._fillerShae);
                this.shapeList.push(this._fillerShae);
            },

            /**
             * 构建拖拽手柄
             */
            _bulidHandle : function () {
                var x = this._calculableLocation.x;
                var y = this._calculableLocation.y;
                var width = this._calculableLocation.width;
                var height = this._calculableLocation.height;

                var font = this.getFont(this.dataRangeOption.textStyle);
                var textHeight = zrArea.getTextHeight(&#x27;国&#x27;, font);
                var textWidth = Math.max(
                    zrArea.getTextWidth(this._textFormat(this.dataRangeOption.max), font),
                    zrArea.getTextWidth(this._textFormat(this.dataRangeOption.min), font)
                ) + 2;

                var pointListStart;
                var textXStart;
                var textYStart;
                var coverRectStart;
                var pointListEnd;
                var textXEnd;
                var textYEnd;
                var coverRectEnd;
                if (this.dataRangeOption.orient == &#x27;horizontal&#x27;) {
                    // 水平
                    if (this.dataRangeOption.y != &#x27;bottom&#x27;) {
                        // 手柄统统在下方
                        pointListStart = [
                            [x, y],
                            [x, y + height + textHeight],
                            [x - textHeight, y + height + textHeight],
                            [x - 1, y + height],
                            [x - 1, y]

                        ];
                        textXStart = x - textWidth / 2 - textHeight;
                        textYStart = y + height + textHeight / 2 + 2;
                        coverRectStart = {
                            x : x - textWidth - textHeight,
                            y : y + height,
                            width : textWidth + textHeight,
                            height : textHeight
                        };

                        pointListEnd = [
                            [x + width, y],
                            [x + width, y + height + textHeight],
                            [x + width + textHeight, y + height + textHeight],
                            [x + width + 1, y + height],
                            [x + width + 1, y]
                        ];
                        textXEnd = x + width + textWidth / 2 + textHeight;
                        textYEnd = textYStart;
                        coverRectEnd = {
                            x : x + width,
                            y : y + height,
                            width : textWidth + textHeight,
                            height : textHeight
                        };
                    }
                    else {
                        // 手柄在上方
                        pointListStart = [
                            [x, y + height],
                            [x, y - textHeight],
                            [x - textHeight, y - textHeight],
                            [x - 1, y],
                            [x - 1, y + height]

                        ];
                        textXStart = x - textWidth / 2 - textHeight;
                        textYStart = y - textHeight / 2 - 2;
                        coverRectStart = {
                            x : x - textWidth - textHeight,
                            y : y - textHeight,
                            width : textWidth + textHeight,
                            height : textHeight
                        };

                        pointListEnd = [
                            [x + width, y + height],
                            [x + width, y - textHeight],
                            [x + width + textHeight, y - textHeight],
                            [x + width + 1, y],
                            [x + width + 1, y + height]
                        ];
                        textXEnd = x + width + textWidth / 2 + textHeight;
                        textYEnd = textYStart;
                        coverRectEnd = {
                            x : x + width,
                            y : y - textHeight,
                            width : textWidth + textHeight,
                            height : textHeight
                        };
                    }
                }
                else {
                    textWidth += textHeight;
                    // 垂直
                    if (this.dataRangeOption.x != &#x27;right&#x27;) {
                        // 手柄统统在右侧
                        pointListStart = [
                            [x, y],
                            [x + width + textHeight, y],
                            [x + width + textHeight, y - textHeight],
                            [x + width, y - 1],
                            [x, y - 1]
                        ];
                        textXStart = x + width + textWidth / 2 + textHeight / 2;
                        textYStart = y - textHeight / 2;
                        coverRectStart = {
                            x : x + width,
                            y : y - textHeight,
                            width : textWidth + textHeight,
                            height : textHeight
                        };

                        pointListEnd = [
                            [x, y + height],
                            [x + width + textHeight, y + height],
                            [x + width + textHeight, y + textHeight + height],
                            [x + width, y + 1 + height],
                            [x, y + height + 1]
                        ];
                        textXEnd = textXStart;
                        textYEnd = y  + height + textHeight / 2;
                        coverRectEnd = {
                            x : x + width,
                            y : y + height,
                            width : textWidth + textHeight,
                            height : textHeight
                        };
                    }
                    else {
                        // 手柄在左侧
                        pointListStart = [
                            [x + width, y],
                            [x - textHeight, y],
                            [x - textHeight, y - textHeight],
                            [x, y - 1],
                            [x + width, y - 1]
                        ];
                        textXStart = x - textWidth / 2 - textHeight / 2;
                        textYStart = y - textHeight / 2;
                        coverRectStart = {
                            x : x - textWidth - textHeight,
                            y : y - textHeight,
                            width : textWidth + textHeight,
                            height : textHeight
                        };

                        pointListEnd = [
                            [x + width, y + height],
                            [x - textHeight, y + height],
                            [x - textHeight, y + textHeight + height],
                            [x, y + 1 + height],
                            [x + width, y + height + 1]
                        ];
                        textXEnd = textXStart;
                        textYEnd = y  + height + textHeight / 2;
                        coverRectEnd = {
                            x : x - textWidth - textHeight,
                            y : y + height,
                            width : textWidth + textHeight,
                            height : textHeight
                        };
                    }
                }

                this._startShape = {
                    style : {
                        pointList : pointListStart,
                        text : this._textFormat(this.dataRangeOption.max),
                        textX : textXStart,
                        textY : textYStart,
                        color : this.getColor(this.dataRangeOption.max),
                        rect : coverRectStart,
                        x : pointListStart[0][0],
                        y : pointListStart[0][1],
                        _x : pointListStart[0][0],   // 拖拽区域控制缓存
                        _y : pointListStart[0][1]
                    }
                };
                this._startShape.highlightStyle = {
                    strokeColor : this._startShape.style.color,
                    lineWidth : 1
                };

                this._endShape = {
                    style : {
                        pointList : pointListEnd,
                        text : this._textFormat(this.dataRangeOption.min),
                        textX : textXEnd,
                        textY : textYEnd,
                        color : this.getColor(this.dataRangeOption.min),
                        rect : coverRectEnd,
                        x : pointListEnd[0][0],
                        y : pointListEnd[0][1],
                        _x : pointListEnd[0][0],   // 拖拽区域控制缓存
                        _y : pointListEnd[0][1]
                    }
                };
                this._endShape.highlightStyle = {
                    strokeColor : this._endShape.style.color,
                    lineWidth : 1
                };

                // 统一参数
                this._startShape.zlevel              = this._endShape.zlevel    = this._zlevelBase + 1;
                this._startShape.draggable           = this._endShape.draggable = true;
                this._startShape.ondrift             = this._endShape.ondrift   = this._ondrift;
                this._startShape.ondragend           = this._endShape.ondragend = this._ondragend;

                this._startShape.style.textColor     = this._endShape.style.textColor
                    = this.dataRangeOption.textStyle.color;
                this._startShape.style.textAlign     = this._endShape.style.textAlign     = &#x27;center&#x27;;
                this._startShape.style.textPosition  = this._endShape.style.textPosition  = &#x27;specific&#x27;;
                this._startShape.style.textBaseline  = this._endShape.style.textBaseline  = &#x27;middle&#x27;;
                // for ondrif计算统一
                this._startShape.style.width         = this._endShape.style.width         = 0;
                this._startShape.style.height        = this._endShape.style.height        = 0;
                this._startShape.style.textPosition  = this._endShape.style.textPosition  = &#x27;specific&#x27;;

                this._startShape = new HandlePolygonShape(this._startShape);
                this._endShape = new HandlePolygonShape(this._endShape);
                this.shapeList.push(this._startShape);
                this.shapeList.push(this._endShape);
            },

            _bulidMask : function () {
                var x = this._calculableLocation.x;
                var y = this._calculableLocation.y;
                var width = this._calculableLocation.width;
                var height = this._calculableLocation.height;
                this._startMask = {
                    zlevel : this._zlevelBase + 1,
                    style : {
                        x : x,
                        y : y,
                        width : this.dataRangeOption.orient == &#x27;horizontal&#x27;
                            ? 0 : width,
                        height : this.dataRangeOption.orient == &#x27;horizontal&#x27;
                            ? height : 0,
                        color : &#x27;#ccc&#x27;
                    },
                    hoverable:false
                };
                this._endMask = {
                    zlevel : this._zlevelBase + 1,
                    style : {
                        x : this.dataRangeOption.orient == &#x27;horizontal&#x27;
                            ? x + width : x,
                        y : this.dataRangeOption.orient == &#x27;horizontal&#x27;
                            ? y : y + height,
                        width : this.dataRangeOption.orient == &#x27;horizontal&#x27;
                            ? 0 : width,
                        height : this.dataRangeOption.orient == &#x27;horizontal&#x27;
                            ? height : 0,
                        color : &#x27;#ccc&#x27;
                    },
                    hoverable:false
                };
                this._startMask = new RectangleShape(this._startMask);
                this._endMask = new RectangleShape(this._endMask);
                this.shapeList.push(this._startMask);
                this.shapeList.push(this._endMask);
            },

            _buildBackground : function () {
                var pTop = this.dataRangeOption.padding[0];
                var pRight = this.dataRangeOption.padding[1];
                var pBottom = this.dataRangeOption.padding[2];
                var pLeft = this.dataRangeOption.padding[3];

                this.shapeList.push(new RectangleShape({
                    zlevel : this._zlevelBase,
                    hoverable :false,
                    style : {
                        x : this._itemGroupLocation.x - pLeft,
                        y : this._itemGroupLocation.y - pTop,
                        width : this._itemGroupLocation.width + pLeft + pRight,
                        height : this._itemGroupLocation.height + pTop + pBottom,
                        brushType : this.dataRangeOption.borderWidth === 0
                            ? &#x27;fill&#x27; : &#x27;both&#x27;,
                        color : this.dataRangeOption.backgroundColor,
                        strokeColor : this.dataRangeOption.borderColor,
                        lineWidth : this.dataRangeOption.borderWidth
                    }
                }));
            },

            /**
             * 根据选项计算值域实体的位置坐标
             */
            _getItemGroupLocation : function () {
                var data = this._valueTextList;
                var dataLength = data.length;
                var itemGap = this.dataRangeOption.itemGap;
                var itemWidth = this.dataRangeOption.itemWidth;
                var itemHeight = this.dataRangeOption.itemHeight;
                var totalWidth = 0;
                var totalHeight = 0;
                var font = this.getFont(this.dataRangeOption.textStyle);
                var textHeight = zrArea.getTextHeight(&#x27;国&#x27;, font);

                if (this.dataRangeOption.orient == &#x27;horizontal&#x27;) {
                    // 水平布局，计算总宽度
                    if (this.dataRangeOption.text
                        || this.dataRangeOption.splitNumber &lt;= 0
                        || this.dataRangeOption.calculable
                        ) {
                        // 指定文字或线性渐变
                        totalWidth =
                            ((this.dataRangeOption.splitNumber &lt;= 0
                                || this.dataRangeOption.calculable)
                                ? (itemWidth * 10 + itemGap)
                                : dataLength * (itemWidth + itemGap))
                            + (this.dataRangeOption.text
                            &amp;&amp; typeof this.dataRangeOption.text[0] != &#x27;undefined&#x27;
                            ? (zrArea.getTextWidth(
                            this.dataRangeOption.text[0],
                            font
                        ) + this._textGap)
                            : 0)
                            + (this.dataRangeOption.text
                            &amp;&amp; typeof this.dataRangeOption.text[1] != &#x27;undefined&#x27;
                            ? (zrArea.getTextWidth(
                            this.dataRangeOption.text[1],
                            font
                        ) + this._textGap)
                            : 0);
                    }
                    else {
                        // 值标签
                        itemWidth += 5;
                        for (var i = 0; i &lt; dataLength; i++) {
                            totalWidth += itemWidth
                                + zrArea.getTextWidth(
                                    data[i],
                                    font
                                )
                                + itemGap;
                        }
                    }
                    totalWidth -= itemGap;      // 减去最后一个的itemGap
                    totalHeight = Math.max(textHeight, itemHeight);
                }
                else {
                    // 垂直布局，计算总高度
                    var maxWidth;
                    if (this.dataRangeOption.text
                        || this.dataRangeOption.splitNumber &lt;= 0
                        || this.dataRangeOption.calculable
                        ) {
                        // 指定文字或线性渐变
                        totalHeight =
                            ((this.dataRangeOption.splitNumber &lt;= 0
                                || this.dataRangeOption.calculable)
                                ? (itemHeight * 10 + itemGap)
                                : dataLength * (itemHeight + itemGap))
                            + (this.dataRangeOption.text
                            &amp;&amp; typeof this.dataRangeOption.text[0] != &#x27;undefined&#x27;
                            ? (this._textGap + textHeight)
                            : 0)
                            + (this.dataRangeOption.text
                            &amp;&amp; typeof this.dataRangeOption.text[1] != &#x27;undefined&#x27;
                            ? (this._textGap + textHeight)
                            : 0);

                        maxWidth = Math.max(
                            zrArea.getTextWidth(
                                    (this.dataRangeOption.text &amp;&amp; this.dataRangeOption.text[0])
                                    || &#x27;&#x27;,
                                font
                            ),
                            zrArea.getTextWidth(
                                    (this.dataRangeOption.text &amp;&amp; this.dataRangeOption.text[1])
                                    || &#x27;&#x27;,
                                font
                            )
                        );
                        totalWidth = Math.max(itemWidth, maxWidth);
                    }
                    else {
                        totalHeight = (itemHeight + itemGap) * dataLength;
                        // 值标签
                        itemWidth += 5;
                        maxWidth = 0;
                        for (var i = 0; i &lt; dataLength; i++) {
                            maxWidth = Math.max(
                                maxWidth,
                                zrArea.getTextWidth(
                                    data[i],
                                    font
                                )
                            );
                        }
                        totalWidth = itemWidth + maxWidth;
                    }
                    totalHeight -= itemGap;     // 减去最后一个的itemGap;
                }

                var x;
                var zrWidth = this.zr.getWidth();
                switch (this.dataRangeOption.x) {
                    case &#x27;center&#x27; :
                        x = Math.floor((zrWidth - totalWidth) / 2);
                        break;
                    case &#x27;left&#x27; :
                        x = this.dataRangeOption.padding[3]
                            + this.dataRangeOption.borderWidth;
                        break;
                    case &#x27;right&#x27; :
                        x = zrWidth
                            - totalWidth
                            - this.dataRangeOption.padding[1]
                            - this.dataRangeOption.borderWidth;
                        break;
                    default :
                        x = this.parsePercent(this.dataRangeOption.x, zrWidth);
                        x = isNaN(x) ? 0 : x;
                        break;
                }

                var y;
                var zrHeight = this.zr.getHeight();
                switch (this.dataRangeOption.y) {
                    case &#x27;top&#x27; :
                        y = this.dataRangeOption.padding[0]
                            + this.dataRangeOption.borderWidth;
                        break;
                    case &#x27;bottom&#x27; :
                        y = zrHeight
                            - totalHeight
                            - this.dataRangeOption.padding[2]
                            - this.dataRangeOption.borderWidth;
                        break;
                    case &#x27;center&#x27; :
                        y = Math.floor((zrHeight - totalHeight) / 2);
                        break;
                    default :
                        y = this.parsePercent(this.dataRangeOption.y, zrHeight);
                        y = isNaN(y) ? 0 : y;
                        break;
                }

                if (this.dataRangeOption.calculable) {
                    // 留出手柄控件
                    var handlerWidth = Math.max(
                        zrArea.getTextWidth(this.dataRangeOption.max, font),
                        zrArea.getTextWidth(this.dataRangeOption.min, font)
                    ) + textHeight;
                    if (this.dataRangeOption.orient == &#x27;horizontal&#x27;) {
                        if (x &lt; handlerWidth) {
                            x = handlerWidth;
                        }
                        if (x + totalWidth + handlerWidth &gt; zrWidth) {
                            x -= handlerWidth;
                        }
                    }
                    else {
                        if (y &lt; textHeight) {
                            y = textHeight;
                        }
                        if (y + totalHeight + textHeight &gt; zrHeight) {
                            y -= textHeight;
                        }
                    }
                }

                return {
                    x : x,
                    y : y,
                    width : totalWidth,
                    height : totalHeight
                };
            },

            // 指定文本
            _getTextShape : function (x, y, text) {
                return {
                    zlevel : this._zlevelBase,
                    style : {
                        x : (this.dataRangeOption.orient == &#x27;horizontal&#x27;
                            ? x
                            : this._itemGroupLocation.x
                            + this._itemGroupLocation.width / 2
                            ),
                        y : (this.dataRangeOption.orient == &#x27;horizontal&#x27;
                            ? this._itemGroupLocation.y
                            + this._itemGroupLocation.height / 2
                            : y
                            ),
                        color : this.dataRangeOption.textStyle.color,
                        text: text,
                        textFont: this.getFont(this.dataRangeOption.textStyle),
                        textBaseline: (this.dataRangeOption.orient == &#x27;horizontal&#x27;
                            ? &#x27;middle&#x27; : &#x27;top&#x27;),
                        textAlign: (this.dataRangeOption.orient == &#x27;horizontal&#x27;
                            ? &#x27;left&#x27; : &#x27;center&#x27;)
                    },
                    hoverable : false
                };
            },

            // 色尺legend item shape
            _getItemShape : function (x, y, width, height, color) {
                return {
                    zlevel : this._zlevelBase,
                    style : {
                        x : x,
                        y : y + 1,
                        width : width,
                        height : height - 2,
                        color : color
                    },
                    highlightStyle: {
                        strokeColor: color,
                        lineWidth : 1
                    },
                    clickable : true
                };
            },

            /**
             * 拖拽范围控制
             */
            __ondrift : function (shape, dx, dy) {
                var x = this._calculableLocation.x;
                var y = this._calculableLocation.y;
                var width = this._calculableLocation.width;
                var height = this._calculableLocation.height;

                if (this.dataRangeOption.orient == &#x27;horizontal&#x27;) {
                    if (shape.style.x + dx &lt;= x) {
                        shape.style.x = x;
                    }
                    else if (shape.style.x + dx + shape.style.width &gt;= x + width) {
                        shape.style.x = x + width - shape.style.width;
                    }
                    else {
                        shape.style.x += dx;
                    }
                }
                else {
                    if (shape.style.y + dy &lt;= y) {
                        shape.style.y = y;
                    }
                    else if (shape.style.y + dy + shape.style.height &gt;= y + height) {
                        shape.style.y = y + height - shape.style.height;
                    }
                    else {
                        shape.style.y += dy;
                    }
                }

                if (shape._type == &#x27;filler&#x27;) {
                    this._syncHandleShape();
                }
                else {
                    this._syncFillerShape(shape);
                }

                if (this.dataRangeOption.realtime) {
                    this._syncData();
                }

                return true;
            },

            __ondragend : function () {
                this.isDragend = true;
            },

            /**
             * 数据项被拖拽出去
             */
            ondragend : function (param, status) {
                if (!this.isDragend || !param.target) {
                    // 没有在当前实例上发生拖拽行为则直接返回
                    return;
                }

                !this.dataRangeOption.realtime &amp;&amp; this._syncData();

                // 别status = {}赋值啊！！
                status.dragOut = true;
                status.dragIn = true;

                if (!this.dataRangeOption.realtime &amp;&amp; false) {
                    this.messageCenter.dispatch(
                        ecConfig.EVENT.DATA_RANGE,
                        null,
                        {
                            range : {
                                start : this._range.end,
                                end : this._range.start
                            }
                        },
                        this.myChart
                    );
                }

                status.needRefresh = false; // 会有消息触发fresh，不用再刷一遍
                // 处理完拖拽事件后复位
                this.isDragend = false;

                return;
            },

            // 外部传入range
            _syncShapeFromRange : function () {
                var range = this.dataRangeOption.range || {};
                // 做一个反转
                this._range.end = typeof this._range.end != &#x27;undefined&#x27;
                    ? this._range.end
                    : (typeof range.start != &#x27;undefined&#x27; ? range.start : 0);
                this._range.start = typeof this._range.start != &#x27;undefined&#x27;
                    ? this._range.start
                    : (typeof range.end != &#x27;undefined&#x27; ? range.end : 100);

                if (this._range.start != 100 || this._range.end !== 0) {
                    // 非默认满值同步一下图形
                    if (this.dataRangeOption.orient == &#x27;horizontal&#x27;) {
                        // 横向
                        var width = this._fillerShae.style.width;
                        this._fillerShae.style.x +=
                            width * (100 - this._range.start) / 100;
                        this._fillerShae.style.width =
                            width * (this._range.start - this._range.end) / 100;
                    }
                    else {
                        // 纵向
                        var height = this._fillerShae.style.height;
                        this._fillerShae.style.y +=
                            height * (100 - this._range.start) / 100;
                        this._fillerShae.style.height =
                            height * (this._range.start - this._range.end) / 100;
                    }
                    this.zr.modShape(this._fillerShae.id);
                    this._syncHandleShape();
                }
            },

            _syncHandleShape : function () {
                var x = this._calculableLocation.x;
                var y = this._calculableLocation.y;
                var width = this._calculableLocation.width;
                var height = this._calculableLocation.height;

                if (this.dataRangeOption.orient == &#x27;horizontal&#x27;) {
                    this._startShape.style.x = this._fillerShae.style.x;
                    this._startMask.style.width = this._startShape.style.x - x;

                    this._endShape.style.x = this._fillerShae.style.x
                        + this._fillerShae.style.width;
                    this._endMask.style.x = this._endShape.style.x;
                    this._endMask.style.width = x + width - this._endShape.style.x;

                    this._range.start = Math.ceil(
                            100 - (this._startShape.style.x - x) / width * 100
                    );
                    this._range.end = Math.floor(
                            100 - (this._endShape.style.x - x) / width * 100
                    );
                }
                else {
                    this._startShape.style.y = this._fillerShae.style.y;
                    this._startMask.style.height = this._startShape.style.y - y;

                    this._endShape.style.y = this._fillerShae.style.y
                        + this._fillerShae.style.height;
                    this._endMask.style.y = this._endShape.style.y;
                    this._endMask.style.height = y + height - this._endShape.style.y;

                    this._range.start = Math.ceil(
                            100 - (this._startShape.style.y - y) / height * 100
                    );
                    this._range.end = Math.floor(
                            100 - (this._endShape.style.y - y) / height * 100
                    );
                }

                this._syncShape();
            },

            _syncFillerShape : function (e) {
                var x = this._calculableLocation.x;
                var y = this._calculableLocation.y;
                var width = this._calculableLocation.width;
                var height = this._calculableLocation.height;

                var a;
                var b;
                if (this.dataRangeOption.orient == &#x27;horizontal&#x27;) {
                    a = this._startShape.style.x;
                    b = this._endShape.style.x;
                    if (e.id == this._startShape.id &amp;&amp; a &gt;= b) {
                        // _startShape触发
                        b = a;
                        this._endShape.style.x = a;
                    }
                    else if (e.id == this._endShape.id &amp;&amp; a &gt;= b) {
                        // _endShape触发
                        a = b;
                        this._startShape.style.x = a;
                    }
                    this._fillerShae.style.x = a;
                    this._fillerShae.style.width = b - a;
                    this._startMask.style.width = a - x;
                    this._endMask.style.x = b;
                    this._endMask.style.width = x + width - b;

                    this._range.start = Math.ceil(100 - (a - x) / width * 100);
                    this._range.end = Math.floor(100 - (b - x) / width * 100);
                }
                else {
                    a = this._startShape.style.y;
                    b = this._endShape.style.y;
                    if (e.id == this._startShape.id &amp;&amp; a &gt;= b) {
                        // _startShape触发
                        b = a;
                        this._endShape.style.y = a;
                    }
                    else if (e.id == this._endShape.id &amp;&amp; a &gt;= b) {
                        // _endShape触发
                        a = b;
                        this._startShape.style.y = a;
                    }
                    this._fillerShae.style.y = a;
                    this._fillerShae.style.height = b - a;
                    this._startMask.style.height = a - y;
                    this._endMask.style.y = b;
                    this._endMask.style.height = y + height - b;

                    this._range.start = Math.ceil(100 - (a - y) / height * 100);
                    this._range.end = Math.floor(100 - (b - y) / height * 100);
                }

                this._syncShape();
            },

            _syncShape : function () {
                this._startShape.position = [
                        this._startShape.style.x - this._startShape.style._x,
                        this._startShape.style.y - this._startShape.style._y
                ];

                this._startShape.style.text = this._textFormat(
                        this._gap * this._range.start + this.dataRangeOption.min
                );

                this._startShape.style.color
                    = this._startShape.highlightStyle.strokeColor
                    = this.getColor(
                        this._gap * this._range.start + this.dataRangeOption.min
                );

                this._endShape.position = [
                        this._endShape.style.x - this._endShape.style._x,
                        this._endShape.style.y - this._endShape.style._y
                ];

                this._endShape.style.text = this._textFormat(
                        this._gap * this._range.end + this.dataRangeOption.min
                );

                this._endShape.style.color
                    = this._endShape.highlightStyle.strokeColor
                    = this.getColor(
                        this._gap * this._range.end + this.dataRangeOption.min
                );

                this.zr.modShape(this._startShape.id);
                this.zr.modShape(this._endShape.id);
                this.zr.modShape(this._startMask.id);
                this.zr.modShape(this._endMask.id);
                this.zr.modShape(this._fillerShae.id);
                this.zr.refresh();
            },

            _syncData : function () {
                if (this.dataRangeOption.realtime) {
                    this.messageCenter.dispatch(
                        ecConfig.EVENT.DATA_RANGE,
                        null,
                        {
                            range : {
                                start : this._range.end,
                                end : this._range.start
                            }
                        },
                        this.myChart
                    );
                }
            },


            __dataRangeSelected : function (param) {
                var idx = param.target._idx;
                this._selectedMap[idx] = !this._selectedMap[idx];
                this.messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this.myChart);
            },

            _textFormat : function(valueStart, valueEnd) {
                valueStart = valueStart.toFixed(this.dataRangeOption.precision);
                valueEnd = typeof valueEnd != &#x27;undefined&#x27;
                    ? valueEnd.toFixed(this.dataRangeOption.precision) : &#x27;&#x27;;
                if (this.dataRangeOption.formatter) {
                    if (typeof this.dataRangeOption.formatter == &#x27;string&#x27;) {
                        return this.dataRangeOption.formatter.replace(&#x27;{value}&#x27;, valueStart)
                            .replace(&#x27;{value2}&#x27;, valueEnd);
                    }
                    else if (typeof this.dataRangeOption.formatter == &#x27;function&#x27;) {
                        return this.dataRangeOption.formatter(valueStart, valueEnd);
                    }
                }

                if (valueEnd !== &#x27;&#x27;) {
                    return valueStart + &#x27; - &#x27; + valueEnd;
                }

                return valueStart;
            },

            /**
             * 刷新
             */
            refresh : function (newOption) {
                if (newOption) {
                    this.option = newOption;
                    this.option.dataRange = this.reformOption(this.option.dataRange);
                    // 补全padding属性
                    this.option.dataRange.padding = this.reformCssArray(
                        this.option.dataRange.padding
                    );
                    this.dataRangeOption = this.option.dataRange;

                    var splitNumber = this.dataRangeOption.splitNumber &lt;= 0
                        || this.dataRangeOption.calculable
                        ? 100
                        : this.dataRangeOption.splitNumber;
                    this._colorList = zrColor.getGradientColors(
                        this.dataRangeOption.color,
                            Math.max(
                                    (splitNumber - this.dataRangeOption.color.length)
                                    / (this.dataRangeOption.color.length - 1),
                                0
                            ) + 1
                    );

                    if (this._colorList.length &gt; splitNumber) {
                        var len = this._colorList.length;
                        var newColorList = [this._colorList[0]];
                        var step = len / (splitNumber - 1);
                        for (var i = 1; i &lt; splitNumber - 1; i++) {
                            newColorList.push(this._colorList[Math.floor(i * step)]);
                        }
                        newColorList.push(this._colorList[len - 1]);
                        this._colorList = newColorList;
                    }
                    // console.log(this._colorList.length)

                    var precision = this.dataRangeOption.precision;
                    this._gap = (this.dataRangeOption.max - this.dataRangeOption.min) / splitNumber;
                    while (this._gap.toFixed(precision) - 0 != this._gap &amp;&amp; precision &lt; 5) {
                        // 精度自适应
                        precision++;
                    }
                    this.dataRangeOption.precision = precision;

                    this._gap = (
                        (this.dataRangeOption.max - this.dataRangeOption.min) / splitNumber
                        ).toFixed(precision) - 0;

                    this._valueTextList = [];
                    for (var i = 0; i &lt; splitNumber; i++) {
                        this._selectedMap[i] = true;
                        this._valueTextList.unshift(
                            this._textFormat(
                                    i * this._gap + this.dataRangeOption.min,
                                    (i + 1) * this._gap + this.dataRangeOption.min
                            )
                        );
                    }
                }

                this.clear();
                this._buildShape();
            },

            getColor : function (value) {
                if (isNaN(value)) {
                    return null;
                }

                if (value &lt; this.dataRangeOption.min) {
                    value = this.dataRangeOption.min;
                }
                else if (value &gt; this.dataRangeOption.max) {
                    value = this.dataRangeOption.max;
                }

                if (this.dataRangeOption.calculable) {
                    if (value - (this._gap * this._range.start + this.dataRangeOption.min) &gt; 0.00005
                        || value - (this._gap * this._range.end + this.dataRangeOption.min) &lt; -0.00005) {
                        return null;
                    }
                }

                var idx = this._colorList.length - Math.ceil(
                        (value - this.dataRangeOption.min)
                        / (this.dataRangeOption.max - this.dataRangeOption.min)
                        * this._colorList.length
                );
                if (idx == this._colorList.length) {
                    idx--;
                }
                //console.log(value, idx,this._colorList[idx])
                if (this._selectedMap[idx]) {
                    return this._colorList[idx];
                }
                else {
                    return null;
                }
            }
        };

        zrUtil.inherits(DataRange, Base);

        require(&#x27;../component&#x27;).define(&#x27;dataRange&#x27;, DataRange);

        return DataRange;
    });

    /**
     * echarts坐标处理方法
     *
     * @author Neil (杨骥, yangji01@baidu.com)
     */

    define(
        &#x27;echarts/util/coordinates&#x27;,[&#x27;require&#x27;,&#x27;zrender/tool/math&#x27;],function (require) {
            var zrMath = require(&#x27;zrender/tool/math&#x27;);

            /**
             * 极坐标转直角坐标
             *
             * @param {number} 半径
             * @param {number} 角度
             *
             * @return {Array.&lt;number&gt;} 直角坐标[x,y]
             */
            function polar2cartesian(r, theta) {
                return [r * zrMath.sin(theta), r*zrMath.cos(theta)];
            }

            /**
             * 直角坐标转极坐标
             *
             * @param {number} 横坐标
             * @param {number} 纵坐标
             *
             * @return {Array.&lt;number&gt;} 极坐标[r,theta]
             */
            function cartesian2polar(x, y) {
                return [Math.sqrt(x * x + y * y), Math.atan(y / x)];
            }

            return {
                polar2cartesian : polar2cartesian,
                cartesian2polar : cartesian2polar
            };
        }
    );
    /**
     * echarts组件类：极坐标
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Neil (杨骥, yangji01@baidu.com)
     *
     */
    define(&#x27;echarts/component/polar&#x27;,[&#x27;require&#x27;,&#x27;./base&#x27;,&#x27;zrender/shape/Text&#x27;,&#x27;zrender/shape/Line&#x27;,&#x27;zrender/shape/Polygon&#x27;,&#x27;../config&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;../util/coordinates&#x27;,&#x27;../component&#x27;],function (require) {
        var Base = require(&#x27;./base&#x27;);

        // 图形依赖
        var TextShape = require(&#x27;zrender/shape/Text&#x27;);
        var LineShape = require(&#x27;zrender/shape/Line&#x27;);
        var PolygonShape = require(&#x27;zrender/shape/Polygon&#x27;);

        var ecConfig = require(&#x27;../config&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);
        var ecCoordinates = require(&#x27;../util/coordinates&#x27;);

        function Polar(ecTheme, messageCenter, zr, option, myChart) {
            Base.call(this, ecTheme, messageCenter, zr, option, myChart);

            this.refresh(option);
        }

        Polar.prototype = {
            type : ecConfig.COMPONENT_TYPE_POLAR,

            /**
             * 绘制图形
             */
            _buildShape : function () {
                for (var i = 0; i &lt; this.polar.length; i ++) {
                    this.reformOption(this.polar[i]);

                    this._queryTarget = [this.polar[i], this.option];
                    this._createVector(i);
                    this._buildSpiderWeb(i);

                    this._buildText(i);

                    this._adjustIndicatorValue(i);
                    this._addAxisLabel(i);
                }

                for (var i = 0; i &lt; this.shapeList.length; i ++) {
                    this.zr.addShape(this.shapeList[i]);
                }
            },

            /**
             * 生成蜘蛛网顶点坐标
             * @param {number} polar的index
             */
            _createVector : function (index) {
                var item = this.polar[index];
                var indicator = this.deepQuery(this._queryTarget, &#x27;indicator&#x27;);
                var length = indicator.length;
                var startAngle = item.startAngle ;
                var dStep = 2 * Math.PI / length;
                var radius = this.parsePercent(
                    item.radius,
                        Math.min(this.zr.getWidth(), this.zr.getHeight()) / 2
                );
                var __ecIndicator = item.__ecIndicator = [];
                var vector;

                for (var i = 0 ;i &lt; length ; i ++) {
                    vector = ecCoordinates.polar2cartesian(
                        radius, startAngle * Math.PI / 180 + dStep * i
                    );
                    __ecIndicator.push({
                        // 将图形翻转
                        vector : [vector[1], -vector[0]]
                    });
                }
            },

            /**
             * 构建蜘蛛网
             * @param {number} polar的index
             */
            _buildSpiderWeb : function (index) {
                var item = this.polar[index];
                var __ecIndicator = item.__ecIndicator;
                var splitArea = item.splitArea;
                var splitLine = item.splitLine;

                var center = this.getCenter(index);
                var splitNumber = item.splitNumber;

                var strokeColor = splitLine.lineStyle.color;
                var lineWidth = splitLine.lineStyle.width;
                var show = splitLine.show;

                var axisLine = this.deepQuery(this._queryTarget, &#x27;axisLine&#x27;);

                this._addArea(
                    __ecIndicator, splitNumber, center,
                    splitArea, strokeColor, lineWidth, show
                );

                this._addLine(
                    __ecIndicator, center, axisLine
                );
            },

            /**
             * 绘制axisLabel
             */
            _addAxisLabel : function (index) {
                var item = this.polar[index];
                var indicator = this.deepQuery(this._queryTarget, &#x27;indicator&#x27;);
                var __ecIndicator = item.__ecIndicator;
                var axisLabel;
                var vector;
                var style;
                var newStyle;
                var splitNumber = this.deepQuery(this._queryTarget, &#x27;splitNumber&#x27;);
                var center = this.getCenter(index);
                var vector;
                var value;
                var text;
                var theta;
                // var startAngle = this.deepQuery(this._queryTarget, &#x27;startAngle&#x27;);
                var offset;
                var precision = this.deepQuery(this._queryTarget, &#x27;precision&#x27;);

                for (var i = 0; i &lt; indicator.length; i ++) {
                    axisLabel = this.deepQuery(
                        [indicator[i], item, this.option], &#x27;axisLabel&#x27;
                    );

                    if (axisLabel.show) {
                        style = {};
                        style.textFont = this.getFont();
                        //Todo: bug fix
                        style = zrUtil.merge(style, axisLabel);
                        style.lineWidth = style.width;

                        vector = __ecIndicator[i].vector;
                        value = __ecIndicator[i].value;
                        theta = i / indicator.length * 2 * Math.PI;
                        offset = axisLabel.offset || 10;

                        for (var j = 1 ; j &lt;= splitNumber; j ++) {
                            newStyle = zrUtil.merge({}, style);
                            text =
                                j * (value.max - value.min) / splitNumber
                                + value.min;
                            if (precision) {
                                text  = text.toFixed(precision);
                            }
                            newStyle.text = this.numAddCommas(text);
                            newStyle.x = j * vector[0] / splitNumber
                                + Math.cos(theta) * offset + center[0];
                            newStyle.y = j * vector[1] / splitNumber
                                + Math.sin(theta) * offset + center[1];

                            this.shapeList.push(new TextShape({
                                zlevel : this._zlevelBase,
                                style : newStyle,
                                draggable : false,
                                hoverable : false
                            }));
                        }
                    }
                }
            },

            /**
             * 绘制坐标头的文字
             * @param {number} polar的index
             */
            _buildText  : function (index) {
                var item = this.polar[index];
                var __ecIndicator = item.__ecIndicator;
                var vector;
                var indicator = this.deepQuery(this._queryTarget, &#x27;indicator&#x27;);
                var center = this.getCenter(index);
                var style;
                var textAlign;
                var name;
                var rotation;
                var x = 0;
                var y = 0;
                var margin;
                var textStyle;

                for (var i = 0; i &lt; indicator.length; i ++) {
                    name = this.deepQuery(
                        [indicator[i], item, this.option], &#x27;name&#x27;
                    );

                    if (!name.show) {
                        continue;
                    }
                    textStyle = this.deepQuery(
                        [name, item, this.option],
                        &#x27;textStyle&#x27;
                    );

                    style = {};

                    style.textFont = this.getFont(textStyle);
                    style.color = textStyle.color;

                    if (typeof name.formatter == &#x27;function&#x27;) {
                        style.text = name.formatter(indicator[i].text, i);
                    }
                    else if (typeof name.formatter == &#x27;string&#x27;){
                        style.text = name.formatter.replace(
                            &#x27;{value}&#x27;, indicator[i].text
                        );
                    }
                    else {
                        style.text = indicator[i].text;
                    }
                    __ecIndicator[i].text = style.text;

                    vector = __ecIndicator[i].vector;

                    if (Math.round(vector[0]) &gt; 0) {
                        textAlign = &#x27;left&#x27;;
                    }
                    else if (Math.round(vector[0]) &lt; 0) {
                        textAlign = &#x27;right&#x27;;
                    }
                    else {
                        textAlign = &#x27;center&#x27;;
                    }

                    if (!name.margin) {
                        vector = this._mapVector(vector, center, 1.2);
                    }
                    else {
                        margin = name.margin;
                        x = vector[0] &gt; 0 ? margin : - margin;
                        y = vector[1] &gt; 0 ? margin : - margin;

                        x = vector[0] === 0 ? 0 : x;
                        y = vector[1] === 0 ? 0 : y;
                        vector = this._mapVector(vector, center, 1);
                    }


                    style.textAlign = textAlign;
                    style.x = vector[0] + x;
                    style.y = vector[1] + y;

                    if (name.rotate) {
                        rotation = [
                                name.rotate / 180 * Math.PI,
                            vector[0], vector[1]
                        ];
                    }
                    else {
                        rotation = [0, 0, 0];
                    }

                    this.shapeList.push(new TextShape({
                        zlevel : this._zlevelBase,
                        style : style,
                        draggable : false,
                        hoverable : false,
                        rotation : rotation
                    }));
                }
            },

            getIndicatorText : function(polarIndex, indicatorIndex) {
                return this.polar[polarIndex]
                    &amp;&amp; this.polar[polarIndex].__ecIndicator[indicatorIndex]
                    &amp;&amp; this.polar[polarIndex].__ecIndicator[indicatorIndex].text;
            },

            /**
             * 添加一个隐形的盒子 当做drop的容器 暴露给外部的图形类使用
             * @param {number} polar的index
             * @return {Object} 添加的盒子图形
             */
            getDropBox : function (index) {
                var index = index || 0;
                var item = this.polar[index];
                var center = this.getCenter(index);
                var __ecIndicator = item.__ecIndicator;
                var len = __ecIndicator.length;
                var pointList = [];
                var vector;
                var shape;

                for (var i = 0; i &lt; len; i ++) {
                    vector = __ecIndicator[i].vector;
                    pointList.push(this._mapVector(vector, center, 1.2));
                }

                shape = this._getShape(
                    pointList, &#x27;fill&#x27;, &#x27;rgba(0,0,0,0)&#x27;, &#x27;&#x27;, 1
                );
                return shape;
            },

            /**
             * 绘制蜘蛛网的正n变形
             *
             * @param {Array&lt;Object&gt;} 指标数组
             * @param {number} 分割线数量
             * @param {Array&lt;number&gt;} 中点坐标
             * @param {Object} 分割区域对象
             * @param {string} 线条颜色
             * @param {number} 线条宽度
             */
            _addArea : function (
                __ecIndicator, splitNumber, center,
                splitArea, strokeColor, lineWidth, show
                ) {
                var shape;
                var scale;
                var scale1;
                var pointList;

                for (var i = 0; i &lt; splitNumber ; i ++ ) {
                    scale = (splitNumber - i) / splitNumber;
                    pointList = this._getPointList(__ecIndicator, scale, center);

                    if (show) {
                        shape = this._getShape(
                            pointList, &#x27;stroke&#x27;, &#x27;&#x27;, strokeColor, lineWidth
                        );
                        this.shapeList.push(shape);
                    }

                    if (splitArea.show) {
                        scale1 = (splitNumber - i - 1) / splitNumber;
                        this._addSplitArea(
                            __ecIndicator, splitArea, scale, scale1, center, i
                        );
                    }
                }
            },

            /**
             * 获取需要绘制的多边形的点集
             * @param {Object} serie的指标参数
             * @param {number} 缩小的系数
             * @param {Array&lt;number&gt;} 中点坐标
             *
             * @return {Array&lt;Array&lt;number&gt;&gt;} 返回绘制的点集
             */
            _getPointList : function (__ecIndicator, scale, center) {
                var pointList = [];
                var len = __ecIndicator.length;
                var vector;

                for (var i = 0 ; i &lt; len ; i ++ ) {
                    vector = __ecIndicator[i].vector;

                    pointList.push(this._mapVector(vector, center, scale));
                }
                return pointList;
            },

            /**
             * 获取绘制的图形
             * @param {Array&lt;Array&lt;number&gt;&gt;} 绘制的点集
             * @param {string} 绘制方式 stroke | fill | both 描边 | 填充 | 描边 + 填充
             * @param {string} 颜色
             * @param {string} 描边颜色
             * @param {number} 线条宽度
             * @param {boolean=} hoverable
             * @param {boolean=} draggable
             * @return {Object} 绘制的图形对象
             */
            _getShape : function (
                pointList, brushType, color, strokeColor, lineWidth,
                hoverable, draggable
                ) {
                return new PolygonShape({
                    zlevel : this._zlevelBase,
                    style : {
                        pointList   : pointList,
                        brushType   : brushType,
                        color       : color,
                        strokeColor : strokeColor,
                        lineWidth   : lineWidth
                    },
                    hoverable : hoverable || false,
                    draggable : draggable || false
                });
            },

            /**
             * 绘制填充区域
             */
            _addSplitArea : function (
                __ecIndicator, splitArea, scale, scale1, center, colorInd
                ) {
                var indLen = __ecIndicator.length;
                var color;
                var colorArr = splitArea.areaStyle.color;
                var colorLen;

                var vector;
                var vector1;
                var pointList = [];
                var indLen = __ecIndicator.length;
                var shape;

                if (typeof colorArr == &#x27;string&#x27;) {
                    colorArr = [colorArr];
                }
                colorLen = colorArr.length;
                color = colorArr[ colorInd % colorLen];

                for (var i = 0; i &lt; indLen ; i ++) {
                    pointList = [];
                    vector = __ecIndicator[i].vector;
                    vector1 = __ecIndicator[(i + 1) % indLen].vector;

                    pointList.push(this._mapVector(vector, center, scale));
                    pointList.push(this._mapVector(vector, center, scale1));
                    pointList.push(this._mapVector(vector1, center, scale1));
                    pointList.push(this._mapVector(vector1, center, scale));

                    shape = this._getShape(
                        pointList, &#x27;fill&#x27;, color, &#x27;&#x27;, 1
                    );
                    this.shapeList.push(shape);
                }

            },

            /**
             * 转换坐标
             *
             * @param {Array&lt;number&gt;} 原始坐标
             * @param {Array&lt;number&gt;} 中点坐标
             * @param {number} 缩小的倍数
             *
             * @return {Array&lt;number&gt;} 转换后的坐标
             */
            _mapVector : function (vector, center, scale) {
                return [
                        vector[0] * scale + center[0],
                        vector[1] * scale + center[1]
                ];
            },

            /**
             * 获取中心点位置 暴露给外部图形类使用
             * @param {number} polar的index
             */
            getCenter : function (index) {
                var index = index || 0;
                return this.parseCenter(this.zr, this.polar[index].center);
            },

            /**
             * 绘制从中点出发的线
             *
             * @param {Array&lt;Object&gt;} 指标对象
             * @param {Array&lt;number&gt;} 中点坐标
             * @param {string} 线条颜色
             * @param {number} 线条宽度
             * @param {string} 线条绘制类型
             *              solid | dotted | dashed 实线 | 点线 | 虚线
             */
            _addLine : function (
                __ecIndicator, center, axisLine
                ) {
                var indLen = __ecIndicator.length;
                var line;
                var vector;
                var lineStyle = axisLine.lineStyle;
                var strokeColor = lineStyle.color;
                var lineWidth = lineStyle.width;
                var lineType = lineStyle.type;

                for (var i = 0; i &lt; indLen ; i ++ ) {
                    vector = __ecIndicator[i].vector;
                    line = this._getLine(
                        center[0], center[1],
                            vector[0] + center[0],
                            vector[1] + center[1],
                        strokeColor, lineWidth, lineType
                    );
                    this.shapeList.push(line);
                }
            },

            /**
             * 获取线条对象
             * @param {number} 出发点横坐标
             * @param {number} 出发点纵坐标
             * @param {number} 终点横坐标
             * @param {number} 终点纵坐标
             * @param {string} 线条颜色
             * @param {number} 线条宽度
             * @param {string} 线条类型
             *
             * @return {Object} 线条对象
             */
            _getLine : function (
                xStart, yStart, xEnd, yEnd, strokeColor, lineWidth, lineType
                ) {
                return new LineShape({
                    zlevel : this._zlevelBase,
                    style : {
                        xStart : xStart,
                        yStart : yStart,
                        xEnd   : xEnd,
                        yEnd   : yEnd,
                        strokeColor : strokeColor,
                        lineWidth   : lineWidth,
                        lineType    : lineType
                    },
                    hoverable : false
                });
            },

            /**
             * 调整指标的值，当indicator中存在max时设置为固定值
             * @param {number} polar的index
             */
            _adjustIndicatorValue : function (index) {
                var item = this.polar[index];
                var indicator = this.deepQuery(this._queryTarget, &#x27;indicator&#x27;);
                var len = indicator.length;
                var __ecIndicator = item.__ecIndicator;
                var value;
                var max;
                var min;
                var data = this._getSeriesData(index);
                var splitNumber = item.splitNumber;

                var boundaryGap = this.deepQuery(this._queryTarget, &#x27;boundaryGap&#x27;);
                var precision = this.deepQuery(this._queryTarget, &#x27;precision&#x27;);
                var power = this.deepQuery(this._queryTarget, &#x27;power&#x27;);
                var scale = this.deepQuery(this._queryTarget, &#x27;scale&#x27;);

                for (var i = 0; i &lt; len ; i ++ ) {
                    if (typeof indicator[i].max == &#x27;number&#x27;) {
                        max = indicator[i].max;
                        min = indicator[i].min || 0;
                        value = {
                            max : max,
                            min : min
                        };
                    }
                    else {
                        value = this._findValue(
                            data, i, splitNumber,
                            boundaryGap, precision, power, scale
                        );
                    }

                    __ecIndicator[i].value = value;
                }
            },

            /**
             * 将series中的数据拿出来，如果没有polarIndex属性，默认为零
             * @param {number} polar 的index
             * @param {Array&lt;Object&gt;} 需要处理的数据
             */
            _getSeriesData : function (index) {
                var data = [];
                var serie;
                var serieData;
                var legend = this.component.legend;

                for (var i = 0; i &lt; this.series.length; i ++) {
                    serie = this.series[i];
                    if (serie.type != ecConfig.CHART_TYPE_RADAR) {
                        continue;
                    }
                    serieData = serie.data || [];
                    for (var j = 0; j &lt; serieData.length; j ++) {
                        polarIndex = this.deepQuery(
                            [serieData[j], serie, this.option], &#x27;polarIndex&#x27;
                        ) || 0;
                        if (polarIndex == index
                            &amp;&amp; (!legend || legend.isSelected(serieData[j].name))
                            ) {
                            data.push(serieData[j]);
                        }
                    }
                }
                return data;
            },

            /**
             * 查找指标合适的值
             *
             * 如果只有一组数据以数据中的最大值作为最大值 0为最小值
             * 如果是多组，使用同一维度的进行比较 选出最大值最小值
             * 对它们进行处理
             * @param {Object} serie 的 data
             * @param {number} 指标的序号
             * @param {boolean} boundaryGap 两端留白
             * @param {number} precision 小数精度
             * @param {number} power 整数精度
             * @return {Object} 指标的最大值最小值
             */
            _findValue : function (
                data, index, splitNumber, boundaryGap, precision, power, scale
                ) {
                var max;
                var min;
                var value;
                var delta;
                var str;
                var len = 0;
                var max0;
                var min0;
                var one;

                if (!data || data.length === 0) {
                    return;
                }

                function _compare(item) {
                    (item &gt; max || max === undefined) &amp;&amp; (max = item);
                    (item &lt; min || min === undefined) &amp;&amp; (min = item);
                }

                if (data.length == 1) {
                    min = 0;
                }
                if (data.length != 1) {
                    for (var i = 0; i &lt; data.length; i ++) {
                        value = typeof data[i].value[index].value != &#x27;undefined&#x27;
                            ? data[i].value[index].value : data[i].value[index];
                        _compare(value);
                    }
                }
                else {
                    one = data[0];
                    for (var i = 0; i &lt; one.value.length; i ++) {
                        _compare(
                                typeof one.value[i].value != &#x27;undefined&#x27;
                                ? one.value[i].value : one.value[i]
                        );
                    }
                }

                if (data.length != 1) {
                    if (scale) {
                        delta = this._getDelta(
                            max, min, splitNumber, precision, power
                        );

                        if (delta &gt;= 1) {
                            min = Math.floor(min / delta) * delta - delta;
                        }
                        else if (delta === 0) {
                            if (max &gt; 0) {
                                min0 = 0;
                                max0 = 2 * max;
                            }
                            else if (max === 0) {
                                min0 = 0;
                                max0 = 100;
                            }
                            else {
                                max0 = 0;
                                min0 = 2 * min;
                            }

                            return {
                                max : max0,
                                min : min0
                            };
                        }
                        else {
                            str = (delta + &#x27;&#x27;).split(&#x27;.&#x27;)[1];
                            len = str.length;
                            min = Math.floor(
                                    min * Math.pow(10, len)) / Math.pow(10, len
                            ) - delta;
                        }

                        if (Math.abs(min) &lt;= delta) {
                            min = 0;
                        }

                        max = min + Math.floor(delta * Math.pow(10, len)
                            * (splitNumber + 1)) / Math.pow(10, len) ;
                    }
                    else {
                        min = min &gt; 0 ? 0 : min;
                    }
                }

                if (boundaryGap) {
                    max = max &gt; 0 ? max * 1.2 : max * 0.8;
                    min = min &gt; 0 ? min * 0.8 : min * 1.2;
                }

                return {
                    max : max,
                    min : min
                };
            },

            /**
             * 获取最大值与最小值中间比较合适的差值
             * @param {number} max;
             * @param {number} min
             * @param {number} precision 小数精度
             * @param {number} power 整数精度
             * @return {number} delta
             */
            _getDelta : function (max , min, splitNumber, precision, power) {
                var delta = (max - min) / splitNumber;
                var str;
                var n;

                if (delta &gt; 1) {
                    if (!power) {
                        str = (delta + &#x27;&#x27;).split(&#x27;.&#x27;)[0];
                        n = str.length;
                        if (str.charAt(0) &gt;= 5) {
                            return Math.pow(10, n);
                        }
                        else {
                            return (str.charAt(0) - 0 + 1 ) * Math.pow(10, n - 1);
                        }
                    }
                    else {
                        delta = Math.ceil(delta);
                        if (delta % power &gt; 0) {
                            return (Math.ceil(delta / power) + 1) * power;
                        }
                        else {
                            return delta;
                        }
                    }
                }
                else if (delta == 1) {
                    return 1;
                }
                else if (delta === 0) {
                    return 0;
                }
                else {
                    if (!precision) {
                        str = (delta + &#x27;&#x27;).split(&#x27;.&#x27;)[1];
                        n = 0;
                        while (str[n] == &#x27;0&#x27;) {
                            n ++ ;
                        }

                        if (str[n] &gt;= 5) {
                            return &#x27;0.&#x27; + str.substring(0, n + 1) - 0
                                + 1 / Math.pow(10, n);
                        }
                        else {
                            return &#x27;0.&#x27; + str.substring(0, n + 1) - 0
                                + 1 / Math.pow(10, n + 1);
                        }
                    }
                    else {
                        return Math.ceil(delta * Math.pow(10, precision))
                            / Math.pow(10, precision);
                    }
                }
            },

            /**
             * 获取每个指标上某个value对应的坐标
             * @param {number} polarIndex
             * @param {number} indicatorIndex
             * @param {number} value
             * @return {Array&lt;number&gt;} 对应坐标
             */
            getVector : function (polarIndex, indicatorIndex, value) {
                polarIndex = polarIndex || 0;
                indicatorIndex = indicatorIndex || 0;
                var __ecIndicator = this.polar[polarIndex].__ecIndicator;

                if (indicatorIndex &gt;= __ecIndicator.length) {
                    return ;
                }

                var indicator = this.polar[polarIndex].__ecIndicator[indicatorIndex];
                var center = this.getCenter(polarIndex);
                var vector = indicator.vector;
                var max = indicator.value.max;
                var min = indicator.value.min;
                var alpha;

                if (typeof value == &#x27;undefined&#x27;) {
                    return center;
                }

                switch (value) {
                    case &#x27;min&#x27; :
                        value = min;
                        break;
                    case &#x27;max&#x27; :
                        value = max;
                        break;
                    case &#x27;center&#x27; :
                        value = (max + min) / 2;
                        break;
                }

                if (max != min) {
                    alpha = (value - min) / (max - min);
                }
                else {
                    alpha = 0.5;
                }

                return this._mapVector(vector, center, alpha);
            },

            /**
             * 判断一个点是否在网内
             * @param {Array&lt;number&gt;} 坐标
             * @return {number} 返回polarindex  返回-1表示不在任何polar
             */
            isInside : function (vector) {
                var polar = this.getNearestIndex(vector);

                if (polar) {
                    return polar.polarIndex;
                }
                return -1;
            },

            /**
             * 如果一个点在网内，返回离它最近的数据轴的index
             * @param {Array&lt;number&gt;} 坐标
             * @return {Object} | false
             *      polarIndex
             *      valueIndex
             */
            getNearestIndex : function (vector) {
                var item;
                var center;
                var radius;
                var polarVector;
                var startAngle;
                var indicator;
                var len;
                var angle;
                var finalAngle;
                var zrSize = Math.min(this.zr.getWidth(), this.zr.getHeight()) / 2;
                for (var i = 0 ; i &lt; this.polar.length; i ++) {
                    item = this.polar[i];
                    center = this.getCenter(i);
                    if (vector[0] == center[0] &amp;&amp; vector[1] == center[1]) {
                        return {
                            polarIndex : i,
                            valueIndex : 0
                        };
                    }
                    radius = this.parsePercent(item.radius, zrSize);
                    startAngle = item.startAngle;
                    indicator = item.indicator;
                    len = indicator.length;
                    angle = 2 * Math.PI / len;
                    // 注意y轴的翻转
                    polarVector = ecCoordinates.cartesian2polar(
                            vector[0] - center[0], center[1] - vector[1]
                    );
                    if (vector[0] - center[0] &lt; 0) {
                        polarVector[1] += Math.PI;
                    }
                    if (polarVector[1] &lt; 0) {
                        polarVector[1] += 2 * Math.PI;
                    }


                    // 减去startAngle的偏移量 再加2PI变成正数
                    finalAngle = polarVector[1] -
                        startAngle / 180 * Math.PI + Math.PI * 2;

                    if (Math.abs(Math.cos(finalAngle % (angle / 2))) * radius
                        &gt; polarVector[0])
                    {
                        return {
                            polarIndex : i,
                            valueIndex : Math.floor(
                                    (finalAngle + angle / 2 ) / angle
                            ) % len
                        };
                    }
                }
            },

            /**
             * 获取指标信息
             * @param {number} polarIndex
             * @return {Array&lt;Object&gt;} indicator
             */
            getIndicator : function (index) {
                var index = index || 0;
                return this.polar[index].indicator;
            },

            /**
             * 刷新
             */
            refresh : function (newOption) {
                if (newOption) {
                    this.option = newOption;
                    this.polar = this.option.polar;
                    this.series = this.option.series;
                }
                this.clear();
                this._buildShape();
            }
        };

        zrUtil.inherits(Polar, Base);

        require(&#x27;../component&#x27;).define(&#x27;polar&#x27;, Polar);

        return Polar;
    });

    define(&#x27;echarts/util/kwargs&#x27;,[],function (){
        function kwargs(func, defaults) {
            /*jshint maxlen : 200*/
            var removeComments = new RegExp(&#x27;(\\/\\*[\\w\\\&#x27;\\,\\(\\)\\s\\r\\n\\*]*\\*\\/)|(\\/\\/[\\w\\s\\\&#x27;][^\\n\\r]*$)|(&lt;![\\-\\-\\s\\w\\&gt;\\/]*&gt;)&#x27;, &#x27;gim&#x27;);
            var removeWhitespc = new RegExp(&#x27;\\s+&#x27;, &#x27;gim&#x27;);
            var matchSignature = new RegExp(&#x27;function.*?\\((.*?)\\)&#x27;, &#x27;i&#x27;);
            // get the argument names from function source
            var names = func.toString()
                .replace(removeComments, &#x27;&#x27;)
                .replace(removeWhitespc, &#x27;&#x27;)
                .match(matchSignature)[1]
                .split(&#x27;,&#x27;);

            // Check the existance of default, if not create an object
            if(defaults !== Object(defaults)){
                defaults = {};
            }

            return function () {
                var args = Array.prototype.slice.call(arguments);
                var kwargs = args[args.length - 1];

                // Check the existance of the kwargs
                if (kwargs &amp;&amp; kwargs.constructor === Object) {
                    args.pop();
                }
                else{
                    kwargs = {};
                }

                // Fill the arguments and apply them
                for (var i = 0; i &lt; names.length; i++) {
                    var name = names[i];
                    if (name in kwargs) {
                        args[i] = kwargs[name];
                    }
                    else if(name in defaults &amp;&amp; args[i] == null){
                        args[i] = defaults[name];
                    }
                }

                return func.apply(this, args);
            };
        }
        // As function prototype
        // Function.prototype.kwargs = kwargs;
        return kwargs;
    });
    /**
     * Numpy like n-dimensional array proccessing class
     * http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html
     *
     * @author pissang (https://github.com/pissang/)
     */
    define(&#x27;echarts/util/ndarray&#x27;,[&#x27;require&#x27;,&#x27;./kwargs&#x27;],function (require) {



        var kwargs = require(&#x27;./kwargs&#x27;);

        var ArraySlice = Array.prototype.slice;

// Polyfill of Typed Array
        this.Int32Array = window.Int32Array || Array;
        this.Int16Array = window.Int16Array || Array;
        this.Int8Array = window.Int8Array || Array;
        this.Uint32Array = window.Uint32Array || Array;
        this.Uint16Array = window.Uint16Array || Array;
        this.Uint8Array = window.Uint8Array || Array;
        this.Float32Array = window.Float32Array || Array;
        this.Float64Array = window.Float64Array || Array;

// Map of numpy dtype and typed array
// http://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html#arrays-dtypes
// http://www.khronos.org/registry/typedarray/specs/latest/
        var ArrayConstructor = {
            &#x27;int32&#x27; : this.Int32Array,
            &#x27;int16&#x27; : this.Int16Array,
            &#x27;int8&#x27; : this.Int8Array,
            &#x27;uint32&#x27; : this.Uint32Array,
            &#x27;uint16&#x27; : this.Uint16Array,
            &#x27;uint8&#x27; : this.Uint8Array,
            // &#x27;uint8c&#x27; is not existed in numpy
            &#x27;uint8c&#x27; : this.Uint8ClampedArray,
            &#x27;float32&#x27; : this.Float32Array,
            &#x27;float64&#x27; : this.Float64Array,
            &#x27;number&#x27; : Array
        };

        var dTypeStrideMap = {
            &#x27;int32&#x27; : 4,
            &#x27;int16&#x27; : 2,
            &#x27;int8&#x27; : 1,
            &#x27;uint32&#x27; : 4,
            &#x27;uint16&#x27; : 2,
            &#x27;uint8&#x27; : 1,
            &#x27;uint8c&#x27; : 1,
            &#x27;float32&#x27; : 4,
            &#x27;float64&#x27; : 8,
            // Consider array stride is 1
            &#x27;number&#x27; : 1
        };

        var E_ADD = 0;
        var E_SUB = 1;
        var E_MUL = 2;
        var E_DIV = 3;
        var E_MOD = 4;
        var E_AND = 5;
        var E_OR = 6;
        var E_XOR = 7;
        var E_EQL = 8;

        function guessDataType(arr) {
            if (typeof(arr) === &#x27;undefined&#x27;) {
                return &#x27;number&#x27;;
            }
            switch(Object.prototype.toString.call(arr)) {
                case &#x27;[object Int32Array]&#x27;:
                    return &#x27;int32&#x27;;
                case &#x27;[object Int16Array]&#x27;:
                    return &#x27;int16&#x27;;
                case &#x27;[object Int8Array]&#x27;:
                    return &#x27;int8&#x27;;
                case &#x27;[object Uint32Array]&#x27;:
                    return &#x27;uint32&#x27;;
                case &#x27;[object Uint16Array]&#x27;:
                    return &#x27;uint16&#x27;;
                case &#x27;[object Uint8Array]&#x27;:
                    return &#x27;uint8&#x27;;
                case &#x27;[object Uint8ClampedArray]&#x27;:
                    return &#x27;uint8c&#x27;;
                case &#x27;[object Float32Array]&#x27;:
                    return &#x27;float32&#x27;;
                case &#x27;[object Float64Array]&#x27;:
                    return &#x27;float64&#x27;;
                default:
                    return &#x27;number&#x27;;
            }
        }

        /**
         * NDArray
         * @param {Array|NDArray}  array
         * @param {String} dtype
         */
        var NDArray = function (array) {
            // Last argument describe the data type of ndarray
            var dtype = arguments[arguments.length-1];
            if (typeof(dtype) == &#x27;string&#x27;) {
                this._dtype = dtype;
            } else {
                // Normal array
                this._dtype = guessDataType(array);
            }

            if (array &amp;&amp; typeof(array) !== &#x27;string&#x27;) {
                if (array instanceof NDArray) {
                    array._dtype = this._dtype;
                    return array;
                } else if (typeof(array.length) !== &#x27;undefined&#x27;) {
                    // Init from array
                    this.initFromArray(array);
                } else if(typeof(array) === &#x27;number&#x27;) {
                    // Init from shape
                    this.initFromShape.apply(this, arguments);
                }
            } else {
                /**
                 * _array
                 * Initialized with an empty array
                 * Data is continuous one-dimensional array, row-major
                 * A [2, 2] dim empty array is stored like
                 * [0,0,  0,0]
                 * TODO : Consider column majors ?
                 * @type {ArrayConstructor}
                 */
                this._array = new ArrayConstructor[this._dtype]();
                /**
                 * _shape
                 * a tuple array describe the dimension and size of each dimension
                 * [10, 10] means a 10x10 array
                 * @type {Array}
                 */
                this._shape = [0];
                /**
                 * _size
                 * size of the storage array length
                 * @type {Number}
                 */
                this._size = 0;
            }
        };

        NDArray.prototype = {
            /**
             * Initialize from a normal js array.
             *
             * @param  {Array} input
             * @return {NDArray} this
             */
            initFromArray : function (input) {
                var dim = getDimension(input);
                var cursor = 0;
                function flatten(axis, _out, _in) {
                    var len = _in.length;
                    for (var i = 0; i &lt; len; i++) {
                        if (axis &lt; dim-1) {
                            flatten(axis+1, _out, _in[i]);
                        } else {
                            _out[cursor++] = _in[i];
                        }
                    }
                }
                var shape = getShape(input);
                var size = getSize(shape);
                this._array = new ArrayConstructor[this._dtype](size);

                flatten(0, this._array, input);
                this._shape = shape;
                this._size = size;

                return this;
            },

            /**
             * Initialize from the given shape description.
             * @param  {Array} shape
             * @return {NDArray} this
             */
            initFromShape : function (shape) {
                if (typeof(shape) == &#x27;number&#x27;) {
                    shape = Array.prototype.slice.call(arguments);
                }
                if(shape) {
                    var size = getSize(shape);
                    if (this._dtype === &#x27;number&#x27;) {
                        this._array = [];
                        var data = this._array;
                        for (var i = 0; i &lt; size; i++) {
                            data[i] = 0;
                        }
                    } else {
                        this._array = new ArrayConstructor[this._dtype](size);
                    }
                }
                this._shape = shape;
                this._size = getSize(shape);

                return this;
            },
            /**
             * Fill the array with the given value.
             * @param  {Number} value
             * @return {NDArray} this
             */
            fill : function (value) {
                var data = this._array;
                for (var i = 0; i &lt; data.length; i++) {
                    data[i] = value;
                }
                return this;
            },

            /**
             * Get ndarray shape copy.
             * @return {Array}
             */
            shape : function () {
                // Create a copy
                return this._shape.slice();
            },

            /**
             * Get array size
             * @return {Number}
             */
            size : function () {
                return this._size;
            },

            /**
             * Get array data type.
             * &#x27;int32&#x27;
             * &#x27;int16&#x27;
             * &#x27;int8&#x27;
             * &#x27;uint32&#x27;
             * &#x27;uint16&#x27;
             * &#x27;uint8&#x27;
             * &#x27;float32&#x27;
             * &#x27;float64&#x27;
             * @return {String}
             */
            dtype : function () {
                return this._dtype;
            },

            /**
             * Get array dimension.
             * @return {[type]} [description]
             */
            dimension : function () {
                return this._shape.length;
            },

            /**
             * Tuple of bytes to step in each dimension when traversing an array.
             * @return {Array}
             */
            strides : function () {
                var strides = calculateDimStrides(this._shape);
                var dTypeStride = dTypeStrideMap[this._dtype];
                for (var i = 0; i &lt; strides.length; i++) {
                    strides[i] *= dTypeStride;
                }
                return strides;
            },
            /**
             * Gives a new shape to an array without changing its data.
             * @param  {Array} shape
             * @return {NDArray}
             */
            reshape : function (shape) {
                if (typeof(shape) == &#x27;number&#x27;) {
                    shape = Array.prototype.slice.call(arguments);
                }
                if (this._isShapeValid(shape)) {
                    this._shape = shape;
                } else {
                    throw new Error(&#x27;Total size of new array must be unchanged&#x27;);
                }
                return this;
            },

            _isShapeValid : function (shape) {
                return getSize(shape) === this._size;
            },

            /**
             * Change shape and size of array in-place.
             * @param  {Array} shape
             * @return {NDArray}
             */
            resize : function (shape) {
                if (typeof(shape) == &#x27;number&#x27;) {
                    shape = Array.prototype.slice.call(arguments);
                }

                var len = getSize(shape);
                if (len &lt; this._size) {
                    if (this._dtype === &#x27;number&#x27;) {
                        this._array.length = len;
                    }
                } else {
                    if (this._dtype === &#x27;number&#x27;) {
                        for (var i = this._array.length; i &lt; len; i++) {
                            // Fill the rest with zero
                            this._array[i] = 0;
                        }
                    } else {
                        // Reallocate new buffer
                        var newArr = new ArrayConstructor[this._dtype](len);
                        var originArr = this._array;

                        // Copy data
                        for (var i = 0; i &lt; originArr.length; i++) {
                            newArr[i] = originArr[i];
                        }
                        this._array = newArr;
                    }
                }
                this._shape = shape;
                this._size = len;

                return this;

            },

            /**
             * Returns a new array with axes transposed.
             * @param  {Array} [axes]
             * @param  {NDArray} [out]
             * @return {NDArray}
             */
            transpose : kwargs(function (axes, out) {
                var originAxes = [];
                for (var i = 0; i &lt; this._shape.length; i++) {
                    originAxes.push(i);
                }
                if (typeof(axes) === &#x27;undefined&#x27;) {
                    axes = originAxes.slice();
                }
                // Check if any axis is out of bounds
                for (var i = 0; i &lt; axes.length; i++) {
                    if (axes[i] &gt;= this._shape.length) {
                        throw new Error(axisOutofBoundsErrorMsg(axes[i]));
                    }
                }
                // Has no effect on 1-D transpose
                if (axes.length &lt;= 1) {
                    return this;
                }

                var targetAxes = originAxes.slice();
                for (var i = 0; i &lt; Math.floor(axes.length / 2); i++) {
                    for (var j = axes.length-1; j &gt;= Math.ceil(axes.length / 2) ; j--) {
                        // Swap axes
                        targetAxes[axes[i]] = axes[j];
                        targetAxes[axes[j]] = axes[i];
                    }
                }

                return this._transposelike(targetAxes, out);

            }),

            /**
             * Return a new array with axis1 and axis2 interchanged.
             * @param  {Number} axis1
             * @param  {Number} axis2
             * @param  {NDArray} out
             * @return {NDArray}
             */
            swapaxes : kwargs(function (axis1, axis2, out) {
                return this.transpose([axis1, axis2], out);
            }),

            /**
             * Roll the specified axis backwards, until it lies in a given position.
             * @param  {Number} axis
             * @param  {Number} [start=0]
             * @param  {NDArray} out
             * @return {NDArray}
             */
            rollaxis : kwargs(function (axis, start, out) {
                if (axis &gt;= this._shape.length) {
                    throw new Error(axisOutofBoundsErrorMsg(axis));
                }

                var axes = [];
                for (var i = 0; i &lt; this._shape.length; i++) {
                    axes.push(i);
                }
                axes.splice(axis, 1);
                axes.splice(start, 0, axis);

                return this._transposelike(axes, out);

            }, { start : 0}),

            // Base function for transpose-like operations
            _transposelike : function (axes, out) {
                var source = this._array;
                var shape = this._shape.slice();
                var strides = calculateDimStrides(this._shape);
                var dim = shape.length;

                // Swap
                var tmpStrides = [];
                var tmpShape = [];
                for (var i = 0; i &lt; axes.length; i++) {
                    var axis = axes[i];
                    // swap to target axis
                    tmpShape[i] = shape[axis];
                    tmpStrides[i] = strides[axis];
                }
                strides = tmpStrides;
                shape = tmpShape;

                this._shape = shape;
                var transposedStrides = calculateDimStrides(this._shape);

                if (!out) {
                    out = new NDArray();
                    out._shape = this._shape.slice();
                    out._dtype = this._dtype;
                    out._size = this._size;
                }
                // FIXME in-place transpose?
                var transposedData = new ArrayConstructor[this._dtype](this._size);
                out._array = transposedData;
                // @param Item offset in current axis offset of the original array
                // @param Item offset in current axis offset of the transposed array
                function transpose(axis, offset, transposedOffset) {
                    var size = shape[axis];
                    // strides in orginal array
                    var stride = strides[axis];
                    // strides in transposed array 
                    var transposedStride = transposedStrides[axis];

                    if (axis &lt; dim-1) {
                        for (var i = 0; i &lt; size; i++) {
                            transpose(
                                    axis+1,
                                    offset + stride * i,
                                    transposedOffset + transposedStride * i
                            );
                        }
                    } else {
                        for (var i = 0; i &lt; size; i++) {
                            // offset + stride * i is the index of the original array
                            // transposedOffset + i is the index of the transposed array
                            transposedData[transposedOffset + i]
                                = source[offset + stride * i];
                        }
                    }
                }

                transpose(0, 0, 0);

                return out;
            },

            /**
             * Repeat elements of an array along axis
             * @param {Number} repeats
             *        The number of repetitions for each element.
             *        repeats is broadcasted to fit the shape of the given axis.
             * @param {Number} [axis]
             *        The axis along which to repeat values.
             *        By default, use the flattened input array,
             *        and return a flat output array.
             * @param {NDArray} [out]
             * @return {NDArray}
             */
            repeat : kwargs(function (repeats, axis, out) {
                var shape;
                // flattened input array
                if (typeof(axis) === &#x27;undefined&#x27;) {
                    shape = [this._size];
                    axis = 0;
                } else {
                    shape = this._shape.slice();
                }
                var originShape = shape.slice();

                shape[axis] *= repeats;
                if (!out) {
                    out = new NDArray(this._dtype);
                    out.initFromShape(shape);
                } else {
                    if (!arrayEqual(shape, out._shape)) {
                        throw new Error(broadcastErrorMsg(shape, out._shape));
                    }
                }
                var data = out._array;

                var stride = calculateDimStride(originShape, axis);
                var axisSize = originShape[axis];
                var source = this._array;

                var offsetStride = stride * axisSize;

                for (var offset = 0; offset &lt; this._size; offset+=offsetStride) {
                    for (var k = 0; k &lt; stride; k++) {
                        var idx = offset + k;
                        var idxRepeated = offset * repeats + k;
                        for (var i = 0; i &lt; axisSize; i++) {
                            for (var j = 0; j &lt; repeats; j++) {
                                data[idxRepeated] = source[idx];
                                idxRepeated += stride;
                            }
                            idx += stride;
                        }
                    }
                }

                return out;
            }),

            choose : function () {
                console.warn(&#x27;TODO&#x27;);
            },

            take : function () {
                console.warn(&#x27;TODO&#x27;);
            },

            tile : function () {
                console.warn(&#x27;TODO&#x27;);
            },

            /**
             * Preprocess for array calculation
             * max, min, argmax, argmin, sum, ptp, val, mean
             * Which will reduce one axis if the axis is given
             *
             * @param  {Number} axis
             * @param  {NDArray} out
             * @param  {Function} funcWithAxis
             * @param  {Function} funcFlatten
             * @return {Number|NDArray}
             */
            _withPreprocess1 : function (axis, out, funcWithAxis, funcFlatten) {
                var source = this._array;
                if (!this._size) {
                    return;
                }

                if (typeof(axis)!==&#x27;undefined&#x27;) {
                    if (axis &lt; 0) {
                        axis = this._shape.length + axis;
                    }
                    if (axis &gt;= this._shape.length || axis &lt; 0) {
                        throw new Error(axisOutofBoundsErrorMsg(axis));
                    }

                    var shape = this._shape.slice();
                    shape.splice(axis, 1);
                    if (out &amp;&amp; !arrayEqual(shape, out._shape)) {
                        throw new Error(broadcastErrorMsg(shape, out._shape));
                    }

                    if (!out) {
                        out = new NDArray(this._dtype);
                        out.initFromShape(shape);
                    }
                    var data = out._array;

                    var stride = calculateDimStride(this._shape, axis);
                    var axisSize = this._shape[axis];
                    var offsetStride = stride * axisSize;

                    funcWithAxis.call(
                        this, data, source, offsetStride, axisSize, stride
                    );

                    return out;
                } else {
                    return funcFlatten.call(this, source);
                }
            },

            /**
             * Preprocess for array calculation cumsum, cumprod
             * Which will keep the shape if axis is given
             * and flatten if axis is undefined
             * @param  {Number} axis
             * @param  {NDArray} out
             * @param  {Function} funcWithAxis
             * @param  {Function} funcFlatten
             * @return {NDArray}
             */
            _withPreprocess2 : function (axis, out, funcWithAxis, funcFlatten) {
                var source = this._array;
                if (!this._size) {
                    return;
                }
                if (out &amp;&amp; !arrayEqual(this._shape, out._shape)) {
                    throw new Error(broadcastErrorMsg(this._shape, out._shape));
                }
                if (!out) {
                    out = new NDArray(this._dtype);
                    out.initFromShape(this._shape);
                }

                var data = out._array;

                if (typeof(axis)!==&#x27;undefined&#x27;) {
                    if (axis &lt; 0) {
                        axis = this._shape.length + axis;
                    }
                    if (axis &gt;= this._shape.length || axis &lt; 0) {
                        throw new Error(axisOutofBoundsErrorMsg(axis));
                    }

                    if (axis &gt;= this._shape.length) {
                        throw new Error(axisOutofBoundsErrorMsg(axis));
                    }

                    var stride = calculateDimStride(this._shape, axis);
                    var axisSize = this._shape[axis];
                    var offsetStride = stride * axisSize;

                    funcWithAxis.call(
                        this, data, source, offsetStride, axisSize, stride
                    );
                } else {
                    out.reshape([this._size]);
                    funcFlatten.call(this, data, source);
                }

                return out;
            },

            /**
             * Get the max value of ndarray
             * If the axis is given, the max is only calculate in this dimension
             * Example, for the given ndarray
             *     [[3, 9],
             *      [4, 8]]
             * &gt;&gt;&gt; max(0)
             *     [4, 9]
             * &gt;&gt;&gt; max(1)
             *     [9, 8]
             *
             * @param  {Number} [axis]
             * @param  {NDArray} out
             * @return {NDArray}
             */
            max : kwargs((function () {
                function withAxis(data, source, offsetStride, axisSize, stride) {
                    var cursor = 0;
                    for (var offset = 0; offset &lt; this._size; offset+=offsetStride) {
                        for (var i = 0; i &lt; stride; i++) {
                            var idx =  i + offset;
                            var max = source[idx];
                            for (var j = 0; j &lt; axisSize; j++) {
                                var d = source[idx];
                                if (d &gt; max) {
                                    max = d;
                                }
                                idx += stride;
                            }
                            data[cursor++] = max;
                        }
                    }
                }
                function withFlatten(source) {
                    var max = source[0];
                    for (var i = 1; i &lt; this._size; i++) {
                        if (source[i] &gt; max) {
                            max = source[i];
                        }
                    }
                    return max;
                }
                return function (axis, out) {
                    return this._withPreprocess1(
                        axis, out,
                        withAxis, withFlatten
                    );
                };
            })()),


            /**
             * Return the minimum of an array or minimum along an axis.
             * @param  {Number} [axis]
             * @param  {NDArray} out
             * @return {NDArray}
             */
            min : kwargs((function () {
                function withAxis(data, source, offsetStride, axisSize, stride) {
                    var cursor = 0;
                    for (var offset = 0; offset &lt; this._size; offset+=offsetStride) {
                        for (var i = 0; i &lt; stride; i++) {
                            var idx =  i + offset;
                            var min = source[idx];
                            for (var j = 0; j &lt; axisSize; j++) {
                                var d = source[idx];
                                if (d &lt; min) {
                                    min = d;
                                }
                                idx += stride;
                            }
                            data[cursor++] = min;
                        }
                    }
                }
                function withFlatten(source) {
                    var min = source[0];
                    for (var i = 1; i &lt; this._size; i++) {
                        if (source[i] &lt; min) {
                            min = source[i];
                        }
                    }
                    return min;
                }
                return function (axis, out) {
                    return this._withPreprocess1(
                        axis, out,
                        withAxis, withFlatten
                    );
                };
            })()),

            /**
             * Return indices of the maximum values along an axis.
             * @param  {Number} [axis]
             * @param  {NDArray} out
             * @return {NDArray}
             */
            argmax : kwargs((function () {
                function withAxis(data, source, offsetStride, axisSize, stride) {
                    var cursor = 0;
                    for (var offset = 0; offset &lt; this._size; offset+=offsetStride) {
                        for (var i = 0; i &lt; stride; i++) {
                            var dataIdx = 0;
                            var idx =  i + offset;
                            var max = source[idx];
                            for (var j = 0; j &lt; axisSize; j++) {
                                var d = source[idx];
                                if (d &gt; max) {
                                    max = d;
                                    dataIdx = j;
                                }
                                idx += stride;
                            }
                            data[cursor++] = dataIdx;
                        }
                    }
                }
                function withFlatten(source) {
                    var max = source[0];
                    var idx = 0;
                    for (var i = 1; i &lt; this._size; i++) {
                        if (source[i] &gt; max) {
                            idx = i;
                            max = source[i];
                        }
                    }
                    return idx;
                }
                return function (axis, out) {
                    return this._withPreprocess1(
                        axis, out,
                        withAxis, withFlatten
                    );
                };
            })()),

            /**
             * Indices of the minimum values along an axis.
             * @param  {Number} [axis]
             * @param  {NDArray} out
             * @return {NDArray}
             */
            argmin : kwargs((function () {
                function withAxis(data, source, offsetStride, axisSize, stride) {
                    var cursor = 0;
                    for (var offset = 0; offset &lt; this._size; offset+=offsetStride) {
                        for (var i = 0; i &lt; stride; i++) {
                            var dataIdx = 0;
                            var idx =  i + offset;
                            var min = source[idx];
                            for (var j = 0; j &lt; axisSize; j++) {
                                var d = source[idx];
                                if (d &lt; min) {
                                    min = d;
                                    dataIdx = j;
                                }
                                idx += stride;
                            }
                            data[cursor++] = dataIdx;
                        }
                    }
                }
                function withFlatten(source) {
                    var min = source[0];
                    var idx = 0;
                    for (var i = 1; i &lt; this._size; i++) {
                        if (source[i] &lt; min) {
                            idx = i;
                            min = source[i];
                        }
                    }
                    return idx;
                }
                return function (axis, out) {
                    return this._withPreprocess1(
                        axis, out,
                        withAxis, withFlatten
                    );
                };
            })()),

            /**
             * Return the sum of the array elements over the given axis.
             * @param  {Number} [axis]
             * @param  {NDArray} out
             * @return {NDArray}
             */
            sum : kwargs((function () {
                function withAxis(data, source, offsetStride, axisSize, stride) {
                    var cursor = 0;
                    for (var offset = 0; offset &lt; this._size; offset+=offsetStride) {
                        for (var i = 0; i &lt; stride; i++) {
                            var sum = 0;
                            var idx =  i + offset;
                            for (var j = 0; j &lt; axisSize; j++) {
                                sum += source[idx];
                                idx += stride;
                            }
                            data[cursor++] = sum;
                        }
                    }
                }
                function withFlatten(source) {
                    var sum = 0;
                    for (var i = 0; i &lt; this._size; i++) {
                        sum += source[i];
                    }
                    return sum;
                }
                return function (axis, out) {
                    return this._withPreprocess1(
                        axis, out,
                        withAxis, withFlatten
                    );
                };
            })()),

            /**
             * Return the product of the array elements over the given axis.
             * @param  {Number} [axis]
             * @param  {NDArray} out
             * @return {NDArray}
             */
            prod : kwargs((function () {
                function withAxis(data, source, offsetStride, axisSize, stride) {
                    var cursor = 0;
                    for (var offset = 0; offset &lt; this._size; offset+=offsetStride) {
                        for (var i = 0; i &lt; stride; i++) {
                            var prod = 1;
                            var idx =  i + offset;
                            for (var j = 0; j &lt; axisSize; j++) {
                                prod *= source[idx];
                                idx += stride;
                            }
                            data[cursor++] = prod;
                        }
                    }
                }
                function withFlatten(source) {
                    var prod = 1;
                    for (var i = 0; i &lt; this._size; i++) {
                        prod *= source[i];
                    }
                    return prod;
                }
                return function (axis, out) {
                    return this._withPreprocess1(
                        axis, out,
                        withAxis, withFlatten
                    );
                };
            })()),

            /**
             * Returns the average of the array elements along given axis.
             * @param  {Number} [axis]
             * @param  {NDArray} out
             * @return {NDArray}
             */
            mean : kwargs((function () {
                function withAxis(data, source, offsetStride, axisSize, stride) {
                    var cursor = 0;
                    for (var offset = 0; offset &lt; this._size; offset+=offsetStride) {
                        for (var i = 0; i &lt; stride; i++) {
                            var sum = 0;
                            var idx =  i + offset;
                            for (var j = 0; j &lt; axisSize; j++) {
                                sum += source[idx];
                                idx += stride;
                            }
                            var mean = sum / axisSize;
                            data[cursor++] = mean;
                        }
                    }
                }
                function withFlatten(source) {
                    var sum = 0;
                    var len = source.length;
                    for (var i = 0; i &lt; len; i++) {
                        sum += source[i];
                    }
                    var mean = sum / len;
                    return mean;
                }
                return function (axis, out) {
                    return this._withPreprocess1(
                        axis, out,
                        withAxis, withFlatten
                    );
                };
            })()),

            /**
             * Return the variance of the array elements over the given axis.
             * @param  {Number} [axis]
             * @param  {NDArray} out
             * @return {NDArray}
             */
            &#x27;var&#x27; : kwargs((function () {
                function withAxis(data, source, offsetStride, axisSize, stride) {
                    var cursor = 0;
                    for (var offset = 0; offset &lt; this._size; offset+=offsetStride) {
                        for (var i = 0; i &lt; stride; i++) {
                            var sum = 0;
                            var idx =  i + offset;
                            for (var j = 0; j &lt; axisSize; j++) {
                                sum += source[idx];
                                idx += stride;
                            }
                            var mean = sum / axisSize;
                            var moments = 0;
                            idx =  i + offset;
                            for (var j = 0; j &lt; axisSize; j++) {
                                var diff = source[idx] - mean;
                                moments += diff * diff;
                                idx += stride;
                            }
                            data[cursor++] = moments / axisSize;
                        }
                    }
                }
                function withFlatten(source) {
                    var sum = 0;
                    var len = source.length;
                    for (var i = 0; i &lt; len; i++) {
                        sum += source[i];
                    }
                    var mean = sum / len;
                    var moments = 0;
                    for (var i = 0; i &lt; len; i++) {
                        var diff = source[i] - mean;
                        moments += diff * diff;
                    }
                    return moments / len;
                }
                return function (axis, out) {
                    return this._withPreprocess1(
                        axis, out,
                        withAxis, withFlatten
                    );
                };
            })()),

            /**
             * Return the standard derivatione of the array elements
             * over the given axis.
             * @param  {Number} [axis]
             * @param  {NDArray} out
             * @return {NDArray}
             */
            std : kwargs((function () {
                function withAxis(data, source, offsetStride, axisSize, stride) {
                    var cursor = 0;
                    for (var offset = 0; offset &lt; this._size; offset+=offsetStride) {
                        for (var i = 0; i &lt; stride; i++) {
                            var sum = 0;
                            var idx =  i + offset;
                            for (var j = 0; j &lt; axisSize; j++) {
                                sum += source[idx];
                                idx += stride;
                            }
                            var mean = sum / axisSize;
                            var moments = 0;
                            idx =  i + offset;
                            for (var j = 0; j &lt; axisSize; j++) {
                                var diff = source[idx] - mean;
                                moments += diff * diff;
                                idx += stride;
                            }
                            data[cursor++] = Math.sqrt(moments / axisSize);
                        }
                    }
                }
                function withFlatten(source) {
                    var sum = 0;
                    var len = source.length;
                    for (var i = 0; i &lt; len; i++) {
                        sum += source[i];
                    }
                    var mean = sum / len;
                    var moments = 0;
                    for (var i = 0; i &lt; len; i++) {
                        var diff = source[i] - mean;
                        moments += diff * diff;
                    }
                    return Math.sqrt(moments / len);
                }
                return function (axis, out) {
                    return this._withPreprocess1(
                        axis, out,
                        withAxis, withFlatten
                    );
                };
            })()),

            /**
             * Peak to peak (maximum - minimum) value along a given axis.
             * @param  {Number} [axis]
             * @param  {NDArray} out
             * @return {NDArray}
             */
            ptp : kwargs((function () {
                function withAxis(data, source, offsetStride, axisSize, stride) {
                    var cursor = 0;
                    for (var offset = 0; offset &lt; this._size; offset+=offsetStride) {
                        for (var i = 0; i &lt; stride; i++) {
                            var idx = offset + i;
                            var min = source[idx];
                            var max = source[idx];
                            for (var j = 0; j &lt; axisSize; j++) {
                                var d = source[idx];
                                if (d &lt; min) {
                                    min = d;
                                }
                                if (d &gt; max) {
                                    max = d;
                                }
                                idx += stride;
                            }
                            data[cursor++] = max - min;
                        }
                    }
                }
                function withFlatten(source) {
                    var min = source[0];
                    var max = source[0];
                    for (var i = 1; i &lt; this._size; i++) {
                        if (source[i] &lt; min) {
                            min = source[i];
                        }
                        if (source[i] &gt; max) {
                            max = source[i];
                        }
                    }
                    return max - min;
                }
                return function (axis, out) {
                    return this._withPreprocess1(
                        axis, out,
                        withAxis, withFlatten
                    );
                };
            })()),

            /**
             *
             * @param {Number} [axis=-1]
             * @param {string} [order=&#x27;ascending&#x27;]
             *        &#x27;ascending&#x27; | &#x27;descending&#x27;
             * @return {NDArray}
             */
            // FIXME : V8 is quick sort, firefox and safari is merge sort
            // order : ascending or desc
            sort : kwargs(function (axis, order) {
                if (axis &lt; 0) {
                    axis = this._shape.length + axis;
                }
                var compareFunc;
                if (order === &#x27;ascending&#x27;) {
                    compareFunc = function (a, b) {
                        return a - b;
                    };
                } else if( order === &#x27;descending&#x27;) {
                    compareFunc = function (a, b) {
                        return b - a;
                    };
                }

                var source = this._array;
                var stride = calculateDimStride(this._shape, axis);
                var axisSize = this._shape[axis];

                var offsetStride = stride * axisSize;

                var tmp = new Array(axisSize);

                for (var offset = 0; offset &lt; this._size; offset+=offsetStride) {

                    for (var i = 0; i &lt; stride; i++) {
                        var idx = offset + i;
                        for (var j = 0; j &lt; axisSize; j++) {
                            tmp[j] = source[idx];
                            idx += stride;
                        }
                        tmp.sort(compareFunc);
                        var idx = offset + i;
                        // Copy back
                        for (var j = 0; j &lt; axisSize; j++) {
                            source[idx] = tmp[j];
                            idx += stride;
                        }
                    }
                }

                return this;

            }, {axis : -1, order : &#x27;ascending&#x27;}),

            /**
             *
             * @param {Number} [axis=-1]
             * @param {string} [order=&#x27;ascending&#x27;]
             *        &#x27;ascending&#x27; | &#x27;descending&#x27;
             * @param {NDArray} [out]
             * @return {NDArray}
             */
            argsort : kwargs(function (axis, order, out) {
                if (axis &lt; 0) {
                    axis = this._shape.length + axis;
                }
                if (!this._size) {
                    return;
                }
                if (out &amp;&amp; !arrayEqual(this._shape, out._shape)) {
                    throw new Error(broadcastErrorMsg(this._shape, out._shape));
                }
                if (!out) {
                    out = new NDArray(this._dtype);
                    out.initFromShape(this._shape);
                }
                var data = out._array;

                var compareFunc;
                if (order === &#x27;ascending&#x27;) {
                    compareFunc = function (a, b) {
                        return tmp[a] - tmp[b];
                    };
                } else if( order === &#x27;descending&#x27;) {
                    compareFunc = function (a, b) {
                        return tmp[b] - tmp[a];
                    };
                }

                var source = this._array;
                var stride = calculateDimStride(this._shape, axis);
                var axisSize = this._shape[axis];
                var offsetStride = stride * axisSize;

                var tmp = new Array(axisSize);
                var indexList = new Array(axisSize);

                for (var offset = 0; offset &lt; this._size; offset+=offsetStride) {
                    for (var i = 0; i &lt; stride; i++) {
                        var idx = offset + i;
                        for (var j = 0; j &lt; axisSize; j++) {
                            tmp[j] = source[idx];
                            indexList[j] = j;
                            idx += stride;
                        }
                        indexList.sort(compareFunc);
                        // Copy back
                        var idx = offset + i;
                        for (var j = 0; j &lt; axisSize; j++) {
                            data[idx] = indexList[j];
                            idx += stride;
                        }
                    }
                }

                return out;

            }, {axis : -1, order : &#x27;ascending&#x27;}),

            /**
             * Return the cumulative sum of the elements along the given axis.
             * @param  {Number} [axis]
             * @param  {NDArray} out
             * @return {NDArray}
             */
            cumsum : kwargs((function () {
                function withAxis(data, source, offsetStride, axisSize, stride) {
                    for (var offset = 0; offset &lt; this._size; offset+=offsetStride) {
                        for (var i = 0; i &lt; stride; i++) {
                            var idx = offset + i;
                            var prevIdx = idx;
                            data[idx] = source[idx];
                            for (var j = 1; j &lt; axisSize; j++) {
                                prevIdx = idx;
                                idx += stride;
                                data[idx] = data[prevIdx] + source[idx];
                            }

                        }
                    }
                }
                function withFlatten(data, source) {
                    data[0] = source[0];
                    for (var i = 1; i &lt; data.length; i++) {
                        data[i] = data[i-1] + source[i];
                    }
                }
                return function (axis, out) {
                    return this._withPreprocess2(
                        axis, out,
                        withAxis, withFlatten
                    );
                };
            })()),

            /**
             * Return the cumulative product of the elements along the given axis.
             * @param  {Number} [axis]
             * @param  {NDArray} out
             * @return {NDArray}
             */
            cumprod : kwargs((function () {
                function withAxis(data, source, offsetStride, axisSize, stride) {
                    for (var offset = 0; offset &lt; this._size; offset+=offsetStride) {
                        for (var i = 0; i &lt; stride; i++) {
                            var idx = offset + i;
                            var prevIdx = idx;
                            data[idx] = source[idx];
                            for (var j = 1; j &lt; axisSize; j++) {
                                prevIdx = idx;
                                idx += stride;
                                data[idx] = data[prevIdx] * source[idx];
                            }

                        }
                    }
                }
                function withFlatten(data, source) {
                    data[0] = source[0];
                    for (var i = 1; i &lt; data.length; i++) {
                        data[i] = data[i-1] * source[i];
                    }
                }
                return function (axis, out) {
                    return this._withPreprocess2(
                        axis, out,
                        withAxis, withFlatten
                    );
                };
            })()),

            /**
             * Dot product of two arrays.
             *
             * @param  {NDArray|Number} b
             * @param  {NDArray}        [out]
             * @return {NDArray|Number}
             */
            dot : function () {
                console.warn(&#x27;TODO&#x27;);
            },

            /**
             * Mapped to region [min, max]
             * @param {Number} mappedMin
             * @param {Number} mappedMax
             */
            map : function (mappedMin, mappedMax) {
                var input = this._array;
                var output = this._array;

                var min = input[0];
                var max = input[0];
                var l = this._size;
                for (var i = 1; i &lt; l; i++) {
                    var val = input[i];
                    if (val &lt; min) {
                        min = val;
                    }
                    if (val &gt; max) {
                        max = val;
                    }
                }
                var range = max - min;
                var mappedRange = mappedMax - mappedMin;
                for (var i = 0; i &lt; l; i++) {
                    if (range === 0) {
                        output[i] = mappedMin;
                    } else {
                        var val = input[i];
                        var percent = (val - min) / range;
                        output[i] = mappedRange * percent + mappedMin;
                    }
                }
                return this;
            },

            /**
             * Add
             */
            add : function (rightOperand, out) {
                return this.binaryOperation(
                    this, rightOperand, E_ADD, out
                );
            },

            /**
             * Substract
             */
            sub : function (rightOperand, out) {
                return this.binaryOperation(
                    this, rightOperand, E_SUB, out
                );
            },

            /**
             * Multiply
             */
            mul : function (rightOperand, out) {
                return this.binaryOperation(
                    this, rightOperand, E_MUL, out
                );
            },

            /**
             * Divide
             */
            div : function (rightOperand, out) {
                return this.binaryOperation(
                    this, rightOperand, E_DIV, out
                );
            },
            /**
             * mod
             */
            mod : function (rightOperand, out) {
                return this.binaryOperation(
                    this, rightOperand, E_MOD, out
                );
            },
            /**
             * and
             */
            and : function (rightOperand, out) {
                return this.binaryOperation(
                    this, rightOperand, E_AND, out
                );
            },
            /**
             * or
             */
            or : function (rightOperand, out) {
                return this.binaryOperation(
                    this, rightOperand, E_OR, out
                );
            },
            /**
             * xor
             */
            xor : function (rightOperand, out) {
                return this.binaryOperation(
                    this, rightOperand, E_XOR, out
                );
            },
            /**
             * equal
             */
            equal : function (rightOperand) {
                return this.binaryOperation(
                    this, rightOperand, E_EQL, out
                );
            },

            binaryOperation : function (lo, ro, op, out) {
                // Broadcasting
                // http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html
                var shape = [];
                var isLoScalar = typeof(lo) === &#x27;number&#x27;;
                var isRoScalar = typeof(ro) === &#x27;number&#x27;;
                if (isLoScalar) {
                    shape = ro._shape.slice();
                } else if (isRoScalar) {
                    shape = lo._shape.slice();
                } else {
                    // Starts with the trailing dimensions
                    var cl = lo._shape.length-1;
                    var cr = ro._shape.length-1;
                    var loBroadCasted = lo;
                    var roBroadCasted = ro;
                    while (cl &gt;= 0 &amp;&amp; cr &gt;= 0) {
                        if (lo._shape[cl] == 1) {
                            shape.unshift(ro._shape[cr]);
                            loBroadCasted = lo.repeat(ro._shape[cr], cl);
                        } else if(ro._shape[cr] == 1) {
                            shape.unshift(lo._shape[cl]);
                            roBroadCasted = ro.repeat(lo._shape[cl], cr);
                        } else if(ro._shape[cr] == lo._shape[cl]) {
                            shape.unshift(lo._shape[cl]);
                        } else {
                            throw new Error(broadcastErrorMsg(lo._shape, ro._shape));
                        }
                        cl --;
                        cr --;
                    }
                    for (var i = cl; i &gt;= 0; i--) {
                        shape.unshift(lo._shape[i]);
                    }
                    for (var i = cr; i &gt;= 0; i--) {
                        shape.unshift(ro._shape[i]);
                    }
                    lo = loBroadCasted;
                    ro = roBroadCasted;
                }
                if (!out) {
                    out = new NDArray(this._dtype);
                    out.initFromShape(shape);
                } else {
                    if (! arrayEqual(shape, out._shape)) {
                        throw new Error(broadcastErrorMsg(shape, out._shape));
                    }
                }
                var outData = out._array;

                var diffAxis;
                var isLoLarger;
                var loData;
                var roData;
                if (isLoScalar) {
                    diffAxis = ro._shape.length-1;
                    isLoLarger = false;
                    loData = lo;
                    roData = ro._array;
                } else if(isRoScalar) {
                    diffAxis = lo._shape.length-1;
                    isLoLarger = true;
                    roData = ro;
                    loData = lo._array;
                } else {
                    diffAxis = Math.abs(lo._shape.length - ro._shape.length);
                    isLoLarger = lo._shape.length &gt;= ro._shape.length;
                    loData = lo._array;
                    roData = ro._array;
                }
                var stride = calculateDimStride(shape, diffAxis);
                var axisSize = shape[diffAxis];

                var offsetStride = stride * axisSize;
                var offsetRepeats = out._size / offsetStride;

                var _a, _b, res;
                var idx = 0;
                if (isLoLarger) {
                    if(isRoScalar) {
                        for (var c = 0; c &lt; offsetRepeats; c++) {
                            for (var i = 0; i &lt; offsetStride; i++) {
                                _a = loData[idx]; _b = roData;
                                switch (op) {
                                    case E_ADD: res = _a + _b; break;
                                    case E_SUB: res = _a - _b; break;
                                    case E_MUL: res = _a * _b; break;
                                    case E_DIV: res = _a / _b; break;
                                    case E_MOD: res = _a % _b; break;
                                    case E_AND: res = _a &amp; _b; break;
                                    case E_OR: res = _a | _b; break;
                                    case E_XOR: res = _a ^ _b; break;
                                    case E_EQL: res = _a == _b; break;
                                    default: throw new Error(&#x27;Unkown operation &#x27; + op);
                                }
                                outData[idx] = res;
                                idx ++;
                            }
                        }
                    } else {
                        for (var c = 0; c &lt; offsetRepeats; c++) {
                            for (var i = 0; i &lt; offsetStride; i++) {
                                _a = loData[idx]; _b = roData[i];
                                switch (op) {
                                    case E_ADD: res = _a + _b; break;
                                    case E_SUB: res = _a - _b; break;
                                    case E_MUL: res = _a * _b; break;
                                    case E_DIV: res = _a / _b; break;
                                    case E_MOD: res = _a % _b; break;
                                    case E_AND: res = _a &amp; _b; break;
                                    case E_OR: res = _a | _b; break;
                                    case E_XOR: res = _a ^ _b; break;
                                    case E_EQL: res = _a == _b; break;
                                    default: throw new Error(&#x27;Unkown operation &#x27; + op);
                                }
                                outData[idx] = res;
                                idx ++;
                            }
                        }
                    }
                } else {
                    if (isLoScalar) {
                        for (var c = 0; c &lt; offsetRepeats; c++) {
                            for (var i = 0; i &lt; offsetStride; i++) {
                                _a = loData; _b = roData[idx];
                                switch (op) {
                                    case E_ADD: res = _a + _b; break;
                                    case E_SUB: res = _a - _b; break;
                                    case E_MUL: res = _a * _b; break;
                                    case E_DIV: res = _a / _b; break;
                                    case E_MOD: res = _a % _b; break;
                                    case E_AND: res = _a &amp; _b; break;
                                    case E_OR: res = _a | _b; break;
                                    case E_XOR: res = _a ^ _b; break;
                                    case E_EQL: res = _a == _b; break;
                                    default: throw new Error(&#x27;Unkown operation &#x27; + op);
                                }
                                outData[idx] = res;
                                idx ++;
                            }
                        }
                    } else {
                        for (var c = 0; c &lt; offsetRepeats; c++) {
                            for (var i = 0; i &lt; offsetStride; i++) {
                                _a = loData[idx]; _b = roData[i];
                                switch (op) {
                                    case E_ADD: res = _a + _b; break;
                                    case E_SUB: res = _a - _b; break;
                                    case E_MUL: res = _a * _b; break;
                                    case E_DIV: res = _a / _b; break;
                                    case E_MOD: res = _a % _b; break;
                                    case E_AND: res = _a &amp; _b; break;
                                    case E_OR: res = _a | _b; break;
                                    case E_XOR: res = _a ^ _b; break;
                                    case E_EQL: res = _a == _b; break;
                                    default: throw new Error(&#x27;Unkown operation &#x27; + op);
                                }
                                outData[idx] = res;
                                idx ++;
                            }
                        }
                    }
                }
                return out;
            },

            /**
             * negtive
             */
            neg : function () {
                var data = this._array;
                for (var i = 0; i &lt; this._size; i++) {
                    data[i] = -data[i];
                }
                return this;
            },

            /**
             * @return {NDArray} this
             */
            sin : function () {
                return this._mathAdapter(Math.sin);
            },

            /**
             * @return {NDArray} this
             */
            cos : function () {
                return this._mathAdapter(Math.cos);
            },

            /**
             * @return {NDArray} this
             */
            tan : function () {
                return this._mathAdapter(Math.tan);
            },

            /**
             * @return {NDArray} this
             */
            abs : function () {
                return this._mathAdapter(Math.abs);
            },

            /**
             * @return {NDArray} this
             */
            log : function () {
                return this._mathAdapter(Math.log);
            },

            /**
             * @return {NDArray} this
             */
            sqrt : function () {
                return this._mathAdapter(Math.sqrt);
            },

            /**
             * @return {NDArray} this
             */
            ceil : function () {
                return this._mathAdapter(Math.ceil);
            },

            /**
             * @return {NDArray} this
             */
            floor : function () {
                return this._mathAdapter(Math.floor);
            },

            /**
             * @return {NDArray} this
             */
            pow : function (exp) {
                var data = this._array;
                for (var i = 0; i &lt; this._size; i++) {
                    data[i] = Math.pow(data[i], exp);
                }
                return this;
            },

            _mathAdapter : function (mathFunc) {
                var data = this._array;
                for (var i = 0; i &lt; this._size; i++) {
                    data[i] = mathFunc(data[i]);
                }
                return this;
            },

            /**
             * @param   {Number} decimals
             * @return  {NDArray} this
             */
            round : function (decimals) {
                decimals = Math.floor(decimals || 0);
                var offset = Math.pow(10, decimals);
                var data = this._array;
                if (decimals === 0) {
                    for (var i = 0; i &lt; this._size; i++) {
                        data[i] = Math.round(data[i]);
                    }
                } else {
                    for (var i = 0; i &lt; this._size; i++) {
                        data[i] = Math.round(data[i] * offset) / offset;
                    }
                }
                return this;
            },
            /**
             * @param {Number} min
             * @param {Number} max
             * Clip to [min, max]
             */
            clip : function (min, max) {
                // TODO : Support array_like param
                var data = this._array;
                for (var i = 0; i &lt; this._size; i++) {
                    data[i] = Math.max(Math.min(data[i], max), min);
                }
                return this;
            },

            /**
             * Indexing array, support range indexing
             * @param {string} index
             *        Index syntax can be an integer 1, 2, 3
             *        Or more complex range indexing
             *        &#x27;1:2&#x27;
             *        &#x27;1:2, 1:2&#x27;
             *        &#x27;1:2, :&#x27;
             *        More about the indexing syntax can check the doc of numpy ndarray
             * @param {NDArray} [out]
             * @return {NDArray} New created sub array, or out if given
             */
            get : function (index, out) {
                if (typeof(index) == &#x27;number&#x27;) {
                    index = index.toString();
                }
                var strides = calculateDimStrides(this._shape);
                var res = this._parseRanges(index);
                var ranges = res[0];
                var shape = res[1];

                if (ranges.length &gt; this._shape.length) {
                    throw new Error(&#x27;Too many indices&#x27;);
                }
                // Get data
                var len = ranges.length;
                var data;
                if (shape.length) {
                    out = new NDArray(this._dtype);
                    out.initFromShape(shape);
                    data = out._array;
                } else {
                    data = [];
                }

                var source = this._array;
                var cursor = 0;
                function getPiece(axis, offset) {
                    var range = ranges[axis];
                    var stride = strides[axis];
                    if (axis &lt; len-1) {
                        if (range[2] &gt; 0) {
                            for (var i = range[0]; i &lt; range[1]; i += range[2]) {
                                getPiece(axis+1,  offset + stride * i);
                            }
                        } else {
                            for (var i = range[0]; i &gt; range[1]; i += range[2]) {
                                getPiece(axis+1,  offset + stride * i);
                            }
                        }
                    } else {
                        if (range[2] &gt; 0) {
                            for (var i = range[0]; i &lt; range[1]; i += range[2]) {
                                for (var j = 0; j &lt; stride; j++) {
                                    data[cursor++] = source[i*stride + j + offset];
                                }
                            }
                        } else {
                            for (var i = range[0]; i &gt; range[1]; i += range[2]) {
                                for (var j = 0; j &lt; stride; j++) {
                                    data[cursor++] = source[i*stride + j + offset];
                                }
                            }
                        }
                    }
                }

                getPiece(0, 0);

                if (shape.length) {
                    // Return scalar
                    return out;
                } else {
                    return data[0];
                }

            },

            /**
             *
             * @param {string} index
             *        index syntax can be an integer 1, 2, 3
             *        Or more complex range indexing
             *        &#x27;1:2&#x27;
             *        &#x27;1:2, 1:2&#x27;
             *        &#x27;1:2, :&#x27;
             *        More about the indexing syntax can check the doc of numpy ndarray
             * @param {NDArray} ndarray Ndarray data source
             * @return {NDArray} this
             */
            set : function (index, narray) {
                if (typeof(index) == &#x27;number&#x27;) {
                    index = index.toString();
                }
                var strides = calculateDimStrides(this._shape);
                var res = this._parseRanges(index);
                var ranges = res[0];
                var shape = res[1];

                if (ranges.length &gt; this._shape.length) {
                    throw new Error(&#x27;Too many indices&#x27;);
                }
                var isScalar = typeof(narray) == &#x27;number&#x27;;
                var len = ranges.length;
                var data = this._array;
                if (isScalar) {
                    // Set with a single scalar
                    var source = narray;
                } else {
                    if (!arrayEqual(shape, narray.shape())) {
                        throw new Error(broadcastErrorMsg(shape, narray.shape()));
                    }
                    var source = narray._array;
                }
                var cursor = 0;
                var setPiece = function (axis, offset) {
                    var range = ranges[axis];
                    var stride = strides[axis];
                    if (axis &lt; len-1) {
                        if (range[2] &gt; 0) {
                            for (var i = range[0]; i &lt; range[1]; i += range[2]) {
                                setPiece(axis+1,  offset + stride * i);
                            }
                        } else {
                            for (var i = range[0]; i &gt; range[1]; i += range[2]) {
                                setPiece(axis+1,  offset + stride * i);
                            }
                        }
                    } else {
                        if (range[2] &gt; 0) {
                            for (var i = range[0]; i &lt; range[1]; i += range[2]) {
                                for (var j = 0; j &lt; stride; j++) {
                                    if (isScalar) {
                                        data[i*stride + j + offset] = source;
                                    } else {
                                        data[i*stride + j + offset] = source[cursor++];
                                    }
                                }
                            }
                        } else {
                            for (var i = range[0]; i &gt; range[1]; i += range[2]) {
                                for (var j = 0; j &lt; stride; j++) {
                                    if (isScalar) {
                                        data[i*stride + j + offset] = source;
                                    } else {
                                        data[i*stride + j + offset] = source[cursor++];
                                    }
                                }
                            }
                        }
                    }
                };

                setPiece(0, 0);

                return this;
            },

            /**
             * Insert values along the given axis before the given indices.
             * @param  {Number|Array} obj
             *         Object that defines the index or indices before
             *         which values is inserted.
             * @param  {Number|Array|NDArray} values
             *         Values to insert
             * @param  {Number} [axis]
             * @return {NDArray} this
             */
            insert : kwargs(function (obj, values, axis) {
                var data = this._array;
                var isObjScalar = false;
                if (typeof(obj) === &#x27;number&#x27;) {
                    obj = [obj];
                    isObjScalar = true;
                }
                if (typeof(values) === &#x27;number&#x27;) {
                    values = new NDArray([values]);
                } else if (values instanceof Array) {
                    values = new NDArray(values);
                }

                if (typeof(axis) === &#x27;undefined&#x27;) {
                    this._shape = [this._size];
                    axis = 0;
                }
                // Checking if indices is valid
                var prev = obj[0];
                var axisSize = this._shape[axis];
                for (var i = 0; i &lt; obj.length; i++) {
                    if (obj[i] &lt; 0) {
                        obj[i] = axisSize + obj[i];
                    }
                    if (obj[i] &gt; axisSize) {
                        throw new Error(indexOutofBoundsErrorMsg(obj[i]));
                    }
                    if (obj[i] &lt; prev) {
                        throw new Error(&#x27;Index must be in ascending order&#x27;);
                    }
                    prev = obj[i];
                }
                // Broadcasting
                var targetShape = this._shape.slice();
                if (isObjScalar) {
                    targetShape.splice(axis, 1);
                } else {
                    targetShape[axis] = obj.length;
                }

                var sourceShape = values._shape;
                var cs = sourceShape.length - 1;
                var ct = targetShape.length - 1;

                var valueBroadcasted = values;
                while (cs &gt;= 0 &amp;&amp; ct &gt;= 0) {
                    if (sourceShape[cs] === 1) {
                        valueBroadcasted = values.repeat(targetShape[ct], cs);
                    } else if(sourceShape[cs] !== targetShape[ct]) {
                        throw new Error(broadcastErrorMsg(sourceShape, targetShape));
                    }
                    cs --;
                    ct --;
                }
                values = valueBroadcasted;

                // Calculate indices to insert
                var stride = calculateDimStride(this._shape, axis);
                var axisSize = this._shape[axis];
                var offsetStride = axisSize * stride;
                var offsetRepeats = this._size / offsetStride;

                var objLen = obj.length;
                var indices = new Uint32Array(offsetRepeats * objLen);

                var cursor = 0;
                for (var offset = 0; offset &lt; this._size; offset += offsetStride) {
                    for (var i = 0; i &lt; objLen; i++) {
                        var objIdx = obj[i];
                        indices[cursor++] = offset + objIdx * stride;
                    }
                }

                var resShape = this._shape.slice();
                resShape[axis] += obj.length;
                var resSize = getSize(resShape);
                if (this._array.length &lt; resSize) {
                    var data = new ArrayConstructor[this._dtype](resSize);
                } else {
                    var data = this._array;
                }
                var source = this._array;
                var valuesArr = values._array;

                var idxCursor = indices.length - 1;
                var end = this._size;
                var start = indices[idxCursor];
                var dataCursor = resSize - 1;
                var valueCursor = values._size - 1;
                while (idxCursor &gt;= 0) {
                    // Copy source data;
                    for (var i = end - 1; i &gt;= start; i--) {
                        data[dataCursor--] = source[i];
                    }
                    end = start;
                    start = indices[--idxCursor];
                    // Copy inserted data;
                    for (var i = 0; i &lt; stride; i++) {
                        if (valueCursor &lt; 0) {
                            valueCursor = values._size - 1;
                        }
                        data[dataCursor--] = valuesArr[valueCursor--];
                    }
                }
                // Copy the rest
                for (var i = end - 1; i &gt;= 0; i--) {
                    data[dataCursor--] = source[i];
                }

                this._array = data;
                this._shape = resShape;
                this._size = resSize;

                return this;
            }),

            append : function () {
                console.warn(&#x27;TODO&#x27;);
            },

            /**
             * Delete values along the axis
             * @param  {Array|Number} obj
             * @param  {Number} [axis]
             * @return {NDArray} this
             */
            &#x27;delete&#x27; : kwargs(function (obj, axis) {
                var data = this._array;
                if (typeof(obj) === &#x27;number&#x27;) {
                    obj = [obj];
                }
                var size = this._size;

                if (typeof(axis) === &#x27;undefined&#x27;) {
                    this._shape = [size];
                    axis = 0;
                }

                var stride = calculateDimStride(this._shape, axis);
                var axisSize = this._shape[axis];

                var offsetStride = stride * axisSize;
                var cursor = 0;
                for (var offset = 0; offset &lt; size; offset += offsetStride) {
                    var start = 0;
                    var end = obj[0];
                    var objCursor = 0;
                    while(objCursor &lt; obj.length) {
                        if (end &lt; 0) {
                            end = end + axisSize;
                        }
                        if (end &gt; axisSize) {
                            throw new Error(indexOutofBoundsErrorMsg(end));
                        }
                        if (end &lt; start) {
                            throw new Error(&#x27;Index must be in ascending order&#x27;);
                        }
                        for (var i = start; i &lt; end; i++) {
                            for (var j = 0; j &lt; stride; j++) {
                                data[cursor++] = data[i * stride + j + offset];
                            }
                        }
                        start = end + 1;
                        end = obj[++objCursor];
                    }
                    // Copy the rest
                    for (var i = start; i &lt; axisSize; i++) {
                        for (var j = 0; j &lt; stride; j++) {
                            data[cursor++] = data[i * stride + j + offset];
                        }
                    }
                }
                this._shape[axis] -= obj.length;
                this._size = getSize(this._shape);

                return this;
            }),

            _parseRanges : function (index) {
                var rangesStr = index.split(/\s*,\s*/);

                // Parse range of each axis
                var ranges = [];
                var shape = [];
                var j = 0;
                for (var i = 0; i &lt; rangesStr.length; i++) {
                    if (rangesStr[i] === &#x27;...&#x27;) {
                        var end = this._shape.length - (rangesStr.length - i);
                        while (j &lt;= end) {
                            ranges.push([0, this._shape[j], 1]);
                            shape.push(this._shape[j]);
                            j++;
                        }
                    } else {
                        var range = parseRange(rangesStr[i], this._shape[j]);
                        ranges.push(range);
                        if(rangesStr[i].indexOf(&#x27;:&#x27;) &gt;= 0) {
                            var size = Math.floor((range[1] - range[0]) / range[2]);
                            size = size &lt; 0 ? 0 : size;
                            // Get a range not a item
                            shape.push(size);
                        }
                        j++;
                    }
                }
                // Copy the lower dimension size
                for (; j &lt; this._shape.length; j++) {
                    shape.push(this._shape[j]);
                }

                return [ranges, shape];
            },

            /**
             * Export normal js array
             * @return {Array}
             */
            toArray : function () {
                var data = this._array;
                var cursor = 0;

                var shape = this._shape;
                var dim = shape.length;

                function create(axis, out) {
                    var len = shape[axis];
                    for (var i = 0; i &lt; len; i++) {
                        if (axis &lt; dim-1) {
                            create(axis+1, out[i] = []);
                        } else {
                            out[i] = data[cursor++];
                        }
                    }
                }

                var output = [];
                create(0, output);

                return output;
            },

            /**
             * Create a copy of self
             * @return {NDArray}
             */
            copy : function () {
                var numArr = new NDArray();
                numArr._array = ArraySlice.call(this._array);
                numArr._shape = this._shape.slice();
                numArr._dtype = this._dtype;
                numArr._size = this._size;

                return numArr;
            },

            constructor : NDArray
        };

        /**
         *
         * @param  {Number} [min=0]
         * @param  {Number} max
         * @param  {Number} [step=1]
         * @param  {string} [dtype]
         * @return {NDArray}
         */
        NDArray.range = kwargs(function (min, max, step, dtype) {
            var args = ArraySlice.call(arguments);
            // Last argument describe the data type of ndarray
            var lastArg = args[args.length-1];
            if (typeof(lastArg) == &#x27;string&#x27;) {
                var dtype = lastArg;
                args.pop();
            }
            if (args.length === 1) {
                max = args[0];
                step = 1;
                min = 0;
            } else if(args.length == 2) {
                step = 1;
            }
            dtype = dtype || &#x27;number&#x27;;

            var array = new ArrayConstructor[dtype](Math.ceil((max - min)/step));
            var cursor = 0;
            for (var i = min; i &lt; max; i+=step) {
                array[cursor++] = i;
            }
            var ndarray = new NDArray();
            ndarray._array = array;
            ndarray._shape = [array.length];
            ndarray._dtype = dtype;
            ndarray._size = array.length;

            return ndarray;

        });

        /**
         *
         * @param  {Array}  shape
         * @param  {String} [dtype]
         * @return {NDArray}
         */
        NDArray.zeros = kwargs(function (shape, dtype) {
            var ret = new NDArray(dtype);
            ret.initFromShape(shape);
            return ret;
        });

        /**
         * Python like array indexing
         * http://www.python.org/dev/peps/pep-0204/
         *
         * @param   {string} index
         *          index can be a simple integer 1,2,3,
         *          or a range 2:10, 2:10:1
         *          example :
         *              2:10    =&gt;  [2, 10, 1],
         *              10:2:-2 =&gt;  [10, 2, -2],
         *              :       =&gt;  [0, dimSize, 1],
         *              ::-1    =&gt;  [dimSize-1, -1, -1],
         * @param   {number} dimSize
         * @return  {Array} a tuple array [startOffset, endOffset, sliceStep]
         */
        function parseRange(index, dimSize) {
            if (index.indexOf(&#x27;:&#x27;) &gt;= 0) {
                // Range indexing;
                var res = index.split(/\s*:\s*/);

                var step = parseInt(res[2] || 1, 10);
                var start, end;
                if (step === 0) {
                    throw new Error(&#x27;Slice step cannot be zero&#x27;);
                }
                else if (step &gt; 0) {
                    start = parseInt(res[0] || 0, 10);
                    end = parseInt(res[1] || dimSize, 10);
                }
                else {
                    start = parseInt(res[0] || dimSize - 1, 10);
                    end = parseInt(res[1] || -1, 10);
                }
                // Negtive offset
                if (start &lt; 0) {
                    start = dimSize + start;
                }
                // Negtive offset
                if (end &lt; 0 &amp;&amp; res[1]) {
                    end = dimSize + end;
                }
                if (step &gt; 0) {
                    // Clamp to [0-dimSize]
                    start = Math.max(Math.min(dimSize, start), 0);
                    // Clamp to [0-dimSize]
                    end = Math.max(Math.min(dimSize, end), 0);
                } else {
                    // Clamp to [0-dimSize)
                    start = Math.max(Math.min(dimSize-1, start), -1);
                    // Clamp to [0-dimSize)
                    end = Math.max(Math.min(dimSize-1, end), -1);
                }
                return [start, end, step];
            } else {
                var start = parseInt(index, 10);
                // Negtive offset
                if (start &lt; 0) {
                    start = dimSize + start;
                }
                if (start &lt; 0 || start &gt; dimSize) {
                    throw new Error(indexOutofBoundsErrorMsg(index));
                }
                // Clamp to [0-dimSize)
                start = Math.max(Math.min(dimSize-1, start), 0);
                return [start, start+1, 1];
            }
        }

        function getSize(shape) {
            var size = shape[0];
            for (var i = 1; i &lt; shape.length; i++) {
                size *= shape[i];
            }
            return size;
        }

        function getDimension(array) {
            var dim = 1;
            var el = array[0];
            while (el instanceof Array) {
                el = el[0];
                dim ++;
            }
            return dim;
        }

        function getShape(array) {
            var shape = [array.length];
            var el = array[0];
            while (el instanceof Array) {
                shape.push(el.length);
                el = el[0];
            }
            return shape;
        }

        function calculateDimStride(shape, axis) {
            if (axis == shape.length-1) {
                return 1;
            }
            var stride = shape[axis+1];
            for (var i = axis+2; i &lt; shape.length; i++) {
                stride *= shape[i];
            }
            return stride;
        }

        function calculateDimStrides(shape) {
            // Calculate stride of each axis
            var strides = [];
            var tmp = 1;
            var len = getSize(shape);
            for (var i = 0; i &lt; shape.length; i++) {
                tmp *= shape[i];
                strides.push(len / tmp);
            }

            return strides;
        }

        function arrayEqual(arr1, arr2) {
            if (arr1.length !== arr2.length) {
                return false;
            }
            for (var i = 0; i &lt;arr1.length; i++) {
                if (arr1[i] !==  arr2[i]) {
                    return false;
                }
            }
            return true;
        }

        function broadcastErrorMsg(shape1, shape2) {
            return &#x27;Shape (&#x27;
                + shape1.toString() + &#x27;) (&#x27; + shape2.toString()
                +&#x27;) could not be broadcast together&#x27;;
        }

        function axisOutofBoundsErrorMsg(axis) {
            return &#x27;Axis &#x27; + axis + &#x27; out of bounds&#x27;;
        }

        function indexOutofBoundsErrorMsg(idx) {
            return &#x27;Index &#x27; + idx + &#x27; out of bounds&#x27;;
        }

        return NDArray;

    });

    /**
     * zrender
     *
     * author: loutongbing@baidu.com
     *
     * shape类：椭圆
     * Todo：excanvas bug ~ 连续scale保持?? IE8下不建议使用
     * 可配图形属性：
     {
       // 基础属性
       shape  : &#x27;ellipse&#x27;,       // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过&#x27;zrender/tool/guid&#x27;方法生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           x             : {number},  // 必须，椭圆心横坐标
           y             : {number},  // 必须，椭圆心纵坐标
           a             : {number},  // 必须，椭圆横轴半径
           b             : {number},  // 必须，椭圆纵轴半径
           brushType     : {string},  // 默认为fill，绘画方式
                                      // fill(填充) | stroke(描边) | both(填充+描边)
           color         : {color},   // 默认为&#x27;#000&#x27;，填充颜色，支持rgba
           strokeColor   : {color},   // 默认为&#x27;#000&#x27;，描边颜色（轮廓），支持rgba
           lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

           opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
           shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
           shadowColor   : {color},   // 默认为&#x27;#000&#x27;，阴影色彩，支持rgba
           shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
           shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

           text          : {string},  // 默认为null，附加文本
           textFont      : {string},  // 默认为null，附加文本样式，eg:&#x27;bold 18px verdana&#x27;
           textPosition  : {string},  // 默认为top，附加文本位置。
                                      // inside | left | right | top | bottom
           textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                      // start | end | left | right | center
           textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                      // top | bottom | middle |
                                      // alphabetic | hanging | ideographic
           textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                      // &#x27;inside&#x27; ? &#x27;#fff&#x27; : color
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
     例子：
     {
       shape  : &#x27;ellipse&#x27;,
       id     : &#x27;123456&#x27;,
       zlevel : 1,
       style  : {
           x : 200,
           y : 100,
           a : 100,
           b : 50,
           color : &#x27;#eee&#x27;,
           text : &#x27;Baidu&#x27;
       },
       myName : &#x27;kener&#x27;,  // 可自带任何有效自定义属性

       clickable : true,
       onClick : function(eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
     */
    define(
        &#x27;zrender/shape/Ellipse&#x27;,[&#x27;require&#x27;,&#x27;./Base&#x27;,&#x27;../tool/util&#x27;],function (require) {
            var Base = require(&#x27;./Base&#x27;);

            function Ellipse(options) {
                Base.call(this, options);
            }

            Ellipse.prototype = {
                type: &#x27;ellipse&#x27;,

                /**
                 * 创建圆形路径
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                buildPath : function(ctx, style) {
                    var k = 0.5522848;
                    var x = style.x;
                    var y = style.y;
                    var a =style.a;
                    var b = style.b;
                    var ox = a * k; // 水平控制点偏移量
                    var oy = b * k; // 垂直控制点偏移量
                    //从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线
                    ctx.moveTo(x - a, y);
                    ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
                    ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
                    ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
                    ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect : function(style) {
                    if (style.__rect) {
                        return style.__rect;
                    }

                    var lineWidth;
                    if (style.brushType == &#x27;stroke&#x27; || style.brushType == &#x27;fill&#x27;) {
                        lineWidth = style.lineWidth || 1;
                    }
                    else {
                        lineWidth = 0;
                    }
                    style.__rect = {
                        x : Math.round(style.x - style.a - lineWidth / 2),
                        y : Math.round(style.y - style.b - lineWidth / 2),
                        width : style.a * 2 + lineWidth,
                        height : style.b * 2 + lineWidth
                    };

                    return style.__rect;
                }
            };

            require(&#x27;../tool/util&#x27;).inherits(Ellipse, Base);
            return Ellipse;
        }
    );
    /**
     * 地图参数
     * key为地图类型: {
 *     getGeoJson: 地图数据加载
 * }
     */
    define(&#x27;echarts/util/mapData/params&#x27;,[&#x27;require&#x27;],function (require) {
        function decode(json) {
            if (!json.UTF8Encoding) {
                return json;
            }
            var features = json.features;

            for (var f = 0; f &lt; features.length; f++) {
                var feature = features[f];
                var coordinates = feature.geometry.coordinates;
                var encodeOffsets = feature.geometry.encodeOffsets;

                for (var c = 0; c &lt; coordinates.length; c++) {
                    var coordinate = coordinates[c];

                    if (feature.geometry.type === &#x27;Polygon&#x27;) {
                        coordinates[c] = decodePolygon(
                            coordinate,
                            encodeOffsets[c]
                        );
                    } else if (feature.geometry.type === &#x27;MultiPolygon&#x27;) {
                        for (var c2 = 0; c2 &lt; coordinate.length; c2++) {
                            var polygon = coordinate[c2];
                            coordinate[c2] = decodePolygon(
                                polygon,
                                encodeOffsets[c][c2]
                            );
                        }
                    }
                }
            }
            // Has been decoded
            json.UTF8Encoding = false;
            return json;
        }

        function decodePolygon(coordinate, encodeOffsets) {
            var result = [];
            var prevX = encodeOffsets[0];
            var prevY = encodeOffsets[1];

            for (var i = 0; i &lt; coordinate.length; i+=2) {
                var x = coordinate.charCodeAt(i) - 64;
                var y = coordinate.charCodeAt(i+1) - 64;
                // ZigZag decoding
                x = (x &gt;&gt; 1) ^ (-(x &amp; 1));
                y = (y &gt;&gt; 1) ^ (-(y &amp; 1));
                // Delta deocding
                x += prevX;
                y += prevY;

                prevX = x;
                prevY = y;
                // Dequantize
                result.push([x / 1024, y / 1024]);
            }

            return result;
        }

        var mapParams = {
            &#x27;china&#x27;: {
                getGeoJson: function (callback) {
                    require([&#x27;./geoJson/china_geo&#x27;], function (md){
                        callback(decode(md));
                    });
                }
            },
            &#x27;南海诸岛&#x27; : {
                textCoord : [126, 25],
                getPath : function(leftTop, scale) {
                    // scale.x : width  = 10.51 : 64
                    var pList = [
                        [
                            [0,3.5],[7,11.2],[15,11.9],[30,7],[42,0.7],[52,0.7],
                            [56,7.7],[59,0.7],[64,0.7],[64,0],[5,0],[0,3.5]
                        ],
                        [
                            [13,16.1],[19,14.7],[16,21.7],[11,23.1],[13,16.1]
                        ],
                        [
                            [12,32.2],[14,38.5],[15,38.5],[13,32.2],[12,32.2]
                        ],
                        [
                            [16,47.6],[12,53.2],[13,53.2],[18,47.6],[16,47.6]
                        ],
                        [
                            [6,64.4],[8,70],[9,70],[8,64.4],[6,64.4]
                        ],
                        [
                            [23,82.6],[29,79.8],[30,79.8],[25,82.6],[23,82.6]
                        ],
                        [
                            [37,70.7],[43,62.3],[44,62.3],[39,70.7],[37,70.7]
                        ],
                        [
                            [48,51.1],[51,45.5],[53,45.5],[50,51.1],[48,51.1]
                        ],
                        [
                            [51,35],[51,28.7],[53,28.7],[53,35],[51,35]
                        ],
                        [
                            [52,22.4],[55,17.5],[56,17.5],[53,22.4],[52,22.4]
                        ],
                        [
                            [58,12.6],[62,7],[63,7],[60,12.6],[58,12.6]
                        ],
                        [
                            [0,3.5],[0,93.1],[64,93.1],[64,0],[63,0],[63,92.4],
                            [1,92.4],[1,3.5],[0,3.5]
                        ]
                    ];
                    var str = &#x27;&#x27;;
                    var left = leftTop[0];
                    var top = leftTop[1];
                    for (var i = 0, l = pList.length; i &lt; l; i++) {
                        str += &#x27;M &#x27;
                            + ((pList[i][0][0] * scale+ left).toFixed(2) - 0)
                            + &#x27; &#x27;
                            + ((pList[i][0][1] * scale + top).toFixed(2) - 0)
                            + &#x27; &#x27;;
                        for (var j = 1, k = pList[i].length; j &lt; k; j++) {
                            str += &#x27;L &#x27;
                                + ((pList[i][j][0] * scale + left).toFixed(2) - 0)
                                + &#x27; &#x27;
                                + ((pList[i][j][1] * scale + top).toFixed(2) - 0)
                                + &#x27; &#x27;;
                        }
                    }
                    return str + &#x27; Z&#x27;;
                }
            }
        };

        return {
            decode : decode,
            params : mapParams
        };
    });
    /**
     * 地图文本位置修正
     */
    define(&#x27;echarts/util/mapData/textFixed&#x27;,[],function() {
        // fix = [xFixed, yFixed, scale]
        // textX += fix[0];
        // textY += fix[1];
        return {
            //&#x27;南海诸岛&#x27; : [32, 83],
            // 全国
            &#x27;广东&#x27;: [0, -10],
            &#x27;香港&#x27;: [10, 10],
            &#x27;澳门&#x27;: [-10, 18],
            &#x27;黑龙江&#x27; : [0, 20],
            //&#x27;北京&#x27;: [-10, 0],
            &#x27;天津&#x27;: [5, 5],
            // 广东
            &#x27;深圳市&#x27;: [-35, 0],
            // 云南
            &#x27;红河哈尼族彝族自治州&#x27; : [0, 20],
            &#x27;楚雄彝族自治州&#x27;: [-5, 15],
            // 新疆
            &#x27;石河子市&#x27;: [-5, 5],
            &#x27;五家渠市&#x27;: [0, -10],
            &#x27;昌吉回族自治州&#x27;: [10, 10],
            // 海南
            &#x27;昌江黎族自治县&#x27;: [0,20],
            &#x27;陵水黎族自治县&#x27;: [0,20],
            &#x27;东方市&#x27;: [0,20],
            // 陕西
            &#x27;渭南市&#x27;: [0,20]
        };
    });
    /**
     * 经纬度坐标，优先于自定计算
     */
    define(&#x27;echarts/util/mapData/geoCoord&#x27;,[],function() {
        return {
            &quot;杭州&quot;:[120.219375,30.259244],
            &quot;恩施&quot;:[109.491923,30.285888],
            &quot;延安&quot;:[109.50051,36.60332],
            &quot;莆田&quot;:[119.077731,25.44845],
            &quot;芜湖&quot;:[118.384108,31.36602],
            &quot;蚌埠&quot;:[117.35708,32.929499],
            &quot;巴中&quot;:[106.757916,31.869189],
            &quot;云浮&quot;:[112.050946,22.937976],
            &quot;唐山&quot;:[118.183451,39.650531],
            &quot;徐州&quot;:[117.188107,34.271553],
            &quot;许昌&quot;:[113.835312,34.02674],
            &quot;镇江&quot;:[119.455835,32.204409],
            &quot;海口&quot;:[110.330802,20.022071],
            &quot;钦州&quot;:[108.638798,21.97335],
            &quot;抚州&quot;:[116.360919,27.954545],
            &quot;吉首&quot;:[109.770926,28.317143],
            &quot;昌都&quot;:[97.244052,31.44848],
            &quot;济宁&quot;:[116.600798,35.402122],
            &quot;聊城&quot;:[115.986869,36.455829],
            &quot;上海&quot;:[121.487899,31.249162],
            &quot;巴彦淖尔&quot;:[107.423807,40.76918],
            &quot;新乡&quot;:[113.91269,35.307258],
            &quot;盘锦&quot;:[122.073228,41.141248],
            &quot;葫芦岛&quot;:[120.860758,40.74303],
            &quot;德宏&quot;:[98.589434,24.44124],
            &quot;河池&quot;:[108.069948,24.699521],
            &quot;赤峰&quot;:[118.930761,42.297112],
            &quot;苏州&quot;:[120.619907,31.317987],
            &quot;南宁&quot;:[108.297234,22.806493],
            &quot;吕梁&quot;:[111.143157,37.527316],
            &quot;青岛&quot;:[120.384428,36.105215],
            &quot;长沙&quot;:[112.979353,28.213478],
            &quot;济南&quot;:[117.024967,36.682785],
            &quot;六盘水&quot;:[104.852087,26.591866],
            &quot;温州&quot;:[120.690635,28.002838],
            &quot;惠州&quot;:[114.410658,23.11354],
            &quot;大连&quot;:[121.593478,38.94871],
            &quot;江门&quot;:[113.078125,22.575117],
            &quot;商洛&quot;:[109.934208,33.873907],
            &quot;淮北&quot;:[116.791447,33.960023],
            &quot;六安&quot;:[116.505253,31.755558],
            &quot;上饶&quot;:[117.955464,28.457623],
            &quot;威海&quot;:[122.093958,37.528787],
            &quot;鄂州&quot;:[114.895594,30.384439],
            &quot;漳州&quot;:[117.676205,24.517065],
            &quot;昆明&quot;:[102.714601,25.049153],
            &quot;雅安&quot;:[103.009356,29.999716],
            &quot;攀枝花&quot;:[101.722423,26.587571],
            &quot;永州&quot;:[111.614648,26.435972],
            &quot;张掖&quot;:[100.459892,38.93932],
            &quot;河源&quot;:[114.713721,23.757251],
            &quot;广元&quot;:[105.819687,32.44104],
            &quot;益阳&quot;:[112.366547,28.588088],
            &quot;景德镇&quot;:[117.186523,29.303563],
            &quot;绍兴&quot;:[120.592467,30.002365],
            &quot;邢台&quot;:[114.520487,37.069531],
            &quot;衢州&quot;:[118.875842,28.95691],
            &quot;营口&quot;:[122.233391,40.668651],
            &quot;昭通&quot;:[103.725021,27.340633],
            &quot;广安&quot;:[106.63572,30.463984],
            &quot;保山&quot;:[99.177996,25.120489],
            &quot;都匀&quot;:[107.477559,26.153657],
            &quot;鞍山&quot;:[123.007763,41.118744],
            &quot;通辽&quot;:[122.260363,43.633756],
            &quot;咸宁&quot;:[114.300061,29.880657],
            &quot;长治&quot;:[113.120292,36.201664],
            &quot;松原&quot;:[124.832995,45.136049],
            &quot;怒江&quot;:[98.859932,25.860677],
            &quot;喀什&quot;:[76.014343,39.513111],
            &quot;阿克苏&quot;:[81.156013,40.349444],
            &quot;拉萨&quot;:[91.111891,29.662557],
            &quot;成都&quot;:[104.067923,30.679943],
            &quot;晋城&quot;:[112.867333,35.499834],
            &quot;酒泉嘉峪关&quot;:[98.510536,39.73354],
            &quot;泉州&quot;:[118.600362,24.901652],
            &quot;佛山&quot;:[113.134026,23.035095],
            &quot;深圳&quot;:[114.025974,22.546054],
            &quot;无锡&quot;:[120.305456,31.570037],
            &quot;南平&quot;:[118.181883,26.643626],
            &quot;丽水&quot;:[119.929576,28.4563],
            &quot;咸阳&quot;:[108.707509,34.345373],
            &quot;安庆&quot;:[117.058739,30.537898],
            &quot;伊春&quot;:[128.910766,47.734685],
            &quot;沧州&quot;:[116.863806,38.297615],
            &quot;眉山&quot;:[103.84143,30.061115],
            &quot;保定&quot;:[115.49481,38.886565],
            &quot;达州&quot;:[107.494973,31.214199],
            &quot;漯河&quot;:[114.046061,33.576279],
            &quot;赣州&quot;:[114.935909,25.845296],
            &quot;茂名&quot;:[110.931245,21.668226],
            &quot;安阳&quot;:[114.351807,36.110267],
            &quot;阿坝&quot;:[102.228565,31.905763],
            &quot;揭阳&quot;:[116.379501,23.547999],
            &quot;新余&quot;:[114.947117,27.822322],
            &quot;涪陵&quot;:[107.3408,29.664671],
            &quot;呼和浩特&quot;:[111.660351,40.828319],
            &quot;娄底&quot;:[111.996396,27.741073],
            &quot;迪庆&quot;:[99.713682,27.831029],
            &quot;辽阳&quot;:[123.172451,41.273339],
            &quot;乌鲁木齐&quot;:[87.564988,43.84038],
            &quot;包头&quot;:[109.846239,40.647119],
            &quot;莱芜&quot;:[117.684667,36.233654],
            &quot;宝鸡&quot;:[107.170645,34.364081],
            &quot;白银&quot;:[104.171241,36.546682],
            &quot;楚雄彝族自治州&quot;:[101.534111,25.051199],
            &quot;沈阳&quot;:[123.432791,41.808645],
            &quot;鸡西&quot;:[130.941767,45.32154],
            &quot;天津&quot;:[117.210813,39.14393],
            &quot;临汾&quot;:[111.538788,36.099745],
            &quot;中山&quot;:[113.42206,22.545178],
            &quot;长春&quot;:[125.313642,43.898338],
            &quot;哈尔滨&quot;:[126.657717,45.773225],
            &quot;银川&quot;:[106.206479,38.502621],
            &quot;廊坊&quot;:[116.703602,39.518611],
            &quot;韶关&quot;:[113.594461,24.80296],
            &quot;来宾&quot;:[109.231817,23.741166],
            &quot;湛江&quot;:[110.365067,21.257463],
            &quot;清远&quot;:[113.040773,23.698469],
            &quot;岳阳&quot;:[113.146196,29.378007],
            &quot;滁州&quot;:[118.32457,32.317351],
            &quot;宣城&quot;:[118.752096,30.951642],
            &quot;湖州&quot;:[120.137243,30.877925],
            &quot;亳州&quot;:[115.787928,33.871211],
            &quot;舟山&quot;:[122.169872,30.03601],
            &quot;肇庆&quot;:[112.479653,23.078663],
            &quot;吉安&quot;:[114.992039,27.113848],
            &quot;随州&quot;:[113.379358,31.717858],
            &quot;淮安&quot;:[119.030186,33.606513],
            &quot;盐城&quot;:[120.148872,33.379862],
            &quot;遂宁&quot;:[105.564888,30.557491],
            &quot;鄂尔多斯&quot;:[109.993706,39.81649],
            &quot;承德&quot;:[117.933822,40.992521],
            &quot;丹东&quot;:[124.338543,40.129023],
            &quot;佳木斯&quot;:[130.284735,46.81378],
            &quot;运城&quot;:[111.006854,35.038859],
            &quot;曲靖&quot;:[103.782539,25.520758],
            &quot;濮阳&quot;:[115.026627,35.753298],
            &quot;三门峡&quot;:[111.181262,34.78332],
            &quot;泰安&quot;:[117.089415,36.188078],
            &quot;宿州&quot;:[116.988692,33.636772],
            &quot;楚雄&quot;:[101.529382,25.066356],
            &quot;合肥&quot;:[117.282699,31.866942],
            &quot;孝感&quot;:[113.935734,30.927955],
            &quot;齐齐哈尔&quot;:[123.987289,47.3477],
            &quot;宁波&quot;:[121.579006,29.885259],
            &quot;广州&quot;:[113.30765,23.120049],
            &quot;铜川&quot;:[108.968067,34.908368],
            &quot;信阳&quot;:[114.085491,32.128582],
            &quot;郑州&quot;:[113.649644,34.75661],
            &quot;石家庄&quot;:[114.522082,38.048958],
            &quot;巢湖&quot;:[117.88049,31.608733],
            &quot;嘉兴&quot;:[120.760428,30.773992],
            &quot;汕尾&quot;:[115.372924,22.778731],
            &quot;邵阳&quot;:[111.461525,27.236811],
            &quot;渭南&quot;:[109.483933,34.502358],
            &quot;龙岩&quot;:[117.017997,25.078685],
            &quot;南通&quot;:[120.873801,32.014665],
            &quot;秦皇岛&quot;:[119.604368,39.945462],
            &quot;泰州&quot;:[119.919606,32.476053],
            &quot;常州&quot;:[119.981861,31.771397],
            &quot;商丘&quot;:[115.641886,34.438589],
            &quot;襄樊&quot;:[112.176326,32.094934],
            &quot;开封&quot;:[114.351642,34.801854],
            &quot;吐鲁番&quot;:[89.266025,42.678925],
            &quot;乐山&quot;:[103.760824,29.600958],
            &quot;九江&quot;:[115.999848,29.71964],
            &quot;郴州&quot;:[113.037704,25.782264],
            &quot;宜春&quot;:[114.400039,27.81113],
            &quot;铜陵&quot;:[117.819429,30.94093],
            &quot;池州&quot;:[117.494477,30.660019],
            &quot;大同&quot;:[113.290509,40.113744],
            &quot;焦作&quot;:[113.211836,35.234608],
            &quot;衡阳&quot;:[112.583819,26.898164],
            &quot;本溪&quot;:[123.778062,41.325838],
            &quot;四平&quot;:[124.391382,43.175525],
            &quot;马鞍山&quot;:[118.515882,31.688528],
            &quot;遵义&quot;:[106.93126,27.699961],
            &quot;延吉&quot;:[129.471302,43.059667],
            &quot;铜仁&quot;:[109.168558,27.674903],
            &quot;内江&quot;:[105.073056,29.599462],
            &quot;大理&quot;:[100.223675,25.5969],
            &quot;黄山&quot;:[118.158045,30.186377],
            &quot;洛阳&quot;:[112.447525,34.657368],
            &quot;淄博&quot;:[118.059134,36.804685],
            &quot;黔南&quot;:[107.523205,26.264536],
            &quot;牡丹江&quot;:[129.608035,44.588521],
            &quot;呼伦贝尔&quot;:[119.760822,49.201636],
            &quot;大庆&quot;:[125.02184,46.596709],
            &quot;伊犁&quot;:[81.297854,43.922248],
            &quot;厦门&quot;:[118.103886,24.489231],
            &quot;白山&quot;:[126.435798,41.945859],
            &quot;南京&quot;:[118.778074,32.057236],
            &quot;宁德&quot;:[119.542082,26.656527],
            &quot;北京&quot;:[116.403874,39.914889],
            &quot;十堰&quot;:[110.801229,32.636994],
            &quot;红河哈尼族彝族自治州&quot;:[103.382147,23.369913],
            &quot;珠海&quot;:[113.562447,22.256915],
            &quot;三明&quot;:[117.642194,26.270835],
            &quot;阜新&quot;:[121.660822,42.01925],
            &quot;版纳&quot;:[100.801778,22.01301],
            &quot;泸州&quot;:[105.44397,28.89593],
            &quot;金华&quot;:[119.652576,29.102899],
            &quot;烟台&quot;:[121.309555,37.536562],
            &quot;汉中&quot;:[107.045478,33.081569],
            &quot;安顺&quot;:[105.92827,26.228595],
            &quot;绵阳&quot;:[104.705519,31.504701],
            &quot;毕节&quot;:[105.333323,27.408562],
            &quot;乌兰察布&quot;:[113.112846,41.022363],
            &quot;枣庄&quot;:[117.279305,34.807883],
            &quot;百色&quot;:[106.631821,23.901512],
            &quot;重庆&quot;:[106.530635,29.544606],
            &quot;文山&quot;:[104.246294,23.374087],
            &quot;驻马店&quot;:[114.049154,32.983158],
            &quot;怀化&quot;:[109.986959,27.557483],
            &quot;黔东南&quot;:[107.985353,26.583992],
            &quot;常德&quot;:[111.653718,29.012149],
            &quot;锡林浩特&quot;:[116.136948,44.078961],
            &quot;鹤壁&quot;:[114.29777,35.755426],
            &quot;阳江&quot;:[111.97701,21.871517],
            &quot;凉山&quot;:[102.259591,27.892393],
            &quot;凯里&quot;:[107.948239,26.631742],
            &quot;平顶山&quot;:[113.300849,33.745301],
            &quot;玉林&quot;:[110.151676,22.643974],
            &quot;绥化&quot;:[126.989095,46.646064],
            &quot;天水&quot;:[105.736932,34.584319],
            &quot;丽江&quot;:[100.229628,26.875351],
            &quot;汶川&quot;:[103.294317,31.168774],
            &quot;吴忠&quot;:[106.208254,37.993561],
            &quot;贵阳&quot;:[106.709177,26.629907],
            &quot;马尔康&quot;:[102.206439,31.905848],
            &quot;武汉&quot;:[114.3162,30.581084],
            &quot;阳泉&quot;:[113.569238,37.869529],
            &quot;台州&quot;:[121.440613,28.668283],
            &quot;东莞&quot;:[113.763434,23.043024],
            &quot;福州&quot;:[119.330221,26.047125],
            &quot;衡水&quot;:[115.686229,37.746929],
            &quot;贵港&quot;:[109.613708,23.103373],
            &quot;湘潭&quot;:[112.935556,27.835095],
            &quot;甘孜&quot;:[101.969232,30.055144],
            &quot;三亚&quot;:[109.522771,18.257776],
            &quot;安康&quot;:[109.038045,32.70437],
            &quot;潮州&quot;:[116.630076,23.661812],
            &quot;黄石&quot;:[115.050683,30.216127],
            &quot;东营&quot;:[118.583926,37.487121],
            &quot;防城港&quot;:[108.351791,21.617398],
            &quot;潍坊&quot;:[119.142634,36.716115],
            &quot;贺州&quot;:[111.552594,24.411054],
            &quot;鹰潭&quot;:[117.03545,28.24131],
            &quot;汕头&quot;:[116.72865,23.383908],
            &quot;德州&quot;:[116.328161,37.460826],
            &quot;宜宾&quot;:[104.633019,28.769675],
            &quot;淮南&quot;:[117.018639,32.642812],
            &quot;张家口&quot;:[114.893782,40.811188],
            &quot;梅州&quot;:[116.126403,24.304571],
            &quot;临沂&quot;:[118.340768,35.072409],
            &quot;万州&quot;:[108.413439,30.710054],
            &quot;资阳&quot;:[104.63593,30.132191],
            &quot;萍乡&quot;:[113.859917,27.639544],
            &quot;宜昌&quot;:[111.310981,30.732758],
            &quot;黔江&quot;:[108.714808,29.440981],
            &quot;玉溪&quot;:[102.545068,24.370447],
            &quot;荆州&quot;:[112.241866,30.332591],
            &quot;兴义&quot;:[104.857837,25.002544],
            &quot;桂林&quot;:[110.26092,25.262901],
            &quot;武威&quot;:[102.640147,37.933172],
            &quot;金昌&quot;:[102.208126,38.516072],
            &quot;通化&quot;:[125.94265,41.736397],
            &quot;日照&quot;:[119.50718,35.420225],
            &quot;白城&quot;:[122.840777,45.621086],
            &quot;阿坝藏族羌族自治州&quot;:[102.231186,31.905607],
            &quot;双鸭山&quot;:[131.201359,46.6672],
            &quot;临沧&quot;:[100.10566,23.914329],
            &quot;伊犁哈萨克自治州&quot;:[81.330696,43.922817],
            &quot;西安&quot;:[108.953098,34.2778],
            &quot;邯郸&quot;:[114.482694,36.609308],
            &quot;德宏傣族景颇族自治州&quot;:[98.591421,24.438028],
            &quot;柳州&quot;:[109.422402,24.329053],
            &quot;榆林&quot;:[109.745926,38.279439],
            &quot;阜阳&quot;:[115.820932,32.901211],
            &quot;凉山彝族自治州&quot;:[102.273967,27.887686],
            &quot;仙桃&quot;:[113.387448,30.293966],
            &quot;宿迁&quot;:[118.296893,33.95205],
            &quot;滨州&quot;:[117.968292,37.405314],
            &quot;太原&quot;:[112.550864,37.890277],
            &quot;黄冈&quot;:[114.906618,30.446109],
            &quot;扬州&quot;:[119.427778,32.408505],
            &quot;陇南&quot;:[104.934573,33.39448],
            &quot;自贡&quot;:[104.776071,29.359157],
            &quot;梧州&quot;:[111.305472,23.485395],
            &quot;天门&quot;:[113.12623,30.649047],
            &quot;西宁&quot;:[101.767921,36.640739],
            &quot;南充&quot;:[106.105554,30.800965],
            &quot;德阳&quot;:[104.402398,31.13114],
            &quot;南昌&quot;:[115.893528,28.689578],
            &quot;连云港&quot;:[119.173872,34.601549],
            &quot;张家界&quot;:[110.48162,29.124889],
            &quot;珲春&quot;:[130.702367,43.074719],
            &quot;鹤岗&quot;:[130.292472,47.338666],
            &quot;锦州&quot;:[121.147749,41.130879],
            &quot;红河&quot;:[103.384065,23.367718],
            &quot;荆门&quot;:[112.21733,31.042611],
            &quot;铁岭&quot;:[123.85485,42.299757],
            &quot;朝阳&quot;:[120.446163,41.571828],
            &quot;周口&quot;:[114.654102,33.623741],
            &quot;兰州&quot;:[103.823305,36.064226],
            &quot;抚顺&quot;:[123.92982,41.877304],
            &quot;黑河&quot;:[127.50083,50.25069],
            &quot;北海&quot;:[116.395541,39.931823],
            &quot;淮阴&quot;:[118.935664,33.664059],
            &quot;晋中&quot;:[112.738514,37.693362],
            &quot;那曲&quot;:[92.034626,31.252315],
            &quot;固原&quot;:[106.285268,36.021523],
            &quot;塔城&quot;:[83.190128,46.811367],
            &quot;忻州&quot;:[112.727939,38.461031],
            &quot;奎屯&quot;:[85.013934,44.559557],
            &quot;中卫&quot;:[105.196754,37.521124],
            &quot;西昌&quot;:[102.117888,27.863377],
            &quot;海拉尔&quot;:[120.042882,49.279245],
            &quot;大兴安岭&quot;:[116.427166,39.967479],
            &quot;定西&quot;:[104.626638,35.586056],
            &quot;文山壮族苗族自治州&quot;:[104.257993,23.374466],
            &quot;共和&quot;:[100.064876,36.538342],
            &quot;湘西土家族苗族自治州&quot;:[109.745498,28.317489],
            &quot;海东&quot;:[102.110729,36.508254],
            &quot;平凉&quot;:[106.688911,35.55011],
            &quot;和田&quot;:[79.919627,37.118012],
            &quot;库尔勒&quot;:[85.709418,41.7055],
            &quot;集宁&quot;:[113.112832,41.027766],
            &quot;乌海&quot;:[106.831999,39.683177],
            &quot;果洛&quot;:[100.223723,34.480485],
            &quot;兴安盟&quot;:[122.048167,46.083757],
            &quot;辽源&quot;:[125.133686,42.923303],
            &quot;酒泉&quot;:[98.508415,39.741474],
            &quot;贵池&quot;:[117.508478,30.514086],
            &quot;石嘴山&quot;:[106.379337,39.020223],
            &quot;延边&quot;:[129.485902,42.896414],
            &quot;潢川&quot;:[115.16441,32.132798],
            &quot;临夏&quot;:[103.215249,35.598514],
            &quot;七台河&quot;:[131.019048,45.775005],
            &quot;克拉玛依&quot;:[84.88118,45.594331],
            &quot;嘉峪关&quot;:[98.281635,39.802397],
            &quot;格尔木&quot;:[92.701667,35.580972],
            &quot;阿勒泰&quot;:[87.926214,47.890136],
            &quot;乌兰浩特&quot;:[122.081534,46.116944],
            &quot;石河子&quot;:[86.041865,44.308259],
            &quot;德令哈&quot;:[97.162832,37.727058],
            &quot;庆阳&quot;:[107.644227,35.726801],
            &quot;临河&quot;:[107.44184,40.932018],
            &quot;朔州&quot;:[112.479928,39.337672],
            &quot;昌吉&quot;:[87.296038,44.007058],
            &quot;梅河口&quot;:[125.723516,42.54265],
            &quot;东胜&quot;:[109.764419,39.805586],
            &quot;山南&quot;:[91.782194,29.231257],
            &quot;海北&quot;:[100.879802,36.960654],
            &quot;海南藏族自治州&quot;:[100.627077,36.292134],
            &quot;甘南藏族自治州&quot;:[102.917603,34.988995],
            &quot;甘孜藏族自治州&quot;:[101.969081,30.055209],
            &quot;株洲&quot;:[113.131695,27.827433],
            &quot;哈密&quot;:[93.521165,42.832914],
            &quot;潜江&quot;:[112.889947,30.415917],
            &quot;阿拉善盟&quot;:[105.735357,38.857802],
            &quot;锡林郭勒盟&quot;:[116.054136,43.93952],
            &quot;南阳&quot;:[112.534649,32.996765]
        };
    });
    /**
     * echarts地图一般投射算法
     * modify from GeoMap v0.5.3 https://github.com/x6doooo/GeoMap
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/util/projection/svg&#x27;,[&#x27;require&#x27;,&#x27;zrender/shape/Path&#x27;],function(require) {

        var PathShape = require(&#x27;zrender/shape/Path&#x27;);
        function toFloat(str) {
            return parseFloat(str || 0);
        }

        function getBbox(root) {
            var svgNode = root.firstChild;
            // Find the svg node
            while (!(svgNode.nodeName.toLowerCase() == &#x27;svg&#x27; &amp;&amp; svgNode.nodeType == 1)) {
                svgNode = svgNode.nextSibling;
            }

            var x = toFloat(svgNode.getAttribute(&#x27;x&#x27;));
            var y = toFloat(svgNode.getAttribute(&#x27;y&#x27;));
            var width = toFloat(svgNode.getAttribute(&#x27;width&#x27;));
            var height = toFloat(svgNode.getAttribute(&#x27;height&#x27;));
            return {
                left : x,
                top : y,
                width : width,
                height : height
            };
        }

        function geoJson2Path(root, transform) {
            var scale = [transform.scale.x, transform.scale.y];
            var elList = [];
            function _getShape(root) {
                var tagName = root.tagName;
                if (shapeBuilders[tagName]) {
                    var obj = shapeBuilders[tagName](root, scale);

                    if (obj) {
                        // Common attributes
                        obj.scale = scale;
                        obj.properties = {
                            name : root.getAttribute(&#x27;name&#x27;) || &#x27;&#x27;
                        };
                        obj.id = root.id;
                        extendCommonAttributes(obj, root);

                        elList.push(obj);
                    }
                }
                var shapes = root.childNodes;
                for (var i = 0, len = shapes.length; i &lt; len; i++) {
                    _getShape(shapes[i]);
                }
            }
            _getShape(root);
            return elList;
        }

        /**
         * 平面坐标转经纬度
         * @param {Array} p
         */
        function pos2geo(obj, p) {
            var point = p instanceof Array ? [p[0] * 1, p[1] * 1] : [p.x * 1, p.y * 1]
            return [point[0] / obj.scale.x, point[1] / obj.scale.y];
        }

        /**
         * 经纬度转平面坐标
         * @param {Array | Object} p
         */
        function geo2pos(obj, p) {
            var point = p instanceof Array ? [p[0] * 1, p[1] * 1] : [p.x * 1, p.y * 1]
            return [point[0] * obj.scale.x, point[1] * obj.scale.y];
        }

        function trim(str) {
            return str.replace(/^\s\s*/, &#x27;&#x27;).replace(/\s\s*$/, &#x27;&#x27;);
        }

        function extendCommonAttributes(obj, xmlNode) {

            var color = xmlNode.getAttribute(&#x27;fill&#x27;);
            var strokeColor = xmlNode.getAttribute(&#x27;stroke&#x27;);
            var lineWidth = xmlNode.getAttribute(&#x27;stroke-width&#x27;);
            var opacity = xmlNode.getAttribute(&#x27;opacity&#x27;);

            if (color &amp;&amp; color != &#x27;none&#x27;) {
                obj.color = color;
                if (strokeColor) {
                    obj.brushType = &#x27;both&#x27;;
                    obj.strokeColor = strokeColor;
                } else {
                    obj.brushType = &#x27;fill&#x27;;
                }
            } else if (strokeColor &amp;&amp; strokeColor != &#x27;none&#x27;) {
                obj.strokeColor = strokeColor;
                obj.brushType = &#x27;stroke&#x27;;
            }
            if (lineWidth &amp;&amp; lineWidth != &#x27;none&#x27;) {
                obj.lineWidth = parseFloat(lineWidth);
            }
            if (opacity &amp;&amp; opacity != &#x27;none&#x27;) {
                obj.opacity = parseFloat(opacity);
            }
        }

        function parsePoints(str) {
            var list = trim(str).replace(/,/g, &#x27; &#x27;).split(/\s+/);
            var points = [];

            for (var i = 0; i &lt; list.length;) {
                var x = parseFloat(list[i++]);
                var y = parseFloat(list[i++]);
                points.push([x, y]);
            }
            return points;
        }

        // Regular svg shapes
        var shapeBuilders = {
            path: function(xmlNode, scale) {
                var path = xmlNode.getAttribute(&#x27;d&#x27;);
                var rect = PathShape.prototype.getRect({path : path});
                return {
                    shapeType: &#x27;path&#x27;,
                    path : path,
                    cp : [
                            (rect.x + rect.width / 2) * scale[0],
                            (rect.y + rect.height / 2) * scale[1]
                    ]
                };
            },

            rect: function(xmlNode, scale) {
                var x = toFloat(xmlNode.getAttribute(&#x27;x&#x27;));
                var y = toFloat(xmlNode.getAttribute(&#x27;y&#x27;));
                var width = toFloat(xmlNode.getAttribute(&#x27;width&#x27;));
                var height = toFloat(xmlNode.getAttribute(&#x27;height&#x27;));

                return {
                    shapeType: &#x27;rectangle&#x27;,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    cp : [
                            (x + width / 2) * scale[0],
                            (y + height / 2) * scale[1]
                    ],
                }
            },

            line: function(xmlNode, scale) {
                var x1 = toFloat(xmlNode.getAttribute(&#x27;x1&#x27;));
                var y1 = toFloat(xmlNode.getAttribute(&#x27;y1&#x27;));
                var x2 = toFloat(xmlNode.getAttribute(&#x27;x2&#x27;));
                var y2 = toFloat(xmlNode.getAttribute(&#x27;y2&#x27;));

                return {
                    shapeType: &#x27;line&#x27;,
                    xStart: x1,
                    yStart: y1,
                    xEnd: x2,
                    yEnd: y2,
                    cp : [
                            (x1 + x2) * 0.5 * scale[0],
                            (y1 + y2) * 0.5 * scale[1]
                    ],
                }
            },

            circle: function(xmlNode, scale) {
                var cx = toFloat(xmlNode.getAttribute(&#x27;cx&#x27;));
                var cy = toFloat(xmlNode.getAttribute(&#x27;cy&#x27;));
                var r = toFloat(xmlNode.getAttribute(&#x27;r&#x27;));

                return {
                    shapeType: &#x27;circle&#x27;,
                    x: cx,
                    y: cy,
                    r: r,
                    cp: [
                            cx * scale[0],
                            cy * scale[1]
                    ]
                }
            },

            ellipse: function(xmlNode, scale) {
                var cx = parseFloat(xmlNode.getAttribute(&quot;cx&quot;) || 0);
                var cy = parseFloat(xmlNode.getAttribute(&quot;cy&quot;) || 0);
                var rx = parseFloat(xmlNode.getAttribute(&quot;rx&quot;) || 0);
                var ry = parseFloat(xmlNode.getAttribute(&quot;ry&quot;) || 0);

                return {
                    shapeType: &#x27;ellipse&#x27;,
                    x: cx,
                    y: cy,
                    a: rx,
                    b: ry,
                    cp: [
                            cx * scale[0],
                            cy * scale[1]
                    ]
                }
            },

            polygon: function(xmlNode, scale) {
                var points = xmlNode.getAttribute(&#x27;points&#x27;);
                var min = [Infinity, Infinity];
                var max = [-Infinity, -Infinity];
                if (points) {
                    points = parsePoints(points);

                    for (var i = 0; i &lt; points.length; i++) {
                        var p = points[i];

                        min[0] = Math.min(p[0], min[0]);
                        min[1] = Math.min(p[1], min[1]);

                        max[0] = Math.max(p[0], max[0]);
                        max[1] = Math.max(p[1], max[1]);

                    }
                    return {
                        shapeType: &#x27;polygon&#x27;,
                        pointList: points,
                        cp : [
                                (min[0] + max[0]) / 2 * scale[0],
                                (min[1] + max[1]) / 2 * scale[0]
                        ]
                    }
                }
            },

            polyline: function(xmlNode, scale) {
                var obj = shapeBuilders.polygon(xmlNode, scale);
                return obj;
            }
        }

        return {
            getBbox : getBbox,
            geoJson2Path : geoJson2Path,
            pos2geo : pos2geo,
            geo2pos : geo2pos
        };
    });
    /**
     * echarts地图一般投射算法
     * modify from GeoMap v0.5.3 https://github.com/x6doooo/GeoMap
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/util/projection/normal&#x27;,[],function() {
        function getBbox(json, specialArea) {
            specialArea = specialArea || {};
            if (!json.srcSize) {
                parseSrcSize(json, specialArea);
            }

            return json.srcSize;
        }

        function parseSrcSize(json, specialArea) {
            specialArea = specialArea || {};
            convertorParse.xmin = 360;
            convertorParse.xmax = -360;
            convertorParse.ymin = 180;
            convertorParse.ymax = -180;

            var shapes = json.features;
            var geometries;
            var shape;
            for (var i = 0, len = shapes.length; i &lt; len; i++) {
                shape = shapes[i];
                if (shape.properties.name &amp;&amp; specialArea[shape.properties.name]) {
                    continue;
                }

                switch (shape.type) {
                    case &#x27;Feature&#x27;:
                        convertorParse[shape.geometry.type](shape.geometry.coordinates);
                        break;
                    case &#x27;GeometryCollection&#x27; :
                        geometries = shape.geometries;
                        for (var j = 0, len2 = geometries.length; j &lt; len2; j++) {
                            convertorParse[geometries[j].type](
                                geometries[j].coordinates
                            );
                        }
                        break;
                }
            }

            json.srcSize = {
                left : convertorParse.xmin.toFixed(4)*1,
                top : convertorParse.ymin.toFixed(4)*1,
                width : (convertorParse.xmax - convertorParse.xmin).toFixed(4)*1,
                height : (convertorParse.ymax - convertorParse.ymin).toFixed(4)*1
            };

            return json;
        }

        var convertor = {
            //调整俄罗斯东部到地图右侧与俄罗斯相连
            formatPoint : function (p) {
                return [
                        ((p[0] &lt; -168.5 &amp;&amp; p[1] &gt; 63.8) ? p[0] + 360 : p[0]) + 168.5,
                        90 - p[1]
                ];
            },
            makePoint : function (p) {
                var self = this;
                var point = self.formatPoint(p);
                // for cp
                if (self._bbox.xmin &gt; p[0]) { self._bbox.xmin = p[0]; }
                if (self._bbox.xmax &lt; p[0]) { self._bbox.xmax = p[0]; }
                if (self._bbox.ymin &gt; p[1]) { self._bbox.ymin = p[1]; }
                if (self._bbox.ymax &lt; p[1]) { self._bbox.ymax = p[1]; }
                var x = (point[0] - convertor.offset.x) * convertor.scale.x
                    + convertor.offset.left;
                var y = (point[1] - convertor.offset.y) * convertor.scale.y
                    + convertor.offset.top;
                return [x, y];
            },
            Point : function (coordinates) {
                coordinates = this.makePoint(coordinates);
                return coordinates.join(&#x27;,&#x27;);
            },
            LineString : function (coordinates) {
                var str = &#x27;&#x27;;
                var point;
                for (var i = 0, len = coordinates.length; i &lt; len; i++) {
                    point = convertor.makePoint(coordinates[i]);
                    if (i === 0) {
                        str = &#x27;M&#x27; + point.join(&#x27;,&#x27;);
                    } else {
                        str = str + &#x27;L&#x27; + point.join(&#x27;,&#x27;);
                    }
                }
                return str;
            },
            Polygon : function (coordinates) {
                var str = &#x27;&#x27;;
                for (var i = 0, len = coordinates.length; i &lt; len; i++) {
                    str = str + convertor.LineString(coordinates[i]) + &#x27;z&#x27;;
                }
                return str;
            },
            MultiPoint : function (coordinates) {
                var arr = [];
                for (var i = 0, len = coordinates.length; i &lt; len; i++) {
                    arr.push(convertor.Point(coordinates[i]));
                }
                return arr;
            },
            MultiLineString : function (coordinates) {
                var str = &#x27;&#x27;;
                for (var i = 0, len = coordinates.length; i &lt; len; i++) {
                    str += convertor.LineString(coordinates[i]);
                }
                return str;
            },
            MultiPolygon : function (coordinates) {
                var str = &#x27;&#x27;;
                for (var i = 0, len = coordinates.length; i &lt; len; i++) {
                    str += convertor.Polygon(coordinates[i]);
                }
                return str;
            }
        };

        var convertorParse = {
            formatPoint : convertor.formatPoint,

            makePoint : function (p) {
                var self = this;
                var point = self.formatPoint(p);
                var x = point[0];
                var y = point[1];
                if (self.xmin &gt; x) { self.xmin = x; }
                if (self.xmax &lt; x) { self.xmax = x; }
                if (self.ymin &gt; y) { self.ymin = y; }
                if (self.ymax &lt; y) { self.ymax = y; }
            },
            Point : function (coordinates) {
                this.makePoint(coordinates);
            },
            LineString : function (coordinates) {
                for (var i = 0, len = coordinates.length; i &lt; len; i++) {
                    this.makePoint(coordinates[i]);
                }
            },
            Polygon : function (coordinates) {
                for (var i = 0, len = coordinates.length; i &lt; len; i++) {
                    this.LineString(coordinates[i]);
                }
            },
            MultiPoint : function (coordinates) {
                for (var i = 0, len = coordinates.length; i &lt; len; i++) {
                    this.Point(coordinates[i]);
                }
            },
            MultiLineString : function (coordinates) {
                for (var i = 0, len = coordinates.length; i &lt; len; i++) {
                    this.LineString(coordinates[i]);
                }
            },
            MultiPolygon : function (coordinates) {
                for (var i = 0, len = coordinates.length; i &lt; len; i++) {
                    this.Polygon(coordinates[i]);
                }
            }
        };

        function geoJson2Path(json, transform, specialArea) {
            specialArea = specialArea || {};
            convertor.scale = null;
            convertor.offset = null;

            if (!json.srcSize) {
                parseSrcSize(json, specialArea);
            }

            transform.offset = {
                x : json.srcSize.left,
                y : json.srcSize.top,
                left : transform.OffsetLeft || 0,
                top : transform.OffsetTop || 0
            };

            convertor.scale = transform.scale;
            convertor.offset = transform.offset;

            var shapes = json.features;
            var geometries;
            var pathArray = [];
            var val;
            var shape;
            for (var i = 0, len = shapes.length; i &lt; len; i++) {
                shape = shapes[i];
                if (shape.properties.name &amp;&amp; specialArea[shape.properties.name]) {
                    // 忽略specialArea
                    continue;
                }
                if (shape.type == &#x27;Feature&#x27;) {
                    pushApath(shape.geometry, shape);
                }
                else if (shape.type == &#x27;GeometryCollection&#x27;) {
                    geometries = shape.geometries;
                    for (var j = 0, len2 = geometries.length; j &lt; len2; j++) {
                        val = geometries[j];
                        pushApath(val, val);
                    }
                }
            }

            var shapeType;
            var shapeCoordinates;
            var str;
            function pushApath(gm, shape) {
                shapeType = gm.type;
                shapeCoordinates = gm.coordinates;
                convertor._bbox = {
                    xmin : 360,
                    xmax : -360,
                    ymin : 180,
                    ymax : -180
                };
                str = convertor[shapeType](shapeCoordinates);
                pathArray.push({
                    //type : shapeType,
                    path : str,
                    cp : shape.properties.cp
                        ? convertor.makePoint(shape.properties.cp)
                        : convertor.makePoint([
                            (convertor._bbox.xmin + convertor._bbox.xmax) / 2,
                            (convertor._bbox.ymin + convertor._bbox.ymax) / 2
                    ]),
                    properties : shape.properties,
                    id : shape.id
                });
            }

            return pathArray;
        }

        /**
         * 平面坐标转经纬度
         * @param {Array} p
         */
        function pos2geo(obj, p) {
            var x;
            var y;
            if (p instanceof Array) {
                x = p[0] * 1;
                y = p[1] * 1;
            }
            else {
                x = p.x * 1;
                y = p.y * 1;
            }

            x = x / obj.scale.x + obj.offset.x - 168.5;
            x = x &gt; 180 ? x - 360 : x;
            y = 90 - (y / obj.scale.y + obj.offset.y);
            return [x, y];
        }

        /**
         * 经纬度转平面坐标
         * @param {Array | Object} p
         */
        function geo2pos(obj, p) {
            convertor.offset = obj.offset;
            convertor.scale = obj.scale;
            return p instanceof Array
                ? convertor.makePoint([p[0] * 1, p[1] * 1])
                : convertor.makePoint([p.x * 1, p.y * 1]);
        }

        return {
            getBbox : getBbox,
            geoJson2Path : geoJson2Path,
            pos2geo : pos2geo,
            geo2pos : geo2pos
        };
    });
    /**
     * echarts图表类：地图
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define(&#x27;echarts/chart/map&#x27;,[&#x27;require&#x27;,&#x27;../component/base&#x27;,&#x27;./base&#x27;,&#x27;zrender/shape/Text&#x27;,&#x27;zrender/shape/Path&#x27;,&#x27;zrender/shape/Circle&#x27;,&#x27;zrender/shape/Rectangle&#x27;,&#x27;zrender/shape/Line&#x27;,&#x27;zrender/shape/Polygon&#x27;,&#x27;zrender/shape/Ellipse&#x27;,&#x27;../component/dataRange&#x27;,&#x27;../config&#x27;,&#x27;../util/ecData&#x27;,&#x27;zrender/tool/util&#x27;,&#x27;zrender/config&#x27;,&#x27;zrender/tool/event&#x27;,&#x27;../util/mapData/params&#x27;,&#x27;../util/mapData/textFixed&#x27;,&#x27;../util/mapData/geoCoord&#x27;,&#x27;../util/projection/svg&#x27;,&#x27;../util/projection/normal&#x27;,&#x27;../util/projection/normal&#x27;,&#x27;../chart&#x27;],function (require) {
        var ComponentBase = require(&#x27;../component/base&#x27;);
        var ChartBase = require(&#x27;./base&#x27;);

        // 图形依赖
        var TextShape = require(&#x27;zrender/shape/Text&#x27;);
        var PathShape = require(&#x27;zrender/shape/Path&#x27;);
        var CircleShape = require(&#x27;zrender/shape/Circle&#x27;);
        var RectangleShape = require(&#x27;zrender/shape/Rectangle&#x27;);
        var LineShape = require(&#x27;zrender/shape/Line&#x27;);
        var PolygonShape = require(&#x27;zrender/shape/Polygon&#x27;);
        var EllipseShape = require(&#x27;zrender/shape/Ellipse&#x27;);
        // 组件依赖
        require(&#x27;../component/dataRange&#x27;);

        var ecConfig = require(&#x27;../config&#x27;);
        var ecData = require(&#x27;../util/ecData&#x27;);
        var zrUtil = require(&#x27;zrender/tool/util&#x27;);
        var zrConfig = require(&#x27;zrender/config&#x27;);
        var zrEvent = require(&#x27;zrender/tool/event&#x27;);

        var _mapParams = require(&#x27;../util/mapData/params&#x27;).params;
        var _textFixed = require(&#x27;../util/mapData/textFixed&#x27;);
        var _geoCoord = require(&#x27;../util/mapData/geoCoord&#x27;);

        /**
         * 构造函数
         * @param {Object} messageCenter echart消息中心
         * @param {ZRender} zr zrender实例
         * @param {Object} series 数据
         * @param {Object} component 组件
         */
        function Map(ecTheme, messageCenter, zr, option, myChart){
            // 基类
            ComponentBase.call(this, ecTheme, messageCenter, zr, option, myChart);
            // 图表基类
            ChartBase.call(this);

            var self = this;
            self._onmousewheel = function(param){
                return self.__onmousewheel(param);
            };
            self._onmousedown = function(param){
                return self.__onmousedown(param);
            };
            self._onmousemove = function(param){
                return self.__onmousemove(param);
            };
            self._onmouseup = function(param){
                return self.__onmouseup(param);
            };

            this._isAlive = true;           // 活着标记
            this._selectedMode = {};        // 选择模式
            this._hoverable = {};           // 悬浮高亮模式，索引到图表
            this._showLegendSymbol = {};    // 显示图例颜色标识
            this._selected = {};            // 地图选择状态
            this._mapTypeMap = {};          // 图例类型索引
            this._mapDataMap = {};          // 根据地图类型索引bbox,transform,path
            this._nameMap = {};             // 个性化地名
            this._specialArea = {};         // 特殊
            this._refreshDelayTicket;       // 滚轮缩放时让refresh飞一会
            this._mapDataRequireCounter;    // 异步回调计数器
            this._markAnimation = false;

            // 漫游相关信息
            this._roamMap = {};
            this._scaleLimitMap = {};
            this._needRoam;
            this._mx;
            this._my;
            this._mousedown;
            this._justMove;   // 避免移动响应点击
            this._curMapType; // 当前移动的地图类型

            this.refresh(option);
            if (this._needRoam) {
                this.zr.on(zrConfig.EVENT.MOUSEWHEEL, this._onmousewheel);
                this.zr.on(zrConfig.EVENT.MOUSEDOWN, this._onmousedown);
            }
        }

        Map.prototype = {
            type : ecConfig.CHART_TYPE_MAP,
            /**
             * 绘制图形
             */
            _buildShape : function () {
                var series = this.series;
                this.selectedMap = {}; // 系列
                this._activeMapType = {}; // 当前活跃的地图类型

                var legend = this.component.legend;
                var seriesName;
                var valueData = {};
                var mapType;
                var data;
                var name;
                var mapSeries = {};
                var mapValuePrecision = {};
                var valueCalculation = {};
                this._needRoam = false;
                for (var i = 0, l = series.length; i &lt; l; i++) {
                    if (series[i].type == ecConfig.CHART_TYPE_MAP) { // map
                        series[i] = this.reformOption(series[i]);
                        mapType = series[i].mapType;
                        mapSeries[mapType] = mapSeries[mapType] || {};
                        mapSeries[mapType][i] = true;
                        mapValuePrecision[mapType] = mapValuePrecision[mapType]
                            || series[i].mapValuePrecision;
                        this._scaleLimitMap[mapType] = this._scaleLimitMap[mapType] || {};
                        series[i].scaleLimit
                        &amp;&amp; zrUtil.merge(this._scaleLimitMap[mapType], series[i].scaleLimit, true);

                        this._roamMap[mapType] = series[i].roam || this._roamMap[mapType];
                        this._needRoam = this._needRoam || this._roamMap[mapType];

                        this._nameMap[mapType] = this._nameMap[mapType] || {};
                        series[i].nameMap
                        &amp;&amp; zrUtil.merge(this._nameMap[mapType], series[i].nameMap, true);
                        this._activeMapType[mapType] = true;

                        if (series[i].textFixed) {
                            zrUtil.merge(
                                _textFixed, series[i].textFixed, true
                            );
                        }
                        if (series[i].geoCoord) {
                            zrUtil.merge(
                                _geoCoord, series[i].geoCoord, true
                            );
                        }

                        this._selectedMode[mapType] = this._selectedMode[mapType]
                            || series[i].selectedMode;
                        if (typeof this._hoverable[mapType] == &#x27;undefined&#x27;
                            || this._hoverable[mapType]                  // false 1票否决
                            ) {
                            this._hoverable[mapType] = series[i].hoverable;
                        }
                        if (typeof this._showLegendSymbol[mapType] == &#x27;undefined&#x27;
                            || this._showLegendSymbol[mapType]           // false 1票否决
                            ) {
                            this._showLegendSymbol[mapType] = series[i].showLegendSymbol;
                        }

                        valueCalculation[mapType] = valueCalculation[mapType]
                            || series[i].mapValueCalculation;

                        seriesName = series[i].name;
                        this.selectedMap[seriesName] = legend
                            ? legend.isSelected(seriesName)
                            : true;
                        if (this.selectedMap[seriesName]) {
                            valueData[mapType] = valueData[mapType] || {};
                            data = series[i].data;
                            for (var j = 0, k = data.length; j &lt; k; j++) {
                                name = this._nameChange(mapType, data[j].name);
                                valueData[mapType][name] = valueData[mapType][name]
                                    || {seriesIndex : []};
                                for (var key in data[j]) {
                                    if (key != &#x27;value&#x27;) {
                                        valueData[mapType][name][key] =
                                            data[j][key];
                                    }
                                    else if (!isNaN(data[j].value)) {
                                        typeof valueData[mapType][name].value
                                        == &#x27;undefined&#x27;
                                        &amp;&amp; (valueData[mapType][name].value = 0);

                                        valueData[mapType][name].value +=
                                            data[j].value;
                                    }
                                }
                                //索引有该区域的系列样式
                                valueData[mapType][name].seriesIndex.push(i);
                            }
                        }
                    }
                }

                this._mapDataRequireCounter = 0;
                for (var mt in valueData) {
                    this._mapDataRequireCounter++;
                }
                //清空
                this._clearSelected();
                for (var mt in valueData) {
                    if (valueCalculation[mt] &amp;&amp; valueCalculation[mt] == &#x27;average&#x27;) {
                        for (var k in valueData[mt]) {
                            valueData[mt][k].value =
                                (valueData[mt][k].value
                                    / valueData[mt][k].seriesIndex.length)
                                    .toFixed(
                                    mapValuePrecision[mt]
                                ) - 0;
                        }
                    }

                    this._mapDataMap[mt] = this._mapDataMap[mt] || {};

                    if (this._mapDataMap[mt].mapData) {
                        // 已经缓存了则直接用
                        this._mapDataCallback(mt, valueData[mt], mapSeries[mt])(
                            this._mapDataMap[mt].mapData
                        );
                    }
                    else if (_mapParams[mt.replace(/\|.*/, &#x27;&#x27;)].getGeoJson) {
                        // 特殊区域
                        this._specialArea[mt] =
                            _mapParams[mt.replace(/\|.*/, &#x27;&#x27;)].specialArea
                            || this._specialArea[mt];
                        _mapParams[mt.replace(/\|.*/, &#x27;&#x27;)].getGeoJson(
                            this._mapDataCallback(mt, valueData[mt], mapSeries[mt])
                        );
                    }
                }
            },

            /**
             * @param {string} mt mapType
             * @parma {Object} vd valueData
             * @param {Object} ms mapSeries
             */
            _mapDataCallback : function (mt, vd, ms) {
                var self = this;
                return function (md) {
                    if (!self._isAlive) {
                        // 异步地图数据回调时有可能实例已经被释放
                        return;
                    }
                    // 缓存这份数据
                    if (mt.indexOf(&#x27;|&#x27;) != -1) {
                        // 子地图，加工一份新的mapData
                        md = self._getSubMapData(mt, md);
                    }
                    self._mapDataMap[mt].mapData = md;

                    if (md.firstChild) {
                        self._mapDataMap[mt].rate = 1;
                        self._mapDataMap[mt].projection = require(&#x27;../util/projection/svg&#x27;);
                    }
                    else {
                        self._mapDataMap[mt].rate = 0.75;
                        self._mapDataMap[mt].projection = require(&#x27;../util/projection/normal&#x27;);
                    }

                    self._buildMap(
                        mt,                             // 类型
                        self._getProjectionData(mt, md, ms),      // 地图数据
                        vd,                  // 用户数据
                        ms                   // 系列
                    );
                    self._buildMark(mt, ms);
                    if (--self._mapDataRequireCounter &lt;= 0) {
                        self.addShapeList();
                        self.zr.refresh();
                    }
                };
            },

            _clearSelected : function() {
                for (var k in this._selected) {
                    if (!this._activeMapType[this._mapTypeMap[k]]) {
                        delete this._selected[k];
                        delete this._mapTypeMap[k];
                    }
                }
            },

            _getSubMapData : function (mapType, mapData) {
                var subType = mapType.replace(/^.*\|/, &#x27;&#x27;);
                var features = mapData.features;
                for (var i = 0, l = features.length; i &lt; l; i++) {
                    if (features[i].properties
                        &amp;&amp; features[i].properties.name == subType
                        ) {
                        features = features[i];
                        if (subType == &#x27;United States of America&#x27;
                            &amp;&amp; features.geometry.coordinates.length &gt; 1 // 未被简化
                            ) {
                            features = {
                                geometry: {
                                    coordinates: features.geometry
                                        .coordinates.slice(5,6),
                                    type: features.geometry.type
                                },
                                id: features.id,
                                properties: features.properties,
                                type: features.type
                            };
                        }
                        break;
                    }
                }
                return {
                    &#x27;type&#x27; : &#x27;FeatureCollection&#x27;,
                    &#x27;features&#x27;:[
                        features
                    ]
                };
            },

            /**
             * 按需加载相关地图
             */
            _getProjectionData : function (mapType, mapData, mapSeries) {
                var normalProjection = this._mapDataMap[mapType].projection;
                var province = [];

                // bbox永远不变
                var bbox = this._mapDataMap[mapType].bbox
                    || normalProjection.getBbox(
                        mapData, this._specialArea[mapType]
                    );
                //console.log(bbox)

                var transform;
                //console.log(1111,transform)
                if (!this._mapDataMap[mapType].hasRoam) {
                    // 第一次或者发生了resize，需要判断
                    transform = this._getTransform(
                        bbox,
                        mapSeries,
                        this._mapDataMap[mapType].rate
                    );
                }
                else {
                    //经过用户漫游不再响应resize
                    transform = this._mapDataMap[mapType].transform;
                }
                //console.log(bbox,transform)
                var lastTransform = this._mapDataMap[mapType].lastTransform
                    || {scale:{}};

                var pathArray;
                if (transform.left != lastTransform.left
                    || transform.top != lastTransform.top
                    || transform.scale.x != lastTransform.scale.x
                    || transform.scale.y != lastTransform.scale.y
                    ) {
                    // 发生过变化，需要重新生成pathArray
                    // 一般投射
                    //console.log(transform)
                    pathArray = normalProjection.geoJson2Path(
                        mapData, transform, this._specialArea[mapType]
                    );
                    lastTransform = zrUtil.clone(transform);
                }
                else {
                    transform = this._mapDataMap[mapType].transform;
                    pathArray = this._mapDataMap[mapType].pathArray;
                }

                this._mapDataMap[mapType].bbox = bbox;
                this._mapDataMap[mapType].transform = transform;
                this._mapDataMap[mapType].lastTransform = lastTransform;
                this._mapDataMap[mapType].pathArray = pathArray;

                //console.log(pathArray)
                var position = [transform.left, transform.top];
                for (var i = 0, l = pathArray.length; i &lt; l; i++) {
                    /* for test
                     console.log(
                     mapData.features[i].properties.cp, // 经纬度度
                     pathArray[i].cp                    // 平面坐标
                     );
                     console.log(
                     this.pos2geo(mapType, pathArray[i].cp),  // 平面坐标转经纬度
                     this.geo2pos(mapType, mapData.features[i].properties.cp)
                     )
                     */
                    province.push(this._getSingleProvince(
                        mapType, pathArray[i], position
                    ));
                }

                if (this._specialArea[mapType]) {
                    for (var area in this._specialArea[mapType]) {
                        province.push(this._getSpecialProjectionData(
                            mapType, mapData,
                            area, this._specialArea[mapType][area],
                            position
                        ));
                    }

                }

                // 中国地图加入南海诸岛
                if (mapType == &#x27;china&#x27;) {
                    var leftTop = this.geo2pos(
                        mapType,
                            _geoCoord[&#x27;南海诸岛&#x27;] || _mapParams[&#x27;南海诸岛&#x27;].textCoord
                    );
                    // scale.x : width  = 10.51 : 64
                    var scale = transform.scale.x / 10.5;
                    var textPosition = [
                            32 * scale + leftTop[0],
                            83 * scale + leftTop[1]
                    ];
                    if (_textFixed[&#x27;南海诸岛&#x27;]) {
                        textPosition[0] += _textFixed[&#x27;南海诸岛&#x27;][0];
                        textPosition[1] += _textFixed[&#x27;南海诸岛&#x27;][1];
                    }
                    province.push({
                        name : this._nameChange(mapType, &#x27;南海诸岛&#x27;),
                        path : _mapParams[&#x27;南海诸岛&#x27;].getPath(leftTop, scale),
                        position : position,
                        textX : textPosition[0],
                        textY : textPosition[1]
                    });

                }
                //console.log(JSON.stringify(province));
                //console.log(JSON.stringify(this._mapDataMap[mapType].transform));
                return province;
            },

            /**
             * 特殊地区投射数据
             */
            _getSpecialProjectionData : function (mapType, mapData, areaName, mapSize, position) {
                //console.log(&#x27;_getSpecialProjectionData--------------&#x27;)
                // 构造单独的geoJson地图数据
                mapData = this._getSubMapData(&#x27;x|&#x27; + areaName, mapData);

                // bbox
                var normalProjection = require(&#x27;../util/projection/normal&#x27;);
                var bbox = normalProjection.getBbox(mapData);
                //console.log(&#x27;bbox&#x27;, bbox)

                // transform
                var leftTop = this.geo2pos(
                    mapType,
                    [mapSize.left, mapSize.top]
                );
                var rightBottom = this.geo2pos(
                    mapType,
                    [mapSize.left + mapSize.width, mapSize.top + mapSize.height]
                );
                //console.log(&#x27;leftright&#x27; , leftTop, rightBottom);
                var width = Math.abs(rightBottom[0] - leftTop[0]);
                var height = Math.abs(rightBottom[1] - leftTop[1]);
                var mapWidth = bbox.width;
                var mapHeight = bbox.height;
                //var minScale;
                var xScale = (width / 0.75) / mapWidth;
                var yScale = height / mapHeight;
                if (xScale &gt; yScale) {
                    xScale = yScale * 0.75;
                    width = mapWidth * xScale;
                }
                else {
                    yScale = xScale;
                    xScale = yScale * 0.75;
                    height = mapHeight * yScale;
                }
                var transform = {
                    OffsetLeft : leftTop[0],
                    OffsetTop : leftTop[1],
                    //width: width,
                    //height: height,
                    scale : {
                        x : xScale,
                        y : yScale
                    }
                };

                //console.log(&#x27;**&#x27;,areaName, transform)
                var pathArray = normalProjection.geoJson2Path(
                    mapData, transform
                );

                //console.log(pathArray)
                return this._getSingleProvince(
                    mapType, pathArray[0], position
                );
            },

            _getSingleProvince : function (mapType, path, position) {
                var textPosition;
                var name = path.properties.name;
                var textFixed = _textFixed[name] || [0, 0];
                if (_geoCoord[name]) {
                    // 经纬度直接定位不加textFixed
                    textPosition = this.geo2pos(
                        mapType,
                        _geoCoord[name]
                    );
                }
                else if (path.cp) {
                    textPosition = [
                            path.cp[0] + textFixed[0],
                            path.cp[1] + textFixed[1]
                    ];
                }
                else {
                    var bbox = this._mapDataMap[mapType].bbox;
                    textPosition = this.geo2pos(
                        mapType,
                        [bbox.left + bbox.width / 2, bbox.top + bbox.height / 2]
                    );
                    textPosition[0] += textFixed[0];
                    textPosition[1] += textFixed[1];
                }

                //console.log(textPosition)
                path.name = this._nameChange(mapType, name);
                path.position = position;
                path.textX = textPosition[0];
                path.textY = textPosition[1];
                return path;
            },

            /**
             * 获取缩放
             */
            _getTransform : function (bbox, mapSeries, rate) {
                var series = this.series;
                var mapLocation;
                var x;
                var cusX;
                var y;
                var cusY;
                var width;
                var height;
                var zrWidth = this.zr.getWidth();
                var zrHeight = this.zr.getHeight();
                //上下左右留空
                var padding = Math.round(Math.min(zrWidth, zrHeight) * 0.02);
                for (var key in mapSeries) {
                    mapLocation = series[key].mapLocation || {};
                    cusX = mapLocation.x || cusX;
                    cusY = mapLocation.y || cusY;
                    width = mapLocation.width || width;
                    height = mapLocation.height || height;
                }

                //x = isNaN(cusX) ? padding : cusX;
                x = this.parsePercent(cusX, zrWidth);
                x = isNaN(x) ? padding : x;
                //y = isNaN(cusY) ? padding : cusY;
                y = this.parsePercent(cusY, zrHeight);
                y = isNaN(y) ? padding : y;
                if (typeof width == &#x27;undefined&#x27;) {
                    width = zrWidth - x - 2 * padding;
                }
                else {
                    width = this.parsePercent(width, zrWidth);
                }

                if (typeof height == &#x27;undefined&#x27;) {
                    height = zrHeight - y - 2 * padding;
                }
                else {
                    height = this.parsePercent(height, zrHeight);
                }

                var mapWidth = bbox.width;
                var mapHeight = bbox.height;
                //var minScale;
                var xScale = (width / rate) / mapWidth;
                var yScale = height / mapHeight;
                if (xScale &gt; yScale) {
                    //minScale = yScale;
                    xScale = yScale * rate;
                    width = mapWidth * xScale;
                }
                else {
                    //minScale = xScale;
                    yScale = xScale;
                    xScale = yScale * rate;
                    height = mapHeight * yScale;
                }
                //console.log(minScale)
                //width = mapWidth * minScale;
                //height = mapHeight * minScale;

                if (isNaN(cusX)) {
                    cusX = cusX || &#x27;center&#x27;;
                    switch (cusX + &#x27;&#x27;) {
                        case &#x27;center&#x27; :
                            x = Math.floor((zrWidth - width) / 2);
                            break;
                        case &#x27;right&#x27; :
                            x = zrWidth - width;
                            break;
                        //case &#x27;left&#x27; :
                        //x = padding;
                    }
                }
                //console.log(cusX,x,zrWidth,width,&#x27;kener&#x27;)
                if (isNaN(cusY)) {
                    cusY = cusY || &#x27;center&#x27;;
                    switch (cusY + &#x27;&#x27;) {
                        case &#x27;center&#x27; :
                            y = Math.floor((zrHeight - height) / 2);
                            break;
                        case &#x27;bottom&#x27; :
                            y = zrHeight - height;
                            break;
                        //case &#x27;top&#x27; :
                        //y = padding;
                    }
                }
                //console.log(x,y,width,height)
                return {
                    left : x,
                    top : y,
                    width: width,
                    height: height,
                    //scale : minScale * 50,  // wtf 50
                    baseScale : 1,
                    scale : {
                        x : xScale,
                        y : yScale
                    }
                    //translate : [x + width / 2, y + height / 2]
                };
            },

            /**
             * 构建地图
             * @param {Object} mapData 图形数据
             * @param {Object} valueData 用户数据
             */
            _buildMap : function (mapType, mapData, valueData, mapSeries) {
                var series = this.series;
                var legend = this.component.legend;
                var dataRange = this.component.dataRange;
                var seriesName;
                var name;
                var data;
                var value;
                var queryTarget;
                var defaultOption = this.ecTheme.map;

                var color;
                var font;
                var style;
                var highlightStyle;

                var shape;
                var textShape;
                for (var i = 0, l = mapData.length; i &lt; l; i++) {
                    style = zrUtil.clone(mapData[i]);
                    highlightStyle = {
                        name : style.name,
                        path : style.path,
                        position : zrUtil.clone(style.position)
                    };
                    name = style.name;
                    data = valueData[name]; // 多系列合并后的数据
                    if (data) {
                        queryTarget = [data]; // level 3
                        seriesName = &#x27;&#x27;;
                        for (var j = 0, k = data.seriesIndex.length; j &lt; k; j++) {
                            // level 2
                            queryTarget.push(series[data.seriesIndex[j]]);
                            seriesName += series[data.seriesIndex[j]].name + &#x27; &#x27;;
                            if (legend
                                &amp;&amp; this._showLegendSymbol[mapType]
                                &amp;&amp; legend.hasColor(series[data.seriesIndex[j]].name)
                                ) {
                                this.shapeList.push(new CircleShape({
                                    zlevel : this._zlevelBase + 1,
                                    position : zrUtil.clone(style.position),
                                    _mapType : mapType,
                                    /*
                                     _geo : this.pos2geo(
                                     mapType, [style.textX + 3 + j * 7, style.textY - 10]
                                     ),
                                     */
                                    style : {
                                        x : style.textX + 3 + j * 7,
                                        y : style.textY - 10,
                                        r : 3,
                                        color : legend.getColor(
                                            series[data.seriesIndex[j]].name
                                        )
                                    },
                                    hoverable : false
                                }));
                            }
                        }
                        queryTarget.push(defaultOption); // level 1
                        value = data.value;
                    }
                    else {
                        data = &#x27;-&#x27;;
                        seriesName = &#x27;&#x27;;
                        queryTarget = [];
                        for (var key in mapSeries) {
                            queryTarget.push(series[key]);
                        }
                        queryTarget.push(defaultOption);
                        value = &#x27;-&#x27;;
                    }

                    // 值域控件控制
                    color = (dataRange &amp;&amp; !isNaN(value))
                        ? dataRange.getColor(value)
                        : null;

                    // 常规设置
                    style.color = style.color
                        || color
                        || this.getItemStyleColor(
                            this.deepQuery(queryTarget, &#x27;itemStyle.normal.color&#x27;),
                            data.seriesIndex, -1, data
                        )
                        || this.deepQuery(
                            queryTarget, &#x27;itemStyle.normal.areaStyle.color&#x27;
                        );
                    style.strokeColor = style.strokeColor
                        || this.deepQuery(queryTarget, &#x27;itemStyle.normal.borderColor&#x27;);
                    style.lineWidth = style.lineWidth
                        || this.deepQuery(queryTarget, &#x27;itemStyle.normal.borderWidth&#x27;);

                    // 高亮
                    highlightStyle.color = this.getItemStyleColor(
                        this.deepQuery(queryTarget, &#x27;itemStyle.emphasis.color&#x27;),
                        data.seriesIndex, -1, data
                    )
                        || this.deepQuery(
                            queryTarget, &#x27;itemStyle.emphasis.areaStyle.color&#x27;
                        )
                        || style.color;
                    highlightStyle.strokeColor = this.deepQuery(
                        queryTarget, &#x27;itemStyle.emphasis.borderColor&#x27;
                    )
                        || style.strokeColor;
                    highlightStyle.lineWidth = this.deepQuery(
                        queryTarget, &#x27;itemStyle.emphasis.borderWidth&#x27;
                    )
                        || style.lineWidth;

                    style.brushType = highlightStyle.brushType = style.brushType || &#x27;both&#x27;;
                    style.lineJoin = highlightStyle.lineJoin = &#x27;round&#x27;;
                    style._name = highlightStyle._name = name;

                    font = this.deepQuery(queryTarget, &#x27;itemStyle.normal.label.textStyle&#x27;);
                    // 文字标签避免覆盖单独一个shape
                    textShape = {
                        zlevel : this._zlevelBase + 1,
                        hoverable: this._hoverable[mapType],
                        position : zrUtil.clone(style.position),
                        _mapType : mapType,
                        _geo : this.pos2geo(
                            mapType, [style.textX, style.textY]
                        ),
                        style : {
                            brushType : &#x27;fill&#x27;,
                            x : style.textX,
                            y : style.textY,
                            text : this.getLabelText(name, value, queryTarget, &#x27;normal&#x27;),
                            _name : name,
                            textAlign : &#x27;center&#x27;,
                            color : this.deepQuery(queryTarget, &#x27;itemStyle.normal.label.show&#x27;)
                                ? this.deepQuery(
                                queryTarget,
                                &#x27;itemStyle.normal.label.textStyle.color&#x27;
                            )
                                : &#x27;rgba(0,0,0,0)&#x27;,
                            textFont : this.getFont(font)
                        }
                    };
                    textShape._style = zrUtil.clone(textShape.style);

                    textShape.highlightStyle = zrUtil.clone(textShape.style);
                    if (this.deepQuery(queryTarget, &#x27;itemStyle.emphasis.label.show&#x27;)) {
                        textShape.highlightStyle.text = this.getLabelText(
                            name, value, queryTarget, &#x27;emphasis&#x27;
                        );
                        textShape.highlightStyle.color = this.deepQuery(
                            queryTarget,
                            &#x27;itemStyle.emphasis.label.textStyle.color&#x27;
                        ) || textShape.style.color;
                        font = this.deepQuery(
                            queryTarget,
                            &#x27;itemStyle.emphasis.label.textStyle&#x27;
                        ) || font;
                        textShape.highlightStyle.textFont = this.getFont(font);
                    }
                    else {
                        textShape.highlightStyle.color = &#x27;rgba(0,0,0,0)&#x27;;
                    }

                    shape = {
                        zlevel : this._zlevelBase,
                        hoverable: this._hoverable[mapType],
                        position : zrUtil.clone(style.position),
                        style : style,
                        highlightStyle : highlightStyle,
                        _style: zrUtil.clone(style),
                        _mapType: mapType
                    };
                    if (typeof style.scale != &#x27;undefined&#x27;) {
                        shape.scale = zrUtil.clone(style.scale);
                    }

                    textShape = new TextShape(textShape);
                    switch (shape.style.shapeType) {
                        case &#x27;rectangle&#x27; :
                            shape = new RectangleShape(shape);
                            break;
                        case &#x27;line&#x27; :
                            shape = new LineShape(shape);
                            break;
                        case &#x27;circle&#x27; :
                            shape = new CircleShape(shape);
                            break;
                        case &#x27;polygon&#x27; :
                            shape = new PolygonShape(shape);
                            break;
                        case &#x27;ellipse&#x27;:
                            shape = new EllipseShape(shape);
                            break;
                        default :
                            shape = new PathShape(shape);
                            shape.pathArray = shape._parsePathData(shape.style.path);
                            break;
                    }

                    if (this._selectedMode[mapType] &amp;&amp;
                        this._selected[name]
                        || (data.selected &amp;&amp; this._selected[name] !== false)
                        ) {
                        textShape.style = textShape.highlightStyle;
                        shape.style = shape.highlightStyle;
                    }

                    if (this._selectedMode[mapType]) {
                        this._selected[name] = typeof this._selected[name] != &#x27;undefined&#x27;
                            ? this._selected[name]
                            : data.selected;
                        this._mapTypeMap[name] = mapType;

                        if (typeof data.selectable == &#x27;undefined&#x27; || data.selectable) {
                            shape.clickable = textShape.clickable = true;
                            shape.onclick = textShape.onclick = this.shapeHandler.onclick;
                        }
                    }

                    if (this._hoverable[mapType]
                        &amp;&amp; (typeof data.hoverable == &#x27;undefined&#x27; || data.hoverable)
                        ) {
                        textShape.hoverable = shape.hoverable = true;
                        shape.hoverConnect = textShape.id;
                        textShape.hoverConnect = shape.id;
                        shape.onmouseover = textShape.onmouseover = this.hoverConnect;
                    }
                    else {
                        textShape.hoverable = shape.hoverable = false;
                    }

                    // console.log(name,shape);
                    ecData.pack(
                        textShape,
                        {
                            name: seriesName,
                            tooltip: this.deepQuery(queryTarget, &#x27;tooltip&#x27;)
                        },
                        0,
                        data, 0,
                        name
                    );
                    this.shapeList.push(textShape);

                    ecData.pack(
                        shape,
                        {
                            name: seriesName,
                            tooltip: this.deepQuery(queryTarget, &#x27;tooltip&#x27;)
                        },
                        0,
                        data, 0,
                        name
                    );
                    this.shapeList.push(shape);
                }
                //console.log(this._selected);
            },

            // 添加标注
            _buildMark : function (mapType, mapSeries) {
                this._seriesIndexToMapType = this._seriesIndexToMapType || {};
                this.markAttachStyle = this.markAttachStyle || {};
                var position = [
                    this._mapDataMap[mapType].transform.left,
                    this._mapDataMap[mapType].transform.top
                ];
                for (var sIdx in mapSeries) {
                    this._seriesIndexToMapType[sIdx] = mapType;
                    this.markAttachStyle[sIdx] = {
                        position : position,
                        _mapType : mapType
                    };
                    this.buildMark(sIdx);
                }
            },

            // 位置转换
            getMarkCoord : function (seriesIndex, mpData) {
                return (mpData.geoCoord || _geoCoord[mpData.name])
                    ? this.geo2pos(
                    this._seriesIndexToMapType[seriesIndex],
                        mpData.geoCoord || _geoCoord[mpData.name]
                )
                    : [0, 0];
            },

            getMarkGeo : function(mpData) {
                return mpData.geoCoord || _geoCoord[mpData.name];
            },

            _nameChange : function (mapType, name) {
                return this._nameMap[mapType][name] || name;
            },

            /**
             * 根据lable.format计算label text
             */
            getLabelText : function (name, value, queryTarget, status) {
                var formatter = this.deepQuery(
                    queryTarget,
                        &#x27;itemStyle.&#x27; + status + &#x27;.label.formatter&#x27;
                );
                if (formatter) {
                    if (typeof formatter == &#x27;function&#x27;) {
                        return formatter(
                            name,
                            value
                        );
                    }
                    else if (typeof formatter == &#x27;string&#x27;) {
                        formatter = formatter.replace(&#x27;{a}&#x27;,&#x27;{a0}&#x27;)
                            .replace(&#x27;{b}&#x27;,&#x27;{b0}&#x27;);
                        formatter = formatter.replace(&#x27;{a0}&#x27;, name)
                            .replace(&#x27;{b0}&#x27;, value);
                        return formatter;
                    }
                }
                else {
                    return name;
                }
            },

            _findMapTypeByPos : function (mx, my) {
                var transform;
                var left;
                var top;
                var width;
                var height;
                for (var mapType in this._mapDataMap) {
                    transform = this._mapDataMap[mapType].transform;
                    if (!transform || !this._roamMap[mapType]) {
                        continue;
                    }
                    left = transform.left;
                    top = transform.top;
                    width = transform.width;
                    height = transform.height;
                    if (mx &gt;= left
                        &amp;&amp; mx &lt;= (left + width)
                        &amp;&amp; my &gt;= top
                        &amp;&amp; my &lt;= (top + height)
                        ) {
                        return mapType;
                    }
                }
                return;
            },

            /**
             * 滚轮缩放
             */
            __onmousewheel : function (param) {
                var event = param.event;
                var mx = zrEvent.getX(event);
                var my = zrEvent.getY(event);
                var delta = zrEvent.getDelta(event);
                //delta = delta &gt; 0 ? (-1) : 1;
                var mapType = this._findMapTypeByPos(mx, my);
                if (mapType) {
                    zrEvent.stop(event);
                    var transform = this._mapDataMap[mapType].transform;
                    var left = transform.left;
                    var top = transform.top;
                    var width = transform.width;
                    var height = transform.height;
                    // 位置转经纬度
                    geoAndPos = this.pos2geo(mapType, [mx - left, my - top]);
                    if (delta &gt; 0) {
                        delta = 1.2;        // 放大
                        if (typeof this._scaleLimitMap[mapType].max != &#x27;undeined&#x27;
                            &amp;&amp; transform.baseScale &gt;= this._scaleLimitMap[mapType].max
                            ) {
                            return;     // 缩放限制
                        }
                    }
                    else {
                        delta = 1 / 1.2;    // 缩小
                        if (typeof this._scaleLimitMap[mapType].min != &#x27;undeined&#x27;
                            &amp;&amp; transform.baseScale &lt;= this._scaleLimitMap[mapType].min
                            ) {
                            return;     // 缩放限制
                        }
                    }
                    transform.baseScale *= delta;
                    transform.scale.x *= delta;
                    transform.scale.y *= delta;
                    transform.width = width * delta;
                    transform.height = height * delta;

                    this._mapDataMap[mapType].hasRoam = true;
                    this._mapDataMap[mapType].transform = transform;
                    // 经纬度转位置
                    geoAndPos = this.geo2pos(mapType, geoAndPos);
                    // 保持视觉中心
                    transform.left -= geoAndPos[0] - (mx - left);
                    transform.top -= geoAndPos[1] - (my - top);
                    this._mapDataMap[mapType].transform = transform;

                    this.clearEffectShape(true);
                    for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                        if(this.shapeList[i]._mapType == mapType) {
                            this.shapeList[i].position[0] = transform.left;
                            this.shapeList[i].position[1] = transform.top;
                            if (this.shapeList[i].type == &#x27;path&#x27;
                                || this.shapeList[i].type == &#x27;symbol&#x27;
                                || this.shapeList[i].type == &#x27;circle&#x27;
                                || this.shapeList[i].type == &#x27;rectangle&#x27;
                                || this.shapeList[i].type == &#x27;polygon&#x27;
                                || this.shapeList[i].type == &#x27;line&#x27;
                                || this.shapeList[i].type == &#x27;ellipse&#x27;
                                ) {
                                this.shapeList[i].scale[0] *= delta;
                                this.shapeList[i].scale[1] *= delta;
                            }
                            else if (this.shapeList[i].type == &#x27;mark-line&#x27;) {
                                this.shapeList[i].style.pointListLength = undefined;
                                this.shapeList[i].style.pointList = false;
                                geoAndPos = this.geo2pos(mapType, this.shapeList[i]._geo[0]);
                                this.shapeList[i].style.xStart = geoAndPos[0];
                                this.shapeList[i].style.yStart = geoAndPos[1];
                                geoAndPos = this.geo2pos(mapType, this.shapeList[i]._geo[1]);
                                this.shapeList[i].style.xEnd = geoAndPos[0];
                                this.shapeList[i].style.yEnd = geoAndPos[1];
                            }
                            else if  (this.shapeList[i].type == &#x27;icon&#x27;) {
                                geoAndPos = this.geo2pos(mapType, this.shapeList[i]._geo);
                                this.shapeList[i].style.x = this.shapeList[i].style._x =
                                    geoAndPos[0] - this.shapeList[i].style.width / 2;
                                this.shapeList[i].style.y = this.shapeList[i].style._y =
                                    geoAndPos[1] - this.shapeList[i].style.height / 2;
                            }
                            else {
                                geoAndPos = this.geo2pos(mapType, this.shapeList[i]._geo);
                                this.shapeList[i].style.x = geoAndPos[0];
                                this.shapeList[i].style.y = geoAndPos[1];
                                if (this.shapeList[i].type == &#x27;text&#x27;) {
                                    this.shapeList[i]._style.x = this.shapeList[i].highlightStyle.x
                                        = geoAndPos[0];
                                    this.shapeList[i]._style.y = this.shapeList[i].highlightStyle.y
                                        = geoAndPos[1];
                                }
                            }

                            this.zr.modShape(this.shapeList[i].id);
                        }
                    }

                    this.zr.refresh();

                    var self = this;
                    clearTimeout(this._refreshDelayTicket);
                    this._refreshDelayTicket = setTimeout(
                        function(){
                            self &amp;&amp; self.shapeList &amp;&amp; self.animationEffect();
                        },
                        100
                    );

                    this.messageCenter.dispatch(
                        ecConfig.EVENT.MAP_ROAM,
                        param.event,
                        {type : &#x27;scale&#x27;},
                        this.myChart
                    );
                }
            },

            __onmousedown : function (param) {
                var target = param.target;
                if (target &amp;&amp; target.draggable) {
                    return;
                }
                var event = param.event;
                var mx = zrEvent.getX(event);
                var my = zrEvent.getY(event);
                var mapType = this._findMapTypeByPos(mx, my);
                if (mapType) {
                    this._mousedown = true;
                    this._mx = mx;
                    this._my = my;
                    this._curMapType = mapType;

                    this.zr.on(zrConfig.EVENT.MOUSEUP, this._onmouseup);
                    var self = this;
                    setTimeout(function (){
                        self.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                    },100);
                }

            },

            __onmousemove : function (param) {
                if (!this._mousedown || !this._isAlive) {
                    return;
                }
                var event = param.event;
                var mx = zrEvent.getX(event);
                var my = zrEvent.getY(event);
                var transform = this._mapDataMap[this._curMapType].transform;
                transform.hasRoam = true;
                transform.left -= this._mx - mx;
                transform.top -= this._my - my;
                this._mx = mx;
                this._my = my;
                this._mapDataMap[this._curMapType].transform = transform;

                for (var i = 0, l = this.shapeList.length; i &lt; l; i++) {
                    if(this.shapeList[i]._mapType == this._curMapType) {
                        this.shapeList[i].position[0] = transform.left;
                        this.shapeList[i].position[1] = transform.top;
                        this.zr.modShape(this.shapeList[i].id);
                    }
                }

                this.messageCenter.dispatch(
                    ecConfig.EVENT.MAP_ROAM,
                    param.event,
                    {type : &#x27;move&#x27;},
                    this.myChart
                );

                this.clearEffectShape(true);
                this.zr.refresh();

                this._justMove = true;
                zrEvent.stop(event);
            },

            __onmouseup : function (param) {
                var event = param.event;
                this._mx = zrEvent.getX(event);
                this._my = zrEvent.getY(event);
                this._mousedown = false;
                var self = this;
                setTimeout(function (){
                    self._justMove &amp;&amp; self.animationEffect();
                    self._justMove = false;
                    self.zr.un(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                    self.zr.un(zrConfig.EVENT.MOUSEUP, self._onmouseup);
                },120);
            },

            /**
             * 点击响应
             */
            onclick : function (param) {
                if (!this.isClick || !param.target || this._justMove || param.target.type == &#x27;icon&#x27;) {
                    // 没有在当前实例上发生点击直接返回
                    return;
                }
                this.isClick = false;

                var target = param.target;
                var name = target.style._name;
                var len = this.shapeList.length;
                var mapType = target._mapType || &#x27;&#x27;;

                if (this._selectedMode[mapType] == &#x27;single&#x27;) {
                    for (var p in this._selected) {
                        // 同一地图类型
                        if (this._selected[p] &amp;&amp; this._mapTypeMap[p] == mapType) {
                            // 复位那些生效shape（包括文字）
                            for (var i = 0; i &lt; len; i++) {
                                if (this.shapeList[i].style._name == p
                                    &amp;&amp; this.shapeList[i]._mapType == mapType
                                    ) {
                                    this.shapeList[i].style = this.shapeList[i]._style;
                                    this.zr.modShape(this.shapeList[i].id);
                                }
                            }
                            p != name &amp;&amp; (this._selected[p] = false);
                        }
                    }
                }

                this._selected[name] = !this._selected[name];

                // 更新当前点击shape（包括文字）
                for (var i = 0; i &lt; len; i++) {
                    if (this.shapeList[i].style._name == name
                        &amp;&amp; this.shapeList[i]._mapType == mapType
                        ) {
                        if (this._selected[name]) {
                            this.shapeList[i].style = this.shapeList[i].highlightStyle;
                        }
                        else {
                            this.shapeList[i].style = this.shapeList[i]._style;
                        }
                        this.zr.modShape(this.shapeList[i].id);
                    }
                }
                this.messageCenter.dispatch(
                    ecConfig.EVENT.MAP_SELECTED,
                    param.event,
                    {
                        selected : this._selected,
                        target : name
                    },
                    this.myChart
                );
                this.zr.refresh();

                var self = this;
                setTimeout(function(){
                    self.zr.trigger(
                        zrConfig.EVENT.MOUSEMOVE,
                        param.event
                    );
                },100)
            },

            /**
             * 刷新
             */
            refresh : function (newOption) {
                if (newOption) {
                    this.option = newOption;
                    this.series = newOption.series;
                }

                if (this._mapDataRequireCounter &gt; 0) {
                    this.clear();
                }
                else {
                    this.backupShapeList();
                }
                this._buildShape();
                this.zr.refreshHover();
            },

            /**
             * 值域响应
             * @param {Object} param
             * @param {Object} status
             */
            ondataRange : function (param, status) {
                if (this.component.dataRange) {
                    this.refresh();
                    status.needRefresh = true;
                }
                return;
            },

            /**
             * 平面坐标转经纬度
             */
            pos2geo : function (mapType, p) {
                if (!this._mapDataMap[mapType].transform) {
                    return null;
                }
                return this._mapDataMap[mapType].projection.pos2geo(
                    this._mapDataMap[mapType].transform, p
                );
            },

            /**
             * 公开接口 : 平面坐标转经纬度
             */
            getGeoByPos : function (mapType, p) {
                if (!this._mapDataMap[mapType].transform) {
                    return null;
                }
                var position = [
                    this._mapDataMap[mapType].transform.left,
                    this._mapDataMap[mapType].transform.top
                ];
                if (p instanceof Array) {
                    p[0] -= position[0];
                    p[1] -= position[1];
                }
                else {
                    p.x -= position[0];
                    p.y -= position[1];
                }
                return this.pos2geo(mapType, p);
            },

            /**
             * 经纬度转平面坐标
             * @param {Object} p
             */
            geo2pos : function (mapType, p) {
                if (!this._mapDataMap[mapType].transform) {
                    return null;
                }
                return this._mapDataMap[mapType].projection.geo2pos(
                    this._mapDataMap[mapType].transform, p
                );
            },

            /**
             * 公开接口 : 经纬度转平面坐标
             */
            getPosByGeo : function (mapType, p) {
                if (!this._mapDataMap[mapType].transform) {
                    return null;
                }
                var pos = this.geo2pos(mapType, p);
                pos[0] += this._mapDataMap[mapType].transform.left;
                pos[1] += this._mapDataMap[mapType].transform.top;
                return pos;
            },

            /**
             * 公开接口 : 地图参考坐标
             */
            getMapPosition : function (mapType) {
                if (!this._mapDataMap[mapType].transform) {
                    return null;
                }
                return [
                    this._mapDataMap[mapType].transform.left,
                    this._mapDataMap[mapType].transform.top
                ];
            },

            /*
             appendShape : function (mapType, shapeList) {
             shapeList = shapeList instanceof Array
             ? shapeList : [shapeList];
             for (var i = 0, l = shapeList.length; i &lt; l; i++) {
             if (typeof shapeList[i].zlevel == &#x27;undefined&#x27;) {
             shapeList[i].zlevel = this._zlevelBase + 1;
             }
             shapeList[i]._mapType = mapType;
             this.shapeList.push(shapeList[i]);
             this.zr.addShape(shapeList[i]);
             }
             this.zr.refresh();
             },
             */

            /**
             * 释放后实例不可用
             */
            dispose : function () {
                this.clear();
                this.shapeList = null;
                this.effectList = null;
                this._isAlive = false;
                if (this._needRoam) {
                    this.zr.un(zrConfig.EVENT.MOUSEWHEEL, this._onmousewheel);
                    this.zr.un(zrConfig.EVENT.MOUSEDOWN, this._onmousedown);
                }
            }
        };

        zrUtil.inherits(Map, ChartBase);
        zrUtil.inherits(Map, ComponentBase);

        // 图表注册
        require(&#x27;../chart&#x27;).define(&#x27;map&#x27;, Map);

        return Map;
    });

    define(&#x27;echarts/util/mapData/geoJson/china_geo&#x27;,[],function() {
        return {&quot;type&quot;:&quot;FeatureCollection&quot;,&quot;features&quot;:[{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;xin_jiang&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;新疆&quot;,&quot;cp&quot;:[84.9023,41.748],&quot;childNum&quot;:18},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@@ρȁôƧƦóəʵסʵóƪԫʵѵͩƧͩړυࡓɛʵ@ȃ@óᇑѵƨɝɚôóНѺͩɜ̏ԭʵôƧɞñ@υƩ݇ȂóƩƧ@ѵȂυƥŌਗ॥ɛóʵѵƧѹ݇̍ࢯəɞυρͩ̏óਙƨƧŋôōó̍ͩóʵןóŋړͪƧѶ@ɜԭԫƦɛȄ̍ɝȄöςƩȂ̏ñȀ̏ƩóóŎə@Ő̎@ɞȀɝŎôƨóנѵȄƧ@óŏɝóɜôŎ̍ͨςŎ@ƨóôƨɞ݈ʶóƨφó̎Ȁƨ̍ԮòѸԮמ@ѺȀ@ƪၬֆòȂñ̐òȂɜóƨ̒Ŏ̑߼@φρȀ@Ő๐ς̎Ƨφ@ɝφڔ೦Ԯǿࢰ@ƦŏԮƨƨȄƧ۬ɜʶڔŐɚɚóŐôƨ߼ôƧƧó̐ƥóŏѺǿƦȁφƧςƨƧ̒@ɜƥƦυ̐ɛƪͩƩəƪʷ̑ə@ȃƨʵנŋྸōਚԭԪ@ɝƨŋ̒օςʵôƧ&quot;],&quot;encodeOffsets&quot;:[[98730,43786]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;xi_zang&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;西藏&quot;,&quot;cp&quot;:[88.7695,31.6846],&quot;childNum&quot;:7},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ôŌנôʶ̎ͪôóŎƨŌਚƧ̐ôςͪφɚɝࢰ݈̎ѺѶƨôʶ०ɜਘƦŋφѶȁ̍ôŏɚŋ@̑ə@ŏò̍ɜóƥôʷƧ̍φѹԪ̍ע@Ѹʷɜ@ôñנ@Ѷɛɞô̐ŏѶƨѸƧƥōƦôŏô@ƧôƩ̒ŋƨŌƦǿô̎ɜȁ̒óʶѶôôО̒ςƥɜНφσɛȁ̎υƨఱƧŏ@ʵƥ@ŌóóóͩƨƧóŋ̑õóɞóɝԩͪɝρôƧ̍ƧѹͨڑŎ̑ōóƧࢭͩ̏ѵɝóఱóóԪυô@̒ƥŌ̏Ƨ̑Ȅ݇ŎƧѵӏ@ɛõŏɛȄôӒƧŌѵǿɝƧŋԫ@̏ʴƥ@óǿ̑Ȁóǿ̍ςóóυô@ʶɛñρƦƩŐó̎óѵó̑ͪࢯОóɜןƧ̏ƥȄ߻̎̏̐ןŎɝɜöɞƩȀôöɛȀóͪ̐ƨƪ̍̎ȂƥԪυО@φɞôƪ&quot;],&quot;encodeOffsets&quot;:[[80911,35146]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;nei_meng_gu&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;内蒙古&quot;,&quot;cp&quot;:[117.5977,44.3408],&quot;childNum&quot;:12},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ኊȁ૊ö߼ƩɜɛנñԮɛѶóԮô@ȁѸóמ̎ගѺၬ@߼ʶԮӒ߼̎@ŐѹӒ̒Ԫƨöග̑ѶȄ̒ς।ѶɚöɞɜʴڔôôȂ̎ѺȀςƨƪóԪɜôɛОਕڔԭѵ̍ѹȂԫɛƥ̍Ȃóɜ̎ô@ʶ݊ੲࢮʵږͪנƨôȂƧ̐ͪ@ŐƦƨφԬѶɜôƦ@ŐƧôôƦəŐ̏@ŐڒѶԬô̐ʳԩНςōôŏɞ@ƨȂѶəóƧ̒ػ̎ó̐Őנóƨô̒@ƨɚɚ@עԫɛɛ@ȁυͩƥʳòևρ̑ࡗƧͪ༃ॣԮփ̎Ʀ@ôô@ôō@@ȁѵóƨ̍υȃóʵɛƨƥóυȂóəƪ̐ρƧͩɜԭڔȄ̎عƧȁ̐ŏó̍ɛƥƧ̑óρŐ@Ƨ̏ɝəɛ߻ͩ̍ͩɝО̍ƪƧóóӓƨóƧʳ݇@ɝςƪ@ʴƩƧƦôƨɛȄəƧŋυóͩѵ@ɝǿóŌן̍ɛóО̍̑̏ôȁ̍ŏòȁñóƦͩ@ǿə@ɛƧ̑ρȁυô̍օѹóȃə@ȂσʵѷƪòƩ̍ôó߻ۯôʳƧóõʵѵóѹɜ̍ȂѹôɛŌφֈƩͨρóυӑóޟఱ̑݇ͪóƪƨŌóȄڔԬƩςםñ̑ȃѵŐԭŏƨȁɛǿρôõɚɛóƧОə@ѹ̐ѵöԪͨôͪɛ̒ןŏƧƥóôƥƧɛŌôóɝó@̒݇Ӓ̒Ō@Ŏԭࢰ&quot;],&quot;encodeOffsets&quot;:[[99540,43830]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;qing_hai&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;青海&quot;,&quot;cp&quot;:[96.2402,35.4199],&quot;childNum&quot;:8},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ƨ@ôƪ݈ȁƪ@φɝòóƨԮʶɛ̐ѹͪôОəóƧɞᇒѶ@ôږô@ǿѶƪȁςɜͩφςŋɞôѶɛƨŌɞ@ɚςŐñԪॢͩƨȂɞóƨŐ̎ŏעӏ̎óƧƦô̒ȁɜςͩ̒ɚɛƨôƨɝφɛóȁƨŋóóɚͩƨóóƩ@ƧəŋƦƩ̍@ƧƧôǿυ̑@ȁɞǿõŏρƥסɚƧóτԫɞôƧƦ@ñȃòñƥóυôôѹѵ@ŏ̏Ȅɝó@ȂəŌóəѹƦ@Ő̍Ōυ݈ԩŐƧóôƧ̑ôʵɞƧ̑ѵôƩɞƧ̑óНѵóôʵ̑ɛȂó̍ƥȀƧŋ̑Ōóƪ@ƨóóŐƥƦŎѷƨѵƧ̏Őɝóѵɜן@óòɛ@ѷʸס@ԩ̎υѺƨ̎óʸôƦɛñ̎@Őɚ@̒əŌóŐ̎&quot;],&quot;encodeOffsets&quot;:[[91890,36945]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;si_chuan&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;四川&quot;,&quot;cp&quot;:[102.9199,30.1904],&quot;childNum&quot;:21},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ôôŋó̑Ԯ̒ɛОמͪƨōöͫ߼ƥôȃƨóóñôƧóƧôōڔŏƨŐ@ŎôòƥѺŎ@ōɜóנôǿôƦôԮ̍ɜôɚƧñɛɚȁ̍Ƨɛևυ@óóôŋρԭɝ@Ƨʸ̍ŏυɜƧƧóƧƨȁρ̍ƨȃɚôʵφóô̑̏Ȃ̑ʵɜʵɞ@ƨʳסƩóŎəóɜƧôƩƧρóôôô@ŎƧƨƨƪѹó̍̍Ʃ@̏ѹНôޟ̍ƩóƪυɝɛəƨôŎɛȀ@Ȃ@ñɝʶ@Ōρנ̏õóɛͨƨȂѵОɛʵ@̏ƩŐó߼Ƨల̍φɜȂυτɛОρƦɝƨóƪ̒Ѷɝƨóʶ̒óƨƨôԪŏφ݇̎ŋ@ŏѺƥôɚɚŋ@ȁɞô̐ȃ@ŐѶóѺφóƦôñòòȄ&quot;],&quot;encodeOffsets&quot;:[[104220,34336]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;hei_long_jiang&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;黑龙江&quot;,&quot;cp&quot;:[128.1445,48.5156],&quot;childNum&quot;:13},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ᇔȂਚНƨŐѶŏöƥςŏñƧƦóƨȁ@óƨóȁφӑóóƨóǿ̎̑ôНɞó̑ɜə߼̎ǿ̒ôڒӑφ@Ƨȁ̎̏ƥƩ̎ρశôȂςƨφ@נɞ݈̑ƥƧɛƨʵƧȃƥ@Ƨƥ@ŏ̑ԩôɝρρóɛƧƩͩƧó߻ʸ̍ʷѹƥɞڕõ̍öɝυ̍ȂƧ̐̑ŏóƨñŋѹóóȁ̍̏Ԭõʸ̏ŏ@ǿ̍@ƧОυ@ñƨòȀƥŎ̑ŐѵóɛŌóȂԫōƧŎѹñ̍ʶóОן@Ƨ̎Ѷô@Ȃ@óŎó@@ó̍ƥԭք༄।ƨͩ̒ࡘςñֈƦʴφͪ@ȂɜɜסԬə@Ƨə̑@Ƨóןô̏ŏ̍ô̑ؼôƨѵɚƧȁɝ@óŐρŎԪО̏ʴ&quot;],&quot;encodeOffsets&quot;:[[124380,54630]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;gan_su&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;甘肃&quot;,&quot;cp&quot;:[95.7129,40.166],&quot;childNum&quot;:14},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ڔôԮࢯ@ō̑ŋ݈ӑ@̑ɞôóôɜŋƦƨôóƨƦנŐɜ̑óͩԩͧѶõѺ̏ɚ@ƨНɜôöəςóɜȀƧȂԮŐѶŏ̒ȄמòƪρړԫôȃƧŋôƩ݈ͩɚ@@ǿɜ@φͩóŏɜӑƧōôǿ̎ôƥƪóõö@ôƨôƧƦôó̒ɜ@ɞŌõʶ̏Ő@ȀóôƨȂ@ʶע@@ƥ୾ӑó̑óŋôʵóɛړ@@ƩöóƩóρɛƨ̑@óʷƥƥ̎ɛƧôōƧǿôͩѵôɝȃɞȁõƧρóó@ōƧŏړŐóŎôƨóƨôòƧôóȄ߻ƦõͬƧŎםͩɜНԭ̑ô̒óŌóƥ@óƨɝσԬƨôעəςƦöŐɝȀ@Ȃφ̒óȀƨƨ̎@ƥƪɚŌ@ƨôƪƧôəͪôôƧŌôȂυɜƧɞƧóəɜ̑ρͪɛ̑Ȃóƨƥ̍ôסӐ̍ŐƧŏɝôƧȁॡͪòԩρŏ@əɝƧŋѵɜɝóρŌυɛͪρƩȂѵ@Ȁڕó@ȄɜʶφࡔڔƨͪѶͪԬʶôƩעʶɚʶƥôóƨςȂ&quot;],&quot;encodeOffsets&quot;:[[98730,43740]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;yun_nan&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;云南&quot;,&quot;cp&quot;:[101.8652,25.1807],&quot;childNum&quot;:16},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ôɞôɝ̒öôŌƧƨôͪôô@ŋƦ@ʶƨŐô߻ƪŏ@̐ɜʶѶНƧȁɜͧöô̐ςן@ŋɞʵ@ò@ȁɜǿóōɚƧɜφɞôƩ̎ƪóޠѺО@̐̎ƪô̎ѺƧƩƨƧ@ōóóôóςƪƨƨóôɛó̑ԭƥŌɛǿɝƨɛͩô@ǿƨȁѺŌɚɛ̍ןѶНɛƧôóƥȁƦͩôŎɞƨ̑ɜòôφ@ƨʵ@ɛѹōóȃəƨυǿóʵρƧƧŌƩɛ̏ȄñƧƧȀɝ̍ԩʶƧ̑υóŌƥʳɚӑóНƥô̑óӒѵʵѹƧӐןôƪφõŌƪ̒ԫŌƧؼƨƨסρȁƧƨȂóʶó@@ʴƨôôφ̎Ŏ@ȀƨƪɚƨóƨôôôςóޤƧŌƩŋƧԪ&quot;],&quot;encodeOffsets&quot;:[[100530,28800]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;guang_xi&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;广西&quot;,&quot;cp&quot;:[108.2813,23.6426],&quot;childNum&quot;:14},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ƦŋѺ̎ڔʵƨŐ@ƦמȄƪôóȂɜŌɚͩɜ@öóɜôôȂƦôɜȁ@ɞφóȄ̎ƨʶɞŋƨʴɚǿ̐̎Ԭ@ôñ@̏ƨρ۫ôɚƨƨНƪŐ̎ƥóƦʵƥŋ@ȃóƥƧ@@ŏɝǿôυƧȁѵɛ@əóŏ̑@@ə̍óƧó@ȁƩρóòНƥô@Ӓ̑@óŎ̍ƥσŎυ@̍ƨ@Ō̑ôóͪƨ̒óŌړ̏Ŏ@ŌôȄѺŎ@ɜƧʶυ@ñóɛƧ̒ɝóōƥͪ&quot;],&quot;encodeOffsets&quot;:[[107011,25335]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;hu_nan&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;湖南&quot;,&quot;cp&quot;:[111.5332,27.3779],&quot;childNum&quot;:14},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@@քɜОƨ@öŐמóƪôƩɚ̒Ő߼ȁςͩɜòƪɜȀòñɝòѺͪ@ŏƨŋóɝôǿƨɚȃóəƨȃѵͩó̍@ȃƨóóƥƨƧ@ʵƦóͩɜɛóñԭɛōυȂ̍ƧƦō@ɛƥɛȀ̑óʷóō̍ƩŏƧОəƧóς۬Ƨ@̐óòԫ@̏̍əȀƧʳɝŌóɞƧƨɜóŐƨò@ȄƧŌρŋóôԪОóʶ@̎óȄ&quot;],&quot;encodeOffsets&quot;:[[111870,29161]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;shan_xi_1&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;陕西&quot;,&quot;cp&quot;:[109.5996,35.6396],&quot;childNum&quot;:10},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ςôöƨɝȂɞȄѶóóͪƨȀóŎƨ̍ɜƦƦôʸ̒@ɜƧςƪôõô@ƪڔ@ôɜóʶôŌô̒୽Ӓ@Ʀ@Ѻ̎ɜѺɛѶôöʶôƨóʴ߼۰óô̎ñƪѸƩτʶ@ȁòŋəѹóǿ̑ʵ@ȁ̒ʷυփô݉ôН̏ط@ȁƨóô̏ƪõ@ʳ̐ʵ@ɝɛŋƩŌɛóןôƧŋ̒ó@ŏ̐ƥ@ŏυ@ƧƧôן̏@ƥȂѹɜəɛóԭ̎ƥóóóȀןɛô@ŎѹōñƦ&quot;],&quot;encodeOffsets&quot;:[[108001,33705]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;guang_dong&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;广东&quot;,&quot;cp&quot;:[113.4668,22.8076],&quot;childNum&quot;:21},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@@Ȃôôƨ̎@ɚ̒@ôŐ@ɚѶɜƨȂóφɞȀ@Őƨ@ôƦ@ȄƦŌƥʶƦôôŎôʸ̒ɜǿƦ@ɜƥŎ̎ƨφȁɜŎòƥԮŎƨōóŏɛƧɝəɞƧ߼ɜςȃñȄƦŎ̒ōôòƨəƨɚН@əƨ̏ƪʵυŌəɛóəԭŏəóŏѹρʵɝƦ̏ƥʳѶöō̑óóŋρȀυƧƥɛѹōƧôןɛŏѵ@óŋôʵɝƪԩõ@Ƨō̍@Ƨ@@ƦɝԮƪО@@&quot;,&quot;@@X¯aWĀ@l&quot;],&quot;encodeOffsets&quot;:[[112411,21916],[116325,22697]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;ji_lin&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;吉林&quot;,&quot;cp&quot;:[126.4746,43.5938],&quot;childNum&quot;:9},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@נ@ôН̎ʵѺòƨōԬŎôȁɜŋѶô̒ŏƦōñǿòƧφ@ƨН̎@@Ȁ̐Őöʷ̐ԫ̎ôȂѺôòŌôƧ̒Őƨ̏̎ȁφ@ŋƩͩםȃƨ@ȁ̑ʶ@Ōóôɛƥѹ̑συ݇@ɜρƧȃࢯƨôəȂɛōƩɛ̏υρóõƪʴυφ@ʶôŌóρք@ɜƧ@ɝǿƧͪρȀƩó̏ŐƨȂ̍غړȃɛԮƨͪ̏ςƩôɚφȁƦôɜƧôʶφȄ&quot;],&quot;encodeOffsets&quot;:[[126181,47341]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;he_bei&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;河北&quot;,&quot;cp&quot;:[115.4004,37.9688],&quot;childNum&quot;:11},&quot;geometry&quot;:{&quot;type&quot;:&quot;MultiPolygon&quot;,&quot;coordinates&quot;:[[&quot;@@Ʃ̒̏ŌѺ̒ƩóȄƧŌƥͪòôñȂ̎ŐóȂ̒̐̎ôНɜנ̎ôŋɞȀѶ@ôͪφƨŌɚɜȃóƧƨƥƪ@ʳƩɞρ݈@υНφʵɜƦρƨƧ̍ɝóɛѹ̍ρŏ̑ôóƨ@ƧƦôƨɛ@ƥƨ@ȂƦ@@ôəŐƧʶƨŌυ̍̎ɛŋôōɝ@óƧ̍ƦʵѵʳôʵɜŏςôƪŋƨŌɚ@ôНƥƧ@ōѸɛ̐ô̎ʵѵНԭ@̍̍Ƨò@ȁɝ@əρυͩƪ̏ƩõƧŎƧōóॡȄɛʶɜȀ@ɞςѶƧƥςɛŐ@ɚɜɜ@Ŏôôςƪς&quot;],[&quot;@@õə@Ƨɛ@ŐóƦφô&quot;]],&quot;encodeOffsets&quot;:[[[117271,40455]],[[120061,41040]]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;hu_bei&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;湖北&quot;,&quot;cp&quot;:[112.2363,31.1572],&quot;childNum&quot;:17},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ñȄυƦöŐƩóנƨƨφ@@Ő̏Ʀ@Ő̑ôƨŌנóɜôƪŋɜŌѶօڔə݈òɞōɜŎôӏƦóƨô̒óôȃƨó̎ŐôƧƪ@ƨȁςƧə̑̎Н@̍Ƨŏρôԭͩԫ̍ʵƧóȀôɞƧŌ@ŐѹͩñòɞñɛǿƩɛñρͪ߻Ȃ̑ŏƪəƩóםôõŏƧ@ɛНƥȄó̑ѺƧôφóƨƨƦƪóɜŐôóòôƨóφ̐ƨóƦ̎&quot;],&quot;encodeOffsets&quot;:[[112860,31905]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;gui_zhou&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;贵州&quot;,&quot;cp&quot;:[106.6113,26.9385],&quot;childNum&quot;:9},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ɜȀƦŋԮô̒ɚôōעƪƧʴɝ@ɛʶ̒ʶ̐ȁƦóȂô@ôŏ@ōôƨʶѸô@ʶƨɞó@ōτöòυƨ@@əƨô@ɛ̒@Ʀɜôȃ@̍ôʵԩНôóςŌƨŋ@ȃƧñôŏƧɛƨôɝƧʵ̍ôȃυ@ɝɛȂƥóóȁɛóõôɛ@əͪɛŋôȁƩóםȃ@ƥƧŏړʶѹ̍ƥŌƦȂóôɜƨѵО̎נəɜѹŋƧȂ@ȀóɜͪɞƧ&quot;],&quot;encodeOffsets&quot;:[[106651,27901]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;shan_dong&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;山东&quot;,&quot;cp&quot;:[118.7402,36.4307],&quot;childNum&quot;:17},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@Ʃ̐φͪɚςɞ@@Ȃƨñ̎̎Ԯ@ѶОƨƧڔ@φН̑ŋ@Ʃ̒ǿ̎@ƨɜԬςôʶ̐ʶöԫƨƧנƥɜŎôō̎@ôŏóρƧŏԫôóƧԩó@ƥɜƧԭóƨʵɛƨ߻ӑɜНԩóô̑óƧʳəóɛƧ@õȀƧ̍ȃɛŐóŏυО̍óɝƩԩ@ƧɚԫȄɚʶƨɞʶԪ̐ړɛƪ̒&quot;],&quot;encodeOffsets&quot;:[[118261,37036]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;jiang_xi&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;江西&quot;,&quot;cp&quot;:[116.0156,27.29],&quot;childNum&quot;:11},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ƧȄôɚəȄ̎ʶԬԮͪςóƨŐƪτɞƦōƥƧ@ŏςôóŐôô̒ʷѶƪƩƩǿ@ō̒ɛôυ@Ƨȁѹɛəƨѹ̑ƨ̏óƥѵʷô̍ɛȁôŏɝǿƧԫƧôʳƥōòȃρȄ߻ɛɝƨɞɚɜƨôŐƧŎԭōñƦòԮɜôɛôͪƥ@ʶƧƨôƦƧô@Ȅô̎Ѷͪ&quot;],&quot;encodeOffsets&quot;:[[117000,29025]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;he_nan&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;河南&quot;,&quot;cp&quot;:[113.4668,33.8818],&quot;childNum&quot;:17},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@φ̎ƪ̐ɞȄɚ@@Ȃעó̎ŌѺ̒ôֆॢȃôƨŎƨōƪöƩ̑ڔɜԩ̏ɝʵƧəʵԬȃƨəԪ@@Ƨ̒ŏô̍υȁƧɚ̍ôóŋ@ɝƧŋõ̑σ@ŏɜŋôɝ̒ƧɚôôطρóóɛƩ@óƨ̍ŏƧôóȄ̑ôƧóƥôóӐɛōɝŎ݇ñړɚѵֆ@ɞ̏ʶ@ʴƩöó̐&quot;],&quot;encodeOffsets&quot;:[[113040,35416]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;liao_ning&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;辽宁&quot;,&quot;cp&quot;:[122.3438,41.0889],&quot;childNum&quot;:14},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ƨʴƧôôӔƨô̎ƩɞН̎ͪ߼ͪɜɞɚ̐@ƨςŏ̒ôƦƨɜô̎ƪôςǿƨͩɞȀƨ@@ɛςփôóŋ@ʵφυƩʳö॥փρѹס@əɛ@ͩࢯ@ѹʵρƩʶφȀƧ݈̒۬óʸɝŎѵ@ԭԫןɛƧƨƥςɛυʶφО&quot;],&quot;encodeOffsets&quot;:[[122131,42301]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;shan_xi_2&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;山西&quot;,&quot;cp&quot;:[112.4121,37.6611],&quot;childNum&quot;:11},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ɚѺñŌɚôȄѺ̎ֆφóςȂ̒ɜƨɚ@@Ȁƨŋôȃƪѹ̑̐ŋƪ̑Ʃρρóó@ōɛɛ@əɜŏƦρƨρѵ@ɝɛǿɜʵóօѹ̑̍ŋסô@ȁə@ɝȃ̏̍ƩυƧô@Ȃ̐ظóОó݊φք̑ʸ@Ȃ̒ʶôȀ&quot;],&quot;encodeOffsets&quot;:[[113581,39645]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;an_hui&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;安徽&quot;,&quot;cp&quot;:[117.2461,32.0361],&quot;childNum&quot;:17},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ó̎̑Ő@ƨƪѶǿɜ̑φƦʵ̐ƧѵôóƪôôυςƨȂɞŏ@̍ԫôò̑ƥóȃѶͩƧƥôŏѺôŏƦ@ƥͩƧôȁυó@̑ƧɛѵʵƩƪѵ̑ʸóóôŏρó@ŐƦƨƥŎσɝƩ@̎̍Оɚ̒ρƨƧȂôɜςôóظəó̑ƨóɞɛŌ@Őτö̒ƨŌ@ɞôŌ̎óƨəφȂ&quot;],&quot;encodeOffsets&quot;:[[119431,34741]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;fu_jian&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;福建&quot;,&quot;cp&quot;:[118.3008,25.9277],&quot;childNum&quot;:9},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@̎óȁƨӑ̒̎ɚƨͩφŐƨɝ̎ŋóŏρ@ōƨòʳəóƨō̏õɛƧ@ƨѵƧōəŏóŋƧô̑ɝɛʳƥ@@óɛõ@Ƨ̑ƧóȁəƧ̑Ƨ̐@ɚəОƧƧɚóñ̑ŎóʴƨƨԬɞȀóŐɜȂó̎ѶʸôƦƧ̐Ѻ̒ɚƧѺɜƨȂ&quot;],&quot;encodeOffsets&quot;:[[121321,28981]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;zhe_jiang&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;浙江&quot;,&quot;cp&quot;:[120.498,29.0918],&quot;childNum&quot;:11},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@Ѷʶƨɜ@̒φôóȂƨƦͪ@̐Ѹ̍τȂ̒̑נŐמôƪƧôӑ̑@ƥρͩƨօ̏@@υɝó@ŋɛ@ôƩəóƧѵυó@ƩɜŋƧ@̍ŌƧɞυŏƧͪ̍ə̑ƧӒôȂ̍@óφ̑ɜ@ŎƪȀ&quot;],&quot;encodeOffsets&quot;:[[121051,30105]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;jiang_su&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;江苏&quot;,&quot;cp&quot;:[120.0586,32.915],&quot;childNum&quot;:13},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ôɞ̎φНôŐɜŏ̎Ȅƨöǿƨ@ôɜɚƨʴ̒ôôó@Ƨ̎əԮȃԪૉöͩ̐ƧòʵφƧôʵ@óړɜóŏɜǿƧɝρσȁѷ̎̏ƥóŐѹóŐƨƦѵͪôȄƦñ̒Ԭó@̎ɝŐƧȁρóφƩóóôƨѶ̏ƥʶυɛ̒ѵȀ&quot;],&quot;encodeOffsets&quot;:[[119161,35460]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;chong_qing&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;重庆&quot;,&quot;cp&quot;:[107.7539,30.1904],&quot;childNum&quot;:40},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@əȂòɜƨѺɛƦȁ̐@ƪõŏφƥòȃƥ̍Ƨôυ̏ƧôñóóôɛŏƩôƧƥôƧóυƨ̒ѹôƦȃ@փƥɛ̑@@ɜƧó@ɚƧ@ñφσõ@ŎɝôƧ@ʵѷóƧʵó@ŎóŐó@ôȁƥó̒υôóʶəƧȄς̎ƧȂôƨƨƨφɛ̎Őƨʷɞ@ςԮóŌôôφ@ɜֈ̎ƨ&quot;],&quot;encodeOffsets&quot;:[[111150,32446]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;ning_xia&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;宁夏&quot;,&quot;cp&quot;:[105.9961,37.3096],&quot;childNum&quot;:5},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ల̒ôޠφӒςôƪͧυևɜŋѺó̎ȁ̍ɛ@ѹס@@ʵƧȁôó@ǿ̐ŏöʵɝŋɛ@ô̑ƥóóƨƧóôó@ƩôóƦ̍óȀƨŎɛӒôŐυͪɛ@@Ȁə@&quot;],&quot;encodeOffsets&quot;:[[106831,38340]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;hai_nan&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;海南&quot;,&quot;cp&quot;:[109.9512,19.2041],&quot;childNum&quot;:18},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@φɜƦʶ̐ôφô̎@ƨŎö@τʵƦԩ۫õН̏óƥȃƧ@Ʃəםƨ̑Ʀ@ޤ&quot;],&quot;encodeOffsets&quot;:[[111240,19846]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;tai_wan&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;台湾&quot;,&quot;cp&quot;:[121.0254,23.5986],&quot;childNum&quot;:1},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ôƩɝöƧɝѵəޣ̏ρƩԭóōóͪρɞƧОôԪ݈ଦѶɜ̒ɛ&quot;],&quot;encodeOffsets&quot;:[[124831,25650]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;bei_jing&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;北京&quot;,&quot;cp&quot;:[116.4551,40.2539],&quot;childNum&quot;:19},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@óóóυóôƥ@ŏóóə@ƧŋƩŌρóɛŐóʶѶʴƥʶ̎ôƨɞ@óŎɜŌ̎̍φƧŋƨʵ&quot;],&quot;encodeOffsets&quot;:[[120241,41176]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;tian_jin&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;天津&quot;,&quot;cp&quot;:[117.4219,39.4189],&quot;childNum&quot;:18},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ôôɜ@ƨöɚôôôɚŏ@óƥ@@ȁƦƧɜ@óƧƨƥ@ƧóəН̏óѷɜ@ŎƦƨóО&quot;],&quot;encodeOffsets&quot;:[[119610,40545]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;shang_hai&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;上海&quot;,&quot;cp&quot;:[121.4648,31.2891],&quot;childNum&quot;:19},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@ɞςƨɛȀôŐڔɛóυô̍ןŏ̑̒&quot;],&quot;encodeOffsets&quot;:[[123840,31771]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;xiang_gang&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;香港&quot;,&quot;cp&quot;:[114.2578,22.3242],&quot;childNum&quot;:1},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@óɛƩ@ρ@óôȀɚŎƨ@ö@@ōƨ@&quot;],&quot;encodeOffsets&quot;:[[117361,22950]]}},{&quot;type&quot;:&quot;Feature&quot;,&quot;id&quot;:&quot;ao_men&quot;,&quot;properties&quot;:{&quot;name&quot;:&quot;澳门&quot;,&quot;cp&quot;:[113.5547,22.1484],&quot;childNum&quot;:1},&quot;geometry&quot;:{&quot;type&quot;:&quot;Polygon&quot;,&quot;coordinates&quot;:[&quot;@@X¯aWĀ@l&quot;],&quot;encodeOffsets&quot;:[[116325,22697]]}}],&quot;UTF8Encoding&quot;:true};
    });


    define(&#x27;_chart&#x27;,[&#x27;require&#x27;,&#x27;echarts/chart/map&#x27;,&#x27;echarts/util/mapData/geoJson/china_geo&#x27;],function (require) {
        require(&quot;echarts/chart/map&quot;);
        require(&quot;echarts/util/mapData/geoJson/china_geo&quot;);
    });
    var zrender = require(&#x27;zrender&#x27;);
    zrender.tool = {
        color : require(&#x27;zrender/tool/color&#x27;),
        math : require(&#x27;zrender/tool/math&#x27;),
        util : require(&#x27;zrender/tool/util&#x27;),
        vector : require(&#x27;zrender/tool/vector&#x27;),
        area : require(&#x27;zrender/tool/area&#x27;),
        event : require(&#x27;zrender/tool/event&#x27;)
    }

    zrender.animation = {
        Animation : require(&#x27;zrender/animation/animation&#x27;),
        Cip : require(&#x27;zrender/animation/clip&#x27;),
        easing : require(&#x27;zrender/animation/easing&#x27;)
    }
    var echarts = require(&#x27;echarts&#x27;);
    echarts.config = require(&#x27;echarts/config&#x27;);
    echarts.util = {
        mapData : {
            params : require(&#x27;echarts/util/mapData/params&#x27;)
        }
    }

// 加载需要的图表，由build.js临时生成
    var chart = require(&#x27;_chart&#x27;);

    _global[&#x27;echarts&#x27;] = echarts;
    _global[&#x27;zrender&#x27;] = zrender;

})(window);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
